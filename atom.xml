<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>01不是包子脸</title>
  
  <subtitle>小01的程序猿成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-03T03:21:08.780Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Linyi Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS viewport</title>
    <link href="http://yoursite.com/2020/03/05/CSS%20viewport/"/>
    <id>http://yoursite.com/2020/03/05/CSS viewport/</id>
    <published>2020-03-05T07:20:55.000Z</published>
    <updated>2020-04-03T03:21:08.780Z</updated>
    
    <content type="html"><![CDATA[<p>#viewport</p><h2 id="页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl-no不生效时，用js怎么控制达到禁止缩放的效果？"><a href="#页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl-no不生效时，用js怎么控制达到禁止缩放的效果？" class="headerlink" title="页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl=no不生效时，用js怎么控制达到禁止缩放的效果？"></a>页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl=no不生效时，用js怎么控制达到禁止缩放的效果？</h2><h3 id="viewport-meta的背景"><a href="#viewport-meta的背景" class="headerlink" title="viewport meta的背景"></a>viewport meta的背景</h3><p>浏览器的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/viewport" target="_blank" rel="noopener">viewport</a> 是可以看到Web内容的窗口区域，通常与渲染出的页面的大小不同，这种情况下，浏览器会提供滚动条以滚动访问所有内容。</p><p>窄屏幕设备（如移动设备）在一个虚拟窗口或视口中渲染页面，这个窗口或视口通常比屏幕宽；然后缩小渲染的结果，以便在一屏内显示所有内容。然后用户可以移动、缩放以查看页面的不同区域。例如，如果移动屏幕的宽度为640px，则可能会用980px的虚拟视口渲染页面，然后缩小页面以适应640px的窗口大小。</p><p>这样做是因为许多页面没有做移动端优化，在小窗口渲染时会乱掉（或看起来乱）。所以，这种虚拟视口是一种让未做移动端优化的网站在窄屏设备上看起来更好的办法。</p><p>但是，对于用媒体查询针对窄屏幕做了优化的页面，这种机制不大好 - 比如如果虚拟视口宽 980px，那么在 640px 或 480px 或更小宽度要起作用的媒体查询就不会触发了，浪费了这些响应式设计。</p><p>为了缓解这个问题，Apple 在 Safari iOS 中引入了“viewport meta 标签”，<strong>让Web开发人员控制视口的大小和比例。</strong>很多其他移动浏览器现在也支持此标签，但它不属于 Web 标准。</p><h3 id="viewport-meta-标签的概念"><a href="#viewport-meta-标签的概念" class="headerlink" title="viewport meta 标签的概念"></a>viewport meta 标签的概念</h3><p>移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。</p><h3 id="css中的1px并不等于设备的1px"><a href="#css中的1px并不等于设备的1px" class="headerlink" title="css中的1px并不等于设备的1px"></a><strong>css中的1px并不等于设备的1px</strong></h3><p> 在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，但在移动设备上，在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。</p><p> 还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。</p><p>window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。</p><p>例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。</p><h3 id="三个viewport"><a href="#三个viewport" class="headerlink" title="三个viewport"></a>三个viewport</h3><p>这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做 <strong>*layout viewport</strong>。<strong><em>*layout viewport</em></strong> 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 <strong>visual viewport</strong>。visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5puat7yj30dt0ai0t9.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5qah7plj30dw0ahjrw.jpg" alt="img"></p><p> 完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适；不只是文字，其他元素像图片什么的也是这个道理ppk把这个viewport叫做 <strong><em>ideal viewport</em></strong>，也就是第三个viewport——移动设备的理想viewport。</p><p> ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5rjwmr1j307i05wq2s.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5s6pthkj307p05w3yc.jpg" alt="img"></p><p>但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到<a href="http://viewportsizes.com/" target="_blank" rel="noopener">http://viewportsizes.com</a>去查看一下，里面收集了众多设备的理想宽度。</p><h3 id="利用meta标签对viewport进行控制"><a href="#利用meta标签对viewport进行控制" class="headerlink" title="利用meta标签对viewport进行控制"></a><strong>利用meta标签对viewport进行控制</strong></h3><p> 移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。</p><p>我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。</p><p>meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。</p><h4 id="meta-viewport-有6个属性-暂且把content中的那些东西称为一个个属性和值-，如下："><a href="#meta-viewport-有6个属性-暂且把content中的那些东西称为一个个属性和值-，如下：" class="headerlink" title="meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下："></a>meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：</h4><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>width</td><td>设置<strong><em>layout viewport</em></strong>  的宽度，为一个正整数，或字符串”device-width”</td></tr><tr><td>initial-scale</td><td>设置页面的初始缩放值，为一个数字，可以带小数（缩放是相对于 ideal viewport来进行缩放的）</td></tr><tr><td>minimum-scale</td><td>允许用户的最小缩放值，为一个数字，可以带小数</td></tr><tr><td>maximum-scale</td><td>允许用户的最大缩放值，为一个数字，可以带小数</td></tr><tr><td>height</td><td>设置<strong><em>layout viewport</em></strong>  的高度，这个属性对我们并不重要，很少使用</td></tr><tr><td>user-scalable</td><td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td></tr></tbody></table><ul><li><p><code>width</code><strong>设为<code>device-width</code> 特殊值，代表缩放为 100% 时以 CSS 像素计量的屏幕宽度</strong>。（相应的也有<code>height</code>及<code>device-height</code>属性，可能对包含基于视口高度调整大小及位置的元素的页面有用。）</p><p>注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。</p></li><li><p>对于设置了初始或最大缩放的页面，width属性实际上变成了<strong>最小</strong>视口宽度。比如，如果你的布局需要至少500像素的宽度，那么你可以使用以下标记。当屏幕宽度大于500像素时，浏览器会扩展视口（而不是放大页面）来适应屏幕：</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=500, initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。</p></li><li><p>在安卓中还支持  target-densitydpi  这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素</p><p>target-densitydpi：值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个</p><p>特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。</p><p>因为这个属性只有安卓支持，并且安卓已经决定要废弃<del>target-densitydpi</del>  这个属性了，所以这个属性我们要避免进行使用  </p></li></ul><h3 id="关于缩放"><a href="#关于缩放" class="headerlink" title="关于缩放"></a>关于缩放</h3><p>缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visual viewport宽度 = ideal viewport宽度  / 当前缩放值</span><br><span class="line"></span><br><span class="line">当前缩放值 = ideal viewport宽度  / visual viewport宽度</span><br></pre></td></tr></table></figure><p>根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewpor设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。</p><p>当前缩放值 = ideal viewport宽度  / visual viewport宽度，我们可以得出：</p><p>​      当前缩放值 = 320 / 980</p><p>也就是当前的initial-scale默认值应该是 0.33这样子。当你指定了initial-scale的值后，这个默认值就不起作用了。</p><p><strong>在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</strong></p><h3 id="js事件监听阻止用户缩放"><a href="#js事件监听阻止用户缩放" class="headerlink" title="js事件监听阻止用户缩放"></a>js事件监听阻止用户缩放</h3><p>移动端web缩放有两种：</p><p><strong>1.双击缩放；</strong></p><p><strong>2.双指手势缩放。</strong></p><ul><li>禁止双击缩放</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.οnlοad=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;         </span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.touches.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)  </span><br><span class="line">  <span class="keyword">var</span> lastTouchEnd=<span class="number">0</span>;  </span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> now=(<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();  </span><br><span class="line">    <span class="keyword">if</span>(now-lastTouchEnd&lt;=<span class="number">300</span>)&#123;  </span><br><span class="line">      event.preventDefault();  </span><br><span class="line">    &#125;  </span><br><span class="line">    lastTouchEnd=now;  </span><br><span class="line">  &#125;,<span class="literal">false</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完美方案</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span>(event.touches.length&gt;<span class="number">1</span>)&#123;</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> lastTouchEnd=<span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> now=(<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span></span><br><span class="line"><span class="vbscript">      <span class="keyword">if</span>(<span class="built_in">now</span>-lastTouchEnd&lt;=<span class="number">300</span>)&#123;</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="vbscript">      lastTouchEnd=<span class="built_in">now</span>;</span></span><br><span class="line"><span class="actionscript">    &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//依然存在bug，双指同时放下放大禁止了，但一指先放下，另一指在放下滑动放大依然不管用</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'gesturestart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#viewport&lt;/p&gt;
&lt;h2 id=&quot;页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl-no不生效时，用js怎么控制达到禁止缩放的效果？&quot;&gt;&lt;a href=&quot;#页面适配的标签viewport这个标签是什么作用？met
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="viewport" scheme="http://yoursite.com/tags/viewport/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件间的通信</title>
    <link href="http://yoursite.com/2020/02/26/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/02/26/Vue组件间的通信/</id>
    <published>2020-02-26T03:18:32.000Z</published>
    <updated>2020-04-03T03:18:23.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue组件间的通信"><a href="#vue组件间的通信" class="headerlink" title="vue组件间的通信"></a>vue组件间的通信</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tg3703qaj309t07ujr9.jpg" alt="img"></p><p>如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。</p><h2 id="props-emit"><a href="#props-emit" class="headerlink" title="props/$emit"></a><code>props</code>/<code>$emit</code></h2><p>父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。</p><h3 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1.父组件向子组件传值"></a>1.父组件向子组件传值</h3><p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 <code>users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//App.vue父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Users from &quot;./components/Users&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    &quot;users&quot;:Users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//users子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/li&gt;//遍历传递过来的值，然后呈现到页面</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;HelloWorld&apos;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    users:&#123;           //这个就是父组件中子标签自定义名字</span><br><span class="line">      type:Array,</span><br><span class="line">      required:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</strong></p><h3 id="2-子组件向父组件传值（通过事件形式）"><a href="#2-子组件向父组件传值（通过事件形式）" class="headerlink" title="2.子组件向父组件传值（通过事件形式）"></a>2.子组件向父组件传值（通过事件形式）</h3><p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tg6j35buj30yg046q33.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1 @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;//绑定一个点击事件</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app-header&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title:&quot;Vue.js Demo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeTitle() &#123;</span><br><span class="line">      this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件  传递值“子向父组件传值”</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致</span><br><span class="line">   // updateTitle($event)接受传递过来的文字</span><br><span class="line">    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from &quot;./components/Header&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      title:&quot;传递的是一个值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateTitle(e)&#123;   //声明这个函数</span><br><span class="line">      this.title = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">   &quot;app-header&quot;:Header,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</strong></p><h2 id="emit-on"><a href="#emit-on" class="headerlink" title="$emit/$on"></a><code>$emit</code>/<code>$on</code></h2><p><strong>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</strong>。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p><h3 id="1-具体实现方式："><a href="#1-具体实现方式：" class="headerlink" title="1.具体实现方式："></a>1.具体实现方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Event=new Vue();</span><br><span class="line">Event.$emit(事件名,数据);</span><br><span class="line">Event.$on(事件名,data =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-举个例子"><a href="#2-举个例子" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><p>假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;itany&quot;&gt;</span><br><span class="line">&lt;my-a&gt;&lt;/my-a&gt;</span><br><span class="line">&lt;my-b&gt;&lt;/my-b&gt;</span><br><span class="line">&lt;my-c&gt;&lt;/my-c&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=&quot;a&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;将数据发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=&quot;b&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;将数组发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=&quot;c&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Event = new Vue();//定义一个空的Vue实例</span><br><span class="line">var A = &#123;</span><br><span class="line">template: &apos;#a&apos;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: &apos;tom&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  send() &#123;</span><br><span class="line">    Event.$emit(&apos;data-a&apos;, this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var B = &#123;</span><br><span class="line">template: &apos;#b&apos;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    age: 20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  send() &#123;</span><br><span class="line">    Event.$emit(&apos;data-b&apos;, this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var C = &#123;</span><br><span class="line">template: &apos;#c&apos;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: &apos;&apos;,</span><br><span class="line">    age: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;//在模板编译完成后执行</span><br><span class="line"> Event.$on(&apos;data-a&apos;,name =&gt; &#123;</span><br><span class="line">     this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event</span><br><span class="line"> &#125;)</span><br><span class="line"> Event.$on(&apos;data-b&apos;,age =&gt; &#123;</span><br><span class="line">     this.age = age;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#itany&apos;,</span><br><span class="line">components: &#123;</span><br><span class="line">  &apos;my-a&apos;: A,</span><br><span class="line">  &apos;my-b&apos;: B,</span><br><span class="line">  &apos;my-c&apos;: C</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/e5ab7d4be1d7178cfa8f1da5f208ec786f277916/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d363637373530316461393030366564323f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e5ab7d4be1d7178cfa8f1da5f208ec786f277916/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d363637373530316461393030366564323f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt="image"></a><br><code>$on</code> 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。</p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p><a href="https://camo.githubusercontent.com/1cb690c2b97cfff1434956e5d66bab39673d84dc/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d653632626134343961306332653761633f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1cb690c2b97cfff1434956e5d66bab39673d84dc/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d653632626134343961306332653761633f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="image"></a></p><h3 id="1-简要介绍Vuex原理"><a href="#1-简要介绍Vuex原理" class="headerlink" title="1.简要介绍Vuex原理"></a>1.简要介绍Vuex原理</h3><p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。</p><h3 id="2-简要介绍各模块在流程中的功能："><a href="#2-简要介绍各模块在流程中的功能：" class="headerlink" title="2.简要介绍各模块在流程中的功能："></a>2.简要介绍各模块在流程中的功能：</h3><ul><li>Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li>dispatch：操作行为触发方法，是唯一能执行action的方法。</li><li>actions：<strong>操作行为处理模块,由组件中的$store.dispatch(‘action 名称’, data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state</strong>。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li>mutations：<strong>状态改变操作方法，由actions中的commit(‘mutation 名称’)来触发</strong>。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul><h3 id="3-Vuex与localStorage"><a href="#3-Vuex与localStorage" class="headerlink" title="3.Vuex与localStorage"></a>3.Vuex与localStorage</h3><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，<strong>具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultCity = <span class="string">"上海"</span></span><br><span class="line"><span class="keyword">try</span> &#123;   <span class="comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span></span><br><span class="line">  <span class="keyword">if</span> (!defaultCity)&#123;</span><br><span class="line">    defaultCity = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'defaultCity'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity(state, city) &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.localStorage.setItem(<span class="string">'defaultCity'</span>, <span class="built_in">JSON</span>.stringify(state.city));</span><br><span class="line">      <span class="comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(state.subscribeList);   <span class="comment">// array -&gt; string</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">"subscribeList"</span>));    <span class="comment">// string -&gt; array</span></span><br></pre></td></tr></table></figure><p>##<code>$attrs</code>/<code>$listeners</code></p><p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—-<code>$attrs</code>/<code>$listeners</code></p><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</li></ul><p>接下来我们看个跨级通信的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;浪里行舟&lt;/h2&gt;</span><br><span class="line">    &lt;child-com1</span><br><span class="line">      :foo=&quot;foo&quot;</span><br><span class="line">      :boo=&quot;boo&quot;</span><br><span class="line">      :coo=&quot;coo&quot;</span><br><span class="line">      :doo=&quot;doo&quot;</span><br><span class="line">      title=&quot;前端工匠&quot;</span><br><span class="line">    &gt;&lt;/child-com1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; childCom1 &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &quot;Javascript&quot;,</span><br><span class="line">      boo: &quot;Html&quot;,</span><br><span class="line">      coo: &quot;CSS&quot;,</span><br><span class="line">      doo: &quot;Vue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// childCom1.vue</span><br><span class="line">&lt;template class=&quot;border&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom2</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span><br><span class="line">  props: &#123;</span><br><span class="line">    foo: String // foo作为props属性绑定</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// childCom2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom3</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: &#123;</span><br><span class="line">    boo: String</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// childCom3.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    coo: String,</span><br><span class="line">    title: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tgffgg8oj30ft06bglo.jpg" alt="img"></p><p>如上图所示<code>$attrs</code>表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4提供了<code>$attrs</code> , <code>$listeners</code> 来传递数据与事件，跨级组件之间的通讯变得更简单。</p><p>简单来说：<code>$attrs</code>与<code>$listeners</code> 是两个对象，<code>$attrs</code> 里存放的是父组件中绑定的非 Props 属性，<code>$listeners</code>里存放的是父组件中绑定的非原生事件。</p><p>##provide/inject</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Vue2.2.0新增API,这对选项需要一起使用，<strong>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</strong>。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。<br><strong>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</strong>。</p><h3 id="2-举个例子-1"><a href="#2-举个例子-1" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: <span class="string">'浪里行舟'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">'name'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">// 浪里行舟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 A.vue 里，我们设置了一个 <strong>provide: name</strong>，值为 浪里行舟，它的作用就是将 <strong>name</strong> 这个变量提供给它的所有子组件。而在 B.vue 中，通过 <code>inject</code> 注入了从 A 组件中提供的 <strong>name</strong> 变量，那么在组件 B 中，就可以直接通过 <strong>this.name</strong> 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。</p><p>需要注意的是：<strong>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的</strong>—-vue官方文档<br>所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。</p><h3 id="3-provide与inject-怎么实现数据响应式"><a href="#3-provide与inject-怎么实现数据响应式" class="headerlink" title="3.provide与inject 怎么实现数据响应式"></a>3.provide与inject 怎么实现数据响应式</h3><p>一般来说，有两种办法：</p><ul><li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods</li><li>使用2.6最新API Vue.observable 优化响应式 provide(推荐)</li></ul><p>我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tgjlms01j30eo09owes.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// A 组件 </span><br><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;h1&gt;A 组件&lt;/h1&gt;</span><br><span class="line">      &lt;button @click=&quot;() =&gt; changeColor()&quot;&gt;改变color&lt;/button&gt;</span><br><span class="line">      &lt;ChildrenB /&gt;</span><br><span class="line">      &lt;ChildrenC /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      color: &quot;blue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  // provide() &#123;</span><br><span class="line">  //   return &#123;</span><br><span class="line">  //     theme: &#123;</span><br><span class="line">  //       color: this.color //这种方式绑定的数据并不是可响应的</span><br><span class="line">  //     &#125; // 即A组件的color变化后，组件D、E、F不会跟着变</span><br><span class="line">  //   &#125;;</span><br><span class="line">  // &#125;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      theme: this//方法一：提供祖先组件的实例</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeColor(color) &#123;</span><br><span class="line">      if (color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.color = this.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 方法二:使用2.6最新API Vue.observable 优化响应式 provide</span><br><span class="line">  // provide() &#123;</span><br><span class="line">  //   this.theme = Vue.observable(&#123;</span><br><span class="line">  //     color: &quot;blue&quot;</span><br><span class="line">  //   &#125;);</span><br><span class="line">  //   return &#123;</span><br><span class="line">  //     theme: this.theme</span><br><span class="line">  //   &#125;;</span><br><span class="line">  // &#125;,</span><br><span class="line">  // methods: &#123;</span><br><span class="line">  //   changeColor(color) &#123;</span><br><span class="line">  //     if (color) &#123;</span><br><span class="line">  //       this.theme.color = color;</span><br><span class="line">  //     &#125; else &#123;</span><br><span class="line">  //       this.theme.color = this.theme.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;;</span><br><span class="line">  //     &#125;</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line">// F 组件 </span><br><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div class=&quot;border2&quot;&gt;</span><br><span class="line">    &lt;h3 :style=&quot;&#123; color: injections.theme.color &#125;&quot;&gt;F 组件&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    theme: &#123;</span><br><span class="line">      //函数式组件取值不一样</span><br><span class="line">      default: () =&gt; (&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p><h2 id="parent-children与-ref"><a href="#parent-children与-ref" class="headerlink" title="$parent / $children与 ref"></a><code>$parent</code> / <code>$children</code>与 <code>ref</code></h2><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li></ul><p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 <code>ref</code>来访问组件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// component-a 子组件</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &apos;Vue.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      window.alert(&apos;Hello&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      const comA = this.$refs.comA;</span><br><span class="line">      console.log(comA.title);  // Vue.js</span><br><span class="line">      comA.sayHello();  // 弹窗</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>不过，<strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// parent.vue</span><br><span class="line">&lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br></pre></td></tr></table></figure><p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。</p><p>##总结</p><p>常见使用场景可以分为三类：</p><ul><li>父子通信：<br>父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></li><li>兄弟通信：<br>Bus；Vuex</li><li>跨级通信：<br>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue组件间的通信&quot;&gt;&lt;a href=&quot;#vue组件间的通信&quot; class=&quot;headerlink&quot; title=&quot;vue组件间的通信&quot;&gt;&lt;/a&gt;vue组件间的通信&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/00
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>Vue相关面试题</title>
    <link href="http://yoursite.com/2020/02/17/Vue%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/17/Vue相关面试题/</id>
    <published>2020-02-17T02:45:21.000Z</published>
    <updated>2020-04-03T03:15:18.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用<a href="http://link.zhihu.com/?target=http%3A//cn.vuejs.org/v2/guide/single-file-components.html" target="_blank" rel="noopener">单文件组件</a>和 <a href="http://link.zhihu.com/?target=http%3A//github.com/vuejs/awesome-vue%23libraries--plugins" target="_blank" rel="noopener">Vue 生态系统支持的库</a>开发的复杂单页应用。</p><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p><ul><li>响应式编程（双向数据绑定 MVVM）</li><li>组件化</li><li>模块化（配合 <a href="https://link.zhihu.com/?target=http%3A//webpack.github.io/" target="_blank" rel="noopener">Webpack</a> 或者 <a href="https://link.zhihu.com/?target=http%3A//browserify.org/" target="_blank" rel="noopener">Browserify</a>等打包工具，然后再加上 ES2015。每一个 Vue 组件都可以看做一个独立的模块）</li><li>动画（Vue 自带简洁易用的<a href="https://link.zhihu.com/?target=http%3A//vuejs.org/guide/transitions.html" target="_blank" rel="noopener">过渡动画系统</a>。Vue 的反应式系统也使得它可以用来开发高效的数据驱动的逐帧动画。这一类逐帧动画在基于脏检查或是 Virtual DOM 的框架中，往往会导致性能问题，因为即使只是改了一个值，整个所处的子树（scope 或是 component）都需要重新计算。而 Vue 则是改了多少，计算多少，不会有无谓的浪费。在小 demo 中，脏检查或是 Virtual DOM 往往也足够快，但是在大型应用中可就不一定了。）</li><li>Virtual DOM</li><li>Vuex</li><li>Vue-router</li></ul><h2 id="1-对于MVVM的理解？"><a href="#1-对于MVVM的理解？" class="headerlink" title="1. 对于MVVM的理解？"></a>1. 对于MVVM的理解？</h2><p>MVVM 是 Model-View-ViewModel 的缩写。 <strong>Model</strong>代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。 <strong>View</strong> 代表UI 组件，它负责将数据模型转化成UI 展现出来。 <strong>ViewModel</strong> 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。 在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。 <strong>ViewModel</strong> 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p><p>###怎么实现MVVM</p><ol><li>脏值检查：angularangular.js 是通过脏值检测的方式比对数据是否有变更，来决定是否更新视图。</li><li>数据劫持：使用Object.defineProperty()方法把这些vm.data属性全部转成setter、getter方法。</li></ol><p><a href="https://jancat.github.io/post/2019/vue-mvvm/" target="_blank" rel="noopener">Vue MVVM的实现(defineProperty)</a></p><p><a href="https://jancat.github.io/post/2019/vue-mvvm-proxy/" target="_blank" rel="noopener">Vue3.0 MVVM的实现(proxy)</a>（Vue 3.0 使用了 <strong>Proxy</strong> 后，将会消除之前 Vue 2.x 中基于 <code>Object.defineProperty</code> 的实现所存在的一些限制：无法监听 <strong>属性的添加和删除</strong>、<strong>数组索引值和长度的变更</strong>。）</p><h3 id="MVVM-各模块职责"><a href="#MVVM-各模块职责" class="headerlink" title="MVVM 各模块职责"></a>MVVM 各模块职责</h3><ul><li><strong>MVVM</strong>: Vue 实例初始化，调用 <strong>Observer</strong> 数据劫持，调用 <strong>Compiler</strong> 解析模板；</li><li><strong>Observer</strong>: 利用Object.defineProperty数据劫持data全部属性，定义 setter 、getter，添加和通知订阅者；（所以vue不能新增属性必须事先定义，model-&gt;vm.data）</li><li><strong>Compiler</strong>: 解析模板初始化视图，收集模板中的数据依赖，创建订阅者订阅变化，绑定更新函数；（在文档碎片中操作dom节点，遍历正则匹配替换data属性，view-&gt;vm.$el）</li><li><strong>Dep</strong>：订阅中心，提供添加、移除、通知订阅的接口；</li><li><strong>Watcher</strong>: data 属性的订阅者，收到变化通知后调用更新函数更新视图。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5vbvssij31460m4n93.jpg" alt="image-20190709192722478"></p><p>###Object.defineProperty() 和 Proxy 实现 MVVM 数据劫持的区别</p><p><code>Object.defineProperty()</code> 和 <code>Proxy</code> 实现 MVVM 数据劫持的区别是：<code>Object.defineProperty()</code> 需要为每个 key 定义 getter 和 setter，也就是需要遍历 <code>data</code> 下的全部子属性；而 <code>Proxy</code> 只需要为 <code>data</code> 本身和内部嵌套的对象创建代理，每个对象统一代理访问内部属性，对外提供代理的引用。</p><h2 id="2-vue生命周期："><a href="#2-vue生命周期：" class="headerlink" title="2.vue生命周期："></a>2.vue生命周期：</h2><h3 id="1-在beforeCreate和created钩子函数之间的生命周期"><a href="#1-在beforeCreate和created钩子函数之间的生命周期" class="headerlink" title="1. 在beforeCreate和created钩子函数之间的生命周期"></a><strong>1. 在beforeCreate和created钩子函数之间的生命周期</strong></h3><p>在这个生命周期之间，进行<strong>初始化事件，进行数据的观测</strong>，可以看到在<strong>created</strong>的时候数据已经和<strong>data属性进行绑定</strong>（放在data中的属性当值发生改变的同时，视图也会改变）。<br>注意看下：此时还是没有el选项</p><p>组件实例刚刚创建，<strong>还未进行数据观测和事件配置</strong>//这里不要被beforeCreate误导，实际上组件实例已经创建了</p><h3 id="2-created钩子函数和beforeMount间的生命周期"><a href="#2-created钩子函数和beforeMount间的生命周期" class="headerlink" title="2. created钩子函数和beforeMount间的生命周期"></a><strong>2. created钩子函数和beforeMount间的生命周期</strong></h3><p>实例已经创建完成，并且<strong>已经完成数据观测，属性和方法的运算，watch/event 事件回调。//常用！！！</strong></p><p>首先会判断对象是否有<strong>el选项</strong>。<strong>如果有的话就继续向下编译，如果没有</strong>el选项<strong>，则停止编译，也就意味着停止了生命周期，直到在该vue实例上调用vm.$mount(el)。</strong></p><p>然后，我们往下看，<strong>template</strong>参数选项的有无对生命周期的影响。<br>（1）.如果vue实例对象中有template参数选项，则将其作为模板编译成render函数。<br>（2）.如果没有template选项，则将外部HTML作为模板编译。<br>（3）.可以看到template中的模板优先级要高于outer HTML的优先级。</p><p>所以综合排名优先级：<br>render函数选项 &gt; template选项 &gt; outer HTML.</p><h3 id="3-beforeMount和mounted-钩子函数间的生命周期"><a href="#3-beforeMount和mounted-钩子函数间的生命周期" class="headerlink" title="3. beforeMount和mounted 钩子函数间的生命周期"></a><strong>3. beforeMount和mounted 钩子函数间的生命周期</strong></h3><p>可以看到此时是给vue实例对象添加<strong>$el成员</strong>，并且替换掉挂在的DOM元素。因为在之前console中打印的结果可以看到<strong>beforeMount</strong>之前el上还是undefined。</p><p>模板编译之前，还没挂载，页面仍未展示，但<strong>虚拟Dom已经配置</strong>//先把坑占住了，到后面mounted挂载的时候再把值渲染进去</p><h3 id="4-mounted"><a href="#4-mounted" class="headerlink" title="4. mounted"></a><strong>4. mounted</strong></h3><p>模板编译之后，已经挂载，<strong>此时才会渲染页面，才能看到页面上数据的展示//常用！！！</strong></p><p><strong>注意:</strong> mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 <strong>vm.$nextTick 替换掉 mounted</strong></p><p>在mounted之前h1中还是通过<code></code>进行占位的，因为此时还有挂在到页面上，还是JavaScript中的虚拟DOM形式存在的。在mounted之后可以看到h1中的内容发生了变化。</p><p>el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互。</p><h3 id="5-beforeUpdate（更新前）"><a href="#5-beforeUpdate（更新前）" class="headerlink" title="5. beforeUpdate（更新前）"></a><strong>5. beforeUpdate</strong>（更新前）</h3><p>在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 </p><h3 id="6-updated（更新后）"><a href="#6-updated（更新后）" class="headerlink" title="6. updated（更新后）"></a><strong>6. updated</strong>（更新后）</h3><p>在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</p><h3 id="7-beforeDestroy（销毁前）"><a href="#7-beforeDestroy（销毁前）" class="headerlink" title="7. beforeDestroy（销毁前）"></a><strong>7. beforeDestroy</strong>（销毁前）</h3><p>在实例销毁之前调用。实例仍然完全可用。 </p><h3 id="8-destroyed（销毁后）"><a href="#8-destroyed（销毁后）" class="headerlink" title="8. destroyed（销毁后）"></a><strong>8. destroyed</strong>（销毁后）</h3><p>在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 </p><h3 id="关于生命周期的问题："><a href="#关于生命周期的问题：" class="headerlink" title="关于生命周期的问题："></a>关于生命周期的问题：</h3><p>1.什么是vue生命周期？ 答： Vue 实例从创建到销毁的过程，就是生命周期。从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、销毁等一系列过程，称之为 Vue 的生命周期。</p><p>2.vue生命周期的作用是什么？ 答：它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。</p><p>3.vue生命周期总共有几个阶段？ 答：它可以总共分为8个阶段：创建前/后, 载入前/后,更新前/后,销毁前/销毁后。</p><p>4.第一次页面加载会触发哪几个钩子？ 答：会触发 下面这几个beforeCreate, created, beforeMount, mounted </p><p>5.DOM 渲染在 哪个周期中就已经完成？ 答：DOM 渲染在 mounted 中就已经完成了。</p><h2 id="3-Vue实现数据双向绑定的原理：Object-defineProperty（）"><a href="#3-Vue实现数据双向绑定的原理：Object-defineProperty（）" class="headerlink" title="3.Vue实现数据双向绑定的原理：Object.defineProperty（）"></a>3.Vue实现数据双向绑定的原理：Object.defineProperty（）</h2><p>vue实现数据双向绑定主要是：采<strong>用数据劫持结合发布者-订阅者模式</strong>的方式，通过<strong>Object.defineProperty（）</strong>来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应监听回调。当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 将它们转为 getter/setter。用户看不到 getter/setter，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。</p><p>vue的数据双向绑定 将MVVM作为数据绑定的入口，整合Observer，Compile和Watcher三者，通过Observer来监听自己的model的数据变化，通过Compile来解析编译模板指令（vue中是用来解析双花括号的），最终利用watcher搭起observer和Compile之间的通信桥梁，达到数据变化 —&gt;视图更新；视图交互变化（input）—&gt;数据model变更双向绑定效果。</p><h3 id="关于Object-defineProperty"><a href="#关于Object-defineProperty" class="headerlink" title="关于Object.defineProperty"></a>关于Object.defineProperty</h3><ul><li><p>语法</p><p><code>Object.defineProperty(obj,prop,descriptor)</code></p></li><li><p>参数</p><p>obj:目标对象</p><p>prop:需要定义的属性或方法的名称</p><p>descriptor:目标属性所拥有的特性</p></li><li><p>可供定义的特性列表</p><p>value:属性的值</p><p>writable:如果为false，属性的值就不能被重写。</p><p>get: 一旦目标属性被访问就会调回此方法，并将此方法的运算结果返回用户。</p><p>set:一旦目标属性被赋值，就会调回此方法。</p><p>configurable:如果为false，则任何尝试删除目标属性或修改属性性以下特性（writable, configurable, enumerable）的行为将被无效化。</p><p>enumerable:是否能在for…in循环中遍历出来或在Object.keys中列举出来。</p></li></ul><p><strong>js实现简单的双向绑定</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span><span class="attr">id</span>=<span class="string">"txt"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">id</span>=<span class="string">"show"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> obj = &#123;&#125;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">Object</span>.defineProperty(obj, <span class="string">'txt'</span>, &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">return</span> obj</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="actionscript">        <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span> <span class="params">(newValue)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'txt'</span>).value = newValue</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.getElementById(<span class="string">'show'</span>).innerHTML = newValue</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line">        obj.txt = e.target.value</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-Vue的路由实现：hash模式-和-history模式"><a href="#4-Vue的路由实现：hash模式-和-history模式" class="headerlink" title="4. Vue的路由实现：hash模式 和 history模式"></a>4. Vue的路由实现：hash模式 和 history模式</h2><p><strong>hash模式：</strong>在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash 模式下，仅 hash 符号之前的内容会被包含在请求中，如 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.xxx.com" target="_blank" rel="noopener">www.xxx.com</a>，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。</p><p><strong>history模式：</strong>history采用HTML5的新特性；且提供了两个新方法：pushState（），replaceState（）可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 history 模式下，前端的 URL 必须和实际向后端发起请求的 URL 一致，如 <a href="https://link.juejin.im?target=http%3A%2F%2Fwww.xxx.com%2Fitems%2Fid" target="_blank" rel="noopener">www.xxx.com/items/id</a>。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。<strong>Vue-Router 官网里如此描述：</strong>“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。”</p><h2 id="5-Vue与Angular以及React的区别？"><a href="#5-Vue与Angular以及React的区别？" class="headerlink" title="5. Vue与Angular以及React的区别？"></a>5. Vue与Angular以及React的区别？</h2><p><strong>1.与AngularJS的区别</strong> </p><p>相同点： 都支持指令：内置指令和自定义指令；都支持过滤器：内置过滤器和自定义过滤器；都支持双向数据绑定；都不支持低端浏览器。</p><p>不同点： AngularJS的学习成本高，比如增加了Dependency Injection特性，而Vue.js本身提供的API都比较简单、直观；在性能上，AngularJS依赖对数据做脏检查，所以Watcher越多越慢；Vue.js使用基于依赖追踪的观察并且使用异步队列更新，所有的数据都是独立触发的。</p><p><strong>2.与React的区别</strong> （详见vue和react区别）</p><p>相同点： </p><ul><li><p>React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；</p></li><li><p>中心思想相同：一切都是组件，组件实例之间可以嵌套；</p></li><li><p>都提供合理的钩子函数，可以让开发者定制化地去处理需求；</p></li><li><p>在组件开发中都支持mixins的特性。</p></li><li><p>使用 Virtual DOM，有自己的diff渲染算法</p></li><li><p>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</p></li><li><p>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。</p><p>不同点：</p></li><li><p>React采用的Virtual DOM会对渲染出来的结果做脏检查；在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。</p><p>如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。</p><p>然而，使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。</p><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。</p></li><li><p>Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。</p></li></ul><h2 id="6-vue路由的钩子函数"><a href="#6-vue路由的钩子函数" class="headerlink" title="6. vue路由的钩子函数"></a>6. vue路由的钩子函数</h2><p>首页可以控制导航跳转，beforeEach，afterEach等，一般用于页面title的修改。一些需要登录才能调整页面的重定向功能。</p><p><strong>beforeEach</strong>主要有3个参数to，from，next：</p><p><strong>to</strong>：route即将进入的目标路由对象，</p><p><strong>from</strong>：route当前导航正要离开的路由</p><p><strong>next</strong>：function一定要调用该方法resolve这个钩子。执行效果依赖next方法的调用参数。可以控制网页的跳转。</p><p>##7. vue中常用的指令有哪些？</p><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li>解释：指令 (Directives) 是带有 <code>v-</code> 前缀的特殊属性</li><li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li></ul><h3 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h3><h4 id="1-v-text：更新元素的-textContent"><a href="#1-v-text：更新元素的-textContent" class="headerlink" title="1.v-text：更新元素的 textContent"></a>1.v-text：更新元素的 textContent</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-text=&quot;msg&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="2-v-html：更新元素的-innerHTML"><a href="#2-v-html：更新元素的-innerHTML" class="headerlink" title="2.v-html：更新元素的 innerHTML"></a>2.v-html：更新元素的 innerHTML</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1 v-html=&quot;msg&quot;&gt;&lt;/h1&gt;</span><br></pre></td></tr></table></figure><h4 id="3-v-bind"><a href="#3-v-bind" class="headerlink" title="3.v-bind"></a>3.v-bind</h4><ul><li>作用：当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM</li><li>语法：<code>v-bind:title=&quot;msg&quot;</code></li><li>简写：<code>:title=&quot;msg&quot;</code></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    // 2 创建 Vue 的实例对象</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      // el 用来指定vue挂载到页面中的元素，值是：选择器</span><br><span class="line">      // 理解：用来指定vue管理的HTML区域</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      // 数据对象，用来给视图中提供数据的</span><br><span class="line">      data: &#123;</span><br><span class="line">        url: &apos;http://www.baidu.com&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="4-v-on"><a href="#4-v-on" class="headerlink" title="4.v-on"></a>4.v-on</h4><ul><li>作用：绑定事件</li><li>语法：<code>v-on:click=&quot;say&quot;</code> or <code>v-on:click=&quot;say(&#39;参数&#39;, $event)&quot;</code></li><li>简写：<code>@click=&quot;say&quot;</code></li><li>说明：绑定的事件从<code>methods</code>中获取</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 完整语法 --&gt;</span><br><span class="line">&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 缩写 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</span><br><span class="line">&lt;!-- 方法传参 --&gt;</span><br><span class="line">&lt;a @click=&quot;doSomething（“123”）&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"> &lt;script&gt;</span><br><span class="line">    // 2 创建 Vue 的实例对象</span><br><span class="line">    var vm = new Vue(&#123;</span><br><span class="line">      el: &apos;#app&apos;,</span><br><span class="line">      // methods属性用来给vue实例提供方法（事件）</span><br><span class="line">      methods: &#123;</span><br><span class="line">        doSomething: function(str) &#123;</span><br><span class="line">          //接受参数，并输出</span><br><span class="line">          console.log(str);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure><h4 id="5-v-model"><a href="#5-v-model" class="headerlink" title="5.v-model"></a>5.v-model</h4><p>数据响应，是通过数据的改变去驱动 DOM 视图的变化，而双向绑定除了数据驱动 DOM 外， DOM 的变化反过来影响数据，是一个双向关系，在 Vue 中，我们可以通过 <code>v-model</code> 来实现双向绑定。</p><ul><li>作用：在表单元素上创建双向数据绑定</li><li>说明：监听用户的输入事件以更新数据</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=&quot;message&quot; placeholder=&quot;edit me&quot;&gt;</span><br><span class="line">&lt;p&gt;Message is: &#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><p>#####v-model只不过是一个语法糖而已,真正的实现靠的还是</p><ul><li>v-bind:绑定响应式数据</li><li>触发 input 事件，并传递数据 (重点)</li></ul><p>#####v-model 在不同的 HTML 标签上使用会监控不同的属性和抛出不同的事件：</p><ul><li>text 和 textarea 元素使用 <code>value</code> 属性和 <code>input</code> 事件；</li><li>checkbox 和 radio 使用 <code>checked</code> 属性和 <code>change</code> 事件；</li><li>select 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li></ul><p><a href="[https://ustbhuangyi.github.io/vue-analysis/extend/v-model.html#%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0](https://ustbhuangyi.github.io/vue-analysis/extend/v-model.html#表单元素)">v-model源码分析</a></p><h4 id="6-v-for"><a href="#6-v-for" class="headerlink" title="6.v-for"></a>6.v-for</h4><ul><li>作用：基于源数据多次渲染元素或模板块</li><li>key属性<ul><li>推荐：使用 <code>v-for</code> 的时候提供 <code>key</code> 属性，以获得性能提升。</li><li>说明：使用 key，VUE会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 1 基础用法 --&gt;</span><br><span class="line">&lt;div v-for=&quot;item in items&quot;&gt;</span><br><span class="line">  &#123;&#123; item.text &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- item 为当前项，index 为索引 --&gt;</span><br><span class="line">&lt;p v-for=&quot;(item, index) in list&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;index&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;!-- item 为值，key 为键，index 为索引 --&gt;</span><br><span class="line">&lt;p v-for=&quot;(item, key, index) in obj&quot;&gt;&#123;&#123;item&#125;&#125; -- &#123;&#123;key&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p v-for=&quot;item in 10&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/p&gt;</span><br></pre></td></tr></table></figure><h4 id="7-v-if-和-v-show"><a href="#7-v-if-和-v-show" class="headerlink" title="7.v-if 和 v-show"></a>7.v-if 和 v-show</h4><ul><li><a href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Fconditional.html" target="_blank" rel="noopener">条件渲染</a></li><li><code>v-if</code>：根据表达式的值的真假条件，销毁或重建元素</li><li><code>v-show</code>：根据表达式之真假值，切换元素的 display CSS 属性</li></ul><h4 id="8-提升用户体验：v-cloak"><a href="#8-提升用户体验：v-cloak" class="headerlink" title="8.提升用户体验：v-cloak"></a>8.提升用户体验：v-cloak</h4><ul><li>这个指令保持在元素上直到关联实例结束编译。和 CSS 规则如 [v-cloak] { display: none } 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。</li><li>防止刷新页面，网速慢的情况下出现<code></code>等数据格式</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;div v-cloak&gt;</span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h4 id="9-提升性能：v-pre"><a href="#9-提升性能：v-pre" class="headerlink" title="9.提升性能：v-pre"></a>9.提升性能：v-pre</h4><ul><li>说明：跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-pre&gt;&#123;&#123; this will not be compiled &#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><h4 id="10-提升性能：v-once"><a href="#10-提升性能：v-once" class="headerlink" title="10.提升性能：v-once"></a>10.提升性能：v-once</h4><ul><li>说明：只渲染元素和组件一次。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span v-once&gt;This will never change: &#123;&#123;msg&#125;&#125;&lt;/span&gt;</span><br></pre></td></tr></table></figure><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>除了核心功能默认内置的指令 (<code>v-model</code> 和 <code>v-show</code>)，Vue 也允许注册自定义指令。注意，在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p><p>例如：</p><p>当页面加载时，该元素将获得焦点 (注意：<code>autofocus</code> 在移动版 Safari 上不工作)。事实上，只要你在打开这个页面后还没点击过任何内容，这个输入框就应当还是处于聚焦状态。现在让我们用指令来实现这个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 注册一个全局自定义指令 `v-focus`</span><br><span class="line">Vue.directive(&apos;focus&apos;, &#123;</span><br><span class="line">  // 当被绑定的元素插入到 DOM 中时……</span><br><span class="line">  inserted: function (el) &#123;</span><br><span class="line">    // 聚焦元素</span><br><span class="line">    el.focus()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果想注册局部指令，组件中也接受一个 <code>directives</code> 的选项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  focus: &#123;</span><br><span class="line">    // 指令的定义</span><br><span class="line">    inserted: function (el) &#123;</span><br><span class="line">      el.focus()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后你可以在模板中任何元素上使用新的 <code>v-focus</code> 属性，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-focus&gt;</span><br></pre></td></tr></table></figure><h4 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h4><p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p><ul><li><code>bind</code>：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li><li><code>inserted</code>：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li><li><code>update</code>：所在组件的 VNode 更新时调用，<strong>但是可能发生在其子 VNode 更新之前</strong>。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。</li><li><code>componentUpdated</code>：指令所在组件的 VNode <strong>及其子 VNode</strong> 全部更新后调用。</li><li><code>unbind</code>：只调用一次，指令与元素解绑时调用。</li></ul><h4 id="钩子函数参数"><a href="#钩子函数参数" class="headerlink" title="钩子函数参数"></a>钩子函数参数</h4><p>指令钩子函数会被传入以下参数：</p><ul><li><p><code>el</code>：指令所绑定的元素，可以用来直接操作 DOM 。</p></li><li><p><code>binding</code>：一个对象，包含以下属性：</p><ul><li><code>name</code>：指令名，不包括 <code>v-</code> 前缀。</li><li><code>value</code>：指令的绑定值，例如：<code>v-my-directive=&quot;1 + 1&quot;</code> 中，绑定值为 <code>2</code>。</li><li><code>oldValue</code>：指令绑定的前一个值，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。无论值是否改变都可用。</li><li><code>expression</code>：字符串形式的指令表达式。例如 <code>v-my-directive=&quot;1 + 1&quot;</code> 中，表达式为 <code>&quot;1 + 1&quot;</code>。</li><li><code>arg</code>：传给指令的参数，可选。例如 <code>v-my-directive:foo</code> 中，参数为 <code>&quot;foo&quot;</code>。</li><li><code>modifiers</code>：一个包含修饰符的对象。例如：<code>v-my-directive.foo.bar</code> 中，修饰符对象为 <code>{ foo: true, bar: true }</code>。</li></ul></li><li><p><code>vnode</code>：Vue 编译生成的虚拟节点。移步 <a href="https://cn.vuejs.org/v2/api/#VNode-接口" target="_blank" rel="noopener">VNode API</a> 来了解更多详情。</p></li><li><p><code>oldVnode</code>：上一个虚拟节点，仅在 <code>update</code> 和 <code>componentUpdated</code> 钩子中可用。</p><p>除了 <code>el</code> 之外，其它参数都应该是只读的，切勿进行修改。如果需要在钩子之间共享数据，建议通过元素的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLElement/dataset" target="_blank" rel="noopener"><code>dataset</code></a> 来进行。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;dynamicexample&quot;&gt;</span><br><span class="line">  &lt;h3&gt;Scroll down inside this section ↓&lt;/h3&gt;</span><br><span class="line">  &lt;p v-pin:[direction]=&quot;200&quot;&gt;I am pinned onto the page at 200px to the left.&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">Vue.directive(&apos;pin&apos;, &#123;</span><br><span class="line">  bind: function (el, binding, vnode) &#123;</span><br><span class="line">    el.style.position = &apos;fixed&apos;</span><br><span class="line">    var s = (binding.arg == &apos;left&apos; ? &apos;left&apos; : &apos;top&apos;)</span><br><span class="line">    el.style[s] = binding.value + &apos;px&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  el: &apos;#dynamicexample&apos;,</span><br><span class="line">  data: function () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      direction: &apos;left&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="8-一句话就能回答的面试题"><a href="#8-一句话就能回答的面试题" class="headerlink" title="8. 一句话就能回答的面试题"></a>8. 一句话就能回答的面试题</h2><p><strong>1.css只在当前组件起作用</strong> 答：在style标签中写入<strong>scoped</strong>即可 例如：</p><p><strong>2.v-if 和 v-show 区别</strong> 答：v-if按照条件是否渲染，v-show是display的block或none；</p><p><strong>3.route和router的区别</strong> 答：route是”路由信息对象”，包括path，params，hash，query，fullPath，matched，name等路由信息参数。而router是“路由实例”对象包括了路由的跳转方法，钩子函数等。</p><p><strong>4.vue.js的两个核心是什么？</strong> 答：数据驱动、组件系统</p><p><strong>5.vue几种常用的指令</strong> 答：v-for 、 v-if 、v-bind、v-on、v-show、v-else</p><p><strong>6.vue常用的修饰符？</strong> 答：.prevent: 提交事件不再重载页面；.stop: 阻止单击事件冒泡；.self: 当事件发生在该元素本身而不是子元素的时候会触发；.capture: 事件侦听，事件发生的时候会调用</p><p><strong>7.v-on 可以绑定多个方法吗？</strong> 答：可以</p><p><strong>8.vue中 key 值的作用？</strong> 答：当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。key的作用主要是为了高效的更新虚拟DOM。</p><p><strong>9.什么是vue的计算属性？</strong> 答：在模板中放入太多的逻辑会让模板过重且难以维护，在需要对数据进行复杂处理，且可能多次使用的情况下，尽量采取计算属性的方式。好处：①使得数据处理结构清晰；②依赖于数据，数据更新，处理结果自动更新；③计算属性内部this指向vm实例；④在template调用时，直接写计算属性名即可；⑤常用的是getter方法，获取数据，也可以使用set方法改变数据；⑥相较于methods，不管依赖的数据变不变，methods都会重新计算，但是依赖数据不变的时候computed从缓存中获取，不会重新计算。</p><p><strong>10.vue等单页面应用及其优缺点</strong> 答：优点：Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件，核心是一个响应的数据绑定系统。MVVM、数据驱动、组件化、轻量、简洁、高效、快速、模块友好。 ==<strong>缺点：</strong>不支持低版本的浏览器，最低只支持到IE9；不利于SEO的优化（如果要支持SEO，建议通过服务端来进行渲染组件）；第一次加载首页耗时相对长一些；不可以使用浏览器的导航按钮需要自行实现前进、后退。==</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue&quot;&gt;&lt;a href=&quot;#vue&quot; class=&quot;headerlink&quot; title=&quot;vue&quot;&gt;&lt;/a&gt;vue&lt;/h1&gt;&lt;p&gt;Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的 渐进式框架。与其他重量级框架不同的是，Vue 采用自底
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>Vue使用异步更新队列</title>
    <link href="http://yoursite.com/2020/02/09/Vue%E4%BD%BF%E7%94%A8%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/02/09/Vue使用异步更新队列/</id>
    <published>2020-02-08T16:06:21.000Z</published>
    <updated>2020-02-08T16:07:02.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue使用异步更新队列"><a href="#Vue使用异步更新队列" class="headerlink" title="Vue使用异步更新队列"></a>Vue使用异步更新队列</h1><h2 id="DOM的异步更新"><a href="#DOM的异步更新" class="headerlink" title="DOM的异步更新"></a>DOM的异步更新</h2><p>异步更新队列指的是当状态发生变化时，Vue异步执行DOM更新。</p><p>我们在项目开发中会遇到这样一种场景：当我们将状态改变之后想获取更新后的DOM，往往我们获取到的DOM是更新前的旧DOM，我们需要使用<code>vm.$nextTick</code>方法异步获取DOM，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'example'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'</span>,</span><br><span class="line">  data: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      message: <span class="string">'没有更新'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    updateMessage: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.message = <span class="string">'更新完成'</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '没有更新'</span></span><br><span class="line">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$el.textContent) <span class="comment">// =&gt; '更新完成'</span></span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们都知道这样做很麻烦，但为什么Vue还要这样做呢？</p><p>首先我们假设Vue是同步执行DOM更新，会有什么问题？</p><p>如果同步更新DOM将会有这样一个问题，我们在代码中同步更新数据N次，DOM也会更新N次，伪代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.message = <span class="string">'更新完成'</span> <span class="comment">// DOM更新一次</span></span><br><span class="line"><span class="keyword">this</span>.message = <span class="string">'更新完成2'</span> <span class="comment">// DOM更新两次</span></span><br><span class="line"><span class="keyword">this</span>.message = <span class="string">'更新完成3'</span> <span class="comment">// DOM更新三次</span></span><br><span class="line"><span class="keyword">this</span>.message = <span class="string">'更新完成4'</span> <span class="comment">// DOM更新四次</span></span><br></pre></td></tr></table></figure><p>但事实上，我们真正想要的其实只是最后一次更新而已，也就是说前三次DOM更新都是可以省略的，我们只需要等所有状态都修改好了之后再进行渲染就可以减少一些无用功。</p><p>而这种无用功在Vue2.0开始变得更为重要，Vue2.0开始引入了Virtualdom，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用VirtualDOM进行计算得出需要更新的具体的DOM节点，然后对DOM进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要。</p><p>组件内部使用VIrtualDOM进行渲染，也就是说，组件内部其实是不关心哪个状态发生了变化，它只需要计算一次就可以得知哪些节点需要更新。也就是说，如果更改了N个状态，其实只需要发送一个信号就可以将DOM更新到最新。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.message = <span class="string">'更新完成'</span></span><br><span class="line"><span class="keyword">this</span>.age =  <span class="number">23</span></span><br><span class="line"><span class="keyword">this</span>.name = berwin</span><br></pre></td></tr></table></figure><p>代码中我们分三次修改了三种状态，但其实Vue只会渲染一次。因为VIrtualDOM只需要一次就可以将整个组件的DOM更新到最新，它根本不会关心这个更新的信号到底是从哪个具体的状态发出来的。</p><p>那如何才能将渲染操作推迟到所有状态都修改完毕呢？很简单，只需要将渲染操作推迟到本轮事件循环的最后或者下一轮事件循环。也就是说，只需要在本轮事件循环的最后，等前面更新状态的语句都执行完之后，执行一次渲染操作，它就可以无视前面各种更新状态的语法，无论前面写了多少条更新状态的语句，只在最后渲染一次就可以了。</p><p>将渲染推迟到本轮事件循环的最后执行渲染的时机会比推迟到下一轮快很多，所以Vue优先将渲染操作推迟到本轮事件循环的最后，如果执行环境不支持会降级到下一轮。</p><p>当然，Vue的变化侦测机制决定了它必然会在每次状态发生变化时都会发出渲染的信号，但Vue会在收到信号之后检查队列中是否已经存在这个任务，保证队列中不会有重复。如果队列中不存在则将渲染操作添加到队列中。</p><p>之后通过异步的方式延迟执行队列中的所有渲染的操作并清空队列，当同一轮事件循环中反复修改状态时，并不会反复向队列中添加相同的渲染操作。</p><p>所以我们在使用Vue时，修改状态后更新DOM都是异步的。</p><h2 id="Watcher队列"><a href="#Watcher队列" class="headerlink" title="Watcher队列"></a>Watcher队列</h2><h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><p>在<code>Watcher</code>的源码中，我们发现<code>watcher</code>的<code>update</code>其实是异步的。（注：<code>sync</code>属性默认为<code>false</code>，也就是异步）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.lazy) &#123;</span><br><span class="line">        <span class="keyword">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.sync) &#123;</span><br><span class="line">        <span class="comment">/*同步则执行run直接渲染视图*/</span></span><br><span class="line">        <span class="keyword">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/*异步推送到观察者队列中，下一个tick时调用。*/</span></span><br><span class="line">        queueWatcher(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h3><p><code>queueWatcher(this)</code>函数的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">    <span class="comment">/*获取watcher的id*/</span></span><br><span class="line">    <span class="keyword">const</span> id = watcher.id</span><br><span class="line">    <span class="comment">/*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/</span></span><br><span class="line">    <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">        has[id] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">            <span class="comment">/*如果没有flush掉，直接push到队列中即可*/</span></span><br><span class="line">            queue.push(watcher)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// queue the flush</span></span><br><span class="line">        <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">            waiting = <span class="literal">true</span></span><br><span class="line">            nextTick(flushSchedulerQueue)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段源码有几个需要注意的地方：</p><ol><li>首先需要知道的是<code>watcher</code>执行<code>update</code>的时候，默认情况下肯定是异步的，它会做以下的两件事：<ul><li>判断<code>has</code>数组中是否有这个<code>watcher</code>的<code>id</code></li><li>如果有的话是不需要把<code>watcher</code>加入<code>queue</code>中的，否则不做任何处理。</li></ul></li><li>这里面的<code>nextTick(flushSchedulerQueue)</code>中，<code>flushScheduleQueue</code>函数的作用主要是执行视图更新的操作，它会把<code>queue</code>中所有的<code>watcher</code>取出来并执行相应的视图更新。</li><li>核心其实是<code>nextTick</code>函数了，下面我们具体看一下<code>nextTick</code>到底有什么用。</li></ol><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><p><code>nextTick</code>函数其实做了两件事情，一是生成一个<code>timerFunc</code>，把回调作为<code>microTask</code>或<code>macroTask</code>参与到事件循环中来。二是把回调函数放入一个<code>callbacks</code>队列，等待适当的时机执行。（这个时机和<code>timerFunc</code>不同的实现有关）</p><p>首先我们先来看它是怎么生成一个<code>timerFunc</code>把回调作为<code>microTask</code>或<code>macroTask</code>的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">    <span class="comment">/*使用Promise*/</span></span><br><span class="line">    <span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">    <span class="keyword">var</span> logError = <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="built_in">console</span>.error(err) &#125;</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        p.then(nextTickHandler).catch(logError)</span><br><span class="line">        <span class="comment">// in problematic UIWebViews, Promise.then doesn't completely break, but</span></span><br><span class="line">        <span class="comment">// it can get stuck in a weird state where callbacks are pushed into the</span></span><br><span class="line">        <span class="comment">// microTask queue but the queue isn't being flushed, until the browser</span></span><br><span class="line">        <span class="comment">// needs to do some other work, e.g. handle a timer. Therefore we can</span></span><br><span class="line">        <span class="comment">// "force" the microTask queue to be flushed by adding an empty timer.</span></span><br><span class="line">        <span class="keyword">if</span> (isIOS) setTimeout(noop)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> MutationObserver !== <span class="string">'undefined'</span> &amp;&amp; (</span><br><span class="line">    isNative(MutationObserver) ||</span><br><span class="line">    <span class="comment">// PhantomJS and iOS 7.x</span></span><br><span class="line">    MutationObserver.toString() === <span class="string">'[object MutationObserverConstructor]'</span></span><br><span class="line">    )) &#123;</span><br><span class="line">    <span class="comment">// use MutationObserver where native Promise is not available,</span></span><br><span class="line">    <span class="comment">// e.g. PhantomJS IE11, iOS7, Android 4.4</span></span><br><span class="line">    <span class="comment">/*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/</span></span><br><span class="line">    <span class="keyword">var</span> counter = <span class="number">1</span></span><br><span class="line">    <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(nextTickHandler)</span><br><span class="line">    <span class="keyword">var</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">    observer.observe(textNode, &#123;</span><br><span class="line">        characterData: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">        textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fallback to setTimeout</span></span><br><span class="line">    <span class="comment">/* istanbul ignore next */</span></span><br><span class="line">    <span class="comment">/*使用setTimeout将回调推入任务队列尾部*/</span></span><br><span class="line">    timerFunc = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(nextTickHandler, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，它会按照<code>Promise</code>、<code>MutationObserver</code>、<code>setTimeout</code>优先级去调用传入的回调函数。前两者会生成一个<code>microTask</code>任务，而后者会生成一个<code>macroTask</code>。（微任务和宏任务）</p><p>之所以会设置这样的优先级，主要是考虑到浏览器之间的兼容性（<code>IE</code>没有内置<code>Promise</code>）。另外，设置<code>Promise</code>最优先是因为<code>Promise.resolve().then</code>回调函数属于一个<strong>微任务</strong>，浏览器在一个<code>Tick</code>中执行完<code>macroTask</code>后会清空当前<code>Tick</code>所有的<code>microTask</code>再进行<code>UI</code>渲染，把<code>DOM</code>更新的操作放在<code>Tick</code>执行<code>microTask</code>的阶段来完成，相比使用<code>setTimeout</code>生成的一个<code>macroTask</code>会少一次<code>UI</code>的渲染。</p><p>而<code>nextTickHandler</code>函数，其实才是我们真正要执行的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTickHandler</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    pending = <span class="literal">false</span></span><br><span class="line">    <span class="comment">/*执行所有callback*/</span></span><br><span class="line">    <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">    callbacks.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">        copies[i]()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的<code>callbacks</code>变量供<code>nextTickHandler</code>消费。而前面我们所说的<code>nextTick</code>函数第二点功能中“等待适当的时机执行”，其实就是因为<code>timerFunc</code>的实现方式有差异，如果是<code>Promise\MutationObserver</code>则<code>nextTickHandler</code>回调是一个<code>microTask</code>，它会在当前<code>Tick</code>的末尾来执行。如果是<code>setTiemout</code>则<code>nextTickHandler</code>回调是一个<code>macroTask</code>，它会在下一个<code>Tick</code>来执行。</p><p>还有就是<code>callbacks</code>中的成员是如何被<code>push</code>进来的？从源码中我们可以知道，<code>nextTick</code>是一个自执行的函数，一旦执行是<code>return</code>了一个<code>queueNextTick</code>，所以我们在调用<code>nextTick</code>其实就是在调用<code>queueNextTick</code>这个函数。它的源代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">queueNextTick</span> (<span class="params">cb?: Function, ctx?: Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> _resolve</span><br><span class="line">    <span class="comment">/*cb存到callbacks中*/</span></span><br><span class="line">    callbacks.push(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            cb.call(ctx)</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">            handleError(e, ctx, <span class="string">'nextTick'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">            _resolve(ctx)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">        pending = <span class="literal">true</span></span><br><span class="line">        timerFunc()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">            _resolve = resolve</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，一旦调用<code>nextTick</code>函数时候，传入的<code>function</code>就会被存放到<code>callbacks</code>闭包中，然后这个<code>callbacks</code>由<code>nextTickHandler</code>消费，而<code>nextTickHandler</code>的执行时间又是由<code>timerFunc</code>来决定。</p><p>回看<code>Watcher</code>这里面的<code>nextTick(flushSchedulerQueue)</code>中的<code>flushSchedulerQueue</code>函数其实就是<code>watcher</code>的视图更新。调用的时候会把它<code>push</code>到<code>callbacks</code>中来异步执行。</p><p>另外，关于<code>waiting</code>变量，这是很重要的一个标志位，它保证<code>flushSchedulerQueue</code>回调只允许被置入<code>callbacks</code>一次。</p><p>也就是说，默认<code>waiting</code>变量为<code>false</code>，执行一次后<code>waiting</code>为<code>true</code>，后续的<code>this.xxx</code>不会再次触发<code>nextTick</code>的执行，而是把<code>this.xxx</code>相对应的<code>watcher</code>推入<code>flushSchedulerQueue</code>的<code>queue</code>队列中。</p><p><strong>所以，也就是说DOM确实是异步更新，但是具体是在下一个Tick更新还是在当前Tick执行microTask的时候更新，具体要看nextTcik的实现方式，也就是具体跑的是Promise/MutationObserver还是setTimeout。</strong></p><h2 id="为什么要异步更新"><a href="#为什么要异步更新" class="headerlink" title="为什么要异步更新"></a>为什么要异步更新</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;test&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    data () &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            test: <span class="number">0</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">this</span>.test++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在有这样的一种情况，<code>mounted</code>的时候<code>test</code>的值会被<code>++</code>循环执行<code>1000</code>次。 每次<code>++</code>时，都会根据响应式触发<code>setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;run</code>。 如果这时候没有异步更新视图，那么每次<code>++</code>都会直接操作<code>DOM</code>更新视图，这是非常消耗性能的。 所以<code>Vue</code>实现了一个<code>queue</code>队列，在下一个<code>Tick</code>（或者是当前<code>Tick</code>的微任务阶段）的时候会统一执行<code>queue</code>中<code>Watcher</code>的<code>run</code>。同时，拥有相同<code>id</code>的<code>Watcher</code>不会被重复加入到该<code>queue</code>中去，所以不会执行<code>1000</code>次<code>Watcher</code>的<code>run</code>。最终更新视图只会直接将<code>test</code>对应的<code>DOM</code>的<code>0</code>变成<code>1000</code>。 保证更新视图操作<code>DOM</code>的动作是在当前栈执行完以后下一个<code>Tick</code>（或者是当前<code>Tick</code>的微任务阶段）的时候调用，大大优化了性能。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue使用异步更新队列&quot;&gt;&lt;a href=&quot;#Vue使用异步更新队列&quot; class=&quot;headerlink&quot; title=&quot;Vue使用异步更新队列&quot;&gt;&lt;/a&gt;Vue使用异步更新队列&lt;/h1&gt;&lt;h2 id=&quot;DOM的异步更新&quot;&gt;&lt;a href=&quot;#DOM的异步更新&quot;
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>token详解</title>
    <link href="http://yoursite.com/2020/02/03/token%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/02/03/token详解/</id>
    <published>2020-02-03T13:44:07.000Z</published>
    <updated>2020-02-08T16:01:08.662Z</updated>
    
    <content type="html"><![CDATA[<h1 id="token详解"><a href="#token详解" class="headerlink" title="token详解"></a>token详解</h1><h2 id="1-传统身份验证的方法（session）"><a href="#1-传统身份验证的方法（session）" class="headerlink" title="1.传统身份验证的方法（session）"></a>1.传统身份验证的方法（session）</h2><p>HTTP 是一种没有状态的协议，也就是它并不知道是谁是访问应用。这里我们把用户看成是客户端，客户端使用用户名还有密码通过了身份验证，不过下回这个客户端再发送请求时候，还得再验证一下。</p><p>解决的方法就是，当用户请求登录的时候，如果没有问题，我们在服务端生成一条记录，这个记录里可以说明一下登录的用户是谁，然后把这条记录的 ID 号发送给客户端，客户端收到以后把这个 ID 号存储在 Cookie 里，下次这个用户再向服务端发送请求的时候，可以带着这个 Cookie ，这样服务端会验证一个这个 Cookie 里的信息，看看能不能在服务端这里找到对应的记录，如果可以，说明用户已经通过了身份验证，就把用户请求的数据返回给客户端。</p><p>上面说的就是 Session，我们需要在服务端存储为登录的用户生成的 Session ，这些 Session 可能会存储在内存，磁盘，或者数据库里。我们可能需要在服务端定期的去清理过期的 Session 。</p><h3 id="基于服务器验证方式暴露的一些问题"><a href="#基于服务器验证方式暴露的一些问题" class="headerlink" title="基于服务器验证方式暴露的一些问题"></a>基于服务器验证方式暴露的一些问题</h3><p>1.Seesion：每次认证用户发起请求时，服务器需要去创建一个记录来存储信息。当越来越多的用户发请求时，内存的开销也会不断增加。</p><p>2.可扩展性：在服务端的内存中使用Seesion存储登录信息，伴随而来的是可扩展性问题。</p><p>3.CORS(跨域资源共享)：当我们需要让数据跨多台移动设备上使用时，跨域资源的共享会是一个让人头疼的问题。在使用Ajax抓取另一个域的资源，就可能会出现禁止请求的情况。</p><p>4.CSRF(跨站请求伪造)：用户在访问银行网站时，他们很容易受到跨站请求伪造的攻击，并且能够被利用其访问其他的网站。</p><p>在这些问题中，可扩展行是最突出的。</p><h2 id="2-基于-Token-的身份验证方法"><a href="#2-基于-Token-的身份验证方法" class="headerlink" title="2.基于 Token 的身份验证方法"></a>2.基于 Token 的身份验证方法</h2><p>使用基于 Token 的身份验证方法是无状态的，在服务端不需要存储用户的登录记录。NoSession意味着你的程序可以根据需要去增减机器，而不用去担心用户是否登录。</p><p>大概的流程是这样的：</p><ol><li>客户端使用用户名跟密码请求登录</li><li>服务端收到请求，去验证用户名与密码</li><li>验证成功后，服务端会签发一个 Token，再把这个 Token 发送给客户端</li><li>客户端收到 Token 以后可以把它存储起来，比如放在 Cookie 里或者 Local Storage 里</li><li>客户端每次向服务端请求资源的时候需要带着服务端签发的 Token</li><li>服务端收到请求，然后去验证客户端请求里面带着的 Token，如果验证成功，就向客户端返回请求的数据（token应该在HTTP的头部发送从而保证了Http请求无状态。我们同样通过设置服务器属性<code>Access-Control-Allow-Origin:*</code>，让服务器能接受到来自所有域的请求。需要注意的是，在ACAO头部标明(designating)*时，不得带有像HTTP认证，客户端SSL证书和cookies的证书。）</li></ol><h3 id="以下几点特性会让你在程序中使用基于Token的身份验证"><a href="#以下几点特性会让你在程序中使用基于Token的身份验证" class="headerlink" title="以下几点特性会让你在程序中使用基于Token的身份验证"></a>以下几点特性会让你在程序中使用基于Token的身份验证</h3><ol><li><p>无状态、可扩展</p></li><li><p>支持移动设备</p></li><li><p>跨程序调用</p></li><li><p>安全</p></li></ol><h2 id="3-Tokens的优势"><a href="#3-Tokens的优势" class="headerlink" title="3.Tokens的优势"></a>3.Tokens的优势</h2><h3 id="无状态、可扩展"><a href="#无状态、可扩展" class="headerlink" title="无状态、可扩展"></a>无状态、可扩展</h3><p>在客户端存储的Tokens是无状态的，并且能够被扩展。基于这种无状态和不存储Session信息，负载负载均衡器能够将用户信息从一个服务传到其他服务器上。</p><p>如果我们将已验证的用户的信息保存在Session中，则每次请求都需要用户向已验证的服务器发送验证信息(称为Session亲和性)。用户量大时，可能会造成一些拥堵。</p><p>使用tokens之后这些问题都迎刃而解，因为tokens自己hold住了用户的验证信息。</p><p>Tokens能够创建与其它程序共享权限的程序。例如，能将一个随便的社交帐号和自己的大号(Fackbook或是Twitter)联系起来。当通过服务登录Twitter(我们将这个过程Buffer)时，我们可以将这些Buffer附到Twitter的数据流上(we are allowing Buffer to post to our Twitter stream)。</p><p>使用tokens时，可以提供可选的权限给第三方应用程序。当用户想让另一个应用程序访问它们的数据，我们可以通过建立自己的API，得出特殊权限的tokens。</p><h3 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h3><p>请求中发送token而不再是发送cookie能够防止CSRF(跨站请求伪造)。即使在客户端使用cookie存储token，cookie也仅仅是一个存储机制而不是用于认证。不将信息存储在Session中，让我们少了对session操作。 </p><p>token是有时效的，一段时间之后用户需要重新验证。我们也不一定需要等到token自动失效，token有撤回的操作，通过token revocataion可以使一个特定的token或是一组有相同认证的token无效。</p><h3 id="多平台跨域"><a href="#多平台跨域" class="headerlink" title="多平台跨域"></a>多平台跨域</h3><p>我们提前先来谈论一下CORS(跨域资源共享)，对应用程序和服务进行扩展的时候，需要介入各种各样的设备和应用程序。</p><p>只要用户有一个通过了验证的token，数据和资源就能够在任何域上被请求到。</p><h3 id="基于标准"><a href="#基于标准" class="headerlink" title="基于标准"></a>基于标准</h3><p>创建token的时候，你可以设定一些选项。我们在后续的文章中会进行更加详尽的描述，但是标准的用法会在JSON Web Tokens体现。</p><p>最近的程序和文档是供给JSON Web Tokens的。它支持众多的语言。这意味在未来的使用中你可以真正的转换你的认证机制。</p><h2 id="4-传统的token组成"><a href="#4-传统的token组成" class="headerlink" title="4.传统的token组成"></a>4.传统的token组成</h2><p>token也称作令牌，由<strong>uid+time+sign[+固定参数]</strong>组成:</p><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h2 id="5-JWT-token的组成"><a href="#5-JWT-token的组成" class="headerlink" title="5.JWT token的组成"></a>5.JWT token的组成</h2><p>实施 Token 验证的方法挺多的，还有一些标准方法，比如 JWT，读作：jot ，表示：JSON Web Tokens 。JWT 标准的 Token 有三个部分：</p><ul><li>header</li><li>payload</li><li>signature</li></ul><p>中间用点分隔开，并且都会使用 Base64 编码，所以真正的 Token 看起来像这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0</span><br><span class="line">Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKX</span><br><span class="line">tabJecpejuef8AqKYMAJc</span><br></pre></td></tr></table></figure><h3 id="header"><a href="#header" class="headerlink" title="header"></a>header</h3><p>header 部分主要是两部分内容，一个是 Token 的类型，另一个是使用的算法</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"typ"</span>: <span class="string">"JWT"</span>,</span><br><span class="line">  <span class="attr">"alg"</span>: <span class="string">"HS256"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型就是 JWT，使用的算法是 HS256.</p><p>上面的内容要用 Base64 的形式编码一下，所以就变成这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span><br></pre></td></tr></table></figure><h3 id="Payload"><a href="#Payload" class="headerlink" title="Payload"></a>Payload</h3><p>Payload 里面是 Token 的具体内容，这些内容里面有一些是标准字段，你也可以添加其它需要的内容。下面是标准字段：</p><ul><li>iss：Issuer，发行者</li><li>sub：Subject，主题</li><li>aud：Audience，观众</li><li>exp：Expiration time，过期时间</li><li>nbf：Not before</li><li>iat：Issued at，发行时间</li><li>jti：JWT ID</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="attr">"iss"</span>: <span class="string">"ninghao.net"</span>,</span><br><span class="line"> <span class="attr">"exp"</span>: <span class="string">"1438955445"</span>,</span><br><span class="line"> <span class="attr">"name"</span>: <span class="string">"wanghao"</span>,</span><br><span class="line"> <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 Base64 编码以后就变成了这个样子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsI</span><br><span class="line">mFkbWluIjp0cnVlfQ</span><br></pre></td></tr></table></figure><h3 id="Signature"><a href="#Signature" class="headerlink" title="Signature"></a>Signature</h3><p>JWT 的最后一部分是 Signature ，这部分内容有三个部分，先是用 Base64 编码的 header.payload ，再用加密算法加密一下，加密的时候要放进去一个 Secret ，这个相当于是一个密码，这个密码秘密地存储在服务端。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodedString = base64UrlEncode(header) + "." + base64UrlEncode(payload); </span><br><span class="line">HMACSHA256(encodedString, 'secret');</span><br></pre></td></tr></table></figure><p>处理完成以后看起来像这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SwyHTEx_RQppr97g4J5lKXtabJecpejuef8AqKYMAJc</span><br></pre></td></tr></table></figure><p>最后这个在服务端生成并且要发送给客户端的 Token 看起来像这样：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJuaW5naGFvLm5ldCIsImV4cCI6IjE0</span><br><span class="line">Mzg5NTU0NDUiLCJuYW1lIjoid2FuZ2hhbyIsImFkbWluIjp0cnVlfQ.SwyHTEx_RQppr97g4J5lKX</span><br><span class="line">tabJecpejuef8AqKYMAJc</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;token详解&quot;&gt;&lt;a href=&quot;#token详解&quot; class=&quot;headerlink&quot; title=&quot;token详解&quot;&gt;&lt;/a&gt;token详解&lt;/h1&gt;&lt;h2 id=&quot;1-传统身份验证的方法（session）&quot;&gt;&lt;a href=&quot;#1-传统身份验证的方法（s
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="安全" scheme="http://yoursite.com/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>symbol</title>
    <link href="http://yoursite.com/2020/01/22/symbol/"/>
    <id>http://yoursite.com/2020/01/22/symbol/</id>
    <published>2020-01-22T07:20:01.000Z</published>
    <updated>2020-02-08T15:52:00.342Z</updated>
    
    <content type="html"><![CDATA[<h1 id="symbol"><a href="#symbol" class="headerlink" title="symbol"></a>symbol</h1><h2 id="symbol的特性。"><a href="#symbol的特性。" class="headerlink" title="symbol的特性。"></a>symbol的特性。</h2><ul><li><p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</p></li><li><p>凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。（Symbol 值作为对象属性名时，不能用点运算符。因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。）Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p></li><li><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p></li><li><p>symbol一旦创建后就不可更改。</p></li><li><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p></li><li><p>Symbol 值不能与其他类型的值进行运算，会报错。（Symbol 不能自动被转换为字符串，当尝试将一个 Symbol 强制转换为字符串时，将返回一个 TypeError。）</p></li><li><p>Symbol 值可以显式转为字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure></li><li><p>Symbol属性名遍历：Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p><p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, foo, &#123;</span><br><span class="line">  value: <span class="string">"foobar"</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span><br><span class="line"><span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure><p><code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  enum: <span class="number">2</span>,</span><br><span class="line">  nonEnum: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Reflect</span>.ownKeys(obj)</span><br><span class="line"><span class="comment">//  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure><p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p></li></ul><h2 id="获取-Symbol-的三种方法"><a href="#获取-Symbol-的三种方法" class="headerlink" title="获取 Symbol 的三种方法"></a>获取 Symbol 的三种方法</h2><ul><li><strong>Symbol()</strong> 每次调用时都返回一个唯一的 Symbol。</li><li><strong>Symbol.for(string) 、Symbol.keyFor()</strong><code>Symbol.For</code>从 Symbol 注册表中返回相应的 Symbol，与上个方法不同的是，Symbol 注册表中的 Symbol 是共享的。也就是说，如果你调用 <code>Symbol.for(&quot;cat&quot;)</code> 三次，都将返回相同的 Symbol。当不同页面或同一页面不同模块需要共享 Symbol 时，注册表就非常有用。（<code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。）<code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</li><li><strong>Symbol.iterator</strong> 返回语言预定义的一些 Symbol，每个都有其特殊的用途。</li></ul><h2 id="Symbol-在-ES6-规范中的应用"><a href="#Symbol-在-ES6-规范中的应用" class="headerlink" title="Symbol 在 ES6 规范中的应用"></a>Symbol 在 ES6 规范中的应用</h2><p>我们已经知道可以使用 Symbol 来避免代码冲突。之前在<a href="https://hacks.mozilla.org/2015/04/es6-in-depth-iterators-and-the-for-of-loop/" target="_blank" rel="noopener">介绍 iterator</a> 时，我们还解析了 <code>for (var item of myArray)</code> 内部是以调用 <code>myArray[Symbol.iterator]()</code> 开始的，当时我提到这个方法可以使用 <code>myArray.iterator()</code> 来代替，但是使用 Symbol 的后向兼容性更好。</p><p>在 ES6 中还有一些地方使用到了 Symbol。（这些特性还没有在 FireFox 中实现。）</p><ul><li><strong>使 instanceof 可扩展</strong>。在 ES6 中，<code>object instanceof constructor</code> 表达式被标准化为构造函数的一个方法：<code>constructor[Symbol.hasInstance](object)</code>，这意味着它是可扩展的。</li><li><strong>消除新特性和旧代码之间的冲突</strong>。</li><li><strong>支持新类型的字符串匹配</strong>。在 ES5 中，调用 <code>str.match(myObject)</code> 时，首先会尝试将 <code>myObject</code> 转换为 <code>RegExp</code> 对象。在 ES6 中，首先将检查 <code>myObject</code> 中是否有 <code>myObject[Symbol.match](str)</code> 方法，在所有正则表达式工作的地方都可以提供一个自定义的字符串解析方法。</li></ul><p>##symbol的11个内置值</p><ul><li><code>Symbol.hasInstance</code>方法，会被<code>instanceof</code>运算符调用。构造器对象用来识别一个对象是否是其实例。</li><li><code>Symbol.isConcatSpreadable</code>布尔值，表示当在一个对象上调用<code>Array.prototype.concat</code>时，这个对象的数组元素是否可展开。</li><li><code>Symbol.iterator</code>方法，被<code>for-of</code>语句调用。返回对象的默认迭代器。</li><li><code>Symbol.match</code>方法，被<code>String.prototype.match</code>调用。正则表达式用来匹配字符串。</li><li><code>Symbol.replace</code>方法，被<code>String.prototype.replace</code>调用。正则表达式用来替换字符串中匹配的子串。</li><li><code>Symbol.search</code>方法，被<code>String.prototype.search</code>调用。正则表达式返回被匹配部分在字符串中的索引。</li><li><code>Symbol.species</code>函数值，为一个构造函数。用来创建派生对象。</li><li><code>Symbol.split</code>方法，被<code>String.prototype.split</code>调用。正则表达式来用分割字符串。</li><li><code>Symbol.toPrimitive</code>方法，被<code>ToPrimitive</code>抽象操作调用。把对象转换为相应的原始值。</li><li><code>Symbol.toStringTag</code>方法，被内置方法<code>Object.prototype.toString</code>调用。返回创建对象时默认的字符串描述。</li><li><code>Symbol.unscopables</code>对象，它自己拥有的属性会被<code>with</code>作用域排除在外。</li></ul><p>（详解可见阮一峰ES6入门<a href="http://es6.ruanyifeng.com/#docs/symbol）" target="_blank" rel="noopener">http://es6.ruanyifeng.com/#docs/symbol）</a></p><h2 id="模拟实现symbol"><a href="#模拟实现symbol" class="headerlink" title="模拟实现symbol"></a>模拟实现symbol</h2><h3 id="回顾特性"><a href="#回顾特性" class="headerlink" title="回顾特性"></a>回顾特性</h3><p><strong>1. Symbol 值通过 Symbol 函数生成，使用 typeof，结果为 “symbol”</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s); <span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure><p><strong>2. Symbol 函数前不能使用 new 命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。</strong></p><p><strong>3. instanceof 的结果为 false</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">Symbol</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>4. Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s1); <span class="comment">// Symbol(foo)</span></span><br></pre></td></tr></table></figure><p><strong>5. 如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line"><span class="built_in">console</span>.log(sym); <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure><p><strong>6. Symbol 函数的参数只是表示对当前 Symbol 值的描述，相同参数的 Symbol 函数的返回值是不相等的。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>7. Symbol 值不能与其他类型的值进行运算，会报错。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"your symbol is "</span> + sym); <span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure><p><strong>8. Symbol 值可以显式转为字符串。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(sym)); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString()); <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><p><strong>9. Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="attr">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line"><span class="built_in">console</span>.log(a[mySymbol]); <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure><p><strong>10. Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line"></span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(objectSymbols);</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure><p><strong>11. 如果我们希望使用同一个 Symbol 值，可以使用 Symbol.for。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s1 === s2); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>12. Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s1)); <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(s2) ); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h3 id="当调用-Symbol-的时候，发生什么？"><a href="#当调用-Symbol-的时候，发生什么？" class="headerlink" title="当调用 Symbol 的时候，发生什么？"></a>当调用 Symbol 的时候，发生什么？</h3><p>当调用 Symbol 的时候，会采用以下步骤：</p><ol><li>如果使用 new ，就报错</li><li>如果 description 是 undefined，让 descString 为 undefined</li><li>否则 让 descString 为 ToString(description)</li><li>如果报错，就返回</li><li>返回一个新的唯一的 Symbol 值，它的内部属性 [[Description]] 值为 descString</li></ol><h3 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一版</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> SymbolPolyfill = <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现第2点特性：Symbol 函数前不能使用 new 命令</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> SymbolPolyfill) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Symbol is not a constructor'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现第 5 点特性：如果 Symbol 的参数是一个对象，就会调用该对象的 toString 方法，将其转为字符串，然后才生成一个 Symbol 值。</span></span><br><span class="line">        <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(symbol, &#123;</span><br><span class="line">            <span class="string">'__Description__'</span>: &#123;</span><br><span class="line">                value: descString,</span><br><span class="line">                writable: <span class="literal">false</span>,</span><br><span class="line">                enumerable: <span class="literal">false</span>,</span><br><span class="line">                configurable: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现第 6 点特性，因为调用该方法，返回的是一个新对象，两个对象之间，只要引用不同，就不会相同</span></span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    root.SymbolPolyfill = SymbolPolyfill;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h3 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h3><p><strong>1. 使用 typeof，结果为 “symbol”。</strong></p><p>利用 ES5，我们并不能修改 typeof 操作符的结果，所以这个无法实现。</p><p><strong>3. instanceof 的结果为 false</strong></p><p>因为不是通过 new 的方式实现的，所以 instanceof 的结果自然是 false。</p><p><strong>4.Symbol 函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述。主要是为了在控制台显示，或者转为字符串时，比较容易区分。</strong></p><p>当我们打印一个原生 Symbol 值的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(Symbol(&apos;1&apos;)); // Symbol(1)</span><br></pre></td></tr></table></figure><p>可是我们模拟实现的时候返回的却是一个对象，所以这个也是无法实现的，当然你修改 console.log 这个方法是另讲。</p><p><strong>8.Symbol 值可以显式转为字符串。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">String</span>(sym)); <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line"><span class="built_in">console</span>.log(sym.toString()); <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure><p>当调用 String 方法的时候，如果该对象有 toString 方法，就会调用该 toString 方法，所以我们只要给返回的对象添加一个 toString 方法，即可实现这两个效果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第二版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 前面面代码相同 ……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Symbol('</span> + <span class="keyword">this</span>.__Description__ + <span class="string">')'</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure><h3 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h3><p><strong>Symbol 值可以作为标识符，用于对象的属性名，可以保证不会出现同名的属性。</strong></p><p>看着好像没什么，这点其实和第 8 点是冲突的，这是因为当我们模拟的所谓 Symbol 值其实是一个有着 toString 方法的 对象，当对象作为对象的属性名的时候，就会进行隐式类型转换，还是会调用我们添加的 toString 方法，对于 Symbol(‘foo’) 和 Symbol(‘foo’)两个 Symbol 值，虽然描述一样，但是因为是两个对象，所以并不相等，但是当作为对象的属性名的时候，都会隐式转换为 <code>Symbol(foo)</code> 字符串，这个时候就会造成同名的属性。举个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = SymbolPolyfill(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> b = SymbolPolyfill(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a ===  b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[a] = <span class="string">'hello'</span>;</span><br><span class="line">o[b] = <span class="string">'hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o); <span class="comment">// &#123;Symbol(foo): 'hi'&#125;</span></span><br></pre></td></tr></table></figure><p>为了防止不会出现同名的属性，毕竟这是一个非常重要的特性，迫不得已，我们需要修改 toString 方法，让它返回一个唯一值，所以第 8 点就无法实现了，而且我们还需要再写一个用来生成 唯一值的方法，就命名为 generateName，我们将该唯一值添加到返回对象的 <strong>Name</strong> 属性中保存下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第三版</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> generateName = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> postfix = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">descString</span>)</span>&#123;</span><br><span class="line">            postfix++;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'@@'</span> + descString + <span class="string">'_'</span> + postfix</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> SymbolPolyfill = <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> SymbolPolyfill) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Symbol is not a constructor'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">            toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.__Name__;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(symbol, &#123;</span><br><span class="line">            <span class="string">'__Description__'</span>: &#123;</span><br><span class="line">                value: descString,</span><br><span class="line">                writable: <span class="literal">false</span>,</span><br><span class="line">                enumerable: <span class="literal">false</span>,</span><br><span class="line">                configurable: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'__Name__'</span>: &#123;</span><br><span class="line">                value: generateName(descString),</span><br><span class="line">                writable: <span class="literal">false</span>,</span><br><span class="line">                enumerable: <span class="literal">false</span>,</span><br><span class="line">                configurable: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    root.SymbolPolyfill = SymbolPolyfill;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>此时再看下这个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = SymbolPolyfill(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> b = SymbolPolyfill(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a ===  b); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line">o[a] = <span class="string">'hello'</span>;</span><br><span class="line">o[b] = <span class="string">'hi'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(o); <span class="comment">// Object &#123; "@@foo_1": "hello", "@@foo_2": "hi" &#125;</span></span><br></pre></td></tr></table></figure><h3 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h3><p><strong>7.Symbol 值不能与其他类型的值进行运算，会报错。</strong></p><p>以 <code>+</code> 操作符为例，当进行隐式类型转换的时候，会先调用对象的 valueOf 方法，如果没有返回基本值，就会再调用 toString 方法，所以我们考虑在 valueOf 方法中进行报错，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot convert a Symbol value'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'1'</span> + symbol); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure><p>看着很简单的解决了这个问题，可是如果我们是显式调用 valueOf 方法呢？对于一个原生的 Symbol 值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(s1.valueOf()); <span class="comment">// Symbol(foo)</span></span><br></pre></td></tr></table></figure><p>是的，对于原生 Symbol，显式调用 valueOf 方法，会直接返回该 Symbol 值，而我们又无法判断是显式还是隐式的调用，所以这个我们就只能实现一半，要不然实现隐式调用报错，要不然实现显式调用返回该值，那……我们选择不报错的那个吧，即后者。</p><p>我们迫不得已的修改 valueOf 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第四版</span></span><br><span class="line"><span class="comment">// 前面面代码相同 ……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">    toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.__Name__;</span><br><span class="line">    &#125;,</span><br><span class="line">    valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure><h3 id="第五版"><a href="#第五版" class="headerlink" title="第五版"></a>第五版</h3><p><strong>10. Symbol 作为属性名，该属性不会出现在 for…in、for…of 循环中，也不会被 Object.keys()、Object.getOwnPropertyNames()、JSON.stringify() 返回。但是，它也不是私有属性，有一个 Object.getOwnPropertySymbols 方法，可以获取指定对象的所有 Symbol 属性名。</strong></p><p>嗯，无法实现。</p><p><strong>11. 有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</strong></p><p>这个实现类似于函数记忆，我们建立一个对象，用来储存已经创建的 Symbol 值即可。</p><p><strong>12. Symbol.keyFor 方法返回一个已登记的 Symbol 类型值的 key。</strong></p><p>遍历 forMap,查找该值对应的键值即可。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第五版</span></span><br><span class="line"><span class="comment">// 前面代码相同 ……</span></span><br><span class="line"><span class="keyword">var</span> SymbolPolyfill = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> forMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperties(SymbolPolyfill, &#123;</span><br><span class="line">    <span class="string">'for'</span>: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line">            <span class="keyword">return</span> forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);</span><br><span class="line">        &#125;,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'keyFor'</span>: &#123;</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> forMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (forMap[key] === symbol) <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        writable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">false</span>,</span><br><span class="line">        configurable: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure><h3 id="完整实现"><a href="#完整实现" class="headerlink" title="完整实现"></a>完整实现</h3><p>综上所述：</p><p>无法实现的特性有：1、4、7、8、10</p><p>可以实现的特性有：2、3、5、6、9、11、12</p><p>最后的实现如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> root = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> generateName = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> postfix = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">descString</span>)</span>&#123;</span><br><span class="line">            postfix++;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'@@'</span> + descString + <span class="string">'_'</span> + postfix</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> SymbolPolyfill = <span class="function"><span class="keyword">function</span> <span class="title">Symbol</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> SymbolPolyfill) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Symbol is not a constructor'</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> symbol = <span class="built_in">Object</span>.create(&#123;</span><br><span class="line">            toString: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>.__Name__;</span><br><span class="line">            &#125;,</span><br><span class="line">            valueOf: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Object</span>.defineProperties(symbol, &#123;</span><br><span class="line">            <span class="string">'__Description__'</span>: &#123;</span><br><span class="line">                value: descString,</span><br><span class="line">                writable: <span class="literal">false</span>,</span><br><span class="line">                enumerable: <span class="literal">false</span>,</span><br><span class="line">                configurable: <span class="literal">false</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'__Name__'</span>: &#123;</span><br><span class="line">                value: generateName(descString),</span><br><span class="line">                writable: <span class="literal">false</span>,</span><br><span class="line">                enumerable: <span class="literal">false</span>,</span><br><span class="line">                configurable: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> forMap = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Object</span>.defineProperties(SymbolPolyfill, &#123;</span><br><span class="line">        <span class="string">'for'</span>: &#123;</span><br><span class="line">            value: <span class="function"><span class="keyword">function</span>(<span class="params">description</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> descString = description === <span class="literal">undefined</span> ? <span class="literal">undefined</span> : <span class="built_in">String</span>(description)</span><br><span class="line">                <span class="keyword">return</span> forMap[descString] ? forMap[descString] : forMap[descString] = SymbolPolyfill(descString);</span><br><span class="line">            &#125;,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'keyFor'</span>: &#123;</span><br><span class="line">            value: <span class="function"><span class="keyword">function</span>(<span class="params">symbol</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> forMap) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (forMap[key] === symbol) <span class="keyword">return</span> key;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    root.SymbolPolyfill = SymbolPolyfill;</span><br><span class="line"></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;symbol&quot;&gt;&lt;a href=&quot;#symbol&quot; class=&quot;headerlink&quot; title=&quot;symbol&quot;&gt;&lt;/a&gt;symbol&lt;/h1&gt;&lt;h2 id=&quot;symbol的特性。&quot;&gt;&lt;a href=&quot;#symbol的特性。&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>ES6类以及继承的实现原理</title>
    <link href="http://yoursite.com/2020/01/17/ES6%E7%B1%BB%E4%BB%A5%E5%8F%8A%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2020/01/17/ES6类以及继承的实现原理/</id>
    <published>2020-01-17T15:46:51.000Z</published>
    <updated>2020-02-08T15:47:48.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6类以及继承的实现原理"><a href="#ES6类以及继承的实现原理" class="headerlink" title="ES6类以及继承的实现原理"></a>ES6类以及继承的实现原理</h1><h2 id="ES6创建一个类的过程"><a href="#ES6创建一个类的过程" class="headerlink" title="ES6创建一个类的过程"></a>ES6创建一个类的过程</h2><p>ES6中通过class关键字，定义类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    speakSomething()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过babel转码之后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">            descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: <span class="string">"speakSomething"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">speakSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><p><strong>ES6类的底层还是通过构造函数去创建的</strong></p><p>可见class的底层依然是构造函数：</p><ol><li><p>调用_classCallCheck方法判断当前函数调用前是否有new关键字。</p><p>构造函数执行前有new关键字，会在构造函数内部创建一个空对象，将构造函数的proptype指向这个空对象的<em>proto</em>,并将this指向这个空对象。如上，_classCallCheck中：this instanceof Parent 返回true。</p><p>若构造函数前面没有new则构造函数的proptype不会不出现在this的原型链上，返回false。</p><p>通过ES6创建的类，是不允许你直接调用的。在ES5中，构造函数是可以直接运行的，比如<code>Parent()</code>。但是在ES6就不行。我们可以看到转码的构造函数中有<code>_classCallCheck(this, Parent)</code>语句,这句话是防止你通过构造函数直接运行的。你直接在ES6运行<code>Parent()</code>,这是不允许的,ES6中抛出<code>Class constructor Parent cannot be invoked without &#39;new&#39;</code>错误。转码后的会抛出<code>Cannot call a class as a function</code>.我觉得这样的规范挺好的，能够规范化类的使用方式。</p></li><li><p>将class内部的变量和函数赋给this。</p><p>转码中<code>_createClass</code>方法，它调用<code>Object.defineProperty</code>方法去给新创建的<code>Parent</code>添加各种属性。<code>defineProperties(Constructor.prototype, protoProps)</code>是给原型添加属性。如果你有静态属性，会直接添加到构造函数上<code>defineProperties(Constructor, staticProps)</code>。</p></li><li><p>执行constuctor内部的逻辑。</p></li><li><p>return this (构造函数默认在最后我们做了)。</p></li></ol><h2 id="ES6实现继承"><a href="#ES6实现继承" class="headerlink" title="ES6实现继承"></a>ES6实现继承</h2><p><strong>1.调用_inherits函数继承父类的proptype。</strong></p><p><strong>2.用一个闭包保存父类引用，在闭包内部做子类构造逻辑。</strong></p><p><strong>3.new检查。</strong></p><p><strong>4.用当前this调用父类构造函数。</strong></p><p><strong>5.将行子类class内部的变量和函数赋给this。</strong></p><p><strong>6.执行子类constuctor内部的逻辑。</strong></p><p>es6实际上是为我们提供了一个“组合寄生继承”的简单写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> height = <span class="number">12</span></span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    speakSomething()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.color = <span class="string">'yellow'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类，继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> width = <span class="number">18</span></span><br><span class="line">    <span class="keyword">constructor</span>(name,age)&#123;</span><br><span class="line">        <span class="keyword">super</span>(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    coding()&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">"I can code JS"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="string">"job"</span>,<span class="number">30</span>);</span><br><span class="line">c.coding()</span><br></pre></td></tr></table></figure><p>转码之后的代码变成了这样</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> descriptor = props[i];</span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</span><br><span class="line">            descriptor.configurable = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        <span class="keyword">return</span> Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line"><span class="comment">//校验this是否被初始化，super是否调用，并返回父类已经赋值完的this。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_possibleConstructorReturn</span>(<span class="params">self, call</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!self) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">"this hasn't been initialised - super() hasn't been called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> call &amp;&amp; (<span class="keyword">typeof</span> call === <span class="string">"object"</span> || <span class="keyword">typeof</span> call === <span class="string">"function"</span>) ? call : self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_inherits</span>(<span class="params">subClass, superClass</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> superClass !== <span class="string">"function"</span> &amp;&amp; superClass !== <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Super expression must either be null or a function, not "</span> + <span class="keyword">typeof</span> superClass);</span><br><span class="line">    &#125;</span><br><span class="line">    subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (superClass) <span class="built_in">Object</span>.setPrototypeOf ? <span class="built_in">Object</span>.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_classCallCheck</span>(<span class="params">instance, Constructor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Parent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: <span class="string">"speakSomething"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">speakSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"I can speek chinese"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Parent;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">Parent.height = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">Parent.prototype.color = <span class="string">'yellow'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义子类，继承父类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Child = <span class="function"><span class="keyword">function</span> (<span class="params">_Parent</span>) </span>&#123;</span><br><span class="line">    _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">        _classCallCheck(<span class="keyword">this</span>, Child);</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**用当前this调用父类构造函数。</span></span><br><span class="line"><span class="comment">      * 这里的Child.proto || Object.getPrototypeOf(Child)实际上是父构造函数(_inherits最后的操作)，</span></span><br><span class="line"><span class="comment">      * 然后通过call将其调用方改为当前this，并传递参数。（这里感觉可以直接用参数传过来的Parent）*/</span></span><br><span class="line">        <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, (Child.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(Child)).call(<span class="keyword">this</span>, name, age));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Child, [&#123;</span><br><span class="line">        key: <span class="string">"coding"</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span> <span class="title">coding</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">"I can code JS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Child;</span><br><span class="line">&#125;(Parent);</span><br><span class="line"></span><br><span class="line">Child.width = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="string">"job"</span>, <span class="number">30</span>);</span><br><span class="line">c.coding();</span><br></pre></td></tr></table></figure><p>我们可以看到，构造类的方法都没变，只是添加了<code>_inherits</code>核心方法来实现继承</p><h3 id="inherits核心方法"><a href="#inherits核心方法" class="headerlink" title="_inherits核心方法"></a><code>_inherits</code>核心方法</h3><p>(1) 校验父构造函数。</p><p>(2) 典型的寄生继承：用父类构造函数的proptype创建一个空对象，并将这个对象指向子类构造函数的proptype。</p><p>(3) 将父构造函数指向子构造函数的_proto_（这步是做什么的不太明确，感觉没什么意义。）</p><p>首先是判断父类的类型，然后</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = <span class="built_in">Object</span>.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        <span class="keyword">constructor</span>: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            enumerable: <span class="literal">false</span>,</span><br><span class="line">            writable: <span class="literal">true</span>,</span><br><span class="line">            configurable: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>这段代码翻译下来就是</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">F.prototype = superClass.prototype</span><br><span class="line">subClass.prototype = <span class="keyword">new</span> F()</span><br><span class="line">subClass.prototype.constructor = subClass</span><br></pre></td></tr></table></figure><p>接下来<code>subClass.__proto__ = superClass</code><br><code>_inherits</code>核心思想就是下面两句</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype.__proto__ = superClass.prototype</span><br><span class="line">subClass.__proto__ = superClass</span><br></pre></td></tr></table></figure><p>首先 <code>subClass.prototype.__proto__ = superClass.prototype</code>保证了<code>c instanceof Parent</code>是true,Child的实例可以访问到父类的属性，包括内部属性，以及原型属性。其次，<code>subClass.__proto__ = superClass</code>，保证了Child.height也能访问到，也就是静态方法。</p><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><p>super代表父类构造函数。</p><p>super.fun1() 等同于 Parent.fun1() 或 Parent.prototype.fun1()。</p><p><strong>super() 等同于Parent.prototype.construtor()</strong></p><p>默认的构造函数中会主动调用父类构造函数，并默认把当前constructor传递的参数传给了父类。</p><p>所以当我们声明了constructor后必须主动调用super(),否则无法调用父构造函数，无法完成继承。</p><p>典型的例子就是Reatc的Component中，我们声明constructor后必须调用super(props)，因为父类要在构造函数中对props做一些初始化操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES6类以及继承的实现原理&quot;&gt;&lt;a href=&quot;#ES6类以及继承的实现原理&quot; class=&quot;headerlink&quot; title=&quot;ES6类以及继承的实现原理&quot;&gt;&lt;/a&gt;ES6类以及继承的实现原理&lt;/h1&gt;&lt;h2 id=&quot;ES6创建一个类的过程&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>yarn&amp;npm</title>
    <link href="http://yoursite.com/2020/01/07/yarn&amp;npm/"/>
    <id>http://yoursite.com/2020/01/07/yarn&amp;npm/</id>
    <published>2020-01-07T03:40:41.000Z</published>
    <updated>2020-02-08T15:43:53.535Z</updated>
    
    <content type="html"><![CDATA[<h1 id="yarn-amp-npm"><a href="#yarn-amp-npm" class="headerlink" title="yarn&amp;npm"></a>yarn&amp;npm</h1><p>Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 — Yarn，是为了弥补 npm 的一些缺陷而出现的：</p><ul><li>npm 安装包（packages）的速度不够快，拉取的 packages 可能版本不同</li><li>npm 允许在安装 packages 时执行代码，这就埋下了安全隐患</li></ul><p>Yarn 没想要完全替代 npm，它只是一个新的 CLI 工具，拉取的 packages 依然来自 npm 仓库。仓库本身不会变，所以获取或者发布模块的时候和原来一样。</p><h2 id="yarn-vs-npm：特性差异"><a href="#yarn-vs-npm：特性差异" class="headerlink" title="yarn vs npm：特性差异"></a>yarn vs npm：特性差异</h2><h3 id="yarn-lock-文件"><a href="#yarn-lock-文件" class="headerlink" title="yarn.lock 文件"></a><strong>yarn.lock 文件</strong></h3><p>npm 和 Yarn 都是通过 package.json 记录项目需要拉取的依赖模块，不过在使用时，往往 package.json 中模块的版本号不太会写得非常确切，通常是定个版本范围。这样你就能自行选择使用模块的大版本或者小版本，也允许 npm 拉取模块最新的修复了 bug 的版本。</p><h4 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h4><p><em>给定一个版本号：主版本号.次版本号.补丁版本号， 以下这三种情况需要增加相应的版本号:</em></p><ul><li><em>主版本号： 当API发生改变，并与之前的版本不兼容的时候</em></li><li><em>次版本号： 当增加了功能，但是向后兼容的时候</em></li><li><em>补丁版本号： 当做了向后兼容的缺陷修复的时候</em></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">    "lodash": "^4.17.4"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在版本号lodash之前有个^字符。这个字符告诉npm，安装主版本等于4的任意一个版本即可。所以如果我现在运行npm进行安装，npm将安装lodash的主版本为4的最新版，可能是 <a href="mailto:lodash@4.25.5" target="_blank" rel="noopener">lodash@4.25.5</a>（@是npm约定用来确定包名的指定版本的）。</p><p>在理想的<a href="https://link.zhihu.com/?target=http%3A//semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a>世界中，新版是不会有颠覆旧版本的改变，然而现实并非如此。这就导致了<strong>使用 npm 拉取依赖时，即使用的是相同的 package.json，在不同的设备上拉到的 packages 版本不一，这就可能为项目引入 bug。</strong></p><h4 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h4><p>为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）yarn.lock 这个文件。这么做就保证了，每一次拉取同一个项目依赖时，使用的都是一样的模块版本。</p><p>npm 其实也有办法实现处处使用相同版本的 packages，但需要开发者执行 <strong>npm shrinkwrap</strong> 命令。这个命令将会生成一个锁定文件，在执行 npm install 的时候，该锁定文件会先被读取，和 Yarn 读取 yarn.lock 文件一个道理。npm 和 Yarn 两者的不同之处在于，Yarn 默认会生成这样的锁定文件，而 npm 要通过 shrinkwrap 命令生成 npm-shrinkwrap.json 文件，只有当这个文件存在的时候，packages 版本信息才会被记录和更新。</p><h3 id="并行安装"><a href="#并行安装" class="headerlink" title="并行安装"></a><strong>并行安装</strong></h3><p>无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。</p><h4 id="npm-1"><a href="#npm-1" class="headerlink" title="npm"></a>npm</h4><p>npm 是按照队列执行每个 package，也就是说必须要等到当前 package 成功安装之后，才能继续后面的安装。</p><p>这种方法的缺点是，npm必须首先遍历所有的项目依赖关系，然后再决定如何生成扁平的node_modules目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fnpm%2Fnpm%2Fissues%2F8826" target="_blank" rel="noopener">npm安装速度慢的一个很重要的原因</a>。</p><h4 id="yarn-1"><a href="#yarn-1" class="headerlink" title="yarn"></a>yarn</h4><p>Yarn 是同步执行所有任务，提高了性能。</p><p>由于yarn是崭新的经过重新设计的npm客户端，它能让开发人员并行化处理所有必须的操作，并添加了一些其他改进，这使得运行速度得到了显著的提升，整个安装时间也变得更少。</p><h4 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h4><p>通过拉取 <a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/express" target="_blank" rel="noopener">express</a> 依赖，我比较了 npm 和 Yarn 的效率，在没有用任何锁定文件（也就是没有缓存）的前提下，一共安装 42 个依赖：</p><ol><li>npm 耗时 9 秒</li><li>Yarn 耗时 1.37 秒</li></ol><p>这耗时……我没法相信自己的眼睛了，反复尝试几次，得到的结果也差不多。于是我又试着安装了有195个依赖的 <a href="https://link.zhihu.com/?target=https%3A//www.npmjs.com/package/gulp" target="_blank" rel="noopener">gulp</a>，这一次：</p><ol><li>npm 耗时 11 秒</li><li>Yarn 耗时 7.81 秒</li></ol><p>看来 npm 和 Yarn 在安装包的速度差异和要安装的包个数强相关，不过不管怎么样，Yarn 都比 npm 要快。</p><h3 id="更简洁的输出"><a href="#更简洁的输出" class="headerlink" title="更简洁的输出"></a><strong>更简洁的输出</strong></h3><h4 id="npm-2"><a href="#npm-2" class="headerlink" title="npm"></a>npm</h4><p>npm 的输出信息比较冗长。在执行 npm install <package> 的时候，命令行里会不断地打印出所有被安装上的依赖。</package></p><h4 id="yarn-2"><a href="#yarn-2" class="headerlink" title="yarn"></a>yarn</h4><p>相比之下，Yarn 简洁太多：默认情况下，结合了 emoji （Windows 上 emoji 不可见）直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7go968d0mj30k00dp75u.jpg" alt="img"></p><h3 id="多注册来源处理"><a href="#多注册来源处理" class="headerlink" title="多注册来源处理"></a><strong>多注册来源处理</strong></h3><p>所有的依赖包，不管他被不同的库间接关联引用多少次，安装这个包时，只会从一个注册来源去装，要么是 npm 要么是 bower, 防止出现混乱不一致。</p><h3 id="更好的语义化"><a href="#更好的语义化" class="headerlink" title="更好的语义化"></a><strong>更好的语义化</strong></h3><p> yarn改变了一些npm命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。</p><h2 id="CLI-区别"><a href="#CLI-区别" class="headerlink" title="CLI 区别"></a>CLI 区别</h2><p>除了特性上的区别，相比于 npm 的命令，Yarn 命令有增有减还有一些更改。</p><h3 id="yarn-global"><a href="#yarn-global" class="headerlink" title="yarn global"></a><strong>yarn global</strong></h3><p>npm 的全局操作命令要加上 -g 或者 –global 参数，Yarn 的全局命令则需要加上 global。和 npm 类似，项目特定的依赖，就不需要全局安装了。</p><p>当执行 yarn add、yarn bin、yarn ls 和 yarn remove 时添加 global 前缀才是有全局作用。除了 yarn add 之外，其他三个命令和 npm 的一样。</p><p><a href="https://link.zhihu.com/?target=https%3A//yarnpkg.com/en/docs/cli/global" target="_blank" rel="noopener">yarn global 文档</a></p><h3 id="yarn-install"><a href="#yarn-install" class="headerlink" title="yarn install"></a><strong>yarn install</strong></h3><p>npm install 命令安装的是 package.json 中的依赖，如果开发者在 package.json 中添加了新的依赖，npm install 也一样安装。然而，yarn install 会优先安装 yarn.lock 中记录的依赖，没有这样的锁定文件时，才会去安装 package.json 中的依赖。</p><p><a href="https://link.zhihu.com/?target=https%3A//yarnpkg.com/en/docs/cli/install" target="_blank" rel="noopener">yarn install 文档</a></p><p><a href="https://link.zhihu.com/?target=https%3A//docs.npmjs.com/cli/install" target="_blank" rel="noopener">npm install 文档</a></p><h3 id="yarn-add-–dev"><a href="#yarn-add-–dev" class="headerlink" title="yarn add [–dev]"></a><strong>yarn add [–dev]</strong></h3><p>和 npm install 类似，yarn add 命令允许你添加并安装依赖。通过这个命令添加的依赖都会被自动加到 package.json 中，和我们在 npm 命令中使用 –save 参数一样。Yarn 的-dev 则等同于 npm 的 –save-dev。</p><p><a href="https://link.zhihu.com/?target=https%3A//yarnpkg.com/en/docs/cli/add" target="_blank" rel="noopener">yarn add 文档</a></p><p><a href="https://link.zhihu.com/?target=https%3A//docs.npmjs.com/cli/install" target="_blank" rel="noopener">npm install 文档</a></p><h3 id="yarn-licenses-ls-generate-disclaimer"><a href="#yarn-licenses-ls-generate-disclaimer" class="headerlink" title="yarn licenses [ls|generate-disclaimer]"></a><strong>yarn licenses [ls|generate-disclaimer]</strong></h3><p>在写这篇文章的时候，npm 没有等同的命令。yarn licenses ls 用于罗列出所有被安装的 package 所持有的执照情况。yarn licenses generate-disclaimer 将生成一个对所有依赖的免责声明。有些执照要求开发者一定要在项目中包含这些它们，这个命令就是为这样的场景存在的。</p><p><a href="https://link.zhihu.com/?target=https%3A//yarnpkg.com/en/docs/cli/licenses" target="_blank" rel="noopener">yarn licenses 文档</a></p><h3 id="yarn-why"><a href="#yarn-why" class="headerlink" title="yarn why"></a><strong>yarn why</strong></h3><p>这条命令能帮助开发者理清安装的 package 之间的关系。拉取了各种依赖以后，有些 package 是你显式安装的，有些包则是递归依赖的。</p><p><a href="https://link.zhihu.com/?target=https%3A//yarnpkg.com/en/docs/cli/why" target="_blank" rel="noopener">yarn why 文档</a></p><h3 id="yarn-upgrade-package"><a href="#yarn-upgrade-package" class="headerlink" title="yarn upgrade [package]"></a><strong>yarn upgrade [package]</strong></h3><p>这条命令将根据 package.json 将 package 升级到最新版本，并更新 yarn.lock，和 npm update 相似。</p><p>有意思的是，如果指定了 [package] 参数，Yarn 会将 package 升级到最新版本，并更新 package.json 中该 package 的版本号字段。</p><p><a href="https://link.zhihu.com/?target=https%3A//yarnpkg.com/en/docs/cli/upgrade" target="_blank" rel="noopener">yarn upgrade 文档</a></p><h3 id="yarn-generate-lock-entry"><a href="#yarn-generate-lock-entry" class="headerlink" title="yarn generate-lock-entry"></a><strong>yarn generate-lock-entry</strong></h3><p>这条命令将会生成一份基于 package.json 的 yarn.lock 文件，作用和 npm shrinkwrap 类似。不过由于执行 yarn add andyarn upgrade 时都会更新 yarn.lock 文件，所以要慎重执行 yarn generate-lock-entry 命令</p><p><a href="https://link.zhihu.com/?target=https%3A//yarnpkg.com/en/docs/cli/generate-lock-entry" target="_blank" rel="noopener">yarn generate-lock-entry 文档</a></p><p><a href="https://link.zhihu.com/?target=https%3A//docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="noopener">npm shrinkwrap 文档</a></p><h2 id="yarn和npm命令对比"><a href="#yarn和npm命令对比" class="headerlink" title="yarn和npm命令对比"></a>yarn和npm命令对比</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install === yarn </span><br><span class="line">npm install taco --save === yarn add taco</span><br><span class="line">npm uninstall taco --save === yarn remove taco</span><br><span class="line">npm install taco --save-dev === yarn add taco --dev</span><br><span class="line">npm update --save === yarn upgrade</span><br></pre></td></tr></table></figure><h2 id="npm的未来：npm5-0"><a href="#npm的未来：npm5-0" class="headerlink" title="npm的未来：npm5.0"></a>npm的未来：npm5.0</h2><p>有了yarn的压力之后，npm做了一些类似的改进。</p><ol><li>默认新增了类似yarn.lock的 package-lock.json；</li><li>git 依赖支持优化：这个特性在需要安装大量内部项目（例如在没有自建源的内网开发），或需要使用某些依赖的未发布版本时很有用。在这之前可能需要使用指定 commit<em>id 的方式来控制版本。</em></li><li><em>文件依赖优化：在之前的版本，如果将本地目录作为依赖来安装，将会把文件目录作为副本拷贝到 node</em>modules 中。而在 npm5 中，将改为使用创建 symlinks 的方式来实现（使用本地 tarball 包除外），而不再执行文件拷贝。这将会提升安装速度。目前yarn还不支持。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;yarn-amp-npm&quot;&gt;&lt;a href=&quot;#yarn-amp-npm&quot; class=&quot;headerlink&quot; title=&quot;yarn&amp;amp;npm&quot;&gt;&lt;/a&gt;yarn&amp;amp;npm&lt;/h1&gt;&lt;p&gt;Facebook、Google、Exponent 和 Til
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="yarn" scheme="http://yoursite.com/tags/yarn/"/>
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>关于01的2019</title>
    <link href="http://yoursite.com/2019/12/31/%E5%85%B3%E4%BA%8E01%E7%9A%842019/"/>
    <id>http://yoursite.com/2019/12/31/关于01的2019/</id>
    <published>2019-12-31T15:59:59.000Z</published>
    <updated>2019-12-29T14:31:07.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于01的2019"><a href="#关于01的2019" class="headerlink" title="关于01的2019"></a>关于01的2019</h1><p>这是 01 第一篇非技术的博客，想记录一下我的 2019 年，因为这一年对我来说，真的意义非凡、与众不同。这篇博客，可能絮絮叨叨，可能思路不清。没有期待看到的你会生出什么样的情绪，只是对自己的一个小小交代，希望自己可以记得这一年来的欢笑与艰难。</p><p>为什么说 2019 年，对我来说意义非凡与众不同呢？首先，这一年，是我 24 岁的本命年。不同于上一次 12 岁的那一年，24 岁，我拥有了更清晰的对世界和周遭的认识，有了属于自己独立的看法与见解，也变得在一些时候开始封建迷信，啊哈哈哈哈。比如，老老实实带起了保命红绳，认认真真买了火红的内衣，换上了「猪事顺利」的红色手机壳，疯狂的为各种事儿转发了各种功能性锦鲤。当然，更重要的是，2019 年里，真的发生了很多大事儿。有的是我从未想到也不敢想象的事儿，有的是即将改变我人生轨迹的事儿。那么，我们一件一件缓缓道来。</p><p>最重要的，放在第一个来说。这件事儿，叫做「爸爸」。我不知道该怎么开始写这件事儿，那就直接一点。2019 年 3 月 3 日，我爸爸去世了。那是一个平常的星期天，前一天，我刚染了蓝色的头发，早上我在厕所里拍了第一张蓝头发的自拍，洗脸刷牙，化妆，中午和好朋友约了一顿海底捞，点了很多菜，等着火锅开涮，一个陌生的号码打进了我的手机，是一个带着哭腔的声音，很像我小姑。海底捞里很吵，听不清电话那头都说了些什么，就听清一句，“你爸死了，你赶快回来”。嗯，我是懵的，本能的觉得，应该是个诈骗电话吧。走出海底捞，给奶奶家的座机打了个电话，接电话的人不是奶奶是我大姑父，我心里想，真的出事儿了。挂了电话买了一张晚上的机票回家。那时候的我，真的反应不过来发生了什么，甚至还安静的吃完了那顿海底捞。</p><p>我其实不能接受这件事儿，一直到现在。</p><p>回到家，奶奶抱着我哭了，我没有哭。小姑哭的泣不成声，我没有哭。烧纸的时候，我妈说，你要喊你爸来拾钱，我喊不出来，我一句话也说不出来，我就沉默的跪在那儿。身边知道这件事儿的朋友问我，我都是笑着说一句没事儿啊，你看我不是好好的吗。在火葬场，我看见我爸穿戴整齐的躺在那儿，西装皮鞋，是我不熟悉的样子，很安详，却一点也不像睡着了，我爸睡觉才不会这么规矩，明明呼噜震天响。我说了悼词，说的乱七八糟，毕竟这是我第一次说悼词，都不知道要说些什么内容，甚至还在控诉他一点都不是一个负责任的好爸爸。我抱着我爸的骨灰盒，真的很沉，得用手指死死抠着才能保证在走到墓地前的这段路上，我不会把他摔下去。</p><p>我以为我没什么事儿，我以为我消化的了，毕竟我之前 23 年的人生，也不怎么平坦。处理完丧事儿回到学校，在操场上，是我第一次崩溃的放声大哭。一边哭一边笑，笑完哭的更大声，想小时候，也想，我真的没有爸爸了。真的就像过电影一样，记忆在这件事儿之后变得异常鲜活，很多以前想不起来的小细节都变得十分清晰。我记得我感冒发烧咳嗽到话也说不出来，却任性的要爸爸去给我买黄桃罐头。我记得小时候我爸开出租我坐在副驾驶玩耍睡觉。我记得每次爸爸让我帮他跑腿下楼买包醋的时候都会多给我五毛钱的跑腿费。我也记得去年和爸爸奶奶一起坐在床上玩激萌的时候他看着那些可爱的表情加在他脸上时笑的有多憨厚。太多太多，都只有回忆了。再也没有人在火车站外期盼放假回家的我，带着刚下火车的我去吃一碗牛肉拉面。再也没有人叫我臭小子，打来电话十分腼腆的说句“老爸想你了”。也不会有人明明厨艺很好，却要在每次做饭的时候不停的呼喊我去厨房给他试菜，想要听我的那句“再加点醋”或者“刚刚好、完美！”。我一直想要带他去看场电影，imax或者3D的，想要挣钱给他买辆好车，也想过他老了我推着他晒太阳的场景。从小到大，我爸，都是那个最惯着我的人。他还说，他在网上学了好多菜，要做给我吃。可是，我还没放假回家，爸爸，你去哪儿了呢？</p><p>我以为，哭过这一场之后，我还是那个积极坚强的 01，生活还是如常。但是这一次，好像真的有些难。</p><p>本命年第二件事儿，彻底和过去的感情说再见。其实这是个开心的事儿，只不过经历的过程惨痛了些。感情上的事儿嘛，总是剪不断理还乱，更何况我还是一个念旧又烂好心的人。我有个异国的前男友，我们之间有很多故事，很多折磨我的故事。之所以是折磨我的故事，显然是三个人的故事，之所以有很多，显然是我的不甘心和泛滥的同情心在作祟。很老套的情节，很多时候，放不下的只是自己在这份感情里的付出加上一张会骗人的渣男的嘴。即便分手了。</p><p>我不得不承认，我这个前男友对我的影响有多大。他让我变得小心翼翼，变得更加没有安全感。对于一些情侣间的小事儿，却搞的小心谨慎，总是朝着最不利的方向去想。换情侣头像或者在社交平台上秀恩爱，不再是为所欲为凭自己开心，而是谨小慎微的试探对方的心思，因为一条微博换来的可能是争吵到心寒。对于节日或者纪念日的仪式感耿耿于怀，我喜欢，他却不在意，OK，那我一定要过的隆重，只是不是和他。对于向身边的人大方公开我在谈恋爱，不可能，因为他只会把我藏起来谈地下情，那么我只能追求变态的公平。分手后的烂好心，又让我继续沦为一个被欺骗的“朋友”，拖拖拉拉没个完。对于感情，我期待的很少，甚至只希望，对方能是个好人，我们能做到善待彼此，就好了。我埋藏自己的想法，用“善解人意”来对待每一个人。我知道我变得越来越扭曲，越来越不是自己喜欢的 01。</p><p>在感情里日渐扭曲把自己往角落里逼的我，在家里发生大变故下终于意识到我彻底失去了爱我的爸爸的我，在春招如火如荼进行却才意识到我该开始学习了还什么都不会的我，彻底崩溃了。</p><p>2019 年 3 月 3 日到 2019 年 8 月 3 日。我其实记不清我这五个月具体都发生了什么，我还是正常的实习上班、为秋招学习、跟朋友扯淡逗逼。但是我知道，我不太正常。我记得我走着走着路就崩溃到蹲在马路边大哭。我记得我在公交车上看到对面的中年男人穿着和我爸爸一样的 polo 衫眼泪就止不住而引起了旁边人的奇怪的眼神。我记得我每隔一天就会做梦梦到爸爸，压抑的喘不过气难受的哭醒。我记得我下班不想回宿舍在操场放空一圈一圈的走着。每一次哭完我都以为，这次哭完就好了，可是没有。我恶语怼着身边关心我的人，也在偶尔清闲的工作日下午非常丧的想着工作的无趣、生活的无聊。我做了很多份网上抑郁症的测试，非常真实的填了答案，看着最后抑郁的结果。真的时刻都在叹气，随时陷入对人生的大思考。我疯狂的找各种人聊天诉说，但是没有缓解。我出去旅行，在微博上开了一个穿搭话题，希望自己每天至少能有一点开心和寄托。每次给家里打电话，都要做很久的心里准备，因为每次打完电话，我都会更丧一些，我能听到奶奶在电话里每一句话中间都夹杂着的叹气，我能听到她的孤单，她一遍遍强调的“以后你只能靠着你自己了，家里也没人能帮你了”，我还能感受到来自很多关心我的人的心疼与可怜。说实话，这些，都挺令我窒息的。可能是我矫情，但是有时候我就是执拗的想着，我才 24 岁，还没有到大多数人面对父母离去的年纪，为什么，我就没有爸爸了。</p><p>对不起，到这里，我都只写了不好的事儿与矫情的压抑。在这儿，我还是想说句，Fuck you！我的本命年，真的很丧。</p><p>但是我想说的第三件事儿，是件幸福的小事儿。我不想吝啬我能想到的任何语言来表达我的开心与幸福，还有对这趴主角的感谢。他叫李煊。存在于我博客「关于」中的男孩子。他是我的老友，以前。是一个我可以随意跟他说生活三两事儿的老友。我认识他多久呢？两三年。见过几次面？约过几次饭？啊哈哈哈哈，我印象中真的没几次。但是你要问我他在我的朋友中排名几何，我真的会说，是在好友榜的前几位。我对他的评价很高，一个相处舒服，温柔绅士且优秀的男孩子。2019 年 8 月 3 号，一个平常的周五，又跟他在微信上逼逼了一天。然后，他表白了，所以，现在，他是我的男朋友。</p><p>他好像是开玩笑的表白，随口说了句，要不你直接当我女朋友算了。我的回答也是啊哈哈哈哈哈哈 我懵逼了。然后，我开始开心，开始走心，开始认认真真动了心。微博里，我秀了恩爱，说了很多我喜欢他的故事，玩他喜欢的游戏，听他喜欢的电台和歌曲，尝试他喜欢的酒。但在这里，我想说说我感受到的他的喜欢和温柔。在网易云，我建了一个歌单，叫「给煊宝的」，里面收藏了一些我听到的甜甜的歌，我没告诉他，但是他自己看到了，就默默的添加了收藏。他会在聊天中不经意的表达爱意与喜欢，说一些彩虹屁，夸我的照骗好看的一匹，说衣服一般但主要还是看谁穿。在我磨叽他的时候突然的语气温柔，说“别闹了～乖～”。他会在我跟他说可能还有两个月才能见面的时候语气失落。也会在被工作折磨的苦逼不堪的时候给我打电话疯狂吐槽三万字。会认真把我脱下来乱放的鞋整齐的摆在鞋柜前。会温柔的吻我抱紧我笑着捏我身上的肉肉挠我的痒痒。会在我追星大喊千玺老公的时候给予我一句包容的“小傻子”。也会在我因为误解他的话闹别扭的时候一句句的认真解释，告诉我他想让我在去找他的时候住的舒服，过得开心，他焦虑着因为工作太忙而陪伴我的时间太少。会默默的记住我害怕蟑螂，在帮我找房子看房子的时候仔细甄选。会用心的给我准备节日礼物。会在繁忙的工作中尽可能的抽时间陪我。他的温柔很多，我，在慢慢感受。我们从未认真讨论过以后，承诺过至死不渝，但是在我为不知道能不能去他的城市工作结束异地而不安的时候，他看似随便的告诉我，如果我不能去，他就来。他让我感受到踏实与安定。我从未遇到过一个男人可以如此温柔。虽然我是一个非典型工科女，也会说矫情的话，可是我真的想不到还有什么比一句我爱你更加深情的表达。看着他的眼睛，三秒我就败下阵来，忍不住笑开了花。听着他的声音，我希望不要停下来，我要听他说好多好多话，情话和废话。</p><p>我说他是我的幸运星，是来帮我「冲喜」的。啊哈哈哈哈哈哈。是因为，从他表白之后，我的生活真的在一点点变好。他解救了我丧气的心情。而且，2019 年第四件事儿，一个决定了我离开学校步入社会的生活轨迹的事儿，来了。秋招，offer，工作。很想骄傲的说，做一个小小的 offer 收割机，真好。除了字节无缘，面试过的公司，百度、京东、滴滴、美团、顺丰、华为、快手，还有我的秋招初心，腾讯，全都发了 offer。没错，这里，我就是来秀的。在 2019 年的愿望清单里，我有写到，想要在深圳找到一份满意的工作。现在年度总结里，我想说，我做到了。拿到了自己心仪的 offer，去自己喜欢的城市，还有，那座城市里，有他～真的很开心。</p><p>现在的 01，很好。在努力的消化着爸爸的离去，也在认真的朝着自己想要的生活努力。我爱我亲爱的家人，也真心的谢谢那些一直陪伴着我的好朋友们～我的鹭宝宝，我的群群脑婆，我的大喵，我的龙龙北北，3308 的小仙女们，梁良，晓宇，志强，朱雪，还有我洋葱的小伙伴们和美团的弟弟、老哥们。01 一直都很幸运，一路都有很多人陪，不管是相伴到如今的挚友，还是同行一段路的曾经的朋友。</p><p>我还是很爱自己，爱这个爱笑的 01。</p><p>2019 年度总结的最后，是 2020 年的愿望清单：</p><ul><li>顺利完成论文，顺利毕业</li><li>拍好看的毕业照</li><li>去日本毕业旅行</li><li>在深圳租个不错的房子，室友 nice</li><li>养一只猫</li><li>健身是永恒的主题</li><li>多看些书</li></ul><p>2020年，祝顺利。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于01的2019&quot;&gt;&lt;a href=&quot;#关于01的2019&quot; class=&quot;headerlink&quot; title=&quot;关于01的2019&quot;&gt;&lt;/a&gt;关于01的2019&lt;/h1&gt;&lt;p&gt;这是 01 第一篇非技术的博客，想记录一下我的 2019 年，因为这一年对我来说，真
      
    
    </summary>
    
      <category term="01的小生活" scheme="http://yoursite.com/categories/01%E7%9A%84%E5%B0%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年度总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Vue计算属性(computed)和侦听属性(watch)</title>
    <link href="http://yoursite.com/2019/12/29/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7(computed)%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7(watch)/"/>
    <id>http://yoursite.com/2019/12/29/Vue计算属性(computed)和侦听属性(watch)/</id>
    <published>2019-12-29T01:52:21.000Z</published>
    <updated>2019-12-29T07:18:55.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue计算属性-computed-和侦听属性-watch"><a href="#Vue计算属性-computed-和侦听属性-watch" class="headerlink" title="Vue计算属性(computed)和侦听属性(watch)"></a>Vue计算属性(computed)和侦听属性(watch)</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点：</p><ul><li>数据可以进行逻辑处理，减少模板中计算逻辑。</li><li>对计算属性中的数据进行监视</li><li>依赖固定的数据类型（响应式数据）</li></ul><p>计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。默认只有get，如果需要set，要自己添加。另外set设置属性，并不是直接修改计算属性，而是修改它的依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="comment">//this.fullName = newValue 这种写法会报错</span></span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]<span class="comment">//对它的依赖进行赋值</span></span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性-vs-普通属性"><a href="#计算属性-vs-普通属性" class="headerlink" title="计算属性 vs 普通属性"></a>计算属性 vs 普通属性</h3><p>可以像绑定普通属性一样在模板中绑定计算属性，在定义上有区别：计算属性的属性值必须是一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data:&#123; <span class="comment">//普通属性</span></span><br><span class="line">  msg:<span class="string">'浪里行舟'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123; <span class="comment">//计算属性</span></span><br><span class="line">  msg2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//该函数必须有返回值，用来获取属性，称为get函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'浪里行舟'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  reverseMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//可以包含逻辑处理操作，同时reverseMsg依赖于msg,一旦msg发生变化，reverseMsg也会跟着变化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg.split(<span class="string">' '</span>).reverse().join(<span class="string">' '</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性-vs-方法"><a href="#计算属性-vs-方法" class="headerlink" title="计算属性 vs 方法"></a>计算属性 vs 方法</h3><p><strong>两者最主要的区别：computed 是可以缓存的，methods 不能缓存；</strong></p><p><strong>只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。</strong>网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，计算属性可以通过闭包来实现传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:data=<span class="string">"closure(item, itemName, blablaParams)"</span></span><br><span class="line">computed: &#123;</span><br><span class="line"> closure () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/** do something */</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性watch。<strong>watch中可以执行任何逻辑，如函数节流，Ajax异步获取数据，甚至操作 DOM（不建议）。</strong></p><h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;attr&quot;&gt;</span><br><span class="line">    &lt;h1&gt;watch属性&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; $data &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;() =&gt; (a += 1)&quot;&gt;修改a的值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: &#123; c: 2, d: 3 &#125;,</span><br><span class="line">      e: &#123;</span><br><span class="line">        f: &#123;</span><br><span class="line">          g: 4</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      h: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: function(val, oldVal) &#123;</span><br><span class="line">      this.b.c += 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b.c&quot;: function(val, oldVal) &#123;</span><br><span class="line">      this.b.d += 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b.d&quot;: function(val, oldVal) &#123;</span><br><span class="line">      this.e.f.g += 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    e: &#123;</span><br><span class="line">      handler: function(val, oldVal) &#123;</span><br><span class="line">        this.h.push(&quot;浪里行舟&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      deep: true //用于监听e对象内部值的变化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-watch-的深度遍历和立即调用功能"><a href="#使用-watch-的深度遍历和立即调用功能" class="headerlink" title="使用 watch 的深度遍历和立即调用功能"></a>使用 watch 的深度遍历和立即调用功能</h3><p>使用 watch 来监听数据变化的时候除了常用到 handler 回调，其实其还有两个参数，便是：</p><ul><li>deep 设置为 true 用于监听对象内部值的变化</li><li>immediate 设置为 true 将立即以表达式的当前值触发回调</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            obj: &#123;</span><br><span class="line">                a: 1,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            handler: function(newVal, oldVal) &#123;</span><br><span class="line">                console.log(newVal); </span><br><span class="line">            &#125;,</span><br><span class="line">            deep: true,</span><br><span class="line">            immediate: true </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上代码我们修改了 obj 对象中 a 属性的值，我们可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 deep: true，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 immediate: true 配置，其会立即以 obj 的当前值触发回调。</p><h2 id="computed和watch两者之间对比"><a href="#computed和watch两者之间对比" class="headerlink" title="computed和watch两者之间对比"></a>computed和watch两者之间对比</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5tpjgacj30ip078q2z.jpg" alt></p><p>从上面流程图中，我们可以看出它们之间的区别：</p><ul><li>watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</li><li>computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</li></ul><p>除此之外，有点很重要的区别是：<strong>计算属性不能执行异步任务，计算属性必须同步执行</strong>。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。</p><p>计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p><ul><li>computed能做的，watch都能做，反之则不行</li><li>能用computed的尽量用computed</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue计算属性-computed-和侦听属性-watch&quot;&gt;&lt;a href=&quot;#Vue计算属性-computed-和侦听属性-watch&quot; class=&quot;headerlink&quot; title=&quot;Vue计算属性(computed)和侦听属性(watch)&quot;&gt;&lt;/a&gt;V
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js学习笔记（二）</title>
    <link href="http://yoursite.com/2019/12/19/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/19/深入浅出Node.js学习笔记（二）/</id>
    <published>2019-12-19T09:25:43.000Z</published>
    <updated>2019-12-29T07:15:07.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Node-js学习笔记（二）"><a href="#深入浅出Node-js学习笔记（二）" class="headerlink" title="深入浅出Node.js学习笔记（二）"></a>深入浅出Node.js学习笔记（二）</h1><h2 id="第四章-异步编程"><a href="#第四章-异步编程" class="headerlink" title="第四章 异步编程"></a>第四章 异步编程</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>高阶函数是可以把函数作为参数，或是将函数作为返回值的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续传递风格(Continuation Passing Style)的结果接收 方式，而非单一的返回值形式。后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>ECMAScript5中提供的一些数组方法(sort()、forEach()、 map()、reduce()、reduceRight()、filter()、every()、some())十分典型</p><h4 id="偏函数用法"><a href="#偏函数用法" class="headerlink" title="偏函数用法"></a>偏函数用法</h4><p>偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="keyword">var</span> isString = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object String]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isFunction = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object Function]'</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要重复去定义一些相似的函数，如果有更多的isXXX()，就会出现更多的冗余代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object '</span> + type + <span class="string">']'</span>; </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">'Function'</span>);</span><br></pre></td></tr></table></figure><p>这 种通过指定部分参数来产生一个新的定制函数的形式就是偏函数</p><h3 id="异步编程的优势与难点"><a href="#异步编程的优势与难点" class="headerlink" title="异步编程的优势与难点"></a>异步编程的优势与难点</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>最大的特性：基于事件驱动的非阻塞I/O模型</p><p>非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用</p><p>并行带来的想象空间更大，延展而开的是分布式和云。并行使得各个单点之间能够更有效地组织起来</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ux6kboyzj30qc0iu3zv.jpg" alt="image-20191213111035164"></p><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><h5 id="难点1-异常处理"><a href="#难点1-异常处理" class="headerlink" title="难点1:异常处理"></a>难点1:异常处理</h5><p>异步I/O的实现主要包含两个阶段:提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">async</span>(callback); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用async()方法后，callback被存放起来，直到下一个事件循环(Tick)才会取出来执行。尝试对异步方法进行try/catch操作只能捕获当次事件循环内的异常，对callback执行时抛出的异常将无能为力。</p><p>Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>自行编写的异步方法上，需要去遵循这样一些原则: </p><ul><li>原则一:必须执行调用者传入的回调函数; </li><li>原则二:正确传递回异常供调用者判断。</li></ul><h5 id="难点2-函数嵌套过深"><a href="#难点2-函数嵌套过深" class="headerlink" title="难点2:函数嵌套过深"></a>难点2:函数嵌套过深</h5><h5 id="难点3-阻塞代码"><a href="#难点3-阻塞代码" class="headerlink" title="难点3:阻塞代码"></a>难点3:阻塞代码</h5><p>没有sleep()这样的线程沉睡功能</p><p>setInterval()和setTimeout()并不能阻塞后续代码的持续执行</p><h5 id="难点4-多线程编程"><a href="#难点4-多线程编程" class="headerlink" title="难点4:多线程编程"></a>难点4:多线程编程</h5><p>对于服务器端而言，如果服务器是多核CPU，单个Node进程实质上是没有充分利用多核CPU的。</p><p>Node借鉴了这个模式，child_process是其基础API，cluster模块是更深层次的应用。借助Web Workers的模式，开发人员要更多地去面临跨线程的编程，这对于以往的JavaScript编程经验是较少考虑的。</p><h5 id="难点5-异步转同步"><a href="#难点5-异步转同步" class="headerlink" title="难点5:异步转同步"></a>难点5:异步转同步</h5><p>Node中试图同步式编程，但并不能得到原生支持，需要借助库或者编译等手段来实现</p><h3 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h3><h4 id="事件发布-订阅模式"><a href="#事件发布-订阅模式" class="headerlink" title="事件发布/订阅模式"></a>事件发布/订阅模式</h4><p>事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">emitter.on(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">emitter.emit(<span class="string">'event1'</span>, <span class="string">"I am message!"</span>);</span><br></pre></td></tr></table></figure><p>事件发布/订阅模式可以实现一个事件与多 个回调函数的关联，这些回调函数又称为事件侦听器。通过emit()发布事件后，消息会立即传递给当前事件的所有侦听器执行。侦听器可以很灵活地添加和删除，使得事件和具体处理逻辑之间可以很轻松地关联和解耦。</p><p>Node对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的:</p><ul><li>如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0);可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。</li><li>为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理。</li></ul><h5 id="1-继承events模块"><a href="#1-继承events模块" class="headerlink" title="1. 继承events模块"></a>1. 继承events模块</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Stream, events.EventEmitter);</span><br></pre></td></tr></table></figure><p>Node在util模块中封装了继承的方法，所以此处可以很便利地调用。开发者可以通过这样的方式轻松继承EventEmitter类，利用事件机制解决业务问题。在Node提供的核心模块中，有近半数都继承自EventEmitter。</p><h5 id="2-利用事件队列解决雪崩问题"><a href="#2-利用事件队列解决雪崩问题" class="headerlink" title="2. 利用事件队列解决雪崩问题"></a>2. 利用事件队列解决雪崩问题</h5><p>雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"><span class="keyword">var</span> status = <span class="string">"ready"</span>;</span><br><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  proxy.once(<span class="string">"selected"</span>, callback); </span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">"ready"</span>) &#123;</span><br><span class="line">    status = <span class="string">"pending"</span>;</span><br><span class="line">    db.select(<span class="string">"SQL"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      proxy.emit(<span class="string">"selected"</span>, results);</span><br><span class="line">      status = <span class="string">"ready"</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用了once()方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每一个回调只会被执行一次。对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。</p><h5 id="3-多异步之间的协作方案"><a href="#3-多异步之间的协作方案" class="headerlink" title="3. 多异步之间的协作方案"></a>3. 多异步之间的协作方案</h5><p>由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间互相没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量</p><h5 id="4-EventProxy的原理"><a href="#4-EventProxy的原理" class="headerlink" title="4. EventProxy的原理"></a>4. EventProxy的原理</h5><p>EventProxy来自于Backbone的事件模块，Backbone的事件模块是Model、View模块的基础功能，在前端有广泛的使用。它在每个非all事件触发时都会触发一次all事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trigger an event, firing all bound callbacks. Callbacks are passed the </span></span><br><span class="line"><span class="comment">// same arguments as `trigger` is, apart from the event name.</span></span><br><span class="line"><span class="comment">// Listening for `"all"` passes the true event name as the first argument </span></span><br><span class="line">trigger : <span class="function"><span class="keyword">function</span>(<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list, calls, ev, callback, args;</span><br><span class="line">  <span class="keyword">var</span> both = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(calls = <span class="keyword">this</span>._callbacks)) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">while</span> (both--) &#123;</span><br><span class="line">    ev = both ? eventName : <span class="string">'all'</span>; </span><br><span class="line">    <span class="keyword">if</span> (list = calls[ev]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = list.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(callback = list[i])) &#123;</span><br><span class="line">          list.splice(i, <span class="number">1</span>); i--; l--; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          args = both ? <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) : <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">          callback[<span class="number">0</span>].apply(callback[<span class="number">1</span>] || <span class="keyword">this</span>, args); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventProxy则是将all当做一个事件流的拦截层，在其中注入一些业务来处理单一事件无法解决的异步处理问题。类似的扩展方法还有all()、tail()、after()、not()和any()等。</p><h5 id="5-EventProxy的异常处理"><a href="#5-EventProxy的异常处理" class="headerlink" title="5. EventProxy的异常处理"></a>5. EventProxy的异常处理</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">exports.getContent = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> ep = <span class="keyword">new</span> EventProxy();</span><br><span class="line">  ep.all(<span class="string">'tpl'</span>, <span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">tpl, data</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    callback(<span class="literal">null</span>, &#123;</span><br><span class="line">      template: tpl,</span><br><span class="line">      data: data </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;); </span><br><span class="line">  <span class="comment">//绑定错误处理函数 </span></span><br><span class="line">  ep.fail(callback);</span><br><span class="line">  fs.readFile(<span class="string">'template.tpl'</span>, <span class="string">'utf-8'</span>, ep.done(<span class="string">'tpl'</span>));</span><br><span class="line">  db.get(<span class="string">'some sql'</span>, ep.done(<span class="string">'data'</span>)); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EventProxy提供了fail()和done()这两个实例方法来优化异常处理，使得开发者将精力关注在业务部分，而不是在异常捕获上。</p><h6 id="fail-方法的实现"><a href="#fail-方法的实现" class="headerlink" title="fail()方法的实现"></a>fail()方法的实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ep.fail(callback);</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep.fail(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; </span><br><span class="line">  callback(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>又等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ep.bind(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 卸载掉所有处理函数 </span></span><br><span class="line">  ep.unbind();</span><br><span class="line">  <span class="comment">// 异常回调</span></span><br><span class="line">  callback(err); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="done-方法的实现"><a href="#done-方法的实现" class="headerlink" title="done()方法的实现"></a>done()方法的实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ep.done(<span class="string">'tpl'</span>);</span><br></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 一旦发生异常，一律交给error事件处理函数处理</span></span><br><span class="line">  <span class="keyword">return</span> ep.emit(<span class="string">'error'</span>, err); </span><br><span class="line">  &#125;</span><br><span class="line">  ep.emit(<span class="string">'tpl'</span>, content); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-Deferred模式"><a href="#Promise-Deferred模式" class="headerlink" title="Promise/Deferred模式"></a>Promise/Deferred模式</h4><p>先执行异步调用，延迟传递处理的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api') </span><br><span class="line">  .success(onSuccess) </span><br><span class="line">  .error(onError) </span><br><span class="line">  .complete(onComplete);</span><br></pre></td></tr></table></figure><p>这使得即使不调用success()、error()等方法，Ajax也会执行，这样的调用方式比预先传入回调让人觉得舒适一些。</p><p>在原始的API中，一个事件只能处理一个回调，而通过Deferred对象，可以对事件加入任意的业务处理逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api') </span><br><span class="line">  .success(onSuccess1) </span><br><span class="line">  .success(onSuccess2);</span><br></pre></td></tr></table></figure><p>CommonJS草案目前已经抽象出了Promises/A、 Promises/B、Promises/D这样典型的异步Promise/Deferred模型，这使得异步操作可以以一种优雅的方式出现。</p><h5 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A"></a>Promises/A</h5><ul><li>Promise操作只会处在3种状态的一种:未完成态、完成态和失败态。</li><li>Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。</li><li>Promise的状态一旦转化，将不能被更改。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yev5y4i1j30gs0c4q3v.jpg" alt="image-20191216113903367"></p><h6 id="Promise对象的then"><a href="#Promise对象的then" class="headerlink" title="Promise对象的then()"></a>Promise对象的then()</h6><p>一个Promise对象只要具备then()方法即可</p><ul><li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。</li><li>可选地支持progress事件回调作为第三个方法。</li><li>then()方法只接受function对象，其余对象将被忽略。 </li><li>then()方法继续返回Promise对象，以实现链式调用。</li></ul><h6 id="Deferred，延迟对象"><a href="#Deferred，延迟对象" class="headerlink" title="Deferred，延迟对象"></a>Deferred，延迟对象</h6><p>触发执行这些回调函数的地方，实现这些功能的对象通常被称为Deferred，即延迟对象</p><h6 id="Promise和Deferred的差别"><a href="#Promise和Deferred的差别" class="headerlink" title="Promise和Deferred的差别"></a>Promise和Deferred的差别</h6><p>Deferred主要是用于内部， 用于维护异步模型的状态;Promise则作用于外部，通过then()方法暴露给外部以添加自定义逻辑。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yf1x7tvnj30ws0coabq.jpg" alt="image-20191216114535955"></p><h5 id="Promise中的多异步协作"><a href="#Promise中的多异步协作" class="headerlink" title="Promise中的多异步协作"></a>Promise中的多异步协作</h5><p>通过all()方法抽象多个异步操作。只有所有异步操作成功，这个异步操作才算成功， 一旦其中一个异步操作失败，整个异步操作就失败。</p><h5 id="Promise的进阶知识"><a href="#Promise的进阶知识" class="headerlink" title="Promise的进阶知识"></a>Promise的进阶知识</h5><ul><li><p>支持序列执行的Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">promise()</span><br><span class="line">  .then(obj.api1) </span><br><span class="line">  .then(obj.api2) </span><br><span class="line">  .then(obj.api3) </span><br><span class="line">  .then(obj.api4) </span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with value4 </span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Handle any error from step1 through step4 </span></span><br><span class="line">&#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure><p>改造一下代码以实现链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成态</span></span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">this</span>.promise;</span><br><span class="line">  <span class="keyword">var</span> handler;</span><br><span class="line">  <span class="keyword">while</span> ((handler = promise.queue.shift())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler &amp;&amp; handler.fulfilled) &#123; </span><br><span class="line">      <span class="keyword">var</span> ret = handler.fulfilled(obj); </span><br><span class="line">      <span class="keyword">if</span> (ret &amp;&amp; ret.isPromise) &#123;</span><br><span class="line">        ret.queue = promise.queue; </span><br><span class="line">        <span class="keyword">this</span>.promise = ret; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败态</span></span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">this</span>.promise;</span><br><span class="line">  <span class="keyword">var</span> handler;</span><br><span class="line">  <span class="keyword">while</span> ((handler = promise.queue.shift())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler &amp;&amp; handler.error) &#123; </span><br><span class="line">      <span class="keyword">var</span> ret = handler.error(err); </span><br><span class="line">      <span class="keyword">if</span> (ret &amp;&amp; ret.isPromise) &#123;</span><br><span class="line">        ret.queue = promise.queue; </span><br><span class="line">        <span class="keyword">this</span>.promise = ret;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 生成回调函数 </span></span><br><span class="line">Deferred.prototype.callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> that.reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    that.resolve(file); </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 队列用于存储待执行的回调函数 </span></span><br><span class="line">  <span class="keyword">this</span>.queue = [];</span><br><span class="line">  <span class="keyword">this</span>.isPromise = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">fulfilledHandler, errorHandler, progressHandler</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fulfilledHandler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    handler.fulfilled = fulfilledHandler; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> errorHandler === <span class="string">'function'</span>) &#123; </span><br><span class="line">    handler.error = errorHandler;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">this</span>.queue.push(handler); </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>读取第二个文件是依 赖于第一个文件中的内容的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile1 = <span class="function"><span class="keyword">function</span> (<span class="params">file, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  fs.readFile(file, encoding, deferred.callback());</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFile2 = <span class="function"><span class="keyword">function</span> (<span class="params">file, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  fs.readFile(file, encoding, deferred.callback());</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;;</span><br><span class="line">readFile1(<span class="string">'file1.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">file1</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> readFile2(file1.trim(), <span class="string">'utf8'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">file2</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(file2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要让Promise支持链式执行，主要通过以下两个步骤。<br> (1) 将所有的回调都存到队列中。<br> (2) Promise完成时，逐个执行回调，一旦检测到返回了新的Promise对象，停止执行，然后将当前Deferred对象的promise引用改变为新的Promise对象，并将队列中余下的回调转交给它。</p><ul><li>将API Promise化</li></ul><p>可以 批量将方法Promise化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smooth(fs.readFile);</span></span><br><span class="line"><span class="keyword">var</span> smooth = <span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>); </span><br><span class="line">    args.push(deferred.callback());</span><br><span class="line">    method.apply(<span class="literal">null</span>, args);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>于是前面的两次文件读取的构造可以简化为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = smooth(fs.readFile);</span><br></pre></td></tr></table></figure><p>于是代码锐减到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = smooth(fs.readFile); readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">file1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(file1.trim(), <span class="string">'utf8'</span>); &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">file2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// file2 =&gt; I am file2</span></span><br><span class="line">  <span class="built_in">console</span>.log(file2); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="流程控制库"><a href="#流程控制库" class="headerlink" title="流程控制库"></a>流程控制库</h4><h5 id="1-尾触发与Next"><a href="#1-尾触发与Next" class="headerlink" title="1. 尾触发与Next"></a>1. 尾触发与Next</h5><p>需要手工调用才能持续执行后续调用的</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ykp64h0pj314a0bggn2.jpg" alt="image-20191216150057148"></p><p>中间件机制使得在处理网络请求时，可以像面向切面编程一样进行过滤、验证、日志等功能， 而不与具体业务逻辑产生关联，以致产生耦合</p><p>尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每 个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的 处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者 Promise完成的，这样业务在纵向和横向都能够各自清晰。</p><p>在Connect中，尾触发十分适合处理网络请求的场景。将复杂的处理逻辑拆解为简洁、单一 的处理单元，逐层次地处理请求对象和响应对象。</p><h5 id="2-async"><a href="#2-async" class="headerlink" title="2. async"></a>2. async</h5><h6 id="异步的串行执行"><a href="#异步的串行执行" class="headerlink" title="异步的串行执行"></a>异步的串行执行</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(err); </span><br><span class="line">  &#125;</span><br><span class="line">  fs.readFile(<span class="string">'file2.txt '</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, [content, data]); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>series()方法中传入的函数callback()并非由使用者指定。事实上，此处的回调函数由async通过高阶函数的方式注入，这里隐含了特殊的逻 辑。每个callback()执行时会将结果保存起来，然后执行下一个调用，直到结束所有调用。最终的回调函数执行时，队列里的异步调用保存的结果以数组的方式传入。这里的异常处理规则是一 旦出现异常，就结束所有调用，并将异常传递给最终回调函数的第一个参数。</p><h6 id="异步的并行执行"><a href="#异步的并行执行" class="headerlink" title="异步的并行执行"></a>异步的并行执行</h6><p>当我们需要通过并行来提升性能时，async提供了parallel()方法，用以并行执行一些异步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([ </span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面这段代码等价于下面的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">  results[index] = value; </span><br><span class="line">  counter--;</span><br><span class="line">  <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">    callback(<span class="literal">null</span>, results); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只传递第一个异常</span></span><br><span class="line"><span class="keyword">var</span> hasErr = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> fail = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasErr) &#123; </span><br><span class="line">    hasErr = <span class="literal">true</span>; </span><br><span class="line">    callback(err);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> fail(err); </span><br><span class="line">  &#125;</span><br><span class="line">  done(<span class="number">0</span>, content); </span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> fail(err); </span><br><span class="line">  &#125;</span><br><span class="line">  done(<span class="number">1</span>, data); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过async编写的代码既没有深度的嵌套，也没有复杂的状态判断，它的诀窍依然来 自于注入的回调函数</p><p>parallel()方法对于异常的判断依然是一旦某个异步调用产生了异常，就 会将异常作为第一个参数传入给最终的回调函数。只有所有异步调用都正常完成时，才会将结果 以数组的方式传入。</p><h6 id="异步调用的依赖处理"><a href="#异步调用的依赖处理" class="headerlink" title="异步调用的依赖处理"></a>异步调用的依赖处理</h6><p>series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了</p><p>async提供了<strong>waterfall()</strong>方法来满足</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([ </span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file2.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">arg1, callback</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// arg1 =&gt; file3.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result =&gt; file4.txt </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>自动依赖处理</li></ul><p>auto()方法能根据依赖关系自动分析，以最佳的顺序执行业务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.auto(deps);</span><br></pre></td></tr></table></figure><h5 id="3-Step"><a href="#3-Step" class="headerlink" title="3. Step"></a>3. Step</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Step(task1, task2, task3);</span><br></pre></td></tr></table></figure><p>Step接受任意数量的任务，所有的任务都将会串行依次执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Step(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFile1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFile2</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content); </span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参 数，并调用执行。</p><ul><li>并行任务执行</li></ul><p>this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Step(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFile1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>.parallel());</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>.parallel()); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">err, content1, content2</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// content1 =&gt; file1</span></span><br><span class="line">    <span class="comment">// content2 =&gt; file2 </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  &#125; </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数</p><p>Step的parallel()方法的原理是每次执行时将内部的计数器加1，然后返回一个回调函数，这个回调函数在异步调用结束时才执行。当回调函数执行时，将计数器减1。当计数器为0的时候， 告知Step所有异步调用结束了，Step会执行下一个方法。</p><p>Step与async相同的是异常处理，一旦有一个异常产生，这个异常会作为下一个方法的第一个 参数传入</p><ul><li>结果分组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Step(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readDir</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readdir(__dirname, <span class="keyword">this</span>); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFiles</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="comment">// Create a new group</span></span><br><span class="line">    <span class="keyword">var</span> group = <span class="keyword">this</span>.group();</span><br><span class="line">    results.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(filename)) &#123;</span><br><span class="line">        fs.readFile(__dirname + <span class="string">"/"</span> + filename, <span class="string">'utf8'</span>, group());</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showAll</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.dir(files); </span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们注意到有两次group()的调用。第一次调用是告知Step要并行执行，第二次调用的结果将会生成一个回调函数，而回调函数接受的返回值将会按组存储。</p><p>parallel()传递给下一个任务的 结果是如下形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err, result1, result2, ...</span>);</span></span><br></pre></td></tr></table></figure><p>group()传递的结果是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>);</span></span><br></pre></td></tr></table></figure><p>这个函数返回的数据保存在数组中。</p><h5 id="4-wind"><a href="#4-wind" class="headerlink" title="4. wind"></a>4. wind</h5><ul><li>异步任务定义</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(Wind.compile(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;));</span><br><span class="line">Wind.Async.sleep(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>Wind.compile()会将普通的函数进行编译，然后交给eval()执行。</p><p>eval(Wind.compile(“async”, function () {}));定义了异步任务。Wind.Async.sleep();内置了对setTimeout()的封装。</p><p>除了通过eval(Wind.compile(“async”, function () {}));定义任务外，正式的任务创建方法为Task.create()。</p><ul><li>$await()与任务模型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">await</span>()</span><br></pre></td></tr></table></figure><p>事实上，它并不是一个方法，也不存在于上下文中，只是一个等待的占位符，告之编译器这里需要等待。</p><p>$await()接受的参数是一个任务对象，表示等待任务结束后才会执行后续操作。每一个异步 操作都可以转化为一个任务，wind正是基于任务模型实现的。</p><p>wind提供了whenAll()来处理并发，通过$await关键字将等待配置的所有任务完成后才向下继续执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parallel = <span class="built_in">eval</span>(Wind.compile(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> result = $<span class="keyword">await</span>(Task.whenAll(&#123;</span><br><span class="line">    file1: readFileAsync(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>),</span><br><span class="line">    file2: readFileAsync(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>) </span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="built_in">console</span>.log(result.file1);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(result.file2); &#125;));</span><br><span class="line">parallel().start();</span><br><span class="line"><span class="comment">//得到输出:</span></span><br><span class="line">file1 file2</span><br></pre></td></tr></table></figure><ul><li>异步方法转换辅助函数</li></ul><p>这种近同步编程的体验需要我们额外 或者提前完成的事情是:将异步方法任务化。</p><p>wind提供了两个 方法来辅助转换:</p><ol><li>Wind.Async.Binding.fromCallback 用于转换这类无异常的异步调用为wind中的任务</li><li>Wind.Async.Binding.fromStandard 用于转换这类带异常的异步调用到wind中的任务。</li></ol><h3 id="异步并发控制"><a href="#异步并发控制" class="headerlink" title="异步并发控制"></a>异步并发控制</h3><p>同步I/O因为每个I/O都是彼此阻塞的，在循环体 中，总是一个接着一个调用，不会出现耗用文件描述符太多的情况，同时性能也是低下的;对于 异步I/O，虽然并发容易实现，但是由于太容易实现，依然需要控制。换言之，尽管是要压榨底 层系统的性能，但还是需要给予一定的过载保护，以防止过犹不及。</p><h4 id="bagpipe的解决方案"><a href="#bagpipe的解决方案" class="headerlink" title="bagpipe的解决方案"></a>bagpipe的解决方案</h4><ul><li>通过一个队列来控制并发量。</li><li>如果当前活跃(指调用发起但未执行回调)的异步调用量小于限定值，从队列中取出执行。 </li><li>如果活跃调用达到限定值，调用暂时存放在队列中。</li><li>每个异步调用结束时，从队列中取出新的异步调用执行</li></ul><p>用户传入的回调函数被真正执行前，被封装替换过。这个封装的回调函数内部的逻辑将活跃 值的计数器减1后，主动调用next()执行后续等待的异步调用。</p><p>bagpipe类似于打开了一道窗口，允许异步调用并行进行，但是严格限定上限。仅仅在调用 push()时分开传递，并不对原有API有任何侵入。</p><h5 id="拒绝模式"><a href="#拒绝模式" class="headerlink" title="拒绝模式"></a>拒绝模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定最大并发数为10</span></span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>, &#123;</span><br><span class="line">  refuse: <span class="literal">true</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返给它一个队列太忙的 拒绝异常。</p><h5 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h5><p>造成队列拥塞的主要原因是异步调用耗时太久，调用产生的速度远远高于执行的速度。为了防止某些异步调用使用了太多的时间，我们需要设置一个时间基线，将那些执行时间太久的异步调用 清理出活跃队列，让排队中的异步调用尽快执行。否则在拒绝模式下，会有太多的调用因为某个执 行得慢，导致得到拒绝异常。</p><p>超时控制是为异步调用设置一个时间阈值，如果异步调用 没有在规定时间内完成，我们先执行用户传入的回调函数，让用户得到一个超时异常，以尽早返 回。然后让下一个等待队列中的调用执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定最大并发数为10</span></span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>, &#123;</span><br><span class="line">  timeout: <span class="number">3000</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="async的解决方案"><a href="#async的解决方案" class="headerlink" title="async的解决方案"></a>async的解决方案</h4><p>async也提供了一个方法用于处理异步调用的限制:parallelLimit()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallelLimit([ </span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同 时并发一定数量，而不是无限制并发。</p><p>parallelLimit()方法的缺陷在于无法动态地增加并行任务。async提供了queue()方法 来满足该需求.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q = <span class="keyword">async</span>.queue(<span class="function"><span class="keyword">function</span> (<span class="params">file, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(file, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">&#125;,<span class="number">2</span>);</span><br><span class="line">q.drain=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 完成了队列中的所有任务 </span></span><br><span class="line">&#125;;</span><br><span class="line">fs.readdirSync(<span class="string">'.'</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  q.push(file, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO </span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>尽管queue()实现了动态添加并行任务，但是相比parallelLimit()，由于queue()接收的参数是固定的，它丢失了parallelLimit()的多样性</p><h2 id="第五章-内存控制"><a href="#第五章-内存控制" class="headerlink" title="第五章 内存控制"></a>第五章 内存控制</h2><h3 id="V8-的垃圾回收机制与内存限制"><a href="#V8-的垃圾回收机制与内存限制" class="headerlink" title="V8 的垃圾回收机制与内存限制"></a>V8 的垃圾回收机制与内存限制</h3><h4 id="V8-的内存限制"><a href="#V8-的内存限制" class="headerlink" title="V8 的内存限制"></a>V8 的内存限制</h4><p>在Node中通过JavaScript 使用内存时就会发现只能使用部分内存(64位系统下约为1.4 GB，32位系统下约为0.7 GB)。在 这样的限制下，将会导致Node无法直接操作大内存对象。</p><p>造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上 都是通过V8自己的方式来进行分配和管理的。V8的这套内存管理机制在浏览器的应用场景下使 用起来绰绰有余，足以胜任前端页面中的所有需求。但在Node中，这却限制了开发者随心所欲使 用大内存的想法。</p><h4 id="V8-的对象分配"><a href="#V8-的对象分配" class="headerlink" title="V8 的对象分配"></a>V8 的对象分配</h4><h5 id="内存使用量的查看"><a href="#内存使用量的查看" class="headerlink" title="内存使用量的查看"></a>内存使用量的查看</h5><p>在V8中，所有的JavaScript对象都是通过堆来进行分配的。Node提供了V8中内存使用量的查 看方式，执行下面的代码，将得到输出的内存信息:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage(); </span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">14958592</span>,</span><br><span class="line">  heapTotal: <span class="number">7195904</span>, </span><br><span class="line">  heapUsed: <span class="number">2821496</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>heapTotal和heapUsed是V8的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。</p><p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲 内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。</p><h5 id="V8限制堆大小的原因"><a href="#V8限制堆大小的原因" class="headerlink" title="V8限制堆大小的原因"></a>V8限制堆大小的原因</h5><p>以1.5 GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一 次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在 这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受， 前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。</p><h5 id="调整内存限制的大小"><a href="#调整内存限制的大小" class="headerlink" title="调整内存限制的大小"></a>调整内存限制的大小</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=<span class="number">1700</span> test.js <span class="comment">// 单位为MB </span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">node --max-<span class="keyword">new</span>-space-size=<span class="number">1024</span> test.js <span class="comment">// 单位为KB</span></span><br></pre></td></tr></table></figure><h4 id="V8-的垃圾回收机制"><a href="#V8-的垃圾回收机制" class="headerlink" title="V8 的垃圾回收机制"></a>V8 的垃圾回收机制</h4><h5 id="V8主要的垃圾回收算法"><a href="#V8主要的垃圾回收算法" class="headerlink" title="V8主要的垃圾回收算法"></a>V8主要的垃圾回收算法</h5><p>V8的垃圾回收策略主要基于分代式垃圾回收机制</p><ul><li><p>V8的内存分代</p><p>在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga27phiuq7j30r005q74q.jpg" alt="image-20191219183341084"></p><p>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面我们提及的 –max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，–max-new-space-size 命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就 指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值 时，就会引起进程出错。</p><ul><li>对于新生代内存，它由两个reserved_semispace_size_所构成.按机器位数不同，reserved_semispace_size_在64位系统和32位系统上分别为16 MB和8 MB。所以新生 代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB。</li><li>默认情况下，V8堆内存的最大值在64位系统上为1464 MB，32位系统上则为732 MB。 这个数值可以解释为何在64位系统下只能使用约1.4 GB内存和在32位系统下只能使用约0.7 GB 内存。</li></ul></li><li><p>Scavenge算法</p><p>新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法。</p><ul><li><p>Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处 于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象 时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这 些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空 间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个 semispace空间之间进行复制。</p></li><li><p>Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时 间效率上有优异的表现。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga27wgek1uj30rm07wq3m.jpg" alt="image-20191219184025403"></p><p>当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中 的过程称为晋升。</p><p>在分代式垃圾回收的前提下，From空间中的存活对 象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中， 也就是完成对象晋升。</p><p>对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。当要从From空间复制一个对象到To空间时，如果 To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中</p><p>（设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接 下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。）</p></li><li><p>Mark-Sweep &amp; Mark-Compact</p><p>Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。<strong>Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。</strong></p><p>Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种 内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有 的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><p>在整理的 过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga283qesgnj317y08sq4f.jpg" alt="image-20191219184724646"></p><p>V8主要使用Mark-Sweep，在空间不足以对从新 生代中晋升过来的对象进行分配时才使用Mark-Compact。</p></li><li><p>Incremental Marking</p><p>为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全 停顿”(stop-the-world)。</p><p>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成 的动作改为增量标记(incremental marking)，也就是拆分为许多小“步进”，每做完一“步进” 就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga287h5jwqj30sk09qt9k.jpg" alt="image-20191219185100781"></p><p>V8在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。</p><p>V8后续还引入了延迟清理(lazy sweeping)与增量式整理(incremental compaction)，让清 理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低 每次停顿的时间。</p></li></ul><h4 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="headerlink" title="查看垃圾回收日志"></a>查看垃圾回收日志</h4><p>查看垃圾回收日志的方式主要是在启动时添加–trace_gc参数。在进行垃圾回收时，将会从 标准输出中打印垃圾回收的日志信息。通过分析垃圾回收日志，可以了解垃圾回收的运行状况，找出垃圾回收的哪些阶段比较耗时， 触发的原因是什么。</p><p>通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾 回收执行时占用的时间。</p><p>（V8提供了linux-tick-processor工具用于统计日志信息。该工具可以从Node源码的 deps/v8/tools目录下找到，Windows下的对应命令文件为windows-tick-processor.bat。将该目录添 加到环境变量PATH中，即可直接调用）</p><h3 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><h5 id="1-标识符查找"><a href="#1-标识符查找" class="headerlink" title="1. 标识符查找"></a>1. 标识符查找</h5><p>标识符，可以理解为变量名。</p><h5 id="2-作用域链"><a href="#2-作用域链" class="headerlink" title="2. 作用域链"></a>2. 作用域链</h5><p>JavaScript在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作 用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。这样的查找方式使得作 用域像一个链条。由于标识符的查找方向是向上的，所以变量只能向外访问，而不能向内访问。</p><h5 id="3-变量的主动释放"><a href="#3-变量的主动释放" class="headerlink" title="3. 变量的主动释放"></a>3. 变量的主动释放</h5><ul><li><p>如果变量是全局变量(不通过var声明或定义在global变量上)，由于全局作用域需要直到 进程退出才能释放，此时将导致引用的对象常驻内存(常驻在老生代中)。如果需要释放常驻内 存的对象，可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理的过程中，会被回收释放。</p></li><li><p>在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。</p></li><li><p>虽然 delete操作和重新赋值具有相同的效果，但是在V8中通过delete删除对象的属性有可能干扰V8 的优化，所以通过赋值方式解除引用更好。</p></li></ul><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>实现外部作用域访问内部作用域中变量的方法叫做闭包(closure)</p><p>这得益 于高阶函数的特性:函数可以作为参数或者返回值。</p><p>一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域 中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。</p><h3 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h3><p>os模块中的 totalmem()和freemem()方法也可以查看内存使用情况</p><h4 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h4><h5 id="1-查看进程的内存占用"><a href="#1-查看进程的内存占用" class="headerlink" title="1. 查看进程的内存占用"></a>1. 查看进程的内存占用</h5><p>调用process.memoryUsage()可以看到Node进程的内存占用情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage() </span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">13852672</span>,</span><br><span class="line">  heapTotal: <span class="number">6131200</span>, </span><br><span class="line">  heapUsed: <span class="number">2757120</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区(swap)或者文件系统(filesystem)中。</p><p>除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内 存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节。</p><h5 id="2-查看系统的内存占用"><a href="#2-查看系统的内存占用" class="headerlink" title="2. 查看系统的内存占用"></a>2. 查看系统的内存占用</h5><p>os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; os.totalmem() </span><br><span class="line"><span class="number">8589934592</span></span><br><span class="line">&gt; os.freemem() </span><br><span class="line"><span class="number">4527833088</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h4><p>堆中的内存用量总是小于进程的常驻内存用 量，这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存。</p><p>Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不 会有堆内存的大小限制。</p><p>利用堆外内存可以突破内存限制的问题。</p><p><strong>Node的内存构成主要由通过V8进行分配的部分和Node自行分配的 部分。受V8的垃圾回收限制的主要是V8的堆内存。</strong></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>造成内存泄漏的原因：</p><ul><li>缓存。</li><li>队列消费不及时。</li><li>作用域未释放。</li></ul><h4 id="慎将内存当做缓存"><a href="#慎将内存当做缓存" class="headerlink" title="慎将内存当做缓存"></a>慎将内存当做缓存</h4><ul><li><p>在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常 驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描 10 和整理时，对这些对象做无用功</p></li><li><p>JavaScript开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上 的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。</p></li></ul><h5 id="1-缓存限制策略"><a href="#1-缓存限制策略" class="headerlink" title="1. 缓存限制策略"></a>1. 缓存限制策略</h5><p>为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。</p><p>模块机制：为了加速模块的引入，所有模块都会通 过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量， 这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。</p><h5 id="2-缓存的解决方案"><a href="#2-缓存的解决方案" class="headerlink" title="2. 缓存的解决方案"></a>2. 缓存的解决方案</h5><p>进 程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用 是一种浪费。</p><p>采用进程外的缓存，进程自身不存储状态。外 部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。</p><p>在Node中主要可以解决以下两个问题。</p><p>(1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。<br> (2) 进程之间可以共享缓存。</p><p>市面上较好的缓存有Redis和Memcached</p><h4 id="关注队列状态"><a href="#关注队列状态" class="headerlink" title="关注队列状态"></a>关注队列状态</h4><p>队列在消费者-生产者模型中经常充当中间产物。一旦消费速度低于生产速度， 将会形成堆积。</p><p>深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关 人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应， 通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个 下限值。</p><h3 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h3><p>常见的定位Node应用的内存泄漏的工具：</p><ul><li>v8-profiler。由Danny Coates提供，它可以用于对V8堆内存抓取快照和对CPU进行分析，但该项目已经有3年没有维护了。</li><li>node-heapdump。这是Node核心贡献者之一Ben Noordhuis编写的模块，它允许对V8堆内存抓取快照，用于事后分析。</li></ul><ul><li>node-mtrace。由Jimb Esser提供，它使用了GCC的mtrace工具来分析堆的使用。</li><li>dtrace。在Joyent的SmartOS系统上，有完善的dtrace工具用来分析内存泄漏。</li><li>node-memwatch。来自Mozilla的Lloyd Hilaiel贡献的模块，采用WTFPL许可发布。</li></ul><h4 id="node-heapdump"><a href="#node-heapdump" class="headerlink" title="node-heapdump"></a>node-heapdump</h4><p>先构造如下一份包含内存泄 漏的代码示例，并将其存为server.js文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line"><span class="keyword">var</span> leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  leak();</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>); </span><br><span class="line">&#125;).listen(<span class="number">1337</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure><p>在上面这段代码中，每次访问服务进程都将引起leakArray数组中的元素增加，而且得不到回收。我们可以用curl工具输入<a href="http://127.0.0.1:1337/命令来模拟用户访问。" target="_blank" rel="noopener">http://127.0.0.1:1337/命令来模拟用户访问。</a></p><h5 id="安装node-heapdump"><a href="#安装node-heapdump" class="headerlink" title="安装node-heapdump"></a>安装node-heapdump</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install heapdump</span><br></pre></td></tr></table></figure><p>安装node-heapdump后，在代码的第一行添加如下代码将其引入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var heapdump = require(&apos;heapdump&apos;);</span><br></pre></td></tr></table></figure><p>引入node-heapdump后，就可以启动服务进程，并接受客户端的请求。访问多次之后， leakArray中就会具备大量的元素。这个时候我们通过向服务进程发送SIGUSR2信号，让 10 node-heapdump抓拍一份堆内存的快照。发送信号的命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill -USR2 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>这份抓取的快照将会在文件目录下以heapdump-<sec>.<usec>.heapsnapshot的格式存放。这是一份较大的JSON文件，需要通过Chrome的开发者工具打开查看。</usec></sec></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga362sgilrj31400qmwq7.jpg" alt="image-20191220142253073"></p><p>可以看到有大量的leak字符串存在，这些字符串就是一直未能得到回收的数据。 通过在开发者工具的面板中查看内存分布，我们可以找到泄漏的数据，然后根据这些信息找到造 成泄漏的代码。</p><h4 id="node-memwatch"><a href="#node-memwatch" class="headerlink" title="node-memwatch"></a>node-memwatch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memwatch = <span class="built_in">require</span>(<span class="string">'memwatch'</span>); memwatch.on(<span class="string">'leak'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'leak:'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(info); </span><br><span class="line">&#125;);</span><br><span class="line">memwatch.on(<span class="string">'stats'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">stats</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'stats:'</span>) </span><br><span class="line">  <span class="built_in">console</span>.log(stats);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line"><span class="keyword">var</span> leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  leak();</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>); </span><br><span class="line">&#125;).listen(<span class="number">1337</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure><h5 id="1-stats事件"><a href="#1-stats事件" class="headerlink" title="1. stats事件"></a>1. stats事件</h5><p>在进程中使用node-memwatch之后，每次进行全堆垃圾回收时，将会触发一次stats事件，这 4 个事件将会传递内存的统计信息。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga366z9jroj30mi0a6q4r.jpg" alt="image-20191220142653590"></p><p>num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况</p><h5 id="2-leak事件"><a href="#2-leak事件" class="headerlink" title="2. leak事件"></a>2. leak事件</h5><p>如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga36evbve4j30uk05wgmj.jpg" alt="image-20191220143429405"></p><p>这个数据能显示5次垃圾回收的过程中内存增长了多少。</p><h5 id="3-堆内存比较"><a href="#3-堆内存比较" class="headerlink" title="3. 堆内存比较"></a>3. 堆内存比较</h5><p>最终得到的leak事件的信息只能告知我们应用中存在内存泄漏，具体问题产生在何处还需要从V8的堆内存上定位。node-memwatch提供了抓取快照和比较快照的功能，它能够比较堆上对象 的名称和分配数量，从而找出导致内存泄漏的元凶。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memwatch = <span class="built_in">require</span>(<span class="string">'memwatch'</span>);</span><br><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line"><span class="keyword">var</span> leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take first snapshot</span></span><br><span class="line"><span class="keyword">var</span> hd = <span class="keyword">new</span> memwatch.HeapDiff();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; </span><br><span class="line">  leak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Take the second snapshot and compute the diff </span></span><br><span class="line"><span class="keyword">var</span> diff = hd.end(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(diff, <span class="literal">null</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>执行上面这段代码，得到的输出结果如下所示:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ node diff.js </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"before"</span>: &#123;</span><br><span class="line">    <span class="attr">"nodes"</span>: <span class="number">11719</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="string">"2013-10-07T06:32:07.000Z"</span>,</span><br><span class="line">    <span class="attr">"size_bytes"</span>: <span class="number">1493304</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="string">"1.42 mb"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"after"</span>: &#123;</span><br><span class="line">    <span class="attr">"nodes"</span>: <span class="number">31618</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="string">"2013-10-07T06:32:07.000Z"</span>, </span><br><span class="line">    <span class="attr">"size_bytes"</span>: <span class="number">2684864</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="string">"2.56 mb"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"change"</span>: &#123;</span><br><span class="line">    <span class="attr">"size_bytes"</span>: <span class="number">1191560</span>, </span><br><span class="line">    <span class="attr">"size"</span>: <span class="string">"1.14 mb"</span>, </span><br><span class="line">    <span class="attr">"freed_nodes"</span>: <span class="number">129</span>, </span><br><span class="line">    <span class="attr">"allocated_nodes"</span>: <span class="number">20028</span>,</span><br><span class="line">    <span class="attr">"details"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"what"</span>: <span class="string">"Array"</span>, </span><br><span class="line">        <span class="attr">"size_bytes"</span>: <span class="number">323720</span>, </span><br><span class="line">        <span class="attr">"size"</span>: <span class="string">"316.13 kb"</span>, </span><br><span class="line">        <span class="attr">"+"</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="attr">"-"</span>: <span class="number">65</span></span><br><span class="line">      &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"what"</span>: <span class="string">"Code"</span>, </span><br><span class="line">        <span class="attr">"size_bytes"</span>: <span class="number">-10944</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="string">"-10.69 kb"</span>,</span><br><span class="line">        <span class="attr">"+"</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="attr">"-"</span>: <span class="number">28</span> </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"what"</span>: <span class="string">"String"</span>,</span><br><span class="line">        <span class="attr">"size_bytes"</span>: <span class="number">879424</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="string">"858.81 kb"</span>,</span><br><span class="line">        <span class="attr">"+"</span>: <span class="number">20001</span>,</span><br><span class="line">        <span class="attr">"-"</span>: <span class="number">1</span></span><br><span class="line">      &#125; </span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>change节点下的freed_nodes和allocated_nodes，它们记录了 释放的节点数量和分配的节点数量。这里由于有内存泄漏，分配的节点数量远远多余释放的节点 数量。在details下可以看到具体每种类型的分配和释放数量。</p><p>加号和减号分别表示分配和释放的字符串对象数量。</p><h3 id="大内存应用"><a href="#大内存应用" class="headerlink" title="大内存应用"></a>大内存应用</h3><p><strong>Node提供了stream模块用于处理大文件</strong></p><p>stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自 定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node中的大多数模块都有 stream的应用，比如fs的createReadStream()和createWriteStream()方法可以分别用于创建文件 的可读流和可写流，process模块中的stdin和stdout则分别是可读流和可写流的示例。</p><h2 id="第六章-理解Buffer"><a href="#第六章-理解Buffer" class="headerlink" title="第六章 理解Buffer"></a>第六章 理解Buffer</h2><h3 id="Buffer-结构"><a href="#Buffer-结构" class="headerlink" title="Buffer 结构"></a>Buffer 结构</h3><p>Buffer是一个像Array的对象，但它主要用于操作字节。</p><h4 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h4><p>Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga370u7oazj30ja09ewf3.jpg" alt="image-20191220145535868"></p><p>Node在进程启动时就已经加载了它，并将其放在全局对象(global) 上。所以在使用Buffer时，无须通过require()即可直接使用</p><h4 id="Buffer-对象"><a href="#Buffer-对象" class="headerlink" title="Buffer 对象"></a>Buffer 对象</h4><p>Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"深入浅出node.js"</span>;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(str, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"><span class="comment">// =&gt; &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span></span><br></pre></td></tr></table></figure><p>不同编码的字符串占用的元素个数各不相同，上面代码中的中文字在 UTF-8编码下占用3个元素，字母和半角标点符号占用1个元素。</p><p>Buffer可以访问length属性得到长度，也可以通过下标访问元素，在构造对象时也与Array相似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">100</span>); </span><br><span class="line"><span class="built_in">console</span>.log(buf.length); <span class="comment">// =&gt; 100</span></span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">//会得到一个比较奇怪的结果，它的元素值是一个0到255的随机值。</span></span><br></pre></td></tr></table></figure><p>如果给元素赋值不是0到255的整数而是小数时会怎样呢?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf[<span class="number">20</span>] = <span class="number">-100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">20</span>]); <span class="comment">// 156 </span></span><br><span class="line">buf[<span class="number">21</span>] = <span class="number">300</span>; </span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">21</span>]); <span class="comment">// 44 </span></span><br><span class="line">buf[<span class="number">22</span>] = <span class="number">3.1415</span>; </span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">22</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到 的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只 保留整数部分。</p><h4 id="Buffer-内存分配"><a href="#Buffer-内存分配" class="headerlink" title="Buffer 内存分配"></a>Buffer 内存分配</h4><p>Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的。因 为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大 量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++ 层面申请内存、在JavaScript中分配内存的策略。</p><p>Node采用了slab分配机制，slab是一种动态内存管理机制。slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态。 </p><ul><li>full:完全分配状态。</li><li>partial:部分分配状态。</li><li>empty:没有被分配状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(size);</span><br></pre></td></tr></table></figure><p>Node以8 KB为界限来区分Buffer是大对象还是小对象。8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配。</p><h5 id="1-分配小Buffer对象"><a href="#1-分配小Buffer对象" class="headerlink" title="1. 分配小Buffer对象"></a>1. 分配小Buffer对象</h5><p>如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocPool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pool = <span class="keyword">new</span> SlowBuffer(Buffer.poolSize); </span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga3g2jgvmhj30x408ot97.jpg" alt="image-20191220200835681"></p><p><strong>slab处于empty状态。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这次构造将会去检查pool对象，如果pool没有被创建，将会创建一个新的slab单元指向它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; <span class="keyword">this</span>.length) allocPool();</span><br></pre></td></tr></table></figure><p>同时当前Buffer对象的parent属性指向该slab，并记录下是从这个slab的哪个位置(offset) 开始使用的，slab对象自身也记录被使用了多少字节</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.parent = pool;</span><br><span class="line"><span class="keyword">this</span>.offset = pool.used;</span><br><span class="line">pool.used += <span class="keyword">this</span>.length;</span><br><span class="line"><span class="keyword">if</span> (pool.used &amp; <span class="number">7</span>) pool.used = (pool.used + <span class="number">8</span>) &amp; ~<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga3g75sbkjj30w80ccmy1.jpg" alt="image-20191220201258838"></p><p><strong>这时候的slab状态为partial。</strong></p><p>当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足 够，使用剩余空间，并更新slab的分配状态。如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费。</p><p>由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对 象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象， 但是如果不释放它，实际可能是8 KB的内存没有释放。</p><h5 id="2-分配大Buffer对象"><a href="#2-分配大Buffer对象" class="headerlink" title="2. 分配大Buffer对象"></a>2. 分配大Buffer对象</h5><p>如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab 单元将会被这个大Buffer对象独占。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Big buffer, just alloc one</span></span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> SlowBuffer(<span class="keyword">this</span>.length); <span class="keyword">this</span>.offset = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="Buffer-的转换"><a href="#Buffer-的转换" class="headerlink" title="Buffer 的转换"></a>Buffer 的转换</h3><p>Buffer对象可以与字符串之间相互转换。目前支持的字符串编码类型有如下这几种。</p><ul><li>ASCII</li><li>UTF-8</li><li>UTF-16LE/UCS-2</li><li>Base64</li><li>Binary</li><li>Hex</li></ul><h4 id="字符串转Buffer"><a href="#字符串转Buffer" class="headerlink" title="字符串转Buffer"></a>字符串转Buffer</h4><p>字符串转Buffer对象主要是通过构造函数完成的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</span><br></pre></td></tr></table></figure><p>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储。</p><p>一个Buffer对象可以存储不同编码类型的字符串转码的值，调用write()方法可以实现该目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string, [offset], [length], [encoding])</span><br></pre></td></tr></table></figure><p>由于可以不断写入内容到Buffer对象中，并且每次写入可以指定编码，所以Buffer对象中可 以存在多种编码转化后的内容。需要小心的是，每种编码所用的字节长度不同，将Buffer反转回 字符串时需要谨慎处理。</p><h4 id="Buffer-转字符串"><a href="#Buffer-转字符串" class="headerlink" title="Buffer 转字符串"></a>Buffer 转字符串</h4><p>Buffer对象的toString()可以将Buffer对象转换为字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end])</span><br></pre></td></tr></table></figure><p>可以设置encoding(默认为UTF-8)、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。</p><h4 id="Buffer-不支持的编码类型"><a href="#Buffer-不支持的编码类型" class="headerlink" title="Buffer 不支持的编码类型"></a>Buffer 不支持的编码类型</h4><p>Buffer提供了一个isEncoding()函数来判断编码是否支持转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.isEncoding(encoding)</span><br></pre></td></tr></table></figure><p>将编码类型作为参数传入上面的函数，如果支持转换返回值为true，否则为false。</p><h3 id="Buffer-的拼接"><a href="#Buffer-的拼接" class="headerlink" title="Buffer 的拼接"></a>Buffer 的拼接</h3><p>Buffer在使用场景中，通常是以一段一段的方式传输。</p><h4 id="乱码是如何产生的"><a href="#乱码是如何产生的" class="headerlink" title="乱码是如何产生的"></a>乱码是如何产生的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>)</span>&#123; </span><br><span class="line">  data += chunk; &#125;);</span><br><span class="line">rs.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>data += chunk;</code>这句代码里隐藏了toString()操作，等价于<code>data = data.toString() + chunk.toString();</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;<span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure><p>搭配该代码的测试数据为李白的《静夜思》。执行该程序，将会得到以下输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">床前明���光，疑���地上霜;举头���明月，���头思故乡。</span><br></pre></td></tr></table></figure><p>产生这个输出结果的原因在于文件可读流在读取时会逐个读取Buffer。这首诗的原始Buffer应存储为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e5 ba <span class="number">8</span>a e5 <span class="number">89</span> <span class="number">8</span>d e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c <span class="number">88</span> e5 <span class="number">85</span> <span class="number">89</span> ef bc <span class="number">8</span>c e7 <span class="number">96</span> <span class="number">91</span> e6 <span class="number">98</span> af e5 <span class="number">9</span>c b0 e4 b8 <span class="number">8</span>a e9 <span class="number">9</span>c <span class="number">9</span>c ef bc <span class="number">9</span>b e4 b8 be e5 a4 b4 e6 <span class="number">9</span>c <span class="number">9</span>b e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c <span class="number">88</span> ...&gt;</span><br></pre></td></tr></table></figure><p>由于我们限定了Buffer对象的长度为11，因此只读流需要读取7次才能完成完整的读取，结果 是以下几个Buffer对象依次输出:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e5 ba <span class="number">8</span>a e5 <span class="number">89</span> <span class="number">8</span>d e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c&gt; </span><br><span class="line">&lt;Buffer <span class="number">88</span> e5 <span class="number">85</span> <span class="number">89</span> ef bc <span class="number">8</span>c e7 <span class="number">96</span> <span class="number">91</span> e6&gt; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>buf.toString()方法默认以UTF-8为编码，中文字在UTF-8下占3个字节。所以第 一个Buffer对象在输出时，只能显示3个字符，Buffer中剩下的2个字节(e6 9c)将会以乱码的形 式显示。第二个Buffer对象的第一个字节也不能形成文字，只能显示乱码。于是形成一些文字无 法正常显示的问题。</p><p>在这个示例中我们构造了11这个限制，但是对于任意长度的Buffer而言，宽字节字符串都有 可能存在被截断的情况，只不过Buffer的长度越大出现的概率越低而已，但该问题依然不可忽视。</p><h4 id="setEncoding-与-string-decoder"><a href="#setEncoding-与-string-decoder" class="headerlink" title="setEncoding()与 string_decoder()"></a>setEncoding()与 string_decoder()</h4><p>可读流还有一个设置编码的方法setEncoding()，该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readable.setEncoding(encoding)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123; <span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br><span class="line">rs.setEncoding(<span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure><p>重新执行程序，得到输出:</p><p><code>床前明月光，疑是地上霜;举头望明月，低头思故乡。</code></p><p><strong>设置编码并未改变按 段读取的基本方式。</strong>在调用setEncoding()时，可读流对象在内部设置了一个decoder对象。每次data事 件都通过该decoder对象进行Buffer到字符串的解码，然后传递给调用者。置编码后，data 不再收到原始的Buffer对象。</p><p>decoder对象来自于string_decoder 模块StringDecoder的实例对象。StringDecoder在得到编码后，知道宽字节字符串在UTF-8编码下是 以3个字节的方式存储的，所以第一次write()时，只输出前9个字节转码形成的字符，“月”字的 前两个字节被保留在StringDecoder实例内部。第二次write()时，会将这2个剩余字节和后续11 个字节组合在一起，再次用3的整数倍字节进行转码。于是乱码问题通过这种中间形式被解决了。</p><p><strong>string_decoder目前只能处理UTF-8、Base64和 UCS-2/UTF-16LE这3种编码。</strong></p><h4 id="正确拼接Buffer"><a href="#正确拼接Buffer" class="headerlink" title="正确拼接Buffer"></a>正确拼接Buffer</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunks = [];</span><br><span class="line"><span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  chunks.push(chunk);</span><br><span class="line">  size += chunk.length;</span><br><span class="line">&#125;)</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buf = Buffer.concat(chunks, size); </span><br><span class="line">  <span class="keyword">var</span> str = iconv.decode(buf, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度， 然后调用Buffer.concat()方法生成一个合并的Buffer对象。Buffer.concat()方法封装了从小 Buffer对象向大Buffer对象的复制过程，实现十分细腻</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat = <span class="function"><span class="keyword">function</span>(<span class="params">list, length</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Usage: Buffer.concat(list, [length])'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (list.length === <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.length === <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> length !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> buf = list[i];</span><br><span class="line">      length += buf.length; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(length);</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> buf = list[i]; </span><br><span class="line">    buf.copy(buffer, pos); </span><br><span class="line">    pos += buf.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buffer; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Buffer-与性能"><a href="#Buffer-与性能" class="headerlink" title="Buffer 与性能"></a>Buffer 与性能</h3><p>一旦在网络中传输，都需要转换为Buffer，以进行二进制数据传输。</p><p>通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。 在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通 过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变 内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。</p><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>在文件的读取时，有一个highWaterMark设置对性能的影响至关重要。</p><p>在fs.createReadStream(path, opts)时，我们可以传入一些参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="literal">null</span>,</span><br><span class="line">  fd: <span class="literal">null</span>,</span><br><span class="line">  mode: <span class="number">0666</span>, </span><br><span class="line">  highWaterMark: <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以传递start和end来指定读取文件的位置范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">start</span>: <span class="number">90</span>, <span class="attr">end</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure><p>fs.createReadStream()的工作方式是在内存中准备一段Buffer，然后在fs.read()读取时逐步 从磁盘中将字节复制到Buffer中。完成一次读取时，则从这个Buffer中通过slice()方法取出部分 数据作为一个小Buffer对象，再通过data事件传递给调用方。如果Buffer用完，则重新分配一个; 如果还有剩余，则继续使用。</p><p>分配一个新的Buffer对象的操作:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocNewPool</span>(<span class="params">poolSize</span>) </span>&#123; </span><br><span class="line">  pool = <span class="keyword">new</span> Buffer(poolSize); </span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在理想的状况下，每次读取的长度就是用户指定的highWaterMark。但是有可能读到了文件结尾，或者文件本身就没有指定的highWaterMark那么大，这个预先指定的Buffer对象将会有部分 剩余，不过好在这里的内存可以分配给下次读取时使用。pool是常驻内存的，只有当pool单元剩 余数量小于128(kMinPoolSpace)字节时，才会重新分配一个新的Buffer对象。</p><p>highWaterMark的大小对性能有两个影响的点</p><ul><li>highWaterMark设置对Buffer内存的分配和使用有一定影响。</li><li>highWaterMark设置过小，可能导致系统调用次数过多。</li></ul><p>文件流读取基于Buffer分配，Buffer则基于SlowBuffer分配</p><p>由于fs.createReadStream()内部采用fs.read()实现，将会引起对磁盘的系统调用，对于大 文件而言，highWaterMark的大小决定会触发系统调用和data事件的次数。</p><p>读取一个相同的大文件时，highWaterMark值的大小与读取速 度的关系:该值越大，读取速度越快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Node-js学习笔记（二）&quot;&gt;&lt;a href=&quot;#深入浅出Node-js学习笔记（二）&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Node.js学习笔记（二）&quot;&gt;&lt;/a&gt;深入浅出Node.js学习笔记（二）&lt;/h1&gt;&lt;h2 id=&quot;第
      
    
    </summary>
    
      <category term="Node.js" scheme="http://yoursite.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js学习笔记（一）</title>
    <link href="http://yoursite.com/2019/12/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/13/深入浅出Node.js学习笔记（一）/</id>
    <published>2019-12-13T07:04:52.000Z</published>
    <updated>2019-12-29T07:11:37.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Node-js学习笔记（一）"><a href="#深入浅出Node-js学习笔记（一）" class="headerlink" title="深入浅出Node.js学习笔记（一）"></a>深入浅出Node.js学习笔记（一）</h1><p>高并发、高性能</p><h2 id="第一章-Node简介"><a href="#第一章-Node简介" class="headerlink" title="第一章 Node简介"></a>第一章 Node简介</h2><ul><li><p>高性能、符合事件驱动、没有历史包袱这3个主要原因，JavaScript成为了Node的实现语言。</p></li><li><p>Node发展为一个强制不共享任何资源的 单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目 标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多 Node，非常容易通过扩展来达成构建大型网络应用的目的。每一个Node进程都构成这个网络应 用中的一个节点，这是它名字所含意义的真谛。</p></li><li><p>它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱 动来服务I/O</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mu9fwye3j30s80g875q.jpg" alt="image-20191206112453524"></p></li></ul><h3 id="Node的特点"><a href="#Node的特点" class="headerlink" title="Node的特点"></a>Node的特点</h3><h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h4><ul><li><p>在Node中，绝大多数的操作都以异步的方式进行调用。</p></li><li><p>在Node中，我们可 以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。</p></li></ul><h4 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h4><ul><li><p>事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下， 事件与事件之间各自独立，如何协作是一个问题。</p></li><li><p>回调函数无处不在。回调函数是最好的接受异步调用返回数据的方式</p></li></ul><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>Node保持了JavaScript在浏览器中单线程的特点。</p><ul><li><p>在Node中，JavaScript与其余线程是无 法共享任何状态的。（单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里 没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。）</p></li><li><p>单线程的弱点：</p><ul><li>无法利用多核CPU</li><li>错误会引起整个应用退出，应用的健壮性值得考验</li><li>大量计算占用CPU导致无法继续调用异步I/O</li></ul></li><li><p>在Node中，长时间的CPU占用也会导致后续的异步I/O发不出调用，已完成的异步I/O的 回调函数也会得不到及时执行。解决单线程中大计算量的问题——child_process</p></li><li><p>子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问 题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来 传递结果，这可以很好地保持应用模型的简单和低依赖。通过Master-Worker的管理方式，也可以 很好地管理各个工作进程，以达到更高的健壮性。</p></li></ul><h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mzbqn9c1j30l80fct9g.jpg" alt="image-20191206142014972"></p><p>它在操作系统与Node上层模块 系统之间构建了一层平台层架构，即libuv。（libuv已经成为许多系统实现跨平台的基础组件）</p><h3 id="Node-的应用场景"><a href="#Node-的应用场景" class="headerlink" title="Node 的应用场景"></a>Node 的应用场景</h3><h4 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h4><p>Node擅长I/O密集型的应用场景。Node面向网络且擅长并行I/O，能够有效 地组织起更多的硬件资源，从而提供更多好的服务。</p><p>I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请 求服务，资源占用极少。</p><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><p>CPU密集型应用给Node 带来的挑战主要是:由于JavaScript单线程的原因，如果有长时间运行的计算(比如大循环)，将 会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个 小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好 处，又能充分利用CPU。</p><ul><li>Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。</li><li>如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。</li></ul><p><strong>CPU密集不可怕，如何合理调度是诀窍。</strong></p><h4 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h4><p>Node高效利用并行I/O的过程，也是高效使用数 据库的过程</p><h2 id="第二章-模块机制"><a href="#第二章-模块机制" class="headerlink" title="第二章 模块机制"></a>第二章 模块机制</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="JavaScript缺陷"><a href="#JavaScript缺陷" class="headerlink" title="JavaScript缺陷"></a>JavaScript缺陷</h4><ul><li>没有模块系统</li><li>标准库较少</li><li>没有标准接口</li><li>缺乏包管理系统</li></ul><p>CommonJS规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9nalsobqcj310m0awq4f.jpg" alt="image-20191206205027614"></p><h4 id="CommonJS-的模块规范"><a href="#CommonJS-的模块规范" class="headerlink" title="CommonJS 的模块规范"></a>CommonJS 的模块规范</h4><ul><li>模块引用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure><ul><li>模块定义</li></ul><p>上下文提供了 exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。</p><p>在模块中，还存在 一个module对象，它代表模块自身，而exports是module的属性。</p><p>在Node中，一个文件就是一个 模块，将方法挂载在exports对象上作为属性即可定义导出的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>, </span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">args = <span class="built_in">arguments</span>,</span><br><span class="line">l = args.length; </span><br><span class="line">  <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">sum += args[i++]; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> sum; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>模块标识</li></ul><p>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者 以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。</p><p>它的意义在于将类聚的方法和变量等限定在私有的 作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9qatnbzkaj30mi0byt98.jpg" alt="image-20191209111442609"></p><h3 id="Node-的模块实现"><a href="#Node-的模块实现" class="headerlink" title="Node 的模块实现"></a>Node 的模块实现</h3><p>在Node中引入模块，需要经历如下3个步骤。</p><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><p>在Node中，模块分为两类:一类是Node提供的模块，称为核心模块;另一类是用户编写的模块，称为文件模块。</p><ul><li>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动 时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编 译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最 快的。</li><li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速 度比核心模块慢。</li></ul><h4 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h4><p>Node对引入过的模块都会进行缓存，以减少二次引入时的开销。Node缓存的事编译和执行之后的对象。</p><p>不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的 方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。</p><h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h4><h5 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h5><p>模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。</p><p>模块路径的生成规则：</p><ul><li>当前文件目录下的node_modules目录。</li><li>父目录下的node_modules目录。</li><li>父目录的父目录下的node_modules目录。</li><li>沿路径向上逐级递归，直到根目录下的node_modules目录。</li></ul><h5 id="模块标识符分析"><a href="#模块标识符分析" class="headerlink" title="模块标识符分析"></a>模块标识符分析</h5><p>模块标识符在Node中主要分为以下几类。</p><ul><li>核心模块，如http、fs、path等。</li><li>.或..开始的相对路径文件模块。</li><li>以/开始的绝对路径文件模块。</li><li>非路径形式的文件模块，如自定义的connect模块。</li></ul><ol><li><p>核心模块</p><p>核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码， 其加载过程最快。</p><p>（如果加载一个与核心模块标识符相同的自定义模块，不会成功。如果自己编写了一个http用户模块，想要加载成功，必须选择不同的标识符或换用路径方式）</p></li><li><p>路径形式的文件模块</p><p>在分析文件模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二 次加载时更快。</p><p>（文件模块指明了确切的文件位置，在查找中会节约时间，加载速度慢于核心模块）</p></li><li><p>自定义模块</p><p>它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</p><p>在加载的过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。</p></li></ol><h5 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h5><ul><li><p>文件扩展名分析：</p><p>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，<strong>Node会按.js、.json、.node的次序补 足扩展名，依次尝试。</strong></p><p><strong>在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。</strong>因为Node是单线程的， 所以这里是一个会引起性能问题的地方。</p><p>（如果是.node和.json文件，在传递给require() 的标识符中带上扩展名，会加快一点速度。同步配合缓存，可以大幅度缓解Node 单线程中阻塞式调用的缺陷。）</p></li><li><p>目录分析和包</p><p>在分析标识符的过程中，require()通过分析文件扩展名之后，可能<strong>没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。</strong></p><ul><li>Node在当前目录下 查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。</li><li>而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node。</li><li>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查 找。</li><li>如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。</li></ul></li></ul><h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象</p><p>定位到具体的文件后，Node会新建一个模块对 象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法有所不同</p><ul><li>.js文件。通过fs模块同步读取文件后编译执行。</li><li>.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。</li><li>.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</li><li>其余扩展名文件。它们都被当做.js文件载入。</li></ul><p>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二 次引入的性能。</p><p>在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。</p><h5 id="JavaScript模块的编译"><a href="#JavaScript模块的编译" class="headerlink" title="JavaScript模块的编译"></a>JavaScript模块的编译</h5><p>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。</p><ul><li><p>在头部添加 了(function (exports, require, module, __filename, __dirname) {\n，在尾部添加了\n});。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">  exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius; </span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>这样每个模块文件之间都进行了作用域隔离。</p></li><li><p>包装之后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的 function对象。</p></li><li><p>将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。</p></li></ul><p>exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。(<strong>如果要达到require引入一个类的效果，请赋值给module.exports对象。</strong>)</p><h5 id="C-C-模块的编译"><a href="#C-C-模块的编译" class="headerlink" title="C/C++模块的编译"></a>C/C++模块的编译</h5><p>Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows 和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。</p><p>它是编写C/C++模块之后编译生成的，所以这 里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返 回给调用者。</p><ul><li>优势：执行效率</li><li>劣势：编写门槛高</li></ul><h5 id="JSON文件的编译"><a href="#JSON文件的编译" class="headerlink" title="JSON文件的编译"></a>JSON文件的编译</h5><p>Node利用fs模块同步读取JSON文件的内容之 后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p><p>（定义了一个JSON文件作为配置，那就 不必调用fs模块去异步读取和解析，直接调用require()引入即可）</p><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块C/C++文件存放在Node项目的src目录下， JavaScript文件存放在lib目录下。</p><h4 id="JavaScript-核心模块的编译过程"><a href="#JavaScript-核心模块的编译过程" class="headerlink" title="JavaScript 核心模块的编译过程"></a>JavaScript 核心模块的编译过程</h4><h5 id="转存为C-C-代码"><a href="#转存为C-C-代码" class="headerlink" title="转存为C/C++代码"></a>转存为C/C++代码</h5><p>Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码(src/node.js和lib/*.js)转换 成C++里的数组，生成node_natives.h头文件</p><p>JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。</p><p>在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经 历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。</p><h5 id="编译JavaScript核心模块"><a href="#编译JavaScript核心模块" class="headerlink" title="编译JavaScript核心模块"></a>编译JavaScript核心模块</h5><p>lib目录下的所有模块文件也没有定义require、module、exports这些变量。在引入JavaScript 核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块有区别的地方在于:<strong>获取源代码的方式(核心模块是从内存中加载的)以及缓存执行结果的位置。</strong></p><p>源文件通过process.binding(‘natives’)取出， 编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上</p><h4 id="C-C-核心模块的编译过程"><a href="#C-C-核心模块的编译过程" class="headerlink" title="C/C++核心模块的编译过程"></a>C/C++核心模块的编译过程</h4><p>C++模块主内完成核心，JavaScript 主外实现封装的模式是Node能够提高性能的常见方式。</p><p>由纯C/C++编写的部分统一称为<strong>内建模块</strong>，因为它们通常不被用户直接调 用。</p><h5 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h5><p>Node提供了get_builtin_module()方法从node_module_list 数组中取出这些模块</p><h6 id="内建模块的优势在于："><a href="#内建模块的优势在于：" class="headerlink" title="内建模块的优势在于："></a>内建模块的优势在于：</h6><ul><li>它们本身由C/C++编写，性能上优于脚本语言</li><li>在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再 次做标识符定位、文件定位、编译等过程，直接就可执行。</li></ul><p>在Node的所有模块类型中，存在着如图2-4所示的一种依赖层级关系，即文件模块可能会依 赖核心模块，核心模块可能会依赖内建模块。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rvjz8pitj30gc0gsmxx.jpg" alt="image-20191210195732891"></p><h6 id="加载内建模块："><a href="#加载内建模块：" class="headerlink" title="加载内建模块："></a>加载内建模块：</h6><ul><li>在加载内建模块时，先创建一个exports空对象</li><li>然后调用get_builtin_module()方法取 出内建模块对象，通过执行register_func()填充exports对象</li><li>最后将exports对象按模块名缓存，并返回给调用方完成导出。</li></ul><h4 id="核心模块的引入流程"><a href="#核心模块的引入流程" class="headerlink" title="核心模块的引入流程"></a>核心模块的引入流程</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rvzu27c2j30m40qa75t.jpg" alt="image-20191210201250065"></p><h4 id="编写核心模块"><a href="#编写核心模块" class="headerlink" title="编写核心模块"></a>编写核心模块</h4><ul><li>编写头文件</li><li>编写C/C++文件</li></ul><h3 id="C-C-扩展模块"><a href="#C-C-扩展模块" class="headerlink" title="C/C++扩展模块"></a>C/C++扩展模块</h3><p>C/C++扩展模块属于文件模块中的一类。</p><p>为了实现跨平台，dlopen()方法在内部实现时区 分了平台，分别用的是加载.so和.dll的方式。（一个平台下的.node文件在另一个平台下是无法加载执行的，必须重新用各 自平台下的编译器编译为正确的.node文件。）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rwa1zemkj30p60wi0vf.jpg" alt="image-20191210202239589"></p><p>require()在引入.node文件的过程中：</p><ul><li>调用uv_dlopen()方法去打开动态链接库</li><li>调用uv_dlsym()方法找到动态链接库中通过NODE_MODULE宏定义的方法地址</li></ul><p>这 两个过程都是通过libuv库进行封装的:在*nix平台下实际上调用的是dlfcn.h头文件中定义的 dlopen()和dlsym()两个方法;在Windows平台则是通过LoadLibraryExW()和GetProcAddress()这两 个方法实现的，它们分别加载.so和.dll文件(实际为.node文件)。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rxappw9mj30pq0lkdhm.jpg" alt="image-20191210205752782"></p><h3 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sxcy1mw1j30qm0hy3zw.jpg" alt="image-20191211174120316"></p><ul><li>C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和 第三方JavaScript文件模块调用。</li><li>JavaScript核心模块主要扮演的职责有两类:<ul><li>一类是作为C/C++内建模块的封装层和桥接层， 供文件模块调用;</li><li>一类是纯粹的功能模块</li></ul></li><li>文件模块通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块。</li></ul><h3 id="包与NPM"><a href="#包与NPM" class="headerlink" title="包与NPM"></a>包与NPM</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sz0nu3v7j30uc0laq4c.jpg" alt="image-20191211184259742"></p><p>由包结构和包描述文件两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p><h4 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h4><p>包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。</p><p>完全符合CommonJS规范的包目录应该包含如下这些文件：</p><ul><li>package.json:包描述文件。</li><li>bin:用于存放可执行二进制文件的目录。 </li><li>lib:用于存放JavaScript代码的目录。</li><li>doc:用于存放文档的目录。</li><li>test:用于存放单元测试用例的代码。</li></ul><h4 id="包描述文件与NPM"><a href="#包描述文件与NPM" class="headerlink" title="包描述文件与NPM"></a>包描述文件与NPM</h4><p>包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于 包的根目录下，是包的重要组成部分。</p><h5 id="必需字段："><a href="#必需字段：" class="headerlink" title="必需字段："></a>必需字段：</h5><ul><li>name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。</li><li>description。包简介。</li><li>version。版本号。一个语义化的版本号，该版本号十分重要，常常用于一些版本控制的场合。</li><li>keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。</li><li>maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。NPM通过该属性进行权限认证。</li><li>contributors。贡献者列表。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。</li><li>bugs。一个可以反馈bug的网页地址或邮件地址。</li><li>licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。</li><li>repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。</li><li>dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。</li></ul><h5 id="可选字段："><a href="#可选字段：" class="headerlink" title="可选字段："></a>可选字段：</h5><ul><li>homepage。当前包的网站地址。</li><li>os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。</li><li>cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。</li><li>engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。</li><li>builtin。标志当前包是否是内建在底层系统的标准组件。 </li><li>directories。包目录说明。</li><li>implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。</li><li>scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。</li></ul><p><strong>在包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、 repositories、author、bin、main、scripts、engines、dependencies、devDependencies。</strong></p><ul><li>author。包作者。 </li><li>bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。</li><li>main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余 模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。</li><li>devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包。</li></ul><h3 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h3><h4 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h4><p>AMD规范是CommonJS模块规范的一个延伸</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure><p>它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> exports = &#123;&#125;; </span><br><span class="line">  exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello from module: '</span> + <span class="built_in">module</span>.id); &#125;;</span><br><span class="line">  <span class="keyword">return</span> exports; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不同之处在于AMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的， 它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局 命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现 导出。</p><h4 id="CMD-规范"><a href="#CMD-规范" class="headerlink" title="CMD 规范"></a>CMD 规范</h4><p>与AMD规范的主要区别在于定义模块和依赖引入的部分。</p><p>AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中。</p><p>在依赖部分，CMD支持动态引入。</p><h2 id="第三章-异步I-O"><a href="#第三章-异步I-O" class="headerlink" title="第三章 异步I/O"></a>第三章 异步I/O</h2><h3 id="为什么要异步I-O"><a href="#为什么要异步I-O" class="headerlink" title="为什么要异步I/O"></a>为什么要异步I/O</h3><h4 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h4><ul><li><p>前端通过异步可以消除掉UI阻塞的现象。但是前端获取资源的速度也取决于后端的响应速度。采用异步方式，第一个资源的获取并不会阻塞第二个资源。</p></li><li><p>随着网站或应用不断膨胀，数据将会分布到多台服务器上，分布式将会是常态。分布也意味着M与N的值（M/N分别为两个请求消耗的时间）会线性增长，这也会放大异步和同步在性能方面的差异。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ty7mwa38j317s0ce400.jpg" alt="image-20191212150038480"></p></li></ul><p>只有后端能够快速响应资源，才能让前端的体验变好。</p><h4 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h4><p>利用单线程，远离多线程死锁、状态同步等问题;利用异 步I/O，让单线程远离阻塞，以更好地使用CPU。</p><p>Node提供了类似前端浏览器中Web Workers的子 进程，该子进程可以通过工作进程高效地利用CPU和I/O</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2861hzfj30lu0lit9x.jpg" alt="image-20191212171933363"></p><h3 id="异步I-O实现现状"><a href="#异步I-O实现现状" class="headerlink" title="异步I/O实现现状"></a>异步I/O实现现状</h3><h4 id="异步I-O与非阻塞I-O"><a href="#异步I-O与非阻塞I-O" class="headerlink" title="异步I/O与非阻塞I/O"></a>异步I/O与非阻塞I/O</h4><p>异步/同步和阻塞/非阻塞实际上是两回事</p><p>操作系统内核对于I/O只有两种方式:阻塞与非阻塞。</p><h5 id="阻塞："><a href="#阻塞：" class="headerlink" title="阻塞："></a>阻塞：</h5><p>在调用阻塞I/O时，应用程序需要等待 I/O完成才返回结果</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2e5a4fnj30j80k6t9l.jpg" alt="image-20191212172518477"></p><ul><li><p>特点：调用之后一定要等到系统内核层面完成所有操作后，调用才结束。</p></li><li><p>阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用</p></li></ul><h5 id="非阻塞："><a href="#非阻塞：" class="headerlink" title="非阻塞："></a>非阻塞：</h5><p>非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2g0l7cmj30jm0kkq3q.jpg" alt="image-20191212172706537"></p><ul><li><p>非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的。</p></li><li><p>问题：由于完整的I/O并没有完成，立即返回的并不是业务层期望的 数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认 是否完成。这种重复调用判断操作是否完成的技术叫做轮询。</p></li><li><p>轮询技术：</p><ul><li><p>read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2jpnno5j30ku0l8gmy.jpg" alt="image-20191212173038848"></p></li><li><p>select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2klirw7j30k20l6wfu.jpg" alt="image-20191212173129915"></p><p>select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态， 所以它最多可以同时检查1024个文件描述符。</p></li><li><p>poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2ly78zij30j40km75l.jpg" alt="image-20191212173248351"></p></li><li><p>epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到 I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调 的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2na09ynj30jw0leta2.jpg" alt="image-20191212173403901"></p></li><li><p>kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。</p></li></ul></li></ul><h4 id="现实的异步I-O"><a href="#现实的异步I-O" class="headerlink" title="现实的异步I/O"></a>现实的异步I/O</h4><p>通过让部分线程进行阻塞I/O或者非阻塞I/O加 轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进 行传递，这就轻松实现了异步I/O</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2rft4wij30pq0iwgmo.jpg" alt="image-20191212173804605"></p><ul><li>ibeio 实质上依然是采用线程池与阻塞I/O模拟异步I/O</li><li>IOCP：调用异步方法，等待I/O完成之后的通知，执行回调，用户无须考虑轮询。但是它的 内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u339w1rrj30g80ekq3m.jpg" alt="image-20191212174138825"></p><p>Node是单线程的，这里的单线程仅仅只是 JavaScript执行在单线程中罢了。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的 另有线程池。</p><h3 id="Node-的异步-I-O"><a href="#Node-的异步-I-O" class="headerlink" title="Node 的异步 I/O"></a>Node 的异步 I/O</h3><p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p><p>Windows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事 件循环，以此完成异步I/O的过程。在Linux下通过epoll实现这个过程，FreeBSD下通过kqueue实 现，Solaris下通过Event ports实现。不同的是线程池在Windows下由内核(IOCP)直接提供，*nix 系列下由libuv自行实现。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p><strong>Node自身的执行模型——事件循环</strong></p><p>每执行一次循环体的过程我 们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调 函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2zihuruj30km0o6dhb.jpg" alt="image-20191212174548717"></p><h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问 是否有要处理的事件。</p><ul><li>观察者将事件进行分类。在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的 观察者有文件I/O观察者、网络I/O观察者等。</li><li>在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。</li></ul><h4 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h4><p>从JavaScript发起调用到内核执行完I/O操作的 过渡过程中，存在一种中间产物，它叫做请求对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.open = <span class="function"><span class="keyword">function</span>(<span class="params">path, flags, mode, callback</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  binding.open(pathModule._makeLong(path), stringToFlags(flags),mode,callback); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u38jib15j30ss0q40uj.jpg" alt="image-20191212175431157"></p><ul><li><p>从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用</p></li><li><p>这里libuv作为封装层，有两个平台的实现，实质上是调 用了uv_fs_open()方法。在uv_fs_open()的调用过程中，我们创建了一个FSReqWrap请求对象</p></li><li><p>回调函数则 被设置在这个对象的oncomplete_sym属性上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;<span class="built_in">Set</span>(oncomplete_sym, callback);</span><br></pre></td></tr></table></figure></li><li><p>对象包装完毕后，在Windows下，则调用QueueUserWorkItem()方法将这个FSReqWrap对象推入线程池中等待执行</p><ul><li>QueueUserWorkItem()方法接受3个参数:第一个参数是将要执行的方法的引用，这里引用的是uv_fs_thread_proc，第二个参数是uv_fs_thread_proc方法运行时所需要的参数;第三个参数是 执行的标志。</li></ul></li><li><p>当线程池中有可用线程时，我们会调用uv_fs_thread_proc()方法。uv_fs_thread_ proc()方法会根据传入参数的类型调用相应的底层函数</p></li><li><p>至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。</p></li></ul><p>JavaScript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它 是否阻塞I/O，都不会影响到JavaScript线程的后续执行，如此就达到了异步的目的。</p><p><strong>请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中</strong>，包括送入线程池等待执行以及I/O操作完毕后的回调处理</p><h4 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h4><ul><li>线程池中的I/O操作调用完毕之后，会将获取的结果储存在req-&gt;result属性上，然后调用 PostQueuedCompletionStatus()通知IOCP，告知当前对象操作已经完成</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostQueuedCompletionStatus((loop)-&gt;iocp, <span class="number">0</span>, <span class="number">0</span>, &amp;((req)-&gt;overlapped))</span><br></pre></td></tr></table></figure><ul><li><p>PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还线程池。通过PostQueuedCompletionStatus()方法提交的状态，可以通过GetQueuedCompletionStatus()提取。</p></li><li><p>在每次Tick的执行中，它会调用 IOCP相关的GetQueuedCompletionStatus()方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。</p></li><li><p>I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u5u87afbj30uu0u0q6o.jpg" alt="image-20191212192431768"></p></li></ul><h3 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h3><p>I/O无关的异步API:setTimeout()、setInterval()、 setImmediate()和process.nextTick()</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>setTimeout()和setInterval()</p><p>它们的实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。</p><p>调用setTimeout()或者 setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会 从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的 回调函数将立即执行。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u6f2b0goj30u60nu76w.jpg" alt="image-20191212194435097"></p><h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// on the way out, don't bother.</span></span><br><span class="line">  <span class="comment">// it won't get fired anyway</span></span><br><span class="line">  <span class="keyword">if</span> (process._exiting) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tickDepth &gt;= process.maxTickDepth) </span><br><span class="line">    maxTickWarn();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> tock = &#123; <span class="attr">callback</span>: callback &#125;;</span><br><span class="line">  <span class="keyword">if</span> (process.domain) tock.domain = process.domain;</span><br><span class="line">  nextTickQueue.push(tock);</span><br><span class="line">  <span class="keyword">if</span> (nextTickQueue.length) &#123;</span><br><span class="line">    process._needTickCallback(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。 定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。</p><h4 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行'</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure><p>其执行结果如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正常执行 </span><br><span class="line">nextTick延迟执行 </span><br><span class="line">setImmediate延迟执行</span><br></pre></td></tr></table></figure><ul><li><p>process.nextTick()中的回调函数执行的优先级要高于setImmediate()。</p></li><li><p>原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者， setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。</p></li><li><p>process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果 则是保存在链表中</p></li><li><p>在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。</p></li><li><p>之所以这样设计，是为了保证每轮循环能够较快地执行结束，防止CPU占用过多而阻塞后续I/O 调用的情况。</p></li></ul><h3 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h3><p>事件驱动的实质：</p><p>通过主循环加事件触发的方式来运行程序。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u77vrg44j30vo0nm77g.jpg" alt="image-20191212201217702"></p><h4 id="几种经典的服务器模型，对比优缺点"><a href="#几种经典的服务器模型，对比优缺点" class="headerlink" title="几种经典的服务器模型，对比优缺点"></a>几种经典的服务器模型，对比优缺点</h4><ul><li>同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。 </li><li>每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。</li><li>每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。</li></ul><h4 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h4><p>Node通过事件驱动的方式处理请求，无须为 每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任 务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的一个原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Node-js学习笔记（一）&quot;&gt;&lt;a href=&quot;#深入浅出Node-js学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Node.js学习笔记（一）&quot;&gt;&lt;/a&gt;深入浅出Node.js学习笔记（一）&lt;/h1&gt;&lt;p&gt;高并发、高性
      
    
    </summary>
    
      <category term="Node.js" scheme="http://yoursite.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>scrollWidth,clientWidth,offsetWidth的区别</title>
    <link href="http://yoursite.com/2019/12/07/scrollWidth,clientWidth,offsetWidth%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/12/07/scrollWidth,clientWidth,offsetWidth的区别/</id>
    <published>2019-12-07T14:01:34.000Z</published>
    <updated>2019-12-29T07:11:43.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scrollWidth-clientWidth-offsetWidth的区别"><a href="#scrollWidth-clientWidth-offsetWidth的区别" class="headerlink" title="scrollWidth,clientWidth,offsetWidth的区别"></a>scrollWidth,clientWidth,offsetWidth的区别</h1><h2 id="总体说明"><a href="#总体说明" class="headerlink" title="总体说明"></a>总体说明</h2><h3 id="元素对象："><a href="#元素对象：" class="headerlink" title="元素对象："></a>元素对象：</h3><ul><li>offsetLeft、offsetTop属性：获取元素相对于文档左上角的坐标位置。</li></ul><ul><li><p>scrollWidth：对象的<strong>实际内容</strong>的宽度，不包括边线宽度，会随对象中内容超过可视区后而变大。</p><p>scrollWidth=元素的width+padding</p></li><li><p>clientWidth：对象内容的<strong>可视区的宽度</strong>，不包括滚动条等边线，会随对象显示大小的变化而改变。</p><p>clientWidth=元素的width+padding</p></li><li><p>offsetWidth：对象<strong>整体的实际宽度</strong>，包括滚动条等边线，会随对象显示大小的变化而改变。</p><p>offsetWidth=元素的width+padding+border</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aq0kktmyj30gx0gqtam.jpg" alt="img"></p><p>###window对象：</p><ul><li><p>innerWidth：窗口中文档显示区域的宽度，不包括菜单栏、工具栏等部分。该属性可读可写。浏览器窗口的内部宽度（对于IE9+、Chrome、Firefox、Opera 以及 Safari）</p></li><li><p>pageXOffset：整数只读属性，表示文档向右滚动过的像素数。IE不支持该属性，使用body元素的scrollLeft属性替代。</p></li><li></li></ul><p>##情况一</p><p>元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下。</p><ul><li>scrollWidth=clientWidth，两者皆为内容可视区的宽度。</li><li>offsetWidth为元素的实际宽度。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aoj7ezc9j30eo07hjs6.jpg" alt="img"></p><p>##情况二</p><p>元素的内容超过可视区，滚动条出现和可用的情况下。</p><ul><li>scrollWidth&gt;clientWidth。</li><li>scrollWidth为实际内容的宽度。</li><li>clientWidth是内容可视区的宽度。</li><li>offsetWidth是元素的实际宽度。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aokjodirj30h40a1q41.jpg" alt="img"></p><h2 id="针对文档-document-的各个height、width、top、left的说明"><a href="#针对文档-document-的各个height、width、top、left的说明" class="headerlink" title="针对文档(document)的各个height、width、top、left的说明"></a>针对文档(document)的各个height、width、top、left的说明</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7apu7784cj30dw0fa0tw.jpg" alt="img"></p><h2 id="针对网页中一个div的各个属性值的说明"><a href="#针对网页中一个div的各个属性值的说明" class="headerlink" title="针对网页中一个div的各个属性值的说明"></a>针对网页中一个div的各个属性值的说明</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7apvi51ygj30jg0ga400.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;scrollWidth-clientWidth-offsetWidth的区别&quot;&gt;&lt;a href=&quot;#scrollWidth-clientWidth-offsetWidth的区别&quot; class=&quot;headerlink&quot; title=&quot;scrollWidth,clie
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>循环中的异步操作问题小结</title>
    <link href="http://yoursite.com/2019/11/26/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%20copy/"/>
    <id>http://yoursite.com/2019/11/26/JS事件机制 copy/</id>
    <published>2019-11-26T05:29:24.000Z</published>
    <updated>2019-11-26T05:36:52.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环中的异步操作问题小结"><a href="#循环中的异步操作问题小结" class="headerlink" title="循环中的异步操作问题小结"></a>循环中的异步操作问题小结</h1><p>循环的异步操作主要有两个问题：</p><ul><li>如何确保循环的所有异步操作完成之后执行某个其他操作</li><li>循环中的下一步操作依赖于前一步的操作，如何解决</li></ul><h2 id="不需等待结果"><a href="#不需等待结果" class="headerlink" title="不需等待结果"></a>不需等待结果</h2><p>要处理这个问题，我们可以把这个匿名函数定义为异步的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> (item)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> delayedLog(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的话 forEach 方法就相当于异步的了，不会等待遍历完所有的 item 将会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Done!</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>如果你不需要等待这个循环完成，这样就已经可以了。但是大部分情况我们还是需要等待这个循环完成才进行之后的操作。</p><h2 id="如何确保循环的所有异步操作完成之后执行某个其他操作"><a href="#如何确保循环的所有异步操作完成之后执行某个其他操作" class="headerlink" title="如何确保循环的所有异步操作完成之后执行某个其他操作"></a>如何确保循环的所有异步操作完成之后执行某个其他操作</h2><h3 id="方法一：设置一个flag，在每个异步操作中对flag进行检测"><a href="#方法一：设置一个flag，在每个异步操作中对flag进行检测" class="headerlink" title="方法一：设置一个flag，在每个异步操作中对flag进行检测"></a>方法一：设置一个flag，在每个异步操作中对flag进行检测</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  flag++;</span><br><span class="line">  Database.save_method().exec().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(flag === len) &#123;</span><br><span class="line">            <span class="comment">// your code</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：将所有的循环放在一个promise中，使用then处理"><a href="#方法二：将所有的循环放在一个promise中，使用then处理" class="headerlink" title="方法二：将所有的循环放在一个promise中，使用then处理"></a>方法二：将所有的循环放在一个promise中，使用then处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">      resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           Database.save_method().exec()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法三：串行遍历"><a href="#方法三：串行遍历" class="headerlink" title="方法三：串行遍历"></a>方法三：串行遍历</h3><p>要等待所有的结果返回，我们还是要回到老式的 for 循环写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> array)&#123;</span><br><span class="line">    <span class="keyword">await</span> delayedLog(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果符合我们的预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure><h3 id="方法四：并行遍历"><a href="#方法四：并行遍历" class="headerlink" title="方法四：并行遍历"></a>方法四：并行遍历</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c606vfgvj30tg081mxe.jpg" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//map array to promise</span></span><br><span class="line">  <span class="keyword">const</span> promises=array.map(delayedLog)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（注意：对于特别大的数组不建议使用这种写法，太多的并行任务会加重 CPU 和内存的负荷）</p><h2 id="循环中的下一步操作依赖于前一步的操作，如何解决"><a href="#循环中的下一步操作依赖于前一步的操作，如何解决" class="headerlink" title="循环中的下一步操作依赖于前一步的操作，如何解决"></a>循环中的下一步操作依赖于前一步的操作，如何解决</h2><h3 id="方法一：使用递归，在异步操作完成之后调用下一次异步操作"><a href="#方法一：使用递归，在异步操作完成之后调用下一次异步操作" class="headerlink" title="方法一：使用递归，在异步操作完成之后调用下一次异步操作"></a>方法一：使用递归，在异步操作完成之后调用下一次异步操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  Database.save_method().exec().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      loop(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：使用async和await（串行遍历）"><a href="#方法二：使用async和await（串行遍历）" class="headerlink" title="方法二：使用async和await（串行遍历）"></a>方法二：使用async和await（串行遍历）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">         <span class="keyword">await</span> Database.save_method().exec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何优雅地写js异步循环"><a href="#如何优雅地写js异步循环" class="headerlink" title="如何优雅地写js异步循环"></a>如何优雅地写js异步循环</h1><h2 id="循环的方式"><a href="#循环的方式" class="headerlink" title="循环的方式"></a>循环的方式</h2><p>假设我们有个数组，包含 5 个数字：<code>let times = [100, 150, 200, 250, 300]</code>；<br>还有一个异步的睡觉方法：<code>sleep(time, cb)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有 cb 时，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time, cb</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        setTimeout(cb, time);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, time);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在要去循环睡这几个数字，问你有哪些睡法？🤔</p><p>为了方便交流，我就给这几个睡法起个名字：</p><ol><li>All in：你如果赶时间又不担心消耗过度，你可以一次性都睡了；</li><li>One by one：你想细水长流，你可以一个一个睡；</li><li>With concurrency：你害羞地低下头，说一次能不能睡两个。</li></ol><blockquote><p>作为一段有节操的代码，肯定要告诉其他人你睡完了，也就是必须有全部完成的回调，否则我们接下来的交流会毫无意义。</p></blockquote><p>本文目的是和大家探讨如何写出优雅的异步循环代码，并不是去实现这些循环控制的逻辑；而保持代码优雅，个人以为最好的办法是使用较新的语言特性，其次是使用优秀的开源项目，最后才是自己撸。下面会使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcaolan%2Fasync" target="_blank" rel="noopener">Async</a>、<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fpetkaantonov%2Fbluebird" target="_blank" rel="noopener">Promise(bluebird)</a> 和 ES7 中的 <code>async/await</code> 对比下实现这几种循环的区别。</p><h3 id="All-in"><a href="#All-in" class="headerlink" title="All in"></a>All in</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c606vfgvj30tg081mxe.jpg" alt="All in"></p><p>这种方式效率是最高的，耗时取决于循环中最慢的那个异步方法。对资源的消耗也是最大的，如果大量循环请求后端服务，很有可能造成瞬时拥堵的情况。</p><p>如果自己实现，这也是最简单的场景，加一个完成计数器，每个异步方法完就给这个完成计数器加 1，然后检查完成数是不是等于数组长度，一旦相等就表示所有的异步方法执行完毕，通知全部完成的回调。</p><h4 id="使用-async-each："><a href="#使用-async-each：" class="headerlink" title="使用 async.each："></a>使用 async.each：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; each &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async all in'</span>);  </span><br><span class="line">each(times, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async all in: 304.627ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-all："><a href="#使用-Promise-all：" class="headerlink" title="使用 Promise.all："></a>使用 Promise.all：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise all in'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.all(times.map(<span class="function"><span class="params">time</span> =&gt;</span> sleep(time))).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise all in: 305.509ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await："><a href="#使用ES7-async-await：" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 all in'</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> times.map(<span class="function"><span class="params">time</span> =&gt;</span> sleep(time))) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 all in: 305.986ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h3 id="One-by-one"><a href="#One-by-one" class="headerlink" title="One by one"></a>One by one</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c65nlncwj30tg04374g.jpg" alt="One by one"></p><p>这种方式效率最低，有点类似于同步语言中的循环，一个接着一个执行，耗时自然也就是所有异步方法耗时的总和。对资源的消耗最小。</p><p>这个实现起来也比较简单，把数组看做一个队列，每次从队列<code>shift</code>出一个代入异步方法执行，执行完成就开始递归调用这个过程，当队列长度为空就表示所有的异步方法执行完毕，结束递归，通知全部完成的回调。</p><h4 id="使用-async-eachSeries："><a href="#使用-async-eachSeries：" class="headerlink" title="使用 async.eachSeries："></a>使用 async.eachSeries：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eachSeries &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async one by one'</span>);  </span><br><span class="line">eachSeries(times, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async one by one: 1020.078ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-reduce："><a href="#使用-Promise-reduce：" class="headerlink" title="使用 Promise.reduce："></a>使用 Promise.reduce：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise one by one'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.reduce(times, (last, curr) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">return</span> sleep(curr);</span><br><span class="line">&#125;, <span class="number">0</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise one by one: 1023.014ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await：-1"><a href="#使用ES7-async-await：-1" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 one by one'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> time <span class="keyword">of</span> times) &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 one by one: 1025.513ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h3 id="With-concurrency"><a href="#With-concurrency" class="headerlink" title="With concurrency"></a>With concurrency</h3><p>这种方式稍微复杂些，但也是最灵活的方式，可以随心控制并发数。效率和耗时取决于魔法数字 <code>concurrency</code>，当 <code>concurrency</code> 大于或等于数组长度时，它就等同于 <strong>All in</strong> 方式；当 <code>concurrency</code> 为 1 时，它就等同于 <strong>One by one</strong> 方式。所以耗时和对资源的消耗都会介于以上两种方式之间。</p><p><strong>With concurrency</strong> 本身在实现上也会有不同的方式，分别是预分组和任务池。</p><h4 id="预分组"><a href="#预分组" class="headerlink" title="预分组"></a>预分组</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c66v9wx3j30tg05074j.jpg" alt="Pre Group"></p><p>顾名思义，就是提前将数组内容按 <code>concurrency</code> 分好组，组内是以 <strong>All in</strong> 方式执行，组之间则是以 <strong>One by one</strong> 的方式执行。</p><p>就以上文的例子，假如 <code>concurrency</code> 为 2，<code>times</code> 预先分组成：<code>[[100, 150], [200, 250], [300]]</code>，这样耗时会是 700（150 + 250 + 300）。</p><p>这个实现方式可以有效地控制并发数，优点就是简单，缺点是并不能达到效率最大化。</p><h4 id="任务池"><a href="#任务池" class="headerlink" title="任务池"></a>任务池</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c67an02oj30tg066q38.jpg" alt="Task Pool"></p><p>任务池的方式就是设置一个容量为 <code>concurrency</code> 的池子，比如容量为 2，初始化放入两个任务，每当有任务完成，就继续往池子添加新的任务，直到所有任务都完成。上文的例子执行过程大致如下：</p><ol><li><code>time = 0; pool = [100, 150]</code>：放入 <code>100</code> 和 <code>150</code></li><li><code>time = 100; pool = [150, 200]</code>：<code>100</code> 结束，放入 <code>200</code></li><li><code>time = 150; pool = [200, 250]</code>：<code>150</code> 结束，放入 <code>250</code></li><li><code>time = 300; pool = [250, 300]</code>：<code>200</code> 结束，放入 <code>300</code></li><li><code>time = 400; pool = [300]</code>：<code>250</code> 结束，没有更多任务</li><li><code>time = 600; pool = []</code>：<code>300</code> 结束，循环完毕</li></ol><p>得出来的耗时是 600，比预分组的方式效率更高，而且同样能有效控制并发个数。async 和 bluebird 也有相关的方法供直接使用。</p><h4 id="使用-async-eachLimit："><a href="#使用-async-eachLimit：" class="headerlink" title="使用 async.eachLimit："></a>使用 async.eachLimit：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eachLimit &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async with concurrency'</span>);  </span><br><span class="line">eachLimit(times, <span class="number">2</span>, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async with concurrency'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async with concurrency: 611.498ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-map（bluebird-特有-api）："><a href="#使用-Promise-map（bluebird-特有-api）：" class="headerlink" title="使用 Promise.map（bluebird 特有 api）："></a>使用 Promise.map（bluebird 特有 api）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise one by one'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.map(times, (time) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">return</span> sleep(time);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    concurrency: <span class="number">2</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise with concurrency: 616.601ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await：-2"><a href="#使用ES7-async-await：-2" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><blockquote><p><code>pool</code> 方法来自<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdavetemplin%2Fasync-parallel%2Fblob%2Fmaster%2Findex.ts%23L153" target="_blank" rel="noopener">davetemplin/async-parallel</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 with concurrency'</span>);</span><br><span class="line">    <span class="keyword">await</span> pool(<span class="number">2</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(times.shift());</span><br><span class="line">        <span class="keyword">return</span> times.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 with concurrency'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pool</span>(<span class="params">size, task</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> active = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> errors = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (active &lt; size &amp;&amp; !done) &#123;</span><br><span class="line">                active += <span class="number">1</span>;</span><br><span class="line">                task()</span><br><span class="line">                    .then(<span class="function"><span class="params">more</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (--active === <span class="number">0</span> &amp;&amp; (done || !more))</span><br><span class="line">                            errors.length === <span class="number">0</span> ? resolve() : reject(errors);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (more)</span><br><span class="line">                            next();</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            done = <span class="literal">true</span>;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        errors.push(err);</span><br><span class="line">                        done = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (--active === <span class="number">0</span>)</span><br><span class="line">                            reject(errors);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 with concurrency: 612.197ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这应该可以给这三种循环方式打下分了：</p><table><thead><tr><th><strong>循环方式</strong></th><th>效率</th><th>消耗</th><th>灵活度</th><th>复杂度</th></tr></thead><tbody><tr><td><strong>All in</strong></td><td>高</td><td>高</td><td>低</td><td>低</td></tr><tr><td><strong>One by one</strong></td><td>低</td><td>低</td><td>低</td><td>低</td></tr><tr><td><strong>With concurrency</strong></td><td>中</td><td>中</td><td>高</td><td>高</td></tr></tbody></table><p>乍一看 <strong>With concurrency</strong> 是完胜，其实并没有。<strong>All in</strong> 和 <strong>One by one</strong> 虽然灵活度低，但是应用的场景还是非常广泛的。要求效率优先就使用 <strong>All in</strong>；如果有下一次循环依赖上一次循环结果的场景，就必须使用 <strong>One by One</strong>。</p><p>再说下上面 async、bluebird、ES7 对这三种循环方式的实现。需求一直在变，async 需要修改的代码非常少，甚至只要改下方法名就可以，方法定义简单优雅，这可能也是 async 易上手的原因；bluebird 在 <code>Promise</code> 标准基础上添加的方法非常实用，如：map、join…，以至于我几乎是没有使用过原生 <code>Promise</code> 😂；ES7 新增的 <code>async/await</code> 语法特性确实减轻了编写异步代码的痛苦，同时还增强了代码的可读性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;循环中的异步操作问题小结&quot;&gt;&lt;a href=&quot;#循环中的异步操作问题小结&quot; class=&quot;headerlink&quot; title=&quot;循环中的异步操作问题小结&quot;&gt;&lt;/a&gt;循环中的异步操作问题小结&lt;/h1&gt;&lt;p&gt;循环的异步操作主要有两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>伪类和伪元素</title>
    <link href="http://yoursite.com/2019/11/16/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/11/16/伪类和伪元素/</id>
    <published>2019-11-16T11:40:32.000Z</published>
    <updated>2019-11-16T11:49:57.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p><code>css</code>引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分。</p><ul><li>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过<code>:hover</code>来描述这个元素的状态。虽然它和普通的<code>css</code>类相似，可以为已有的元素添加样式，但是它只有处于<code>dom</code>树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</li><li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过<code>:before</code>来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</li></ul><p>伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p><p>伪类和伪元素的根本区别在于：它们是否创造了<strong>新</strong>的元素,,   这个新创造的元素就叫  “伪无素” 。</p><p>##伪类</p><p>伪类前面是一个冒号，<code>E:first-child</code>会对现有的元素进行筛选</p><ul><li><p><code>:link</code>:选择未访问的链接</p></li><li><p><code>:visited</code>:选择已访问的链接</p></li><li><p><code>:hover</code>:选择鼠标指针浮动在其上的元素</p></li><li><p><code>:active</code>:选择活动的链接</p></li><li><p><code>:focus</code>:选择获取焦点的输入字段</p></li><li><p><code>:not()</code>:一个否定伪类，用于匹配不符合参数选择器的元素。</p></li><li><p><code>:first-child</code>:匹配元素的第一个子元素。</p></li><li><p><code>:last-child</code>:匹配元素的最后一个子元素。</p></li><li><p><code>:first-of-type</code>:匹配属于其父元素的首个特定类型的子元素的每个元素。</p></li><li><p><code>:last-of-type</code>:匹配属于其父元素的最后一个特定类型的子元素的每个元素。</p></li><li><p><code>:nth-child</code>:<code>:nth-child</code>根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素</p></li><li><p><code>:nth-last-child</code>:<code>:nth-last-child</code> 与<code>:nth-child</code>相似，不同之处在于它是从最后一个子元素开始计数的。</p></li><li><p><code>:nth-of-type</code>:<code>:nth-of-type</code> 与 <code>nth-child</code>相似，不同之处在于它是只匹配特定类型的元素。</p></li><li><p><code>:nth-last-type</code>:<code>:nth-last-of-type</code> 与 <code>nth-of-type</code>相似，不同之处在于它是从最后一个子元素开始计数的。</p></li><li><p><code>:only-child</code> :当元素是其父元素中唯一一个特定类型的子元素时，<code>:only-child</code>匹配该元素。</p></li><li><p><code>:target</code> :当URL带有锚名称，指向文档内某个具体的元素时，<code>:target</code>匹配该元素。</p></li><li><p><code>:checked</code>:<code>:checked</code>匹配被选中的 input 元素，这个 input 元素包括 radio 和 checkbox。</p></li><li><p><code>:default</code>: 匹配默认选中的元素</p></li><li><p><code>:disabled</code>: 匹配禁用的表单元素。</p></li><li><p><code>:empty</code> :匹配没有子元素的元素</p></li><li><p><code>:enabled</code>: 匹配没有设置 disabled 属性的表单元素。</p></li><li><p><code>:in-range</code>: 匹配在指定区域内元素。</p></li><li><p><code>:out-of-range</code>: 与<code>:in-range</code>相反，它匹配不在指定区域内的元素。</p></li><li><p><code>:indeterminate</code>:indeterminate 的英文意思是“ 不确定的”。当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。</p></li><li><p><code>:valid</code> :匹配条件验证正确的表单元素。</p></li><li><p><code>:invalid</code>: 与<code>:valid</code> 相反，匹配条件验证错误的表单元素。</p></li><li><p><code>:optional</code>:匹配是具有 optional 属性的表单元素。当表单元素没有设置为 required 时，即为 optional 属性。</p></li><li><p><code>:required</code>: 与<code>:optional</code>相反匹配设置了 required 属性的表单元素。</p></li><li><p><code>:read-only</code>: 匹配设置了只读属性的元素，表单元素可以通过设置“readonly” 属性来定义元素只读。</p></li><li><p><code>:read-write</code>: 匹配处于编辑状态的元素。input，textarea 和设置了 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。</p></li><li><p><code>:scope</code>: 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。</p></li><li><p><code>:dir</code>:匹配指定阅读方向的元素，当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持:dir 伪类，并在火狐浏览器中使用时需要添加前缀 ( -moz-dir() )。</p></li><li><p><code>:lang</code>:匹配设置了特定语言的元素，设置特定语言可以通过为了 HTML 元素设置 lang=”” 属性，设置 meta 元素的 charset=”” 属性，或者是在 http 头部上设置语言属性。</p><p>实际上，lang=”” 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。</p></li></ul><ul><li><code>:root</code>:匹配文档的根元素。一般的 html 文件的根元素是 html 元素，而 SVG 或 XML 文件的根元素则可能是其他元素。</li><li><code>:fullscreen</code>: 匹配处于全屏模式下的元素。全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79wl6d5ouj30gi0exq4h.jpg" alt="img"></p><p>##伪元素</p><p>伪元素前面是两个冒号，<code>E::first-line</code>会创造出不存在的新元素，由于css对单冒号的伪元素也支持，所以这样很容易让新学者混淆。但实际上现在css3已经明确规定了伪类单冒号，伪元素双冒号的规则。</p><ul><li><p><code>::before/:before</code>在被选元素前插入内容。需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</p></li><li><p><code>::after/:after</code> 在被元素后插入内容，其用法和特性与<code>:before</code>相似。</p><p>对于伪元素 <code>:before</code> 和 <code>:after</code> 而言，属性 <code>content</code> 是必须设置的，我们知道属性的值可以为字符串，也可以有其它形式，比如指向一张图片的 <code>URL:</code></p><p><code>content: url(&#39;img/icon.png&#39;)</code></p></li><li><p><code>::first-letter/:first-letter</code> 匹配元素中文本的首字母。被修饰的首字母不在文档树中</p></li><li><p><code>::first-line/:first-line</code> 匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。</p></li><li><p><code>::selection</code> 匹配用户被用户选中或者处于高亮状态的部分。在火狐浏览器使用时需要添加<code>-moz</code>前缀。该伪元素只支持双冒号的形式。</p></li><li><p><code>::placeholder</code> 匹配占位符的文本，只有元素设置了<code>placeholder</code>属性时，该伪元素才能生效。</p><p>伪元素不是<code>CSS</code>的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（<code>IE10</code>和<code>Firefox18</code>及其以下版本）会使用单冒号的形式。</p></li></ul><ul><li><code>::backdrop</code> 用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式</li></ul><p>注意：</p><ul><li>配合伪类使用<ul><li>伪元素 <code>:before</code> 还可以配合伪类使用，这里举经常与 <code>:before</code> 配合使用的伪类 <code>:hover</code> 为例：</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.before</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:before</span>&#123;<span class="attribute">content</span>:<span class="string">'you before'</span>; <span class="attribute">color</span>:red;&#125;</span><br><span class="line">&lt;div class="before"&gt; me&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>配合取值函数 <code>attr()</code> 使用</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">::before</span>&#123;<span class="attribute">content</span>: <span class="built_in">attr</span>(title)&#125;</span><br><span class="line">&lt;a href="https://blog.ihoey.com" title="梦魇小栈"&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line">&lt;a href="https://blog.ihoey.com" title="梦魇小栈"&gt;梦魇小栈&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79wlwrg6aj30dn05w3yy.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;伪类和伪元素&quot;&gt;&lt;a href=&quot;#伪类和伪元素&quot; class=&quot;headerlink&quot; title=&quot;伪类和伪元素&quot;&gt;&lt;/a&gt;伪类和伪元素&lt;/h1&gt;&lt;p&gt;&lt;code&gt;css&lt;/code&gt;引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="伪元素" scheme="http://yoursite.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
      <category term="伪类" scheme="http://yoursite.com/tags/%E4%BC%AA%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>sass&amp;less对比</title>
    <link href="http://yoursite.com/2019/11/11/sass&amp;less%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2019/11/11/sass&amp;less对比/</id>
    <published>2019-11-11T06:09:00.000Z</published>
    <updated>2019-11-10T15:36:08.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sass-amp-less"><a href="#sass-amp-less" class="headerlink" title="sass&amp;less"></a>sass&amp;less</h1><p>##为什么要使用 CSS 预处理器？</p><p>作为前端开发人员，大家都知道，Js 中可以自定义变量，而 CSS 仅仅是一个标记语言，不是编程语言，因此不可以自定义变量，不可以引用等等。</p><p><strong>CSS 有具体以下几个缺点：</strong></p><p>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</p><p>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</p><p>这就导致了我们在工作中无端增加了许多工作量。而使用 CSS 预处理器，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了我们的开发效率。</p><p>但是，CSS 预处理器也不是万金油，CSS 的好处在于简便、随时随地被使用和调试。预编译 CSS 步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。</p><p>所以我们在实际项目中衡量预编译方案时，还是得想想，比起带来的额外维护开销，CSS 预处理器有没有解决更大的麻烦。</p><h2 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h2><p>首先 sass 和 less 都是 css 的预编译处理语言，他们引入了 mixins，参数，嵌套规则，运算，颜色，名字空间，作用域，JavaScript 赋值等 加快了 css 开发效率,当然这两者都可以配合 gulp 和 grunt 等前端构建工具使用</p><p>sass 和 less<strong>主要区别:在于实现方式 less 是基于 JavaScript 的在客户端处理 所以安装的时候用 npm，sass 是基于 ruby 所以在服务器处理。</strong></p><h2 id="SASS-介绍"><a href="#SASS-介绍" class="headerlink" title="SASS 介绍"></a>SASS 介绍</h2><p>Sass 是 Ruby 开发者为前端开发提供的处理 CSS 的工具。它为 CSS 提供更动态的设定方式，允许编译、变量、函数……总之，使 CSS 更动态，也更像一门真正的可编程语言。</p><ol><li>Sass 是基于 Ruby 开发的，所以开发环境首先需要安装 Ruby。</li><li>浏览器中无法编译 Sass，所以要先编译好 css 文件，再交给浏览器。Sass<strong>不能</strong>在浏览器环境中直接运行。</li></ol><p>##Less 介绍</p><p>Less 是晚些产生的语言，基于 JS 进行开发，在 Node 中进行编译。所以使用时不需要安装其他语言，不过要记得<strong>先导入 less 文件，然后导入 less.js</strong>。提供 CDN 地址在这里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/less.js/3.0.4/less.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/less.js/3.0.4/less.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然 Less 也提供服务器端的编译功能。</p><h2 id="Stylus-介绍"><a href="#Stylus-介绍" class="headerlink" title="Stylus 介绍"></a>Stylus 介绍</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2F" target="_blank" rel="noopener">Stylus</a>相对前两者较新，可以看官方文档介绍的功能。</p><p>1.来自 NodeJS 社区，所以和 NodeJS 走得很近，与 JavaScript 联系非常紧密。还有专门 JavaScript API：<a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2Fdocs%2Fjs.html" target="_blank" rel="noopener">learnboost.github.io/stylus/docs…</a></p><p>2.支持 Ruby 之类等等框架</p><p>3.更多更强大的支持和功能</p><p>以 stylus 的角度来说,stylus 更加注重对 javascript( <a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2Fdocs%2Fjs.html" target="_blank" rel="noopener">learnboost.github.io/stylus/docs…</a> ) 的利用。 当用户觉得写 stylus 函数遇到了过于复杂或者无法测试，stylus 语法不支持等需求时， 也可以直接用 js 来实现这个函数并且在 stylus 中调用。</p><p>其次从编译器源码上来看：stylus 应该比 less.js 更有条理， 感觉如果未来社区添加功能的话，stylus 的源码添加起功能来会更简单，同样，目前 stylus 的功能也更复杂。</p><p>stylus 和 sass 另一个区别在于 sass 本身会建议，以下划线(_) 打头的文件在静态资源打包的时候不会被编译成 .css 文件【只是作为一种 import 存在】。而 stylus 没有这方面的规范。</p><p>同时写过 stylus 和 sass， 就语法简洁来看， stylus 在这方面占了很大的便宜。</p><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a><a href="https://cloud.tencent.com/developer/article/1092653" target="_blank" rel="noopener">三者对比</a></h2><ul><li><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3></li></ul><p>Sass: $var<br>Less: @var<br>两种语言都会有作用域的问题。一个变量只能在它被定义的代码块中使用。重复定义的变量会报错。</p><p>Stylus 对变量名没有任何限定，你可以是 $ 开始，也可以是任意的字符，而且与变量值之间可以用冒号、空格隔开，需要注意的是 Stylus (0.22.4) 将会编译 @ 开始的变量，但其对应的值并不会赋予该变量，换句话说，在 Stylus 的变量名不要用 @ 开头。</p><ul><li><h3 id="运算赋值："><a href="#运算赋值：" class="headerlink" title="运算赋值："></a>运算赋值：</h3></li></ul><p>只要保持单位统一或可相互转换，就可以进行运算，包括颜色在内：<br>Sass:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: e + -resize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="comment">// p &#123;</span></span><br><span class="line"><span class="comment">//   cursor: e-resize;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: (<span class="number">14px</span>/<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span> + <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="variable">$var</span> * <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Less:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base:</span> <span class="number">5%</span>;</span><br><span class="line"><span class="variable">@filler:</span> <span class="variable">@base</span> * <span class="number">2</span>;</span><br><span class="line"><span class="variable">@other:</span> <span class="variable">@base</span> + <span class="variable">@filler</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#888</span> / <span class="number">4</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@base-color</span> + <span class="number">#111</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span> / <span class="number">2</span> + <span class="variable">@filler</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">@var:</span> <span class="number">1px</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">width</span>: (<span class="variable">@var</span> + <span class="number">5</span>) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: (<span class="variable">@width</span> * <span class="number">2</span>) solid black;</span><br></pre></td></tr></table></figure><ul><li><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3></li></ul><p>Sass 和 Less 均允许元素嵌套。如果父子选择器均用逗号分开，那么编译时会按结合律拆开编译。<br>Sass 和 Less 指代上层元素均使用<code>&amp;</code>符号。</p><ul><li><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></li></ul><p>Sass 中，写好的选择器进行集成，需要<code>@extend</code>关键字。（sytlus 与 sass 相同）<br>Less 中，直接写入即可：<code>.be-extend-class;</code></p><ul><li><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3></li></ul><p>Sass 中，需要进行 Mixin 操作的选择器需要<code>@mixin</code>关键字，选择器后可以传入变量和默认值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> left(<span class="variable">$value</span>: 10px) padding: <span class="variable">$value</span>;</span><br></pre></td></tr></table></figure><p>使用时使用<code>@include</code>关键字，并可以更新变量：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">include</span> left @<span class="keyword">include</span> left(<span class="number">20px</span>);</span><br></pre></td></tr></table></figure><p>Less 中 Mixin 和继承感觉更相似，选择器在书写时就留好了变量，直接继承或更新变量即可：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.be-extend-class</span>(<span class="variable">@width</span>: <span class="number">10px</span>) &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">@width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="selector-class">.be-extend-class</span>;</span><br><span class="line"><span class="selector-class">.be-extend-class</span>(<span class="number">20px</span>);</span><br></pre></td></tr></table></figure><p>sass：在 sass 定义 Mixins 和 less、stylus 有所不同，在声明 Mixins 时需要使用“@mixin”,然后后面紧跟 Mixins 的名，他也可以定义参数，同时可以给这个参数设置一个默认值，但参数名是使用“$”符号开始，而且和参数值之间需要使用冒号（：）分开。另外在 sass 中调用 Mixins 需要使用“@include”，然后在其后紧跟你要调用的 Mixins 名。</p><p>less：less 中声明 Mixins 和 CSS 定义样式非常类似，可以将 Mixins 看成是一个选择器，当然 Mixins 也可以设置参数，并给参数设置默认值。不过设置参数的变量名是使用“@”开始，同样参数和默认参数值之间需要使用冒号（：）分开。</p><p>stylus：stylus 和前两者也略有不同，他可以不使用任何符号，就是直接定义 Mixins 名，然后在定义参数和默认值之间用等号（=）来连接。</p><ul><li><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3></li></ul><p>两种语言相同：多行注释格式可保留，单行注释格式会在编译时被删除。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 会被保留的注释格式 */</span></span><br><span class="line"><span class="comment">// 不保存的注释格式</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="颜色运算："><a href="#颜色运算：" class="headerlink" title="颜色运算："></a>颜色运算：</h3></li></ul><p>CSS 预处理器提供一系列<strong>颜色函数</strong>帮助生成主题系列颜色：<br>Sass：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lighten(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #d6d65c</span></span><br><span class="line">darken(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #a3a329</span></span><br><span class="line">grayscale(<span class="selector-id">#cc3</span>) <span class="comment">// #808080 灰度</span></span><br><span class="line">complement(<span class="selector-id">#cc3</span>) <span class="comment">// #33c</span></span><br></pre></td></tr></table></figure><p>Less：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lighten</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color which is 10% *lighter* than @color</span></span><br><span class="line"><span class="selector-tag">darken</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color which is 10% *darker* than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">saturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);    <span class="comment">// return a color 10% *more* saturated than @color</span></span><br><span class="line"><span class="selector-tag">desaturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);  <span class="comment">// return a color 10% *less* saturated than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">fadein</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color 10% *less* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fadeout</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color 10% *more* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fade</span>(<span class="variable">@color</span>, <span class="number">50%</span>);        <span class="comment">// return @color with 50% transparency</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, <span class="number">10</span>);         <span class="comment">// return a color with a 10 degree larger in hue than @color</span></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, -<span class="number">10</span>);        <span class="comment">// return a color with a 10 degree smaller hue than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mix</span>(<span class="variable">@color1</span>, <span class="variable">@color2</span>);    <span class="comment">// return a mix of @color1 and @color2</span></span><br></pre></td></tr></table></figure><p>stylus：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lighten(color, 10%); /* 返回的颜色在'color'基础上变亮10% */</span><br><span class="line">darken(color, 10%);  /* 返回的颜色在'color'基础上变暗10% */</span><br><span class="line">saturate(color, 10%);   /* 返回的颜色在'color'基础上饱和度增加10% */</span><br><span class="line">desaturate(color, 10%); /* 返回的颜色在'color'基础上饱和度降低10% */</span><br></pre></td></tr></table></figure><ul><li><h3 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a>插入文件</h3></li></ul><p>两种语言相同，使用@import 关键字引入。注意后缀名，可以直接导入 css 文件。后缀名为 css 的文件不会被预处理器处理。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"path/filename.scss"</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"lib.less"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"lib.css"</span>;</span><br></pre></td></tr></table></figure><ul><li><h3 id="高级语法："><a href="#高级语法：" class="headerlink" title="==高级语法：=="></a>==高级语法：==</h3></li></ul><h4 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h4><p>在 Sass 中，需要用 Sass 自己的一套语言编程：</p><ol><li>条件 if-else</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">if</span> lightness(<span class="variable">$color</span>) &gt; 30% &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>循环</li></ol><p>for:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 10 &#123;</span><br><span class="line">  <span class="selector-class">.border-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">border</span>: #&#123;<span class="variable">$i</span>&#125;px solid blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line">@<span class="keyword">while</span> <span class="variable">$i</span> &gt; 0 &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>each:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$member</span> in a, b, c, d &#123;</span><br><span class="line">  .#&#123;<span class="variable">$member</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">"/image/#&#123;$member&#125;.jpg"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义函数</li></ol><p>需要<code>@function</code>、<code>@return</code>关键字。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function double(<span class="variable">$n</span>) &#123;</span><br><span class="line">  @return <span class="variable">$n</span> * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: double(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><p>Less 是使用 JS 作为编译环境的，所以它支持 JS 语法。</p><ol><li>字符串插值</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base-url:</span> <span class="string">"http://assets.fnord.com"</span>;</span><br><span class="line"><span class="attribute">background-image</span>: url(<span class="string">"@&#123;base-url&#125;/images/bg.png"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>用反引号使用 JS 语法：</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> <span class="built_in">` "hello" .toUpperCase() + "!" `</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接访问 JS 环境</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@height:</span> <span class="built_in">`document.body.clientHeight`</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sass-amp-less&quot;&gt;&lt;a href=&quot;#sass-amp-less&quot; class=&quot;headerlink&quot; title=&quot;sass&amp;amp;less&quot;&gt;&lt;/a&gt;sass&amp;amp;less&lt;/h1&gt;&lt;p&gt;##为什么要使用 CSS 预处理器？&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="SASS" scheme="http://yoursite.com/tags/SASS/"/>
    
      <category term="LESS" scheme="http://yoursite.com/tags/LESS/"/>
    
  </entry>
  
  <entry>
    <title>oh-my-zsh git 命令缩写</title>
    <link href="http://yoursite.com/2019/11/05/oh-my-zsh%20git%20%E5%91%BD%E4%BB%A4%E7%BC%A9%E5%86%99/"/>
    <id>http://yoursite.com/2019/11/05/oh-my-zsh git 命令缩写/</id>
    <published>2019-11-05T13:08:23.000Z</published>
    <updated>2019-11-10T14:37:39.026Z</updated>
    
    <content type="html"><![CDATA[<p>#oh-my-zsh git 命令缩写</p><p>喜欢用 git 命令行，平时能少打几个字还是会节省不少时间的。</p><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alias ga=<span class="string">'git add'</span></span><br><span class="line">alias gb=<span class="string">'git branch'</span></span><br><span class="line">alias gba=<span class="string">'git branch -a'</span></span><br><span class="line">alias gbd=<span class="string">'git branch -d'</span></span><br><span class="line">alias gcam=<span class="string">'git commit -a -m'</span></span><br><span class="line">alias gcb=<span class="string">'git checkout -b'</span></span><br><span class="line">alias gco=<span class="string">'git checkout'</span></span><br><span class="line">alias gcp=<span class="string">'git cherry-pick'</span></span><br><span class="line">alias gd=<span class="string">'git diff'</span></span><br><span class="line">alias gfo=<span class="string">'git fetch origin'</span></span><br><span class="line">alias ggpush=<span class="string">'git push origin $(git_current_branch)'</span></span><br><span class="line">alias ggsup=<span class="string">'git branch --set-upstream-to=origin/$(git_current_branch)'</span></span><br><span class="line">alias glgp=<span class="string">'git log --stat -p'</span></span><br><span class="line">alias gm=<span class="string">'git merge'</span></span><br><span class="line">alias gp=<span class="string">'git push'</span></span><br><span class="line">alias gst=<span class="string">'git status'</span></span><br><span class="line">alias gsta=<span class="string">'git stash save'</span></span><br><span class="line">alias gstp=<span class="string">'git stash pop'</span></span><br></pre></td></tr></table></figure><h2 id="全部"><a href="#全部" class="headerlink" title="全部"></a>全部</h2><p>参考：<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">alias g=<span class="string">'git'</span></span><br><span class="line"></span><br><span class="line">alias ga=<span class="string">'git add'</span></span><br><span class="line">alias gaa=<span class="string">'git add --all'</span></span><br><span class="line">alias gapa=<span class="string">'git add --patch'</span></span><br><span class="line">alias gau=<span class="string">'git add --update'</span></span><br><span class="line"></span><br><span class="line">alias gb=<span class="string">'git branch'</span></span><br><span class="line">alias gba=<span class="string">'git branch -a'</span></span><br><span class="line">alias gbd=<span class="string">'git branch -d'</span></span><br><span class="line">alias gbda=<span class="string">'git branch --no-color --merged | command grep -vE "^(\*|\s*(master|develop|dev)\s*$)" | command xargs -n 1 git branch -d'</span></span><br><span class="line">alias gbl=<span class="string">'git blame -b -w'</span></span><br><span class="line">alias gbnm=<span class="string">'git branch --no-merged'</span></span><br><span class="line">alias gbr=<span class="string">'git branch --remote'</span></span><br><span class="line">alias gbs=<span class="string">'git bisect'</span></span><br><span class="line">alias gbsb=<span class="string">'git bisect bad'</span></span><br><span class="line">alias gbsg=<span class="string">'git bisect good'</span></span><br><span class="line">alias gbsr=<span class="string">'git bisect reset'</span></span><br><span class="line">alias gbss=<span class="string">'git bisect start'</span></span><br><span class="line"></span><br><span class="line">alias gc=<span class="string">'git commit -v'</span></span><br><span class="line">alias gc!=<span class="string">'git commit -v --amend'</span></span><br><span class="line">alias gcn!=<span class="string">'git commit -v --no-edit --amend'</span></span><br><span class="line">alias gca=<span class="string">'git commit -v -a'</span></span><br><span class="line">alias gca!=<span class="string">'git commit -v -a --amend'</span></span><br><span class="line">alias gcan!=<span class="string">'git commit -v -a --no-edit --amend'</span></span><br><span class="line">alias gcans!=<span class="string">'git commit -v -a -s --no-edit --amend'</span></span><br><span class="line">alias gcam=<span class="string">'git commit -a -m'</span></span><br><span class="line">alias gcsm=<span class="string">'git commit -s -m'</span></span><br><span class="line">alias gcb=<span class="string">'git checkout -b'</span></span><br><span class="line">alias gcf=<span class="string">'git config --list'</span></span><br><span class="line">alias gcl=<span class="string">'git clone --recursive'</span></span><br><span class="line">alias gclean=<span class="string">'git clean -fd'</span></span><br><span class="line">alias gpristine=<span class="string">'git reset --hard &amp;&amp; git clean -dfx'</span></span><br><span class="line">alias gcm=<span class="string">'git checkout master'</span></span><br><span class="line">alias gcd=<span class="string">'git checkout develop'</span></span><br><span class="line">alias gcmsg=<span class="string">'git commit -m'</span></span><br><span class="line">alias gco=<span class="string">'git checkout'</span></span><br><span class="line">alias gcount=<span class="string">'git shortlog -sn'</span></span><br><span class="line">compdef _git gcount</span><br><span class="line">alias gcp=<span class="string">'git cherry-pick'</span></span><br><span class="line">alias gcpa=<span class="string">'git cherry-pick --abort'</span></span><br><span class="line">alias gcpc=<span class="string">'git cherry-pick --continue'</span></span><br><span class="line">alias gcs=<span class="string">'git commit -S'</span></span><br><span class="line"></span><br><span class="line">alias gd=<span class="string">'git diff'</span></span><br><span class="line">alias gdca=<span class="string">'git diff --cached'</span></span><br><span class="line">alias gdct=<span class="string">'git describe --tags `git rev-list --tags --max-count=1`'</span></span><br><span class="line">alias gdt=<span class="string">'git diff-tree --no-commit-id --name-only -r'</span></span><br><span class="line">alias gdw=<span class="string">'git diff --word-diff'</span></span><br><span class="line"></span><br><span class="line">gdv() &#123; git diff -w <span class="string">"$@"</span> | view - &#125;</span><br><span class="line">compdef _git gdv=git-diff</span><br><span class="line"></span><br><span class="line">alias gf=<span class="string">'git fetch'</span></span><br><span class="line">alias gfa=<span class="string">'git fetch --all --prune'</span></span><br><span class="line">alias gfo=<span class="string">'git fetch origin'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gfg</span>(<span class="params"></span>) </span>&#123; git ls-files | grep $@ &#125;</span><br><span class="line">compdef _grep gfg</span><br><span class="line"></span><br><span class="line">alias gg=<span class="string">'git gui citool'</span></span><br><span class="line">alias gga=<span class="string">'git gui citool --amend'</span></span><br><span class="line"></span><br><span class="line">ggf() &#123;</span><br><span class="line">  [[ <span class="string">"$#"</span> != <span class="number">1</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">  git push --force origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggf=git-checkout</span><br><span class="line"></span><br><span class="line">ggl() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> != <span class="number">0</span> ]] &amp;&amp; [[ <span class="string">"$#"</span> != <span class="number">1</span> ]]; then</span><br><span class="line">    git pull origin <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    [[ <span class="string">"$#"</span> == <span class="number">0</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">    git pull origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggl=git-checkout</span><br><span class="line"></span><br><span class="line">ggp() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> != <span class="number">0</span> ]] &amp;&amp; [[ <span class="string">"$#"</span> != <span class="number">1</span> ]]; then</span><br><span class="line">    git push origin <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    [[ <span class="string">"$#"</span> == <span class="number">0</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">    git push origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggp=git-checkout</span><br><span class="line"></span><br><span class="line">ggpnp() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> == <span class="number">0</span> ]]; then</span><br><span class="line">    ggl &amp;&amp; ggp</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ggl <span class="string">"$&#123;*&#125;"</span> &amp;&amp; ggp <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggpnp=git-checkout</span><br><span class="line"></span><br><span class="line">ggu() &#123;</span><br><span class="line">  [[ <span class="string">"$#"</span> != <span class="number">1</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">  git pull --rebase origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggu=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpur=<span class="string">'ggu'</span></span><br><span class="line">compdef _git ggpur=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpull=<span class="string">'git pull origin $(git_current_branch)'</span></span><br><span class="line">compdef _git ggpull=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpush=<span class="string">'git push origin $(git_current_branch)'</span></span><br><span class="line">compdef _git ggpush=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggsup=<span class="string">'git branch --set-upstream-to=origin/$(git_current_branch)'</span></span><br><span class="line">alias gpsup=<span class="string">'git push --set-upstream origin $(git_current_branch)'</span></span><br><span class="line"></span><br><span class="line">alias ghh=<span class="string">'git help'</span></span><br><span class="line"></span><br><span class="line">alias gignore=<span class="string">'git update-index --assume-unchanged'</span></span><br><span class="line">alias gignored=<span class="string">'git ls-files -v | grep "^[[:lower:]]"'</span></span><br><span class="line">alias git-svn-dcommit-push=<span class="string">'git svn dcommit &amp;&amp; git push github master:svntrunk'</span></span><br><span class="line">compdef _git git-svn-dcommit-push=git</span><br><span class="line"></span><br><span class="line">alias gk=<span class="string">'\gitk --all --branches'</span></span><br><span class="line">compdef _git gk=<span class="string">'gitk'</span></span><br><span class="line">alias gke=<span class="string">'\gitk --all $(git log -g --pretty=%h)'</span></span><br><span class="line">compdef _git gke=<span class="string">'gitk'</span></span><br><span class="line"></span><br><span class="line">alias gl=<span class="string">'git pull'</span></span><br><span class="line">alias glg=<span class="string">'git log --stat'</span></span><br><span class="line">alias glgp=<span class="string">'git log --stat -p'</span></span><br><span class="line">alias glgg=<span class="string">'git log --graph'</span></span><br><span class="line">alias glgga=<span class="string">'git log --graph --decorate --all'</span></span><br><span class="line">alias glgm=<span class="string">'git log --graph --max-count=10'</span></span><br><span class="line">alias glo=<span class="string">'git log --oneline --decorate'</span></span><br><span class="line">alias glol=<span class="string">"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">alias glola=<span class="string">"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --all"</span></span><br><span class="line">alias glog=<span class="string">'git log --oneline --decorate --graph'</span></span><br><span class="line">alias gloga=<span class="string">'git log --oneline --decorate --graph --all'</span></span><br><span class="line">alias glp=<span class="string">"_git_log_prettily"</span></span><br><span class="line">compdef _git glp=git-log</span><br><span class="line"></span><br><span class="line">alias gm=<span class="string">'git merge'</span></span><br><span class="line">alias gmom=<span class="string">'git merge origin/master'</span></span><br><span class="line">alias gmt=<span class="string">'git mergetool --no-prompt'</span></span><br><span class="line">alias gmtvim=<span class="string">'git mergetool --no-prompt --tool=vimdiff'</span></span><br><span class="line">alias gmum=<span class="string">'git merge upstream/master'</span></span><br><span class="line"></span><br><span class="line">alias gp=<span class="string">'git push'</span></span><br><span class="line">alias gpd=<span class="string">'git push --dry-run'</span></span><br><span class="line">alias gpoat=<span class="string">'git push origin --all &amp;&amp; git push origin --tags'</span></span><br><span class="line">compdef _git gpoat=git-push</span><br><span class="line">alias gpu=<span class="string">'git push upstream'</span></span><br><span class="line">alias gpv=<span class="string">'git push -v'</span></span><br><span class="line"></span><br><span class="line">alias gr=<span class="string">'git remote'</span></span><br><span class="line">alias gra=<span class="string">'git remote add'</span></span><br><span class="line">alias grb=<span class="string">'git rebase'</span></span><br><span class="line">alias grba=<span class="string">'git rebase --abort'</span></span><br><span class="line">alias grbc=<span class="string">'git rebase --continue'</span></span><br><span class="line">alias grbi=<span class="string">'git rebase -i'</span></span><br><span class="line">alias grbm=<span class="string">'git rebase master'</span></span><br><span class="line">alias grbs=<span class="string">'git rebase --skip'</span></span><br><span class="line">alias grh=<span class="string">'git reset HEAD'</span></span><br><span class="line">alias grhh=<span class="string">'git reset HEAD --hard'</span></span><br><span class="line">alias grmv=<span class="string">'git remote rename'</span></span><br><span class="line">alias grrm=<span class="string">'git remote remove'</span></span><br><span class="line">alias grset=<span class="string">'git remote set-url'</span></span><br><span class="line">alias grt=<span class="string">'cd $(git rev-parse --show-toplevel || echo ".")'</span></span><br><span class="line">alias gru=<span class="string">'git reset --'</span></span><br><span class="line">alias grup=<span class="string">'git remote update'</span></span><br><span class="line">alias grv=<span class="string">'git remote -v'</span></span><br><span class="line"></span><br><span class="line">alias gsb=<span class="string">'git status -sb'</span></span><br><span class="line">alias gsd=<span class="string">'git svn dcommit'</span></span><br><span class="line">alias gsi=<span class="string">'git submodule init'</span></span><br><span class="line">alias gsps=<span class="string">'git show --pretty=short --show-signature'</span></span><br><span class="line">alias gsr=<span class="string">'git svn rebase'</span></span><br><span class="line">alias gss=<span class="string">'git status -s'</span></span><br><span class="line">alias gst=<span class="string">'git status'</span></span><br><span class="line">alias gsta=<span class="string">'git stash save'</span></span><br><span class="line">alias gstaa=<span class="string">'git stash apply'</span></span><br><span class="line">alias gstc=<span class="string">'git stash clear'</span></span><br><span class="line">alias gstd=<span class="string">'git stash drop'</span></span><br><span class="line">alias gstl=<span class="string">'git stash list'</span></span><br><span class="line">alias gstp=<span class="string">'git stash pop'</span></span><br><span class="line">alias gsts=<span class="string">'git stash show --text'</span></span><br><span class="line">alias gsu=<span class="string">'git submodule update'</span></span><br><span class="line"></span><br><span class="line">alias gts=<span class="string">'git tag -s'</span></span><br><span class="line">alias gtv=<span class="string">'git tag | sort -V'</span></span><br><span class="line"></span><br><span class="line">alias gunignore=<span class="string">'git update-index --no-assume-unchanged'</span></span><br><span class="line">alias gunwip=<span class="string">'git log -n 1 | grep -q -c "\-\-wip\-\-" &amp;&amp; git reset HEAD~1'</span></span><br><span class="line">alias gup=<span class="string">'git pull --rebase'</span></span><br><span class="line">alias gupv=<span class="string">'git pull --rebase -v'</span></span><br><span class="line">alias glum=<span class="string">'git pull upstream master'</span></span><br><span class="line"></span><br><span class="line">alias gwch=<span class="string">'git whatchanged -p --abbrev-commit --pretty=medium'</span></span><br><span class="line">alias gwip=<span class="string">'git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m "--wip-- [skip ci]"'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#oh-my-zsh git 命令缩写&lt;/p&gt;
&lt;p&gt;喜欢用 git 命令行，平时能少打几个字还是会节省不少时间的。&lt;/p&gt;
&lt;h2 id=&quot;常用&quot;&gt;&lt;a href=&quot;#常用&quot; class=&quot;headerlink&quot; title=&quot;常用&quot;&gt;&lt;/a&gt;常用&lt;/h2&gt;&lt;figure
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Object.prototype.toString方法的原理</title>
    <link href="http://yoursite.com/2019/10/28/Object.prototype.toString%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/28/Object.prototype.toString方法的原理/</id>
    <published>2019-10-28T04:33:37.000Z</published>
    <updated>2019-11-10T14:37:39.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-prototype-toString-方法的原理"><a href="#Object-prototype-toString-方法的原理" class="headerlink" title="Object.prototype.toString 方法的原理"></a>Object.prototype.toString 方法的原理</h1><h2 id="ECMAScript-3"><a href="#ECMAScript-3" class="headerlink" title="ECMAScript 3"></a>ECMAScript 3</h2><h3 id="Object-prototype-toString-方法的规范"><a href="#Object-prototype-toString-方法的规范" class="headerlink" title="Object.prototype.toString 方法的规范"></a>Object.prototype.toString 方法的规范</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>获取 this 对象的[[Class]]属性的值.</li><li>计算出三个字符串<strong>“[object “,</strong>第一步的操作结果 Result(1), 以及 <strong>“]”</strong>连接后的新字符串.</li><li>返回第二步的操作结果 Result(2).</li></ol><h3 id="Class"><a href="#Class" class="headerlink" title="[[Class]]"></a>[[Class]]</h3><p>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的</p><table><thead><tr><th>内部属性</th><th>描述</th></tr></thead><tbody><tr><td>[[Class]]</td><td>一个字符串值,表明了该对象的类型.</td></tr></tbody></table><p>然后给了一段解释:</p><blockquote><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过<strong>Object.prototype.toString</strong>方法之外,本规范没有提供任何其他方式来让程序访问该属性的值</p></blockquote><p>也就是说,把 Object.prototype.toString 方法返回的字符串,去掉前面固定的<strong>“[object “</strong>和后面固定的<strong>“]”,</strong>就是内部属性[[class]]的值,也就达到了判断对象类型的目的。</p><h3 id="Class-的值"><a href="#Class-的值" class="headerlink" title="[[Class]]的值"></a>[[Class]]的值</h3><p>在 ES3 中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有 10 种.分别是:<code>&quot;Array&quot;</code>, <code>&quot;Boolean&quot;</code>, <code>&quot;Date&quot;</code>, <code>&quot;Error&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;Math&quot;</code>, <code>&quot;Number&quot;</code>, <code>&quot;Object&quot;</code>, <code>&quot;RegExp&quot;</code>, <code>&quot;String&quot;.</code></p><h2 id="ECMAScript-5"><a href="#ECMAScript-5" class="headerlink" title="ECMAScript 5"></a>ECMAScript 5</h2><h3 id="Object-prototype-toString-方法的规范-1"><a href="#Object-prototype-toString-方法的规范-1" class="headerlink" title="Object.prototype.toString 方法的规范"></a>Object.prototype.toString 方法的规范</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用 ToObject(<strong>this)</strong>的结果.</li><li>让<em>class</em>成为<em>O</em>的内部属性[[Class]]的值.</li><li>返回三个字符串<strong>“[object “,</strong> <em>class</em>, 以及 <strong>“]”</strong>连接后的新字符串.</li></ol><p>可以看出,ES5 比 ES3 多了 1,2,3 步.第 1,2 步属于新规则,比较特殊,因为”<code>Undefined&quot;</code>和”<code>Null&quot;</code>并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this 的值才会保持 undefined 或 null,非严格模式下会自动成为全局对象).第 3 步并不算是新规则,因为在 ES3 的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.</p><h3 id="Class-1"><a href="#Class-1" class="headerlink" title="[[Class]]"></a>[[Class]]</h3><p>ES5 中,[[Class]]属性的解释更加详细:</p><blockquote><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过<strong>Object.prototype.toString</strong>方法之外,本规范没有提供任何其他方式来让程序访问该属性的值</p></blockquote><h3 id="对比-ES3"><a href="#对比-ES3" class="headerlink" title="对比 ES3"></a>对比 ES3</h3><ul><li>第一个差别就是[[class]]内部属性的值多了两种,成了 12 种<ul><li>一种是 arguments 对象的[[class]]成了”Arguments”,而不是以前的”Object”</li><li>多个了全局对象 JSON,它的[[class]]值为”JSON”.</li></ul></li><li>第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这 12 种值冲突（不过在支持 ES3 的浏览器中,貌似也没有发现哪些宿主对象故意使用那 10 个值）</li></ul><h2 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h2><p><strong>[[class]]内部属性没有了</strong>,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的:</p><table><thead><tr><th>内部属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>[[NativeBrand]]</td><td>枚举 NativeBrand 的一个成员.</td><td>该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型.</td></tr></tbody></table><h3 id="NativeBrand-属性（internal-slot）"><a href="#NativeBrand-属性（internal-slot）" class="headerlink" title="[[NativeBrand]]属性（internal slot）"></a>[[NativeBrand]]属性（<code>internal slot</code>）</h3><p>[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的 ECMAScript 原生对象.只有在表 10 中明确指出的对象类型才有[[NativeBrand]]内部属性.</p><table><thead><tr><th>属性值</th><th>对应类型</th></tr></thead><tbody><tr><td>NativeFunction</td><td>Function objects</td></tr><tr><td>NativeArray</td><td>Array objects</td></tr><tr><td>StringWrapper</td><td>String objects</td></tr><tr><td>BooleanWrapper</td><td>Boolean objects</td></tr><tr><td>NumberWrapper</td><td>Number objects</td></tr><tr><td>NativeMath</td><td>The Math object</td></tr><tr><td>NativeDate</td><td>Date objects</td></tr><tr><td>NativeRegExp</td><td>RegExp objects</td></tr><tr><td>NativeError</td><td>Error objects</td></tr><tr><td>NativeJSON</td><td>The JSON object</td></tr><tr><td>NativeArguments</td><td>Arguments objects</td></tr><tr><td>NativePrivateName</td><td>Private Name objects</td></tr></tbody></table><p>可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].</p><h3 id="Object-prototype-toString-方法的规范-2"><a href="#Object-prototype-toString-方法的规范-2" class="headerlink" title="Object.prototype.toString 方法的规范:"></a>Object.prototype.toString 方法的规范:</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用 ToObject(<strong>this)</strong>的结果.</li><li>如果<em>O</em>有[[NativeBrand]]内部属性,让<em>tag</em>成为表 29 中对应的值.</li><li>否则<ol><li>让<em>hasTag</em>成为调用<em>O</em>的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>hasTag</em>为<strong>false</strong>,则让<em>tag</em>为<code>&quot;Object&quot;</code>.</li><li>否则,<ol><li>让<em>tag</em>成为调用<em>O</em>的[[Get]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>tag</em>是一个 abrupt completion,则让<em>tag</em>成为 NormalCompletion(<code>&quot;???&quot;</code>).</li><li>让<em>tag<em>成为</em>tag</em>.[[value]].</li><li>如果 Type(<em>tag</em>)不是字符串,则让<em>tag 成为</em><code>&quot;???&quot;</code>.</li><li>如果<em>tag</em>的值为<code>&quot;Arguments&quot;</code>, <code>&quot;Array&quot;</code>, <code>&quot;Boolean&quot;</code>, <code>&quot;Date&quot;</code>, <code>&quot;Error&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;JSON&quot;</code>, <code>&quot;Math&quot;</code>, <code>&quot;Number&quot;</code>, <code>&quot;Object&quot;</code>, <code>&quot;RegExp&quot;</code>,<code>或者&quot;String&quot;中的任一个,则让</code><em>tag</em>成为字符串<code>&quot;~&quot;和</code><em>tag</em>当前的值连接后的结果.</li></ol></li></ol></li><li>返回三个字符串”[object “, tag, and “]”连接后的新字符串.</li></ol><h3 id="ES6-里的新类型-Map-Set"><a href="#ES6-里的新类型-Map-Set" class="headerlink" title="ES6 里的新类型 Map,Set"></a>ES6 里的新类型 Map,Set</h3><p>ES6 里的新类型 Map,Set 等,都没有在表 29 中.它们在执行 toString 方法的时候返回的是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Map</span>())); <span class="comment">//"[object Map]"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Set</span>())); <span class="comment">//"[object Set]"</span></span><br></pre></td></tr></table></figure><p>Map.prototype.@@toStringTag</p><p>@@toStringTag 属性的初始值为字符串<strong>“Map”</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object-prototype-toString-方法的原理&quot;&gt;&lt;a href=&quot;#Object-prototype-toString-方法的原理&quot; class=&quot;headerlink&quot; title=&quot;Object.prototype.toString 方法的原
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://yoursite.com/2019/10/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/21/函数式编程/</id>
    <published>2019-10-21T03:15:12.000Z</published>
    <updated>2019-11-10T14:37:39.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>函数式编程是一种编程范式，主要是利用函数把运算过程封装起来，通过组合各种函数来计算结果。函数式编程意味着你可以在更短的时间内编写具有更少错误的代码。</p><p>举个简单的例子，假设我们要把字符串 <code>functional programming is great</code> 变成每个单词首字母大写，我们可以这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"functional programming is great"</span>;</span><br><span class="line"><span class="keyword">var</span> result = string</span><br><span class="line">  .split(<span class="string">" "</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">v</span> =&gt;</span> v.slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + v.slice(<span class="number">1</span>))</span><br><span class="line">  .join(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure><p>上面的例子先用 split 把字符串转换数组，然后再通过 map 把各元素的首字母转换成大写，最后通过 join 把数组转换成字符串。 整个过程就是 <code>join(map(split(str)))</code>,体现了函数式编程的核心思想： <strong>通过函数对数据进行转换</strong>。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>由此我们可以得到，函数式编程有两个基本特点：</p><ul><li>通过函数来对数据进行转换</li><li>通过串联多个函数来求结果</li></ul><h2 id="对比声明式与命令式"><a href="#对比声明式与命令式" class="headerlink" title="对比声明式与命令式"></a>对比声明式与命令式</h2><ul><li>命令式：我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。命令式代码中频繁使用语句,来完成某个行为。比如 for、if、switch、throw 等这些语句。</li><li>声明式：我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; companies.length; i++) &#123;</span><br><span class="line">  CEOs.push(companies[i].CEO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = companies.map(<span class="function"><span class="params">c</span> =&gt;</span> c.CEO);</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到声明式的写法是一个表达式，无需关心如何进行计数器迭代，返回的数组如何收集，它指明的是做什么，而不是怎么做。<strong>函数式编程的一个明显的好处就是这种声明式的代码</strong>，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。</p><h2 id="常见特性"><a href="#常见特性" class="headerlink" title="常见特性"></a>常见特性</h2><h3 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h3><p>指调用函数时不会修改外部状态，即一个函数调用 n 次后依然返回同样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 含有副作用，它修改了外部变量 a</span></span><br><span class="line"><span class="comment">// 多次调用结果不一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无副作用，没有修改外部状态</span></span><br><span class="line"><span class="comment">// 多次调用结果一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明引用"><a href="#透明引用" class="headerlink" title="透明引用"></a>透明引用</h3><p>指一个函数只会用到传递给它的变量以及自己内部创建的变量，不会使用到其他变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 函数内部使用的变量并不属于它的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数内部使用的变量是显式传递进去的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h3><p>指的是一个变量一旦创建后，就不能再进行修改，任何修改都会生成一个新的变量。使用不可变变量最大的好处是线程安全。多个线程可以同时访问同一个不可变变量，让并行变得更容易实现。 由于 JavaScript 原生不支持不可变变量，需要通过第三方库来实现。 (如 Immutable.js，Mori 等等)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = obj.set(<span class="string">"a"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Immutable(&#123; a: 1 &#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// Immutable(&#123; a: 2 &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>我们常说函数是 JavaScript 的”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。下文将要介绍的闭包、高阶函数、函数柯里化和函数组合都是围绕这一特性的应用</p><h2 id="常见的函数式编程模型"><a href="#常见的函数式编程模型" class="headerlink" title="常见的函数式编程模型"></a>常见的函数式编程模型</h2><h3 id="1-闭包（Closure）"><a href="#1-闭包（Closure）" class="headerlink" title="1.闭包（Closure）"></a>1.闭包（Closure）</h3><p>如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。</p><p>闭包的形成条件：</p><ul><li>存在内、外两层函数</li><li>内层函数对外层函数的局部变量进行了引用</li></ul><p>闭包的用途:<br><strong>可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的缓存工具</span></span><br><span class="line"><span class="comment">// 匿名函数创造了一个闭包</span></span><br><span class="line"><span class="keyword">const</span> cache = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">      <span class="keyword">return</span> store[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(key, val) &#123;</span><br><span class="line">      store[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(cache); <span class="comment">//&#123;get: ƒ, set: ƒ&#125;</span></span><br><span class="line">cache.set(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">cache.get(<span class="string">"a"</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。</p><p>闭包的弊端:<strong>持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费</strong>，所以一般需要一些额外手动的清理机制。</p><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2.高阶函数"></a>2.高阶函数</h3><p>函数式编程倾向于复用一组通用的函数功能来处理数据，它通过使用高阶函数来实现。<strong>高阶函数指的是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值</strong>。</p><p>高阶函数经常用于：</p><ul><li>抽象或隔离行为、作用，异步控制流程作为回调函数，promises，monads 等</li><li>创建可以泛用于各种数据类型的功能</li><li>部分应用于函数参数（偏函数应用）或创建一个柯里化的函数，用于复用或函数复合。</li><li>接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。</li></ul><p>JavaScript 语言是原生支持高阶函数的, 例如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce 是 JavaScript 中内置的一些高阶函数，使用高阶函数会让我们的代码更清晰简洁。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。map 不会改变原数组。</p><p>假设我们有一个包含名称和种类属性的对象数组，我们想要这个数组中所有名称属性放在一个新数组中，如何实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  names.push(animals[i].name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(names); <span class="comment">//["Fluffykins", "Caro", "Hamilton", "Harold", "Ursula", "Jimmy"]</span></span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = animals.map(<span class="function"><span class="params">x</span> =&gt;</span> x.name);</span><br><span class="line"><span class="built_in">console</span>.log(names); <span class="comment">//["Fluffykins", "Caro", "Hamilton", "Harold", "Ursula", "Jimmy"]</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter() 方法会创建一个新数组，其中包含所有通过回调函数测试的元素。filter 为数组中的每个元素调用一次 callback 函数， callback 函数返回 true 表示该元素通过测试，保留该元素，false 则不保留。filter 不会改变原数组，它返回过滤后的新数组。</p><p>假设我们有一个包含名称和种类属性的对象数组。 我们想要创建一个只包含狗（species: “dog”）的数组。如何实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> dogs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (animals[i].species === <span class="string">"dog"</span>) dogs.push(animals[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dogs);</span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> dogs = animals.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.species === <span class="string">"dog"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogs); <span class="comment">// &#123;name: "Caro", species: "dog"&#125;</span></span><br><span class="line"><span class="comment">// &#123; name: "Hamilton", species: "dog" &#125;</span></span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce 方法对调用数组的每个元素执行回调函数，最后生成一个单一的值并返回。 reduce 方法接受两个参数：1）reducer 函数（回调），2）一个可选的 initialValue。</p><p>假设我们要对一个数组的求和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  sum = sum + arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.reduce(</span><br><span class="line">  (accumulator, currentValue) =&gt; accumulator + currentValue,</span><br><span class="line">  <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br></pre></td></tr></table></figure><p>我们可以通过下图，形象生动展示三者的区别：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ixh3e6euj30ml0bnwf2.jpg" alt="img"></p><h3 id="3-函数柯里化"><a href="#3-函数柯里化" class="headerlink" title="3.函数柯里化"></a>3.函数柯里化</h3><p>柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候，再一次性把所有传入的参数进行求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 函数柯里化</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line">increment(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。那么，我们如何来实现一个简易的柯里化函数呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数fn函数的参数个数</span></span><br><span class="line">  <span class="keyword">var</span> n = fn.length;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    args.push(arg);</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; n) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>.callee; <span class="comment">// 返回这个函数的引用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = curryIt(add);</span><br><span class="line"><span class="keyword">var</span> c1 = c(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = c1(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> c3 = c2(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c3); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>由此我们可以看出，柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法！</p><h3 id="4-函数组合-Composition"><a href="#4-函数组合-Composition" class="headerlink" title="4.函数组合 (Composition)"></a>4.函数组合 (Composition)</h3><p>前面提到过，函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。<br>假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数的组合</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> f(g(x));</span><br><span class="line"><span class="keyword">var</span> add1 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mul5 = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">5</span>;</span><br><span class="line">compose(</span><br><span class="line">  mul5,</span><br><span class="line">  add1</span><br><span class="line">)(<span class="number">2</span>); <span class="comment">// =&gt;15</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h1&gt;&lt;h2 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>IP</title>
    <link href="http://yoursite.com/2019/10/13/IP/"/>
    <id>http://yoursite.com/2019/10/13/IP/</id>
    <published>2019-10-13T07:41:22.000Z</published>
    <updated>2019-11-10T14:37:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p>IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“<strong>实现终端节点之间的通信</strong>”。这种终端节点之间的通信也叫“点对点通信”。</p><p>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p><p><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></p><h2 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h2><p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhns2grvj30lc0eojse.jpg" alt="img"></p><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhmr7ldbj30fk0dz751.jpg" alt="img"></p><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸。</strong></p><h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhpvepe5j30lg0lkdis.jpg" alt="img"></p><ol><li>应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li><li>TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li><li>IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li><li>网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li><li>网络接口（以太网驱动）的处理<br>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li><li>IP 模块的处理<br>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li><li>TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li><li>应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li></ol><h2 id="IP-服务的主要特点"><a href="#IP-服务的主要特点" class="headerlink" title="IP 服务的主要特点"></a>IP 服务的主要特点</h2><p>IP 协议为上层协议提供无状态、无连接、不可靠的服务。</p><ul><li><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6></li></ul><p>无状态是指 IP 通信双方不同步传输数据的状态信息，所有 IP 数据报的发送、传输、接受都是相互独立、没有上下文关系的。这种服务优点在于简单、高效。最大的缺点是无法处理乱序和重复的 IP 数据报，确保 IP 数据报完整的工作只能交给上层协议来完成。</p><ul><li><h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6></li></ul><p>无连接是指 IP 通信双方都不长久地维持对方的任何信息。上层协议每次发送数据的时候，都需要明确指出对方的 IP 地址。</p><ul><li><h6 id="不可靠"><a href="#不可靠" class="headerlink" title="不可靠"></a>不可靠</h6></li></ul><p>不可靠是指 IP 协议不能保证 IP 数据报准确到达接收端，它指承诺尽最大努力交付。IP 模块一旦检测到数据报发送失败，就通知上层协议，而不会试图重传。</p><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><h3 id="IP-地址概述"><a href="#IP-地址概述" class="headerlink" title="IP 地址概述"></a>IP 地址概述</h3><ul><li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li><li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“<strong>连接到网络中的所有主机中识别出进行通信的目标地址</strong>”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li><li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li><li>IP 地址（IPv4 地址）由 32 位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将 32 位的 IP 地址以每 8 位为一组，分成 4 组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li></ul><table><thead><tr><th>2^8</th><th>2^8</th><th>2^8</th><th>2^8</th><th></th></tr></thead><tbody><tr><td>10101100</td><td>00010100</td><td>00000001</td><td>00000001</td><td>（2 进制）</td></tr><tr><td>172.</td><td>20.</td><td>1.</td><td>1</td><td>（10 进制）</td></tr></tbody></table><h3 id="IP-地址由网络和主机两部分标识组成"><a href="#IP-地址由网络和主机两部分标识组成" class="headerlink" title="IP 地址由网络和主机两部分标识组成"></a>IP 地址由网络和主机两部分标识组成</h3><ul><li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 <strong>IP 地址具有了唯一性</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l2qlpa6j30k80hiwhe.jpg" alt="img"></p><ul><li>如下图，IP 包被转发到途中某个路由器时，正是<strong>利用目标 IP 地址的网络标识进行路由</strong>。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l4my99cj30k40auabx.jpg" alt="img"></p><h3 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h3><p><strong>IP 地址分为四个级别，分别为 A 类、B 类、C 类、D 类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></p><ul><li><strong>A 类 IP 地址是首位以 “0” 开头的地址。</strong>从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 16,777,214 个。</li><li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 65,534 个。</li><li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 254 个。</li><li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li><li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li></ul><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><ul><li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li><li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li></ul><h3 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h3><ul><li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p></li><li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l8g7veoj30f70jjn02.jpg" alt="img"></p></li><li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</p></li><li><p>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p></li></ul><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li><li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li><li>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr></tbody></table><ul><li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th><th>/ 26</th></tr></thead><tbody><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td><td>/ 26</td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td><td>/ 26</td></tr></tbody></table><ul><li>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。</li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li><li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li><li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li></ul><h3 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h3><ul><li>IP 地址的网络地址部分用于进行路由控制。</li><li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li><li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70ldgjh6gj30ka0gen0n.jpg" alt="img"></p><h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>路由匹配顺序：<br>1） 直接匹配，查找路由表中是否由与目标 IP 地址完全匹配的主机 IP 地址，找到则匹配成功，没有的话转 2；<br>2）查找是否有与目标 IP 地址具有相同网络 ID 的 IP 地址，找到则匹配成功，没有的话转 3；<br>3）查看是否有默认网关，有则转发给它，没有的话，路由查找失败，由 ICMP 返回错误信息。</p><h3 id="路由更新"><a href="#路由更新" class="headerlink" title="路由更新"></a>路由更新</h3><p>通过 route 命令或其他工具可以手工修改路由表，是静态路由更新方式。对于大型路由器，它们通常通过 BGP、RIP、OSPF 等协议进行动态路由更新。</p><h2 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h2><ul><li>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li><li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li><li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li></ul><h3 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h3><ul><li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li><li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li><li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li></ul><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="IPv4-头部"><a href="#IPv4-头部" class="headerlink" title="IPv4 头部"></a>IPv4 头部</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lsqccjaj30eh064dge.jpg" alt="img"></p><ul><li><h6 id="头部长度"><a href="#头部长度" class="headerlink" title="头部长度"></a>头部长度</h6></li></ul><p>标识该 IP 头部有多少个 32 位 bit 字（4 字节），由于 4 位最大描述 15，所以 IP 头部最大长度为 60 字节。</p><ul><li><h6 id="8-为服务位"><a href="#8-为服务位" class="headerlink" title="8 为服务位"></a>8 为服务位</h6></li></ul><p>包括 3 位优先权位，4 为 TOS 字段和 1 位保留字段。<br>4 为 TOS 字段分别表示：最小延时，最大吞吐量、最高可靠性和最小费用。其中最多能选择一位置 1，应用程序根据实际需要来设置服务类型。</p><ul><li><h6 id="16-位标识"><a href="#16-位标识" class="headerlink" title="16 位标识"></a>16 位标识</h6></li></ul><p>唯一标识主机发送的每一个数据报。其初始值由系统随机生成；每发一个数据报就加 1。每个分片中具有相同的标识值。</p><ul><li><h6 id="分片偏移"><a href="#分片偏移" class="headerlink" title="分片偏移"></a>分片偏移</h6></li></ul><p>有 3 位用于标识偏移，第一位保留，第二位 DF 字段（禁止分片标识），第三位 MF 字段（更多分片标识，最后一个分片为 0，其他分片置 1）。13 位偏移是勇敢将实际值左移三位得到的，因此要求数据部分的长度是 8 的倍数。</p><ul><li><h6 id="8-位协议"><a href="#8-位协议" class="headerlink" title="8 位协议"></a>8 位协议</h6></li></ul><p>标识上层协议，1 是 ICMP，6 是 TCP，17 是 UDP。</p><ul><li><h6 id="16-位头部校验和"><a href="#16-位头部校验和" class="headerlink" title="16 位头部校验和"></a>16 位头部校验和</h6></li></ul><p>IP 模块接受数据后，首先对数据报头部做 CRC 校验，确保 IP 头部在传输过程中无损坏后，再分析其头部具体信息。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</p><p>IPv6 协议并不是 IPv4 的简单扩展，而是完全独立的协议。从以太网帧封装的数据类型来看，前者类型是 0X86dd，后者是 0x8600，是完全不同的类型。</p><p>IPv6 解决了网络地址不足的问题，其头部增加了多播和流的功能，引入了自动配置功能，还增加了网络安全的功能。</p><h3 id="IPv6-头部固定部分"><a href="#IPv6-头部固定部分" class="headerlink" title="IPv6 头部固定部分"></a>IPv6 头部固定部分</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lv0wgqij30em05ydg6.jpg" alt="img"></p><ul><li><h6 id="流标签"><a href="#流标签" class="headerlink" title="流标签"></a>流标签</h6></li></ul><p>是 IPv6 新增加的字段，用于对某些连接的服务质量有特殊要求的通信，比如音频或者视频等实时数据传递。</p><ul><li><h6 id="下一个包头"><a href="#下一个包头" class="headerlink" title="下一个包头"></a>下一个包头</h6></li></ul><p>指出紧跟 IPv6 固定头部后的包头类型，如拓展头，或者某个上层协议头（ICMP，TCP，UDP），它类似 IPv4 中的协议字段，且相同的取值具有相同的含义。</p><h3 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h3><ul><li>IP 得知的扩大与路由控制表的聚合。</li><li>性能提升。包首部长度采用固定的值（40 字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li><li>支持即插即用功能。即使没有 DHCP 服务器也可以实现自动分配 IP 地址。</li><li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li><li>多播、Mobile IP 成为扩展功能。</li></ul><h3 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h3><ul><li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li><li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li></ul><h3 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h3><ul><li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li><li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li></ul><table><thead><tr><th>未定义</th><th>0000 … 0000（128 比特）</th><th>：：/ 128</th></tr></thead><tbody><tr><td>环回地址</td><td>0000 … 0001（128 比特）</td><td>：：1 / 128</td></tr><tr><td>唯一本地地址</td><td>1111 110</td><td>FC00：/ 7</td></tr><tr><td>链路本地单播地址</td><td>1111 1110 10</td><td>FE80：：/ 10</td></tr><tr><td>多播地址</td><td>1111 1111</td><td>FF00：：/ 8</td></tr><tr><td>全局单播地址</td><td>（其他）</td><td></td></tr></tbody></table><h3 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h3><ul><li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li><li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lktamkvj30lt08qmxq.jpg" alt="img"></p><h3 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h3><p>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70llnrbecj30lg052weo.jpg" alt="img"></p><h3 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h3><ul><li>唯一本地地址是不进行互联网通信时所用的地址。</li><li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li><li>L 通常被置为 1</li><li>全局 ID 的值随机决定</li><li>子网 ID 是指该域子网地址</li><li>接口 ID 即为接口的 ID</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lmkuopyj30ms053mxf.jpg" alt="img"></p><h3 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h3><ul><li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li><li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li></ul><h3 id="IP-首部（暂略）"><a href="#IP-首部（暂略）" class="headerlink" title="IP 首部（暂略）"></a>IP 首部（暂略）</h3><h2 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h2><p>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li><li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul><li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li><li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li><li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li></ul><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul><li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li><li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li></ul><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><ul><li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li><li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li><li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li></ul><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><ul><li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li><li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li><li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li></ul><h3 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lqkzre9j30ht04caaa.jpg" alt="img"></p><ul><li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li><li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li><li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP&quot;&gt;&lt;a href=&quot;#IP&quot; class=&quot;headerlink&quot; title=&quot;IP&quot;&gt;&lt;/a&gt;IP&lt;/h1&gt;&lt;p&gt;IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“&lt;strong&gt;实现终端节点之间的通信&lt;/s
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
</feed>
