<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>01不是包子脸</title>
  
  <subtitle>小01的程序猿成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-21T14:54:12.854Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Linyi Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>git merge和git rebase的区别</title>
    <link href="http://yoursite.com/2019/09/21/git%20merge%E5%92%8Cgit%20rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/09/21/git merge和git rebase的区别/</id>
    <published>2019-09-21T14:53:17.000Z</published>
    <updated>2019-09-21T14:54:12.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h1><p>git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wkw4uh2dj30xc0qtjsl.jpg" alt="img"></p><p>为了将master 上新的提交合并到你的feature分支上，你有两种选择：<code>merging</code> or <code>rebase</code></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master feature</span><br></pre></td></tr></table></figure><p>那么此时在feature上git 自动会产生一个新的commit(merge commit)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wky69tunj30w90850te.jpg" alt="img"></p><h3 id="git-merge-有如下特点："><a href="#git-merge-有如下特点：" class="headerlink" title="git merge 有如下特点："></a><code>git merge</code> 有如下特点：</h3><ul><li>只处理一次冲突，如果合并的时候遇到冲突，仅需要修改后重新commit</li><li>引入了一次合并的历史记录，合并后的所有 <code>commit</code> 会按照提交时间从旧到新排列</li><li>所有的过程信息更多，可能会提高之后查找问题的难度</li></ul><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>记录了真实的commit情况，包括每个分支的详情</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>与 <code>git merge</code> 一致，<code>git rebase</code> 的目的也是将一个分支的更改并入到另外一个分支中去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>本质是<strong>变基 变基 变基</strong></p><p>变基是什么? <code>找公共祖先</code></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wl0azimrj30wx0823zd.jpg" alt="img"></p><h3 id="rebase-特点："><a href="#rebase-特点：" class="headerlink" title="rebase 特点："></a>rebase 特点：</h3><ul><li>改变当前分支从 <code>master</code>上拉出分支的位置</li><li>没有多余的合并历史的记录，会合并之前的commit历史，且合并后的 <code>commit</code>顺序不一定按照 <code>commit</code>的提交时间排列</li><li>可能会多次解决同一个地方的冲突（有 <code>squash</code>来解决）</li><li>更清爽一些，<code>master</code>分支上每个 <code>commit</code>点都是相对独立完整的功能单元</li></ul><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>得到更简洁的项目历史，去掉了merge commit</p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>如果合并出现代码问题不容易定位，因为rewrite了history</p><h3 id="合并时遇到冲突："><a href="#合并时遇到冲突：" class="headerlink" title="合并时遇到冲突："></a>合并时遇到冲突：</h3><p>合并时如果出现冲突需要按照如下步骤解决</p><ul><li>修改冲突部分</li><li>git add</li><li><code>git rebase --continue</code></li><li>（如果第三步无效可以执行 <code>git rebase --skip</code>）</li></ul><p>不要在git add 之后习惯性的执行 git commit命令</p><h3 id="git-rebase-的交互模式"><a href="#git-rebase-的交互模式" class="headerlink" title="git rebase 的交互模式"></a>git rebase 的交互模式</h3><p>打开变基的交互模式只需要传入一个参数 <code>-i</code> 即可，同时还需要指定对哪些提交进行处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p>上述命令指定了对当前分支的最近四次提交进行操作。下面我们使用上面这行命令将 <code>feature</code> 分支的提交合并。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wl7ji36xj30wi0gpq67.jpg" alt="img"></p><p>中间红框内有一些命令，可以用来处理某次提交的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果你想要一个干净的，没有merge commit的线性历史树，或者当发现自己修改某个功能时，频繁进行了<code>git commit</code>提交时，发现其实过多的提交信息没有必要时，那么你应该选择git rebase</li><li>当需要保留详细的合并信息的时候建议使用<code>git merge</code>，特别是需要将分支合并进入<code>master</code>分支时，并且想要避免重写commit history的风险，你应该选择使用git merge</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-merge和git-rebase的区别&quot;&gt;&lt;a href=&quot;#git-merge和git-rebase的区别&quot; class=&quot;headerlink&quot; title=&quot;git merge和git rebase的区别&quot;&gt;&lt;/a&gt;git merge和git reb
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浏览器同域名请求的最大并发数限制</title>
    <link href="http://yoursite.com/2019/09/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E5%9F%9F%E5%90%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%95%B0%E9%99%90%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/14/浏览器同域名请求的最大并发数限制/</id>
    <published>2019-09-14T15:14:44.000Z</published>
    <updated>2019-09-21T10:49:32.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器同域名请求的最大并发数限制"><a href="#浏览器同域名请求的最大并发数限制" class="headerlink" title="浏览器同域名请求的最大并发数限制"></a>浏览器同域名请求的最大并发数限制</h1><p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p><p>如果同时只有 2 个并发连接数数量，那网页打开的时候只能依赖于这 2 条线程，前面如果有打开慢的内容，就会直接影响到后面的内容打开。但是如果同时有更多的并发连接数，这样就会大大的提高网页加载速度。但是浏览器的并发连接数也并非越大越好。</p><p>HTTP 客户端一般对同一个服务器的并发连接个数都是有限制的。实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p><h2 id="主流浏览器最大并发连接数"><a href="#主流浏览器最大并发连接数" class="headerlink" title="主流浏览器最大并发连接数"></a>主流浏览器最大并发连接数</h2><p>一些主流浏览器对 HTTP 1.1 和 HTTP 1.0 的最大并发连接数目，可以参考如下表格：</p><table><thead><tr><th>浏览器</th><th>HTTP / 1.1</th><th>HTTP / 1.0</th></tr></thead><tbody><tr><td>IE 11</td><td>6</td><td>6</td></tr><tr><td>IE 10</td><td>6</td><td>6</td></tr><tr><td>IE 9</td><td>10</td><td>10</td></tr><tr><td>IE 8</td><td>6</td><td>6</td></tr><tr><td>IE 6,7</td><td>2</td><td>4</td></tr><tr><td>火狐</td><td>6</td><td>6</td></tr><tr><td>Safari 3,4</td><td>4</td><td>4</td></tr><tr><td>Chrome 4+</td><td>6</td><td>6</td></tr><tr><td>歌剧 9.63,10.00alpha</td><td>4</td><td>4</td></tr><tr><td>Opera 10.51+</td><td>8</td><td>？</td></tr><tr><td>iPhone 2</td><td>4</td><td>？</td></tr><tr><td>iPhone 3</td><td>6</td><td>？</td></tr><tr><td>iPhone 4</td><td>4</td><td>？</td></tr><tr><td>iphone 5</td><td>6</td><td>？</td></tr><tr><td>Android2-4</td><td>4</td><td>？</td></tr></tbody></table><h3 id="Firefox-浏览器的最大并发连接数"><a href="#Firefox-浏览器的最大并发连接数" class="headerlink" title="Firefox 浏览器的最大并发连接数"></a>Firefox 浏览器的最大并发连接数</h3><p>在 Firefox 中的地址栏输入“about：config 中”，然后搜索并修改如下两个配置项目即可：</p><ul><li><code>network.http.max-persistent-connections-per-server:6</code>连接同一个服务器允许的最大持久连接数，默认为 6，可以不用更改。</li><li><code>network.http.max-persistent-connections-per-proxy:8</code>每个代理服务器允许的最大持久连接数,公司用户使用代理服务器，但是外面的客户一般不使用代理，火狐推荐的每台代理服务器设置为：&lt;= 10。</li></ul><h4 id="Firefox3-6"><a href="#Firefox3-6" class="headerlink" title="Firefox3.6"></a>Firefox3.6</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbxx2j6tj30fq06faa1.jpg" alt="img"></p><p>和 IE8 的几乎完全一样：</p><ul><li>最大并发 HTTP 连接数为 6 个（可在 about:config 中修改）。</li><li>javascript 文件不会阻塞其他资源的加载，多个 javascript 文件可以一起加载。</li><li>会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。</li></ul><h4 id="Firefox4-beta12"><a href="#Firefox4-beta12" class="headerlink" title="Firefox4 beta12"></a>Firefox4 beta12</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jby0whawj30fv07n3yj.jpg" alt="img"></p><p>不知是因为设计理念上的不同，还是因为 beta 版未照顾到这一块，Firefox4 反而退化了，和 Firefox3.6 的区别主要体现在对资源类型的处理上，Firefox4 不再严格地优先下载 script 和 link 标签定义的外部资源，而是按照 HTML 结构中出现的顺序来进行加载。</p><h3 id="IE-浏览器的最大并发连接数"><a href="#IE-浏览器的最大并发连接数" class="headerlink" title="IE 浏览器的最大并发连接数"></a>IE 浏览器的最大并发连接数</h3><p>用“注册表编辑器”命令打开注册表编辑器，找到：</p><p>[HKEY_CURRRENT_USER \ Software \ Microsoft \ Windows \ CurrentVersion \ Internet Settings]，可以看到<strong>MaxConnectionsPerServer</strong>和<strong>MaxConnectionsPer1_0Server</strong>这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置）</p><p><strong>对于 IE 9</strong></p><p>[HKEY_CURRRENT_USER \ Software \ Policies \ Microsoft \ Internet Exploer \ Main \ FeatureControl，可以看到<strong>FEATURE_MAXCONNECTIONSPER1_0SERVER</strong>和<strong>FEATURE_MAXCONNECTIONSPERSERVER</strong>这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置）</p><h4 id="IE8"><a href="#IE8" class="headerlink" title="IE8"></a>IE8</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbx8rdwaj30g407pweh.jpg" alt="img"></p><p>和 IE6 完全不同的瀑布图，其特点有：</p><ul><li>最大并发 HTTP 连接数为 6 个。</li><li>javascript 文件已经不会阻塞其他资源的加载，甚至多个 javascript 文件可以一起加载，并且会保证执行的顺序。</li><li>会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。</li></ul><h3 id="chrome-浏览器的最大并发连接数"><a href="#chrome-浏览器的最大并发连接数" class="headerlink" title="chrome 浏览器的最大并发连接数"></a>chrome 浏览器的最大并发连接数</h3><h4 id="Chrome8"><a href="#Chrome8" class="headerlink" title="Chrome8"></a>Chrome8</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbzcty9xj30fw07zwef.jpg" alt="img"></p><p>Chrome 自带的工具不能很清楚地表示各请求的开始时间，所以使用了 Fiddler 的瀑布图，从图上可以看出，Chrome 也是比较特立独行的一位，其特点有：</p><ul><li>最大并发 HTTP 连接数为 6。</li><li>head 部分的资源会单独下载，且阻塞 body 中的其他资源的加载。</li><li>会优先加载 script 和 link 标签定义的资源。</li></ul><h3 id="opera-浏览器的最大并发连接数"><a href="#opera-浏览器的最大并发连接数" class="headerlink" title="opera 浏览器的最大并发连接数"></a>opera 浏览器的最大并发连接数</h3><h4 id="Opera11"><a href="#Opera11" class="headerlink" title="Opera11"></a>Opera11</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbzixw3tj30fj0813yh.jpg" alt="img"></p><p>先报怨一下，Dragonfly 不怎么好用来着……Opera 的资源加载也比较有特色，而且很难看出规律，只能大致总结一下：</p><ul><li>Opera 的最大并发 HTTP 连接数默认为 16，可在 opera:config - Performance - Max Connections Server 查看和修改。</li><li>javascript 文件的加载会阻塞其他 script 和 link 标签定义的外部资源的加载，如图中的 2.js。但不会阻塞图片等其他资源的加载，如图中的 3.js。</li><li>会一定程度上对资源的优先级进行优化，但由于 javascript 文件要阻止后续部分资源的加载，又为了充分利用最大 HTTP 连接数，因此不能严格先加载所有的 script 和 link 标签定义的资源，导致瀑布图上各类型资源有相互穿插，难寻规律。</li></ul><h2 id="HTTP-连接请求与线程"><a href="#HTTP-连接请求与线程" class="headerlink" title="HTTP 连接请求与线程"></a>HTTP 连接请求与线程</h2><p>HTTP 连接是复杂，有状态的对象，所以它必须被妥善管理。<strong>一个 HTTP 连接请求在同一时间只能被一个线程访问。</strong></p><p>HttpClient 使用一个叫做的 Http 连接管理器的特殊实体类来管理的 Http 连接。Http 连接管理器在新建的 HTTP 连接时，作为工厂类；管理持久的 http 连接的生命周期；同步持久连接（确保线程安全，即一个 HTTP 连接同一时间只能被一个线程访问）。</p><p>如果一个的 Http 连接被释放或者被它的消费者明确表示要关闭，那么底层的连接就会和它的代理进行分离，并且该连接会被交还给连接管理器。这是，即使服务消费者仍然持有代理的引用，它也不能再执行 I / O 操作，或者更改的 Http 连接的状态。</p><h3 id="连接池管理器"><a href="#连接池管理器" class="headerlink" title="连接池管理器"></a>连接池管理器</h3><p>连接池管理器是个复杂的类，它管理着连接池，可以同时为很多线程提供 HTTP 连接请求。当请求一个新的连接时，如果连接池有有可用的持久连接，连接管理器就会使用其中的一个，而不是再创建一个新的连接。</p><p>当使用了请求连接池管理器后，HttpClient 的就可以同时执行多个线程的请求了。</p><p>连接池管理器会根据它的配置来分配请求连接。如果连接池中的所有连接都被占用了，那么后续的请求就会被阻塞，直到有连接被释放回连接池中。</p><h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p>线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：</p><p>线程池在还没有任务到来之前，创建一定数量的线程，放入空闲队列中。这些线程都是处于睡眠状态，即均为启动，不消耗 CPU，而只是占用较小的内存空间。当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。</p><p>线程池能节约大量的的系统资源，使得更多的 CPU 时间和内存用来处理实际的商业应用，而不是频繁的线程创建与销毁</p><p>每个线程需要大约 1MB 内存，线程开的越多，消耗的内存也就越大。</p><p>在什么情况下使用线程池：</p><ol><li>单个任务处理的时间比较短</li><li>将需处理的任务的数量大</li></ol><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池（简单说：在一个“池”里放了好多半成品的数据库联接对象），由应用程序动态地对池中的连接进行申请，使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。<br>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量，使用情况等。</p><p>1）最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费;<br>2）最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p><p><strong>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。</strong>一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。</p><h3 id="WebSphere-Application-Server-性能"><a href="#WebSphere-Application-Server-性能" class="headerlink" title="WebSphere Application Server 性能"></a>WebSphere Application Server 性能</h3><p><a href="http://websphere.sys-con.com/node/46514/print" target="_blank" rel="noopener">http://websphere.sys-con.com/node/46514/print</a></p><p>构建服务器应用程序的一个过于简单的模型是：每当一个请求到达就创建一个新的服务对象，然后在新的服务对象中为服务请求，但当有大量请求并发访问时，服务器不断的创建和销毁对象的开销很大。</p><p>在面向对象的编程中，创建和销毁对象是很浪费资源的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 的中更是如此，虚拟机试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以，提高程序效率的一个手段就是尽可能减少创建和销毁对象的次数。利用已有的对象来服务就是“池化资源”技术产生的原因。</p><p><strong>HTTP 侦听器</strong><br>HTTP 侦听器负责在 HTTP 服务器级别创建线程。这里发生的大多数处理是静态页面服务，或 HTTP post / GET 传递命令到后端。这是必须考虑的第一级线程配置。</p><p><strong>Web 容器</strong><br>Web 容器负责在应用程序服务器级别创建线程池。此级别的大多数处理包括 servlet，JSP，EJB，动态页面创建和后端传递处理。Web 容器是必须配置的第二级线程池配置。</p><p><strong>ORB 容器</strong> ORB 容器负责在对象级创建线程池。这里发生的大部分处理包括处理基于非 Web 的客户端。ORB 容器是必须配置的线程池配置的第三级。</p><p><strong>数据源</strong><br>数据源级负责创建从数据库或“传统”系统访问的连接线程。这些线程是必须解决的第四级配置</p><h3 id="WAS-线程池数与-IHS-server"><a href="#WAS-线程池数与-IHS-server" class="headerlink" title="WAS 线程池数与 IHS server"></a>WAS 线程池数与 IHS server</h3><p>假定一个浏览器的并发连接请求数为 10，通常同一时间内会有多个用户并发访问网站。又考虑到，一个 Http 连接请求在同一时间只能被一个线程访问。所以，IHS 服务器的 httpd.conf 里的 maxclients（允许建立的总线程数）要能够处理峰值时刻的浏览器连接请求才行。同时，考虑不是所有的连接请求都会到 was server，有的连接只是为了在 web 服务器上取静态资源，所以，was 上的线程池数目（Thread pools ：50 ）会远小于 IHS server 上的 maxclients 值譬如 400）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浏览器同域名请求的最大并发数限制&quot;&gt;&lt;a href=&quot;#浏览器同域名请求的最大并发数限制&quot; class=&quot;headerlink&quot; title=&quot;浏览器同域名请求的最大并发数限制&quot;&gt;&lt;/a&gt;浏览器同域名请求的最大并发数限制&lt;/h1&gt;&lt;p&gt;当我们在浏览网页的时候，对浏
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端优化</title>
    <link href="http://yoursite.com/2019/09/08/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/08/前端优化/</id>
    <published>2019-09-08T15:48:15.000Z</published>
    <updated>2019-09-21T14:22:12.510Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h1><h2 id="前端性能衡量指标"><a href="#前端性能衡量指标" class="headerlink" title="前端性能衡量指标"></a>前端性能衡量指标</h2><ul><li><strong>白屏时间</strong> 该时间点表示浏览器开始绘制页面，在此之前页面都是白屏，也称为开始渲染时间</li><li><strong>首屏时间</strong> 该时间点表示用户看到第一屏页面的时间</li><li><strong>用户可交互时间</strong> 也叫 DOM Ready,该时间点表示 DOM 解析完成，资源还没有完成，这个时候用户与页面可以交互了</li><li><strong>完全加载时间</strong> 该时间点是 window.onload 时间触发的时间，表示原始文档和所用引用的内容已经加载完成，用户最明显的感觉就是浏览器 tab 上 loading 状态结束</li><li><strong>首字节时间（TTFB）</strong> 第一字节响应时间（TTFB）=发送请求到 WEB 服务器的时间+WEB 服务器处理请求并生成响应花费的时间+WEB 服务器生成响应到浏览器花费的时间</li><li><strong>DNS 解析时间</strong></li><li><strong>TCP 连接时间</strong></li><li><strong>HTTP 请求时间</strong></li><li><strong>HTTP 响应时间</strong></li></ul><h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><p>雅虎 14 条优化原则：</p><ol><li><p>尽可能的减少 HTTP 的请求数 content</p></li><li><p>使用 CDN（Content Delivery Network） server</p></li><li><p>添加 Expires 头(或者 Cache-control ) server</p></li><li><p>Gzip 组件 server</p></li><li><p>将 CSS 样式放在页面的上方 css</p></li><li><p>将脚本移动到底部（包括内联的） javascript</p></li><li><p>避免使用 CSS 中的 Expressions css</p></li><li><p>将 JavaScript 和 CSS 独立成外部文件 javascript css</p></li><li><p>减少 DNS 查询 content</p></li><li><p>压缩 JavaScript 和 CSS (包括内联的) javascript css</p></li><li><p>避免重定向 server</p></li><li><p>移除重复的脚本 javascript</p></li><li><p>配置实体标签（ETags） css</p></li><li><p>使 AJAX 缓存</p></li></ol><table><thead><tr><th>优化方向</th><th>优化手段</th></tr></thead><tbody><tr><td>请求数量</td><td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域，字体图标，雪碧图片等</td></tr><tr><td>请求带宽</td><td>开启服务器 GZip，精简 JavaScript，移除重复脚本，图像优化（包括图片大小 kb）</td></tr><tr><td>缓存利用</td><td>使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AjaX 可缓存</td></tr><tr><td>页面结构</td><td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td></tr><tr><td>代码校验</td><td>避免 CSS 表达式，避免重定向</td></tr></tbody></table><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//yuchengkai.cn"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用缓存"><a href="#利用缓存" class="headerlink" title="利用缓存"></a>利用缓存</h3><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p><p>通常浏览器缓存策略分为两种：强缓存和协商缓存</p><h4 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h4><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul><h3 id="使用-HTTP-2-0"><a href="#使用-HTTP-2-0" class="headerlink" title="使用 HTTP / 2.0"></a>使用 HTTP / 2.0</h3><p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p><p>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p><h3 id="预加载-amp-懒加载"><a href="#预加载-amp-懒加载" class="headerlink" title="预加载&amp;懒加载"></a>预加载&amp;懒加载</h3><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p><p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><h4 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h4><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染。</p><h4 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h4><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载就是将不关键的资源延后加载。</p><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p><h2 id="文件优化"><a href="#文件优化" class="headerlink" title="文件优化"></a>文件优化</h2><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><h4 id="图片大小计算"><a href="#图片大小计算" class="headerlink" title="图片大小计算"></a>图片大小计算</h4><p>在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p><p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p><ul><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ul><h4 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h4><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h3 id="其他文件优化"><a href="#其他文件优化" class="headerlink" title="其他文件优化"></a>其他文件优化</h3><ul><li>CSS 文件放在 <code>head</code> 中</li><li>服务端开启文件压缩功能</li><li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。</li><li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。—— 科学百科</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6p436ax42j30ia09l74f.jpg" alt="img"></p><h4 id="CDN-存在的意义"><a href="#CDN-存在的意义" class="headerlink" title="CDN 存在的意义"></a>CDN 存在的意义</h4><p>为了不让网络拥塞成为互联网发展的障碍。</p><h4 id="CDN-的优势"><a href="#CDN-的优势" class="headerlink" title="CDN 的优势"></a>CDN 的优势</h4><ol><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li><li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载；</li><li>降低“广播风暴”的影响，提高网络访问的稳定性；节省骨干网带宽，减少带宽需求量。</li></ol><h4 id="CDN-的核心点"><a href="#CDN-的核心点" class="headerlink" title="CDN 的核心点"></a>CDN 的核心点</h4><ul><li><p>缓存：将从根服务器请求来的资源按要求缓存。</p></li><li><p>回源：当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</p></li></ul><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><ol><li>内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；</li><li>内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应；</li><li>内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在 POP 的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；</li><li>性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</li></ol><h4 id="CDN-amp-静态资源"><a href="#CDN-amp-静态资源" class="headerlink" title="CDN &amp; 静态资源"></a>CDN &amp; 静态资源</h4><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段。</p><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="使用-Webpack-优化项目"><a href="#使用-Webpack-优化项目" class="headerlink" title="使用 Webpack 优化项目"></a>使用 Webpack 优化项目</h3><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</p><ul><li>对于跨域的代码运行错误会显示 <code>Script error.</code> 对于这种情况我们需要给 <code>script</code> 标签添加 <code>crossorigin</code> 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li></ul><p>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promise</code> 可以直接使用 <code>catch</code> 函数，<code>async await</code> 可以使用 <code>try catch</code></p><p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。</p><p>对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</p><h2 id="如何优化第二次加载速度？（增量加载）"><a href="#如何优化第二次加载速度？（增量加载）" class="headerlink" title="如何优化第二次加载速度？（增量加载）"></a>如何优化第二次加载速度？（增量加载）</h2><p><a href="https://juejin.im/post/5d00820b5188255ee806a1c7" target="_blank" rel="noopener">前端性能优化三部曲(加载篇)</a></p><p><a href="https://juejin.im/entry/599403656fb9a0247f4f2ee3" target="_blank" rel="noopener">移动 H5 首屏秒开优化方案探讨</a></p><ol><li><strong>降低请求量：</strong>合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li><li><strong>加快请求速度：</strong>预解析 DNS，减少域名数，并行加载，CDN 分发。</li><li><strong>缓存：</strong>HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</li><li><strong>渲染：</strong>JS/CSS 优化，加载顺序，服务端渲染，pipeline。</li></ol><p>其中对首屏启动速度影响最大的就是网络请求，所以优化的重点就是缓存</p><p><strong>增量式更新”</strong>的解决方案，简单地说就是在版本更新的时候不需要重新加载资源，只需要加载一段很小的 diff 信息，然后合并到当前资源上，类似 git merge 的效果。</p><p>增量加载的一种思路：</p><p>1、用户端使用 LocalStorage 或者其它储存方案，存储一份原始代码+时间戳：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    timeStamp: &quot;20161026xxxxxx&quot;,</span><br><span class="line">    data: &quot;aaabbbccc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、每次加载资源的时候向服务器发送这个时间戳；</p><p>3、服务器从接受到时间戳中识别出客户端的版本，和最新的版本做一次 diff，返回两者的 diff 信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff(<span class="string">"aaabbbccc"</span>, <span class="string">"aaagggccc"</span>);</span><br><span class="line"><span class="comment">// 假设我们的diff信息这样表示：</span></span><br><span class="line"><span class="comment">// [3, "-3", "+ggg", 3]</span></span><br></pre></td></tr></table></figure><p>4、客户端接收到这个 diff 信息之后，把本地资源和时间戳更新到最新，实现一次增量更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mergeDiff(<span class="string">"aaabbbccc"</span>, [<span class="number">3</span>, <span class="string">"-3"</span>, <span class="string">"+ggg"</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">//=&gt; "aaagggccc"</span></span><br></pre></td></tr></table></figure><h2 id="面试题（如何渲染几万条数据并不卡住界）"><a href="#面试题（如何渲染几万条数据并不卡住界）" class="headerlink" title="面试题（如何渲染几万条数据并不卡住界）"></a>面试题（如何渲染几万条数据并不卡住界）</h2><p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 <code>requestAnimationFrame</code> 来每 16 ms 刷新一次。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      控件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> total = <span class="number">100000</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 一次插入 20 条，如果觉得性能不好就减少</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> once = <span class="number">20</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 渲染数据总共需要几次</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> loopCount = total / once;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> countOfRender = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 优化性能，插入不会造成回流</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">            li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span></span><br><span class="line">            fragment.appendChild(li);</span><br><span class="line">          &#125;</span><br><span class="line">          ul.appendChild(fragment);</span><br><span class="line">          countOfRender += 1;</span><br><span class="line"><span class="vbscript">          <span class="keyword">loop</span>();</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.requestAnimationFrame(add);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="vbscript">        <span class="keyword">loop</span>();</span></span><br><span class="line">      &#125;, 0);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="拓展知识之-Gzip"><a href="#拓展知识之-Gzip" class="headerlink" title="拓展知识之 Gzip"></a>拓展知识之 Gzip</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome,firefox,IE 等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持 gzip。</p><p>gzip 压缩比率在 3 到 10 倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。</p><h3 id="gzip-工作原理："><a href="#gzip-工作原理：" class="headerlink" title="gzip 工作原理："></a>gzip 工作原理：</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjepqxiaj30go0bcaa9.jpg" alt="img"></p><ol><li>浏览器请求 url，并在 request header 中设置属性 accept-encoding:gzip。表明浏览器支持 gzip。</li><li>服务器收到浏览器发送的请求之后，判断浏览器是否支持 gzip，如果支持 gzip，则向浏览器传送压缩过的内容，不支持则向浏览器发送未经压缩的内容。一般情况下，浏览器和服务器都支持 gzip，response headers 返回包含 content-encoding:gzip。</li><li>浏览器接收到服务器的响应之后判断内容是否被压缩，如果被压缩则解压缩显示页面内容。</li></ol><h3 id="Nginx-中开启-gzip"><a href="#Nginx-中开启-gzip" class="headerlink" title="Nginx 中开启 gzip"></a>Nginx 中开启 gzip</h3><p>如果服务端接口使用 nodejs 和 express，那么开启 nginx 非常简单。启用 compress() 中间件即可并在 nginx.conf 中添加 gzip 配置项即可，express.compress() gzip 压缩中间件，通过 filter 函数设置需要压缩的文件类型。压缩算法为 gzip/deflate。这个中间件应该放置在所有的中间件最前面以保证所有的返回都是被压缩的。如果使用 java 开发，需要配置 filter。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjg93f23j30go03eq2v.jpg" alt="img"></p><p>添加完参数后，运行 nginx –t 检查一下语法，若语法检测通过，则开始访问 url 检测 gzip 是否添加成功。</p><ol><li>gzip on：开启 gzip。</li><li>gzip_comp_level：gzip 压缩比。</li><li>gzip_min_length：允许被压缩的页面最小字节数。</li><li>gzip_types：匹配 MIME 类型进行压缩，text/html 默认被压缩。</li></ol><h3 id="检测-gzip-是否开启"><a href="#检测-gzip-是否开启" class="headerlink" title="检测 gzip 是否开启"></a>检测 gzip 是否开启</h3><p>如果没有现成的项目代码，这里提供一个比较简单的检测方式。首先在本地安装 nginx，在 nginx 默认目录下面添加了两个静态文件 bootstrap.css、bootstrap.js。</p><p>OS X 系统的默认路径为：/usr/local/Cellar/nginx/1.10.2_1/html，Windows 系统直接复制文件到文件夹下面。</p><p>拷贝文件指令可参考：cp -r bootstrap.js /usr/local/Cellar/nginx/1.10.2_1/html，在 nginx 的默认成功跳转页面 index.html 引入这两个静态文件。index.html 页面内容如图所示。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjhnk9acj30go0c90tb.jpg" alt="img"></p><p>做好这一切的准备工作之后，浏览器输入<a href="https://link.juejin.im/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flocalhost%3A8080%2F" target="_blank" rel="noopener">http://localhost:8080/</a>。出现如图所示页面表明 nginx 启动成功。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjii979gj30go048wei.jpg" alt="img"></p><p>nginx 启动成功界面。</p><p>此时打开 Chrome 控制台，可以看到 network 信息，response headers 中返回了 content-encoding:gzip，表明 gzip 开启成功。</p><p>gzip 未开启前 network 信息如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjjd5bavj30go02ogll.jpg" alt="img"></p><p>开启后返回 network 信息如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjjxm19cj30go02m0sp.jpg" alt="img"></p><p>url 请求的 headers 报文如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjk4yn88j30go0a4jrt.jpg" alt="img"></p><p>对比以上三图可以看出 gzip 压缩效率非常高，且经过压缩后静态文件大小不到原来的五分之一。这里值得一提的是静态资源文件越大，gzip 的压缩效率越高。所以对于静态资源量非常大的网站，开启 gzip 可节省大量流量，而同时 gzip 的应用远不止提高 web 性能,Android，IOS 底层网络请求同样可用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端优化&quot;&gt;&lt;a href=&quot;#前端优化&quot; class=&quot;headerlink&quot; title=&quot;前端优化&quot;&gt;&lt;/a&gt;前端优化&lt;/h1&gt;&lt;h2 id=&quot;前端性能衡量指标&quot;&gt;&lt;a href=&quot;#前端性能衡量指标&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CSS的position属性</title>
    <link href="http://yoursite.com/2019/08/31/CSS%E7%9A%84position%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/08/31/CSS的position属性/</id>
    <published>2019-08-31T13:48:53.000Z</published>
    <updated>2019-09-21T14:26:18.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-的-position-属性"><a href="#CSS-的-position-属性" class="headerlink" title="CSS 的 position 属性"></a>CSS 的 position 属性</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>默认值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code>属性无效。</p><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h3 id="定位类型"><a href="#定位类型" class="headerlink" title="定位类型"></a>定位类型</h3><p>相对定位元素，相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。</p><h3 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成相对定位的元素，相对于其正常位置进行定位。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白，”left:20” 会向元素的 LEFT 位置添加 20 像素。）。<code>position:relative</code> 对 <code>table-group</code>, <code>table-row</code>,<code>table-column</code>,<code>table-cell</code>,<code>table-caption</code> 元素无效。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"three"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"four"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#two</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyqx5px1j312q0b40t2.jpg" alt="img"></p><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h3 id="定位类型-1"><a href="#定位类型-1" class="headerlink" title="定位类型"></a>定位类型</h3><p>绝对定位元素，相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于<em>最近的非 static 祖先元素</em>定位。当这样的祖先元素不存在时，则相对于 ICB（inital container block, 初始包含块）。</p><h3 id="定位方式-1"><a href="#定位方式-1" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成绝对定位的元素，不为元素预留空间，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"three"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"four"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#three</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyrszydtj310809e0sz.jpg" alt="image-20190823001646550"></p><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><h3 id="定位类型-2"><a href="#定位类型-2" class="headerlink" title="定位类型"></a>定位类型</h3><p>绝对定位元素，固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。</p><h3 id="定位方式-2"><a href="#定位方式-2" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成绝对定位的元素，不为元素预留空间，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。</p><p><strong>当元素祖先的 <code>transform</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</strong></p><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><h3 id="定位类型-3"><a href="#定位类型-3" class="headerlink" title="定位类型"></a>定位类型</h3><p>粘性定位元素，粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p><h3 id="定位方式-3"><a href="#定位方式-3" class="headerlink" title="定位方式"></a>定位方式</h3><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table 时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code>对 <code>table</code> 元素的效果与 <code>position: relative</code>相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。</p><p>粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>A<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Andrew W.K.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Apparat<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Arcade Fire<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>At The Drive-In<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Aziz Ansari<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>C<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Chromeo<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Common<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Converge<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Crystal Castles<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Cursive<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>E<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Explosions In The Sky<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>T<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Ted Leo &amp; The Pharmacists<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>T-Pain<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Thrice<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>TV On The Radio<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Two Gallants<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">24px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dt</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b8c1c8</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#989ea4</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#717d85</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">18px</span>/<span class="number">21px</span> Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">position</span>: -webkit-sticky;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">20px</span>/<span class="number">45px</span> Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生效规则"><a href="#生效规则" class="headerlink" title="生效规则"></a>生效规则</h3><p><code>position:sticky</code> 的生效是有一定的限制的，总结如下：</p><ol><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。<ul><li>并且 <code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高。</li></ul></li><li>设定为 <code>position:sticky</code> 元素的任意父节点的 overflow 属性必须是 visible，否则 <code>position:sticky</code> 不会生效。这里需要解释一下：<ul><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>overflow:hidden</code>，则父容器无法进行滚动，所以 <code>position:sticky</code> 元素也不会有滚动然后固定的情况。</li><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>position:relative | absolute | fixed</code>，则元素相对父元素进行定位，而不会相对 viewprot 定位。</li></ul></li><li>达到设定的阀值。这个还算好理解，也就是设定了 <code>position:sticky</code> 的元素表现为 <code>relative</code> 还是 <code>fixed</code> 是根据元素是否达到设定了的阈值决定的。</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>同一个父容器中的 sticky 元素，如果定位值相等，则会重叠；如果属于不同父元素，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li></ol><h2 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h2><p><code>initial</code> 关键字用于设置 CSS 属性为它的默认值，可作用于任何 CSS 样式。（IE 不支持该关键字）</p><h2 id="inherit："><a href="#inherit：" class="headerlink" title="inherit："></a>inherit：</h2><p>规定应该从父元素继承 position 属性的值。</p><p>每一个 CSS 属性都有一个特性就是，这个属性必然是默认继承的 (<code>inherited: Yes</code>) 或者是默认不继承的 (<code>inherited: no</code>)其中之一，我们可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference" target="_blank" rel="noopener">MDN</a> 上通过这个索引查找，判断一个属性的是否继承特性。</p><h3 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h3><ul><li>所有元素可继承：visibility 和 cursor</li><li>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction</li><li>块状元素可继承：text-indent 和 text-align</li><li>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image</li><li>表格元素可继承：border-collapse</li></ul><h2 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h2><p><code>unset</code> 关键字我们可以简单理解为不设置。其实，它是关键字 <code>initial</code> 和 <code>inherit</code> 的组合。</p><p>什么意思呢？也就是当我们给一个 CSS 属性设置了 <code>unset</code> 的话：</p><ol><li>如果该属性是默认继承属性，该值等同于 <code>inherit</code></li><li>如果该属性是非继承属性，该值等同于 <code>initial</code></li></ol><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children"</span>&gt;</span>子级元素一<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children unset"</span>&gt;</span>子级元素二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.father &#123; color: red; border: 1px solid black; &#125; .children &#123; color: green;</span><br><span class="line">border: 1px solid blue; &#125; .unset &#123; color: unset; border: unset; &#125;</span><br></pre></td></tr></table></figure><ol><li>由于 <code>color</code> 是可继承样式，设置了 <code>color: unset</code> 的元素，最终表现为了父级的颜色 <code>red</code>。</li><li>由于 <code>border</code> 是不可继承样式，设置了 <code>border: unset</code> 的元素，最终表现为 <code>border: initial</code> ，也就是默认 border 样式，无边框。</li></ol><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>revert 未列入规范</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-的-position-属性&quot;&gt;&lt;a href=&quot;#CSS-的-position-属性&quot; class=&quot;headerlink&quot; title=&quot;CSS 的 position 属性&quot;&gt;&lt;/a&gt;CSS 的 position 属性&lt;/h1&gt;&lt;h2 id=&quot;stati
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>ES6 装饰器</title>
    <link href="http://yoursite.com/2019/08/18/ES6%20%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2019/08/18/ES6 装饰器/</id>
    <published>2019-08-18T14:47:55.000Z</published>
    <updated>2019-09-21T13:59:04.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-装饰器"><a href="#ES6-装饰器" class="headerlink" title="ES6 装饰器"></a>ES6 装饰器</h1><p>装饰器（Decorator）是一种与类（class）相关的语法，<strong>用来注释或修改类和类方法</strong>。装饰器是一种函数，写成<code>@ + 函数名</code>。它可以放在类和类方法的定义前面。</p>  <a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@frozen</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  @configurable(<span class="literal">false</span>)</span><br><span class="line">  @enumerable(<span class="literal">true</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @throttle(<span class="number">500</span>)</span><br><span class="line">  expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。</p><p><strong>Proxy 的核心作用是控制外界对被代理者内部的访问，Decorator 的核心作用是增强被装饰者的功能。著作权归作者所有。</strong></p><h2 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h2><p>装饰器可以用来装饰整个类。</p><h3 id="为类添加静态属性"><a href="#为类添加静态属性" class="headerlink" title="为类添加静态属性"></a>为类添加静态属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>@testable</code>就是一个装饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p><p>基本上，装饰器的行为就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，<strong>装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</strong></p><p>如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，装饰器<code>testable</code>可以接受参数，这就等于可以修改装饰器的行为。</p><p><strong>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</strong></p><h3 id="为类添加实例属性"><a href="#为类添加实例属性" class="headerlink" title="为类添加实例属性"></a>为类添加实例属性</h3><p>如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，装饰器函数<code>testable</code>是在目标类的<code>prototype</code>对象上添加属性，因此就可以在实例上调用。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">"./mixins"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码通过装饰器<code>mixins</code>，把<code>Foo</code>对象的方法添加到了<code>MyClass</code>的实例上面。可以用<code>Object.assign()</code>模拟这个功能。</p><h2 id="方法的装饰"><a href="#方法的装饰" class="headerlink" title="方法的装饰"></a>方法的装饰</h2><h3 id="装饰器修改属性的描述对象"><a href="#装饰器修改属性的描述对象" class="headerlink" title="装饰器修改属性的描述对象"></a>装饰器修改属性的描述对象</h3><p>装饰器不仅可以装饰类，还可以装饰类的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，装饰器<code>readonly</code>用来装饰“类”的<code>name</code>方法。</p><p>装饰器函数<code>readonly</code>一共可以接受三个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// descriptor对象原来的值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//   enumerable: false,</span></span><br><span class="line">  <span class="comment">//   configurable: true,</span></span><br><span class="line">  <span class="comment">//   writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">"name"</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, descriptor);</span><br></pre></td></tr></table></figure><p>装饰器第一个参数是类的原型对象，上例是<code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但是<strong>这个时候实例还没生成，所以只能去装饰原型</strong>（这不同于类的装饰，那种情况时<code>target</code>参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。</p><p>另外，上面代码说明，<strong>装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</strong></p><p>下面是另一个例子，修改属性描述对象的<code>enumerable</code>属性，使得该属性不可遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="keyword">get</span> kidCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.children.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的<code>@log</code>装饰器，可以起到输出日志的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with`</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// passed parameters should get logged now</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>@log</code>装饰器的作用就是在执行原始的操作之前，执行一次<code>console.log</code>，从而达到输出日志的目的。</p><h3 id="装饰器的注释作用"><a href="#装饰器的注释作用" class="headerlink" title="装饰器的注释作用"></a>装饰器的注释作用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中，我们一眼就能看出，<code>Person</code>类是可测试的，而<code>name</code>方法是只读和不可枚举的。</p><p>下面是使用 Decorator 写法的<a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener">组件</a>，看上去一目了然。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  tag: <span class="string">"my-component"</span>,</span><br><span class="line">  styleUrl: <span class="string">"my-component.scss"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  @Prop() first: string;</span><br><span class="line">  @Prop() last: string;</span><br><span class="line">  @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Hello, my name is &#123;<span class="keyword">this</span>.first&#125; &#123;<span class="keyword">this</span>.last&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h3><p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"evaluated"</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"executed"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  @dec(<span class="number">1</span>)</span><br><span class="line">  @dec(<span class="number">2</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行。</p><h3 id="装饰器可用作类型检查"><a href="#装饰器可用作类型检查" class="headerlink" title="装饰器可用作类型检查"></a>装饰器可用作类型检查</h3><p>除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</p><h2 id="为什么装饰器不能用于函数"><a href="#为什么装饰器不能用于函数" class="headerlink" title="为什么装饰器不能用于函数"></a>为什么装饰器不能用于函数</h2><h3 id="函数提升，类没有提升"><a href="#函数提升，类没有提升" class="headerlink" title="函数提升，类没有提升"></a>函数提升，类没有提升</h3><p>装饰器只能用于类和类的方法，不能用于函数，<strong>因为存在函数提升</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0。因为函数提升，使得实际执行的代码是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter;</span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly = <span class="built_in">require</span>(<span class="string">"some-decorator"</span>);</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也有问题，因为实际执行是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly;</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readOnly = <span class="built_in">require</span>(<span class="string">"some-decorator"</span>);</span><br></pre></td></tr></table></figure><p>总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><h3 id="函数一定要用装饰器"><a href="#函数一定要用装饰器" class="headerlink" title="函数一定要用装饰器"></a>函数一定要用装饰器</h3><p>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingDecorator</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Starting"</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure><h2 id="常见装饰器"><a href="#常见装饰器" class="headerlink" title="常见装饰器"></a>常见装饰器</h2><p><a href="https://github.com/jayphelps/core-decorators.js" target="_blank" rel="noopener">core-decorators.js</a>是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。</p><h3 id="1-autobind"><a href="#1-autobind" class="headerlink" title="1. @autobind"></a>1. @autobind</h3><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; autobind &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @autobind</span><br><span class="line">  getPerson() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.getPerson;</span><br><span class="line"></span><br><span class="line">getPerson() === person;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2-readonly"><a href="#2-readonly" class="headerlink" title="2. @readonly"></a>2. @readonly</h3><p><code>readonly</code>装饰器使得属性或方法不可写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  entree = <span class="string">"steak"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dinner = <span class="keyword">new</span> Meal();</span><br><span class="line">dinner.entree = <span class="string">"salmon"</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property 'entree' of [object Object]</span></span><br></pre></td></tr></table></figure><h3 id="3-override"><a href="#3-override" class="headerlink" title="3. @override"></a>3. @override</h3><p><code>override</code>装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; override &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  speak(first, second) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  @override</span><br><span class="line">  speak() &#123;&#125;</span><br><span class="line">  <span class="comment">// SyntaxError: Child#speak() does not properly override Parent#speak(first, second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  @override</span><br><span class="line">  speaks() &#123;&#125;</span><br><span class="line">  <span class="comment">// SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   Did you mean "speak"?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-deprecate-别名-deprecated"><a href="#4-deprecate-别名-deprecated" class="headerlink" title="4. @deprecate (别名@deprecated)"></a>4. @deprecate (别名@deprecated)</h3><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; deprecate &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @deprecate</span><br><span class="line">  facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">"We stopped facepalming"</span>)</span><br><span class="line">  facepalmHard() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">"We stopped facepalming"</span>, &#123;</span><br><span class="line">    url: <span class="string">"http://knowyourmeme.com/memes/facepalm"</span></span><br><span class="line">  &#125;)</span><br><span class="line">  facepalmHarder() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalm();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalm: This function will be removed in future versions.</span></span><br><span class="line"></span><br><span class="line">person.facepalmHard();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHard: We stopped facepalming</span></span><br><span class="line"></span><br><span class="line">person.facepalmHarder();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHarder: We stopped facepalming</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     See http://knowyourmeme.com/memes/facepalm for more details.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="5-suppressWarnings"><a href="#5-suppressWarnings" class="headerlink" title="5. @suppressWarnings"></a>5. @suppressWarnings</h3><p><code>suppressWarnings</code>装饰器抑制<code>deprecated</code>装饰器导致的<code>console.warn()</code>调用。但是，异步代码发出的调用除外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; suppressWarnings &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @deprecated</span><br><span class="line">  facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @suppressWarnings</span><br><span class="line">  facepalmWithoutWarning() &#123;</span><br><span class="line">    <span class="keyword">this</span>.facepalm();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalmWithoutWarning();</span><br><span class="line"><span class="comment">// no warning is logged</span></span><br></pre></td></tr></table></figure><h2 id="使用装饰器实现自动发布事件"><a href="#使用装饰器实现自动发布事件" class="headerlink" title="使用装饰器实现自动发布事件"></a>使用装饰器实现自动发布事件</h2><p>我们可以使用装饰器，使得对象的方法被调用时，自动发出一个事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postal = <span class="built_in">require</span>(<span class="string">"postal/lib/postal.lodash"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">topic, channel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> channelName = channel || <span class="string">"/"</span>;</span><br><span class="line">  <span class="keyword">const</span> msgChannel = postal.channel(channelName);</span><br><span class="line">  msgChannel.subscribe(topic, v =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"频道: "</span>, channelName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"事件: "</span>, topic);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数据: "</span>, v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> value = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      msgChannel.publish(topic, value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个名为<code>publish</code>的装饰器，它通过改写<code>descriptor.value</code>，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是<a href="https://github.com/postaljs/postal.js" target="_blank" rel="noopener">Postal.js</a>。</p><p>它的用法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> publish <span class="keyword">from</span> <span class="string">"./publish"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooComponent</span> </span>&#123;</span><br><span class="line">  @publish(<span class="string">"foo.some.message"</span>, <span class="string">"component"</span>)</span><br><span class="line">  someMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">my</span>: <span class="string">"data"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @publish(<span class="string">"foo.some.other"</span>)</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> FooComponent();</span><br><span class="line"></span><br><span class="line">foo.someMethod();</span><br><span class="line">foo.anotherMethod();</span><br></pre></td></tr></table></figure><p>以后，只要调用<code>someMethod</code>或者<code>anotherMethod</code>，就会自动发出一个事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bash-node index.js</span><br><span class="line">频道:  component</span><br><span class="line">事件:  foo.some.message</span><br><span class="line">数据:  &#123; my: <span class="string">'data'</span> &#125;</span><br><span class="line"></span><br><span class="line">频道:  /</span><br><span class="line">事件:  foo.some.other</span><br><span class="line">数据:  undefined</span><br></pre></td></tr></table></figure><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><p>在装饰器的基础上，可以实现<code>Mixin</code>模式。所谓<code>Mixin</code>模式，就是<strong>对象继承的一种替代方案</strong>，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p><p>请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码之中，对象<code>Foo</code>有一个<code>foo</code>方法，通过<code>Object.assign</code>方法，可以将<code>foo</code>方法“混入”<code>MyClass</code>类，导致<code>MyClass</code>的实例<code>obj</code>对象都具有<code>foo</code>方法。这就是“混入”模式的一个简单实现。</p><p>下面，我们部署一个通用脚本<code>mixins.js</code>，将 Mixin 写成一个装饰器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以使用上面这个装饰器，为类“混入”各种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">"./mixins"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure><p>通过<code>mixins</code>这个装饰器，实现了在<code>MyClass</code>类上面“混入”<code>Foo</code>对象的<code>foo</code>方法。</p><p>不过，上面的方法会改写<code>MyClass</code>类的<code>prototype</code>对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyBaseClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>继承了<code>MyBaseClass</code>。如果我们想在<code>MyClass</code>里面“混入”一个<code>foo</code>方法，一个办法是在<code>MyClass</code>和<code>MyBaseClass</code>之间插入一个混入类，这个类具有<code>foo</code>方法，并且继承了<code>MyBaseClass</code>的所有方法，然后<code>MyClass</code>再继承这个类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyMixin = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from MyMixin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyMixin</code>是一个混入类生成器，接受<code>superclass</code>作为参数，然后返回一个继承<code>superclass</code>的子类，该子类包含一个<code>foo</code>方法。</p><p>接着，目标类再去继承这个混入类，就达到了“混入”<code>foo</code>方法的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyMixin</span>(<span class="title">MyBaseClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line">c.foo(); <span class="comment">// "foo from MyMixin"</span></span><br></pre></td></tr></table></figure><p>如果需要“混入”多个方法，就生成多个混入类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">MyBaseClass</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的一个好处，是可以调用<code>super</code>，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Mixin1 = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from Mixin1"</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Mixin2 = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from Mixin2"</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo from S"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">S</span>)) </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo from C"</span>);</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，每一次<code>混入</code>发生时，都调用了父类的<code>super.foo</code>方法，导致父类的同名方法没有被覆盖，行为被保留了下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> C().foo();</span><br><span class="line"><span class="comment">// foo from C</span></span><br><span class="line"><span class="comment">// foo from Mixin1</span></span><br><span class="line"><span class="comment">// foo from Mixin2</span></span><br><span class="line"><span class="comment">// foo from S</span></span><br></pre></td></tr></table></figure><h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>Trait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。</p><p>下面采用<a href="https://github.com/CocktailJS/traits-decorator" target="_blank" rel="noopener">traits-decorator</a>这个第三方模块作为例子。这个模块提供的<code>traits</code>装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码中，通过<code>traits</code>装饰器，在<code>MyClass</code>类上面“混入”了<code>TFoo</code>类的<code>foo</code>方法和<code>TBar</code>对象的<code>bar</code>方法。</p><p>Trait 不允许“混入”同名方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// throw new Error('Method named: ' + methodName + ' is defined twice.');</span></span><br><span class="line"><span class="comment">//        ^</span></span><br><span class="line"><span class="comment">// Error: Method named: foo is defined twice.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>TFoo</code>和<code>TBar</code>都有<code>foo</code>方法，结果<code>traits</code>装饰器报错。</p><p>一种解决方法是排除<code>TBar</code>的<code>foo</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits, excludes &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::excludes(<span class="string">"foo"</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码使用绑定运算符（::）在<code>TBar</code>上排除<code>foo</code>方法，混入时就不会报错了。</p><p>另一种方法是为<code>TBar</code>的<code>foo</code>方法起一个别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits, alias &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::alias(&#123; <span class="attr">foo</span>: <span class="string">"aliasFoo"</span> &#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.aliasFoo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码为<code>TBar</code>的<code>foo</code>方法起了别名<code>aliasFoo</code>，于是<code>MyClass</code>也可以混入<code>TBar</code>的<code>foo</code>方法了。</p><p><code>alias</code>和<code>excludes</code>方法，可以结合起来使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@traits(TExample::excludes(<span class="string">"foo"</span>, <span class="string">"bar"</span>)::alias(&#123; <span class="attr">baz</span>: <span class="string">"exampleBaz"</span> &#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码排除了<code>TExample</code>的<code>foo</code>方法和<code>bar</code>方法，为<code>baz</code>方法起了别名<code>exampleBaz</code>。</p><p><code>as</code>方法则为上面的代码提供了另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@traits(</span><br><span class="line">  TExample::<span class="keyword">as</span>(&#123; <span class="attr">excludes</span>: [<span class="string">"foo"</span>, <span class="string">"bar"</span>], <span class="attr">alias</span>: &#123; <span class="attr">baz</span>: <span class="string">"exampleBaz"</span> &#125; &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-装饰器&quot;&gt;&lt;a href=&quot;#ES6-装饰器&quot; class=&quot;headerlink&quot; title=&quot;ES6 装饰器&quot;&gt;&lt;/a&gt;ES6 装饰器&lt;/h1&gt;&lt;p&gt;装饰器（Decorator）是一种与类（class）相关的语法，&lt;strong&gt;用来注释或修改类和类方法&lt;/strong&gt;。装饰器是一种函数，写成&lt;code&gt;@ + 函数名&lt;/code&gt;。它可以放在类和类方法的定义前面。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>QUIC</title>
    <link href="http://yoursite.com/2019/08/16/QUIC/"/>
    <id>http://yoursite.com/2019/08/16/QUIC/</id>
    <published>2019-08-15T17:52:20.000Z</published>
    <updated>2019-09-21T14:26:18.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h1><h2 id="QUIC-概述"><a href="#QUIC-概述" class="headerlink" title="QUIC 概述"></a>QUIC 概述</h2><p>Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。</p><p>QUIC 协议内置了 TLS 栈，实现了自己的<a href="https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit" target="_blank" rel="noopener">传输加密层</a>，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izr9eluaj315w0k0aaa.jpg" alt="img"></p><p>从图上可以看出，QUIC 底层通过 UDP 协议替代了 TCP，上层只需要一层用于和远程服务器交互的 HTTP/2 API。这是因为 QUIC 协议已经包含了多路复用和连接管理，HTTP API 只需要完成 HTTP 协议的解析即可。</p><h2 id="QUIC-优势"><a href="#QUIC-优势" class="headerlink" title="QUIC 优势"></a>QUIC 优势</h2><ol><li>减少了 TCP 三次握手及 TLS 握手时间。</li><li>改进的拥塞控制。</li><li>避免队头阻塞的多路复用。</li><li>连接迁移。</li><li>前向冗余纠错。（目前默认的冗余量是 10%，既每发送 10 个数据包，其冗余数据就可以重新构建一个丢失的数据包）</li></ol><h2 id="为什么需要-QUIC"><a href="#为什么需要-QUIC" class="headerlink" title="为什么需要 QUIC"></a>为什么需要 QUIC</h2><ol><li><p>协议历史悠久导致中间设备僵化。</p><p>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口（80、443）及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p></li><li><p>依赖于操作系统的实现导致协议本身僵化。</p><p>TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。</p></li><li><p>建立连接的握手延迟大。</p><p>不管是 HTTP1.0/1.1 还是 HTTPS，HTTP2，都使用了 TCP 进行传输。HTTPS 和 HTTP2 还需要使用 TLS 协议来进行安全传输。这就出现了两个握手延迟：</p><ul><li>TCP 三次握手导致的 TCP 连接建立的延迟。</li><li>TLS 完全握手需要至少 2 个 RTT 才能建立，简化握手需要 1 个 RTT 的握手延迟。</li></ul><p>对于很多短连接场景，这样的握手延迟影响很大，且无法消除。</p></li><li><p>队头阻塞。</p><p>队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。</p><p>另外 TLS 协议层面也有一个队头阻塞，因为 TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。</p></li></ol><p><strong>QUIC 协议选择了 UDP，因为 UDP 本身没有连接的概念，不需要三次握手，优化了连接建立的握手延迟，同时在应用程序层面实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性，只需要用户端和服务端的应用程序支持 QUIC 协议，完全避开了操作系统和中间设备的限制。</strong></p><h2 id="QUIC-详解"><a href="#QUIC-详解" class="headerlink" title="QUIC 详解"></a>QUIC 详解</h2><h3 id="1-QUIC-核心特性连接建立延时低"><a href="#1-QUIC-核心特性连接建立延时低" class="headerlink" title="1. QUIC 核心特性连接建立延时低"></a>1. QUIC 核心特性连接建立延时低</h3><p><strong>0RTT 建连</strong>可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</p><ol><li>传输层 0RTT 就能建立连接。</li><li>加密层 0RTT 就能建立加密连接。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izr8c4vjj314a0n0gpa.jpg" alt="img"></p><p>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption[14]，也需要至少 2 个 RTT。</p><p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket[13] 要高很多。</p><h3 id="2-改进的拥塞控制"><a href="#2-改进的拥塞控制" class="headerlink" title="2. 改进的拥塞控制"></a>2. 改进的拥塞控制</h3><p>TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。</p><p>QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。</p><p>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</p><ul><li><strong>可插拔</strong></li></ul><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：</p><ol><li>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</li><li>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</li><li>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。</li></ol><p>STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</p><ul><li><strong>单调递增的 Packet Number</strong></li></ul><p>TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。</p><p>QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrp5123j30k008rjro.jpg" alt="img"></p><p>​ 图 2 Tcp 重传歧义性</p><p>如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。</p><p>如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。</p><p>由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrs95mpj30k007xjrn.jpg" alt="img"></p><p>​ 图 3 Quic 重传没有歧义性</p><p>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。</p><p>但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 Stream Offset 的概念。</p><p>即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。但是 Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。如错误! 未找到引用源。所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。</p><p>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrw4o31j30k005smxc.jpg" alt="img"></p><p>​ 图 4 Stream Offset 保证有序性</p><ul><li><strong>不允许 Reneging</strong></li></ul><p>什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。</p><p>Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据。</p><p>QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰。</p><ul><li><strong>更多的 Ack 块</strong></li></ul><p>TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</p><p>由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 [25]，所以留给 Sack 选项的只有 30 个字节。</p><p>每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。</p><p>但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。</p><ul><li><strong>Ack Delay 时间</strong></li></ul><p>Tcp 的 Timestamp 选项存在一个问题，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。</p><p>这样就会导致 RTT 计算误差。如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrzqtwlj30k00f4wf5.jpg" alt="img"></p><p>可以认为 TCP 的 RTT 计算：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs42dncj308d015743.jpg" alt="img"></p><p>而 Quic 计算如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs6x1lbj30a70153yc.jpg" alt="img"></p><p>当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式 [9]。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs9tffbj308d01vwed.jpg" alt="img"></p><h3 id="3-基于-stream-和-connecton-级别的流量控制"><a href="#3-基于-stream-和-connecton-级别的流量控制" class="headerlink" title="3.基于 stream 和 connecton 级别的流量控制"></a>3.基于 stream 和 connecton 级别的流量控制</h3><p>QUIC 的流量控制类似 HTTP2，即在 Connection 和 Stream 级别提供了两种流量控制。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。</p><ol><li>Stream 可以认为就是一条 HTTP 请求。</li><li>Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</li></ol><p>QUIC 实现流量控制的原理比较简单：</p><p>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</p><p>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</p><p>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。</p><p>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsddv9lj30k0087q3a.jpg" alt="img"></p><p>​ 图 5 Quic Flow Control</p><p>针对 Stream：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsh7d39j30bz011glh.jpg" alt="img"></p><p>针对 Connection：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsk0cpyj30gy011a9z.jpg" alt="img"></p><p>同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。</p><p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p><h3 id="4-没有队头阻塞的多路复用"><a href="#4-没有队头阻塞的多路复用" class="headerlink" title="4.没有队头阻塞的多路复用"></a>4.没有队头阻塞的多路复用</h3><p>QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。</p><p>QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。</p><p>这也就在很大程度上缓解甚至消除了队头阻塞的影响。</p><p>多路复用是 HTTP2 最强大的特性，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞，如下图示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsn9t0ej30k007gq3a.jpg" alt="img"></p><p>​ 图 6 HTTP2 队头阻塞</p><p>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。</p><p>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞 [12]。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsr1djhj30k00ctaac.jpg" alt="img"></p><p>​ 图 7 TLS 队头阻塞</p><p>Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。</p><p>那 QUIC 多路复用为什么能避免上述问题呢？</p><ol><li>QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。</li><li>Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。（QUIC 协议直接通过底层使用 UDP 协议天然的避免了该问题。由于 UDP 协议没有严格的顺序，当一个数据包遇到问题需要重传时，只会影响该数据包对应的资源，其他独立的资源（如其他 css、js 文件）不会受到影响）</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsvoeyqj30k007gdg7.jpg" alt="img"></p><p>​ 图 8 QUIC 多路复用时没有队头阻塞的问题</p><p>当然，并不是所有的 QUIC 数据都不会受到队头阻塞的影响，比如 QUIC 当前也是使用 Hpack 压缩算法 [10]，由于算法的限制，丢失一个头部数据时，可能遇到队头阻塞。</p><p>总体来说，QUIC 在传输大量数据时，比如视频，受到队头阻塞的影响很小。</p><h3 id="5-加密认证的报文"><a href="#5-加密认证的报文" class="headerlink" title="5.加密认证的报文"></a>5.加密认证的报文</h3><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><p>如下图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsyv3ovj30i3091dgf.jpg" alt="img"></p><h3 id="6-连接迁移"><a href="#6-连接迁移" class="headerlink" title="6.连接迁移"></a>6.连接迁移</h3><p>一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。</p><p>比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。</p><p>又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。</p><p>针对 TCP 的连接变化，MPTCP 其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。</p><p>所以从 TCP 连接的角度来讲，这个问题是无解的。</p><p>那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。</p><p>由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。</p><h3 id="7-其他亮点"><a href="#7-其他亮点" class="headerlink" title="7.其他亮点"></a>7.其他亮点</h3><p>此外，QUIC 还能实现前向冗余纠错，在重要的包比如握手消息发生丢失时，能够根据冗余信息还原出握手消息。</p><p>QUIC 还能实现证书压缩，减少证书传输量，针对包头进行验证等。</p><h2 id="QUIC-协议实践"><a href="#QUIC-协议实践" class="headerlink" title="QUIC 协议实践"></a>QUIC 协议实践</h2><p>Chrome 浏览器从 2014 年开始已经实验性的支持了 QUIC 协议。可以通过在 Chrome 浏览器中输入<code>chrome://net-internals/#quic</code>查看是否已经支持 QUIC 协议。如果还未支持，可以在<code>chrome://flags/#enable-quic</code>中进行开启。</p><p>开始 Chrome 浏览器对 QUIC 协议的支持之后，可以在<code>chrome://net-internals/#quic</code>中查看到当前浏览器的 QUIC 一些连接。当然目前只有 Google 服务才支持 QUIC 协议（如 YouTube、 Google.com）。</p><h3 id="1-关于防火墙"><a href="#1-关于防火墙" class="headerlink" title="1. 关于防火墙"></a>1. 关于防火墙</h3><p>通常系统管理员会关注防火墙的 TCP 规则，而忽略 UDP 规则。如果要在防火墙之后使用 QUIC 协议，除了传统 web 服务需要开放的<code>80/TCP</code>、<code>443/TCP</code>之外，针对 QUIC 还需要开放<code>443/UDP</code>的访问。</p><h3 id="2-服务端使用-QUIC-协议"><a href="#2-服务端使用-QUIC-协议" class="headerlink" title="2.服务端使用 QUIC 协议"></a>2.服务端使用 QUIC 协议</h3><p>目前支持 QUIC 协议的 web 服务只有 0.9 版本以后的<a href="https://github.com/mholt/caddy/wiki/QUIC" target="_blank" rel="noopener">Caddy</a>。其他常用 web 服务如 nginx、apache 等都未开始支持。curl 表达了对 QUIC 协议<a href="https://daniel.haxx.se/blog/2016/07/20/curl-wants-to-quic/" target="_blank" rel="noopener">支持的兴趣</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;QUIC&quot;&gt;&lt;a href=&quot;#QUIC&quot; class=&quot;headerlink&quot; title=&quot;QUIC&quot;&gt;&lt;/a&gt;QUIC&lt;/h1&gt;&lt;h2 id=&quot;QUIC-概述&quot;&gt;&lt;a href=&quot;#QUIC-概述&quot; class=&quot;headerlink&quot; title=&quot;QUIC 概述&quot;&gt;&lt;/a&gt;QUIC 概述&lt;/h2&gt;&lt;p&gt;Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。&lt;/p&gt;
&lt;p&gt;QUIC 协议内置了 TLS 栈，实现了自己的&lt;a href=&quot;https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传输加密层&lt;/a&gt;，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="http://yoursite.com/2019/08/11/TCP/"/>
    <id>http://yoursite.com/2019/08/11/TCP/</id>
    <published>2019-08-11T13:15:33.000Z</published>
    <updated>2019-09-21T14:05:31.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul><li>TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment）</li><li>IP 在第三层——Network 层（在第三层上的数据叫 Packet）</li><li>ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame）</li></ul><p>我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p><a id="more"></a><h2 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izttyfinj30m8090jsz.jpg" alt="img"></p><p>你需要注意这么几点：</p><ul><li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li><li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li><li>注意上图中的四个非常重要的东西：<ul><li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li><li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li><li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li><li><strong>TCP Flag</strong> ，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li></ul></li></ul><h2 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h2><p>其实，<strong>网络上的传输是没有连接的，包括 TCP 也是一样的</strong>。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。</p><p>“<strong>TCP 协议的状态机</strong>”和 “<strong>TCP 建链接</strong>”、“<strong>TCP 断链接</strong>”、“<strong>传数据</strong>” 的对照图</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcpfsm.png" style="zoom:70%;display:inline"><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcp_open_close.jpg" style="zoom:40%;display:inline"></p><p>很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？</p><ul><li><strong>对于建链接的 3 次握手，</strong>主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number）——所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。</li><li><strong>对于 4 次挥手，</strong>其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）：</li></ul><h2 id="数据传输中的-Sequence-Number"><a href="#数据传输中的-Sequence-Number" class="headerlink" title="数据传输中的 Sequence Number"></a>数据传输中的 Sequence Number</h2><p>下图是从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 Statistics -&gt;Flow Graph… ）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5nx0rq0j30al0a1jsq.jpg" alt="img"></p><p>你可以看到，<strong>SeqNum 的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。</p><p><strong>注意</strong>：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为 0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum——相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p><h2 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h2><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p><h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4——意味着 3 和 4 都收到了。</p><p>但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。</p><p>对此有两种选择：</p><ul><li>一种是仅重传 timeout 的包。也就是第 3 份数据。</li><li>另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。</li></ul><p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的）</p><h3 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h3><p>于是，TCP 引入了一种叫<strong>Fast Retransmit</strong> 的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。Fast Retransmit 的好处是不用等 timeout 了再重传。</p><p>比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack=2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5o1shzuj30ci0833yx.jpg" alt="img"></p><p>Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2 呢还是重传#2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2)是谁传回来的？也许发送端发了 20 份数据，是#6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。</p><h3 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h3><p>另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（参看<a href="http://tools.ietf.org/html/rfc2018" target="_blank" rel="noopener">RFC 2018</a>），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5o7gj8sj30sg0g1ta5.jpg" alt="img"></p><p>这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过<strong>tcp_sack</strong>参数打开这个功能（Linux 2.4 后默认打开）。</p><p>这里还需要注意一个问题——<strong>接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了</strong>。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。<strong>所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。</strong></p><p>注意：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。</p><h3 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h3><p>Duplicate SACK 又称 D-SACK，<strong>其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了</strong>。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="noopener">RFC-2883 </a>里有详细描述和示例。下面举几个例子（来源于<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="noopener">RFC-2883</a>）</p><p>D-SACK 使用了 SACK 的第一个段来做标志，</p><ul><li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK</li><li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK</li></ul><h4 id="示例一：ACK-丢包"><a href="#示例一：ACK-丢包" class="headerlink" title="示例一：ACK 丢包"></a>示例一：ACK 丢包</h4><p>下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个 SACK=3000-3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transmitted  Received    ACK Sent</span><br><span class="line">Segment      Segment     (Including SACK Blocks)</span><br><span class="line">3000-3499    3000-3499   3500 (ACK dropped)</span><br><span class="line">3500-3999    3500-3999   4000 (ACK dropped)</span><br><span class="line">3000-3499    3000-3499   4000, SACK=3000-3500</span><br><span class="line">                                    ---------</span><br></pre></td></tr></table></figure><h4 id="示例二，网络延误"><a href="#示例二，网络延误" class="headerlink" title="示例二，网络延误"></a>示例二，网络延误</h4><p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK=1000-1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK——标识收到了重复的包。</p><p>这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transmitted    Received    ACK Sent</span><br><span class="line">Segment        Segment     (Including SACK Blocks)</span><br><span class="line"><span class="number">500</span><span class="number">-999</span>        <span class="number">500</span><span class="number">-999</span>     <span class="number">1000</span></span><br><span class="line">1000-1499      (delayed)</span><br><span class="line">1500-1999      1500-1999   1000, SACK=1500-2000</span><br><span class="line">2000-2499      2000-2499   1000, SACK=1500-2500</span><br><span class="line">2500-2999      2500-2999   1000, SACK=1500-3000</span><br><span class="line"><span class="number">1000</span><span class="number">-1499</span>      <span class="number">1000</span><span class="number">-1499</span>   <span class="number">3000</span></span><br><span class="line">               1000-1499   3000, SACK=1000-1500</span><br><span class="line">                                      ---------</span><br></pre></td></tr></table></figure><p>可见，引入了 D-SACK，有这么几个好处：</p><p>1）可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。</p><p>2）是不是自己的 timeout 太小了，导致重传。</p><p>3）网络上出现了先发的包后到的情况（又称 reordering）</p><p>4）网络上是不是把我的数据包给复制了。</p><p><strong>知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控</strong>。</p><p>Linux 下的 tcp_dsack 参数用于开启这个功能（Linux 2.4 后默认打开）</p><h2 id="TCP-的-RTT-算法"><a href="#TCP-的-RTT-算法" class="headerlink" title="TCP 的 RTT 算法"></a>TCP 的 RTT 算法</h2><p>从前面的 TCP 重传机制我们知道 Timeout 的设置对于重传非常重要。</p><ul><li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP 引入了 RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置 Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下 t0，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p><h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><p><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a> 中定义的经典算法是这样的：</p><p>1）首先，先采样 RTT，记下最近好几次的 RTT 值。</p><p>2）然后做平滑计算 SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 Exponential weighted moving average，中文叫：加权移动平均）</p><p><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p><p>3）开始计算 RTO。公式如下：</p><p><strong>RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ]</strong></p><p>其中：</p><ul><li>UBOUND 是最大的 timeout 时间，上限值</li><li>LBOUND 是最小的 timeout 时间，下限值</li><li>β 值一般在 1.3 到 2.0 之间。</li></ul><h3 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h3><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和 ack 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？</p><p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p><ul><li>情况（a）是 ack 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。</li><li>情况（b）是 ack 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5odttngj30kp098mxm.jpg" alt="img"></p><p>所以 1987 年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn's_Algorithm" target="_blank" rel="noopener">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的 RTT 做采样</strong>（你看，你不需要去解决不存在的问题）。</p><p>但是，这样一来，又会引发一个大 BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的 RTO 很小），于是，因为重转的不算，所以，RTO 就不会被更新，这是一个灾难</strong>。 于是 Karn 算法用了一个取巧的方式——只要一发生重传，就对现有的 RTO 值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的 RTT 也不靠谱。</p><h3 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h3><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果 RTT 有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988 年，又有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC6289</a>）。这个算法引入了最新的 RTT 的采样和平滑过的 SRTT 的差距做因子来计算。 公式如下：（其中的 DevRTT 是 Deviation RTT 的意思）</p><p><strong>SRTT</strong> <strong>= S**</strong>RTT** <strong>+ α</strong> <strong>(**</strong>RTT** <strong>– S**</strong>RTT*<strong>*)</strong> —— 计算平滑 RTT</p><p><strong>DevRTT</strong> <strong>= (1-β**</strong>)**<strong>*DevRTT</strong> <strong>+ β***</strong>(|*<strong>*RTT-SRTT**</strong>|)** ——计算平滑 RTT 和真实的差距（加权移动平均）</p><p><strong>RTO= µ * SRTT + ∂ *DevRTT</strong> —— 神一样的公式</p><p>（其中：在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的 TCP 协议中（Linux 的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank" rel="noopener">tcp_rtt_estimator</a>）。</p><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>需要说明一下，如果你不了解 TCP 的滑动窗口这个事，你等于不了解 TCP 协议。我们都知道，<strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>所以，TCP 引入了一些技术和设计来做网络流控，Sliding Window 是其中一个技术。 前面我们说过，<strong>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下 TCP 缓冲区的一些数据结构：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5oinwowj30p60a13z5.jpg" alt="img"></p><p>上图中，我们可以看到：</p><ul><li>接收端 LastByteRead 指向了 TCP 缓冲区中读到的位置，NextByteExpected 指向的地方是收到的连续包的最后一个位置，LastByteRcved 指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li><li>发送端的 LastByteAcked 指向了被接收端 Ack 过的位置（表示成功发送确认），LastByteSent 表示发出去了，但还没有收到成功确认的 Ack，LastByteWritten 指向的是上层应用正在写的地方。</li></ul><p>于是：</p><ul><li>接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li><li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li></ul><p>下面我们来看一下发送方的滑动窗口示意图：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5omcs7ej30ic07i750.jpg" alt="img"></p><p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p><ul><li>#1 已收到 ack 确认的数据。</li><li>#2 发还没收到 ack 的。</li><li>#3 在窗口中还没有发出的（接收方还有空间）。</li><li>#4 窗口以外的数据（接收方没空间）</li></ul><p>下面是个滑动后的示意图（收到 36 的 ack，并发出了 46-51 的字节）：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5oq49tuj30ic05uwev.jpg" alt="img"></p><p>下面我们来看一个接受端控制发送端的图示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5ot8lvsj30ii0n8wfy.jpg" alt="img"></p><h3 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h3><p>上图，我们可以看到一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的 TCP Sliding Window 给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？</p><p>解决这个问题，TCP 使用了 Zero Window Probe 技术，缩写为 ZWP，也就是说，发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。</p><p><strong>注意</strong>：只要有等待的地方都可能出现 DDoS 攻击，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress" target="_blank" rel="noopener">Wikipedia 的 SockStress 词条</a>）</p><p>另外，Wireshark 中，你可以使用 tcp.analysis.zero_window 来过滤包，然后使用右键菜单里的 follow TCP stream，你可以看到 ZeroWindowProbe 及 ZeroWindowProbeAck 的包。</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h3><p>Silly Window Syndrome 翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。</p><p>要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p><p>另外，你需要知道网络上有个 MTU，对于以太网来说，MTU 是 1500 字节，除去 TCP+IP 头的 40 个字节，真正的数据传输可以有 1460，这就是所谓的 MSS（Max Segment Size）注意，TCP 的 RFC 定义这个 MSS 的默认值是 536，这是因为 <a href="http://tools.ietf.org/html/rfc791" target="_blank" rel="noopener">RFC 791</a>里说了任何一个 IP 设备都得最少接收 576 尺寸的大小（实际上来说 576 是拨号的网络的 MTU，而 576 减去 IP 头的 20 个字节就是 536）。</p><p><strong>如果你的网络包可以塞满 MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于 MTU 的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个 MTU 就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p><p>所以，<strong>Silly Windows Syndrome 这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。</p><ul><li>如果这个问题是由 Receiver 端引起的，那么就会使用 David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。</li><li>如果这个问题是由 Sender 端引起的，那么就会使用著名的 <a href="http://en.wikipedia.org/wiki/Nagle's_algorithm" target="_blank" rel="noopener">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。</li></ul><p>另外，Nagle 算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像 telnet 或 ssh 这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char*)&amp;value,sizeof(int));</span><br></pre></td></tr></table></figure><p>另外，网上有些文章说 TCP_CORK 的 socket option 是也关闭 Nagle 算法，这不对。<strong>TCP_CORK 其实是更新激进的 Nagle 算汉，完全禁止小包发送，而 Nagle 算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p><h2 id="TCP-的拥塞处理-–-Congestion-Handling"><a href="#TCP-的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP 的拥塞处理 – Congestion Handling"></a>TCP 的拥塞处理 – Congestion Handling</h2><p>上面我们知道了，TCP 通过 Sliding Window 来做流控（Flow Control），但是 TCP 觉得这还不够，因为 Sliding Window 需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP 的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型 4 层以上的事，TCP 的还应该更聪明地知道整个网络上的事。</p><p>具体一点，我们知道 TCP 通过一个 timer 采样了 RTT 并计算 RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP 对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的 TCP 连接都这么行事，那么马上就会形成“网络风暴”，TCP 这个协议就会拖垮整个网络。</strong>这是一个灾难。</p><p>所以，TCP 不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此 TCP 的设计理念是：<strong>TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong></p><p>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p><ul><li>1988 年，TCP-Tahoe 提出了 1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li><li>1990 年，TCP Reno 在 Tahoe 的基础上增加了 4）快速恢复</li></ul><h3 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h3><p>首先，我们来看一下 TCP 的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p><p>慢启动的算法如下(cwnd 全称 Congestion Window)：</p><p>1）连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。</p><p>2）每当收到一个 ACK，cwnd++; 呈线性上升</p><p>3）每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升</p><p>4）还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”（后面会说这个算法）</p><p>所以，我们可以看到，如果网速很快的话，ACK 也会返回得快，RTT 也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5oz81ffj30ie0asjsi.jpg" alt="img"></p><p>一篇 Google 的论文《<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="noopener">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0 后采用了这篇论文的建议——把 cwnd 初始化成了 10 个 MSS。而 Linux 3.0 以前，比如 2.6，Linux 采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank" rel="noopener">RFC3390</a>，cwnd 是跟 MSS 的值来变的，如果 MSS&lt; 1095，则 cwnd = 4；如果 MSS&gt;2190，则 cwnd=2；其它情况下，则是 3。</p><h3 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h3><p>前面说过，还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”。一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下：</p><p>1）收到一个 ACK 时，cwnd = cwnd + 1/cwnd</p><p>2）当每过一个 RTT 时，cwnd = cwnd + 1</p><p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p><h3 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h3><p>前面我们说过，当丢包的时候，会有两种情况：</p><p>1）等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。</p><ul><li><ul><li>sshthresh = cwnd /2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ul></li></ul><p>2）Fast Retransmit 算法，也就是在收到 3 个 duplicate ACK 时就开启重传，而不用等到 RTO 超时。</p><ul><li><ul><li>TCP Tahoe 的实现和 RTO 超时一样。</li></ul></li><li><ul><li>TCP Reno 的实现是：<ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li><li>进入快速恢复算法——Fast Recovery</li></ul></li></ul></li></ul><p>上面我们可以看到 RTO 超时后，sshthresh 会变成 cwnd 的一半，这意味着，如果 cwnd&lt;=sshthresh 时出现的丢包，那么 TCP 的 sshthresh 就会减了一半，然后等 cwnd 又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP 是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p><h3 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h3><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><p>这个算法定义在<a href="http://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有 3 个 Duplicated Acks 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。 注意，正如前面所说，进入 Fast Recovery 之前，cwnd 和 sshthresh 已被更新：</p><ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li></ul><p>然后，真正的 Fast Recovery 算法如下：</p><ul><li>cwnd = sshthresh + 3 * MSS （3 的意思是确认有 3 个数据包被收到了）</li><li>重传 Duplicated ACKs 指定的数据包</li><li>如果再收到 duplicated Acks，那么 cwnd = cwnd +1</li><li>如果收到了新的 Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li></ul><p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于 3 个重复的 Acks</strong>。注意，3 个重复的 Acks 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成 TCP 的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。</p><p>通常来说，正如我们前面所说的，SACK 或 D-SACK 的方法可以让 Fast Recovery 或 Sender 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持 SACK（SACK 需要两端都支持），所以，需要一个没有 SACK 的解决方案。而通过 SACK 进行拥塞控制的算法是 FACK（后面会讲）</p><h4 id="TCP-New-Reno"><a href="#TCP-New-Reno" class="headerlink" title="TCP New Reno"></a>TCP New Reno</h4><p>于是，1995 年，TCP New Reno（参见 <a href="http://tools.ietf.org/html/rfc6582" target="_blank" rel="noopener">RFC 6582</a> ）算法提出来，主要就是在没有 SACK 的支持下改进 Fast Recovery 算法的——</p><ul><li>当 sender 这边收到了 3 个 Duplicated Acks，进入 Fast Retransimit 模式，开发重传重复 Acks 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 Ack 会把整个已经被 sender 传输出去的数据 ack 回来。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。</li><li>一旦 Sender 这边发现了 Partial ACK 出现，那么，sender 就可以推理出来有多个包被丢了，于是乎继续重传 sliding window 里未被 ack 的第一个包。直到再也收不到了 Partial Ack，才真正结束 Fast Recovery 这个过程</li></ul><p>我们可以看到，这个“Fast Recovery 的变更”是一个非常激进的玩法，他同时延长了 Fast Retransmit 和 Fast Recovery 的过程。</p><h5 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h5><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5p47j65j30sg09zgmc.jpg" alt="img"></p><h4 id="FACK-算法"><a href="#FACK-算法" class="headerlink" title="FACK 算法"></a>FACK 算法</h4><p>FACK 全称 Forward Acknowledgment 算法，论文地址在这里（PDF）<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf" target="_blank" rel="noopener">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于 SACK 的，前面我们说过 SACK 是使用了 TCP 扩展字段 Ack 了有哪些数据收到，哪些数据没有收到，他比 Fast Retransmit 的 3 个 duplicated acks 好处在于，前者只知道有包丢了，不知道是一个还是多个，而 SACK 可以准确的知道有哪些包丢了。 所以，SACK 可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK 用来做重传过程中的拥塞流控。</p><ul><li>这个算法会把 SACK 中最大的 Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack 的更新由 ack 带秋，如果网络一切安好则和 snd.una 一样（snd.una 就是还没有收到 ack 的地方，也就是前面 sliding window 里的 category #2 的第一个地方）</li><li>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt 指向发送端 sliding window 中正在要被发送的地方——前面 sliding windows 图示的 category#3 第一个位置），这样 awnd 的意思就是在网络上的数据。（所谓 awnd 意为：actual quantity of data outstanding in the network）</li><li>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd 是传出去的数据 + 重传的数据。</li><li>然后触发 Fast Recovery 的条件是： ( <strong>( snd.fack – snd.una ) &gt; (3*MSS)</strong> ) || (dupacks == 3) ) 。这样一来，就不需要等到 3 个 duplicated acks 才重传，而是只要 sack 中的最大的一个数据和 ack 的数据比较长了（3 个 MSS），那就触发重传。在整个重传过程中 cwnd 不变。直到当第一次丢包的 snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd 线性上涨。</li></ul><p>我们可以看到如果没有 FACK 在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的 window 的大小，而需要几个 RTT 的时间才会完成恢复，而 FACK 会比较激进地来干这事。 但是，FACK 如果在一个网络包会被 reordering 的网络里会有很大的问题。</p><h2 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h2><h3 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a><strong>TCP Vegas 拥塞控制算法</strong></h3><p>这个算法 1994 年被提出，它主要对 TCP Reno 做了些修改。这个算法通过对 RTT 的非常重的监控来计算一个基准 RTT。然后通过这个基准 RTT 来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加 cwnd 的大小。如果这个计算出来的 RTT 大于了 Timeout 后，那么，不等 ack 超时就直接重传。（Vegas 的核心思想是用 RTT 的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf" target="_blank" rel="noopener">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了 Vegas 和 New Reno 的对比：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5p96am2j30sg0fftd3.jpg" alt="img"></p><p>关于这个算法实现，你可以参看 Linux 源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank" rel="noopener">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank" rel="noopener">/net/ipv4/tcp_vegas.c</a></p><h3 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h3><p>这个算法来自<a href="http://tools.ietf.org/html/rfc3649" target="_blank" rel="noopener">RFC 3649</a>（<a href="http://en.wikipedia.org/wiki/HSTCP" target="_blank" rel="noopener">Wikipedia 词条</a>）。其对最基础的算法进行了更改，他使得 Congestion Window 涨得快，减得慢。其中：</p><ul><li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li><li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li></ul><p>注：α(cwnd)和 β(cwnd)都是函数，如果你要让他们和标准的 TCP 一样，那么让 α(cwnd)=1，β(cwnd)=0.5 就可以了。 对于 α(cwnd)和 β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看 Linux 源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank" rel="noopener">/net/ipv4/tcp_highspeed.c</a></p><h3 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h3><p>2004 年，产内出 BIC 算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN|lang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr%3Alang_1zh-CN|lang_1zh-TW&q=美科学家研发BIC-TCP协议+速度是DSL六千倍&oq=美科学家研发BIC-TCP协议+速度是DSL六千倍" target="_blank" rel="noopener">美科学家研发 BIC-TCP 协议 速度是 DSL 六千倍</a>》 BIC 全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="noopener">Binary Increase Congestion control</a>，在 Linux 2.6.8 中是默认拥塞控制算法。BIC 的发明者发这么多的拥塞控制算法都在努力找一个合适的 cwnd – Congestion Window，而且 BIC-TCP 的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以 BIC 这个算法主要用的是 Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看 Linux 源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c" target="_blank" rel="noopener">/net/ipv4/tcp_bic.c</a></p><h3 id="TCP-WestWood-算法"><a href="#TCP-WestWood-算法" class="headerlink" title="TCP WestWood 算法"></a>TCP WestWood 算法</h3><p>westwood 采用和 Reno 相同的慢启动算法、拥塞避免算法。westwood 的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个 RTT 时间，会测量一次带宽，测量带宽的公式很简单，就是这段 RTT 内成功被 ack 了多少字节。因为，这个带宽和用 RTT 计算 RTO 一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送 X 个字节，而 RTT 是一个数据发出去后确认需要的时候，所以，X _ RTT 应该是我们缓冲区大小。所以，在这个算法中，ssthresh 的值就是 est_BD _ min-RTT(最小的 RTT 值)，如果丢包是 Duplicated ACKs 引起的，那么如果 cwnd &gt; ssthresh，则 cwin = ssthresh。如果是 RTO 引起的，cwnd = 1，进入慢启动。 关于这个算法实现，你可以参看 Linux 源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank" rel="noopener">/net/ipv4/tcp_westwood.c</a></p><h2 id="四次挥手优化——三次挥手"><a href="#四次挥手优化——三次挥手" class="headerlink" title="四次挥手优化——三次挥手"></a>四次挥手优化——三次挥手</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#三次挥手 -- 客户端发起断开连接请求    客户端序列号为 3495051432</span><br><span class="line">#fin  seq = 3495051432</span><br><span class="line">00:05:30.157325 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [F.], seq 3495051432, ack 485492629, win 115, options [nop,nop,TS val 1695781058 ecr 629900122], length 0</span><br><span class="line">#三次挥手 -- 服务器端发起断开连接请求</span><br><span class="line">#ack = 3495051432 + 1 = 3495051433  注意 因为服务器端也没有东西要发送了，所以也要关闭连接，因此同时发送了fin信号，seq = 485492629</span><br><span class="line">00:05:30.157562 IP VM_0_6_centos.webcache &gt; 221.122.42.100.58706: Flags [F.], seq 485492629, ack 3495051433, win 235, options [nop,nop,TS val 629900162 ecr 1695781058], length 0</span><br><span class="line">#三次挥手 -- 客户端应答</span><br><span class="line">#ack = 485492629 + 1 = 485492630</span><br><span class="line">00:05:30.196710 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [.], ack 485492630, win 115, options [nop,nop,TS val 1695781097 ecr 629900162], length 0</span><br></pre></td></tr></table></figure><p>这是因为关闭连接有两种方式，当一方关闭连接，另外一方没有数据发送时，马上关闭连接，也就将第二步的 ack 与第三步的 fin 合并为一步了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment）&lt;/li&gt;
&lt;li&gt;IP 在第三层——Network 层（在第三层上的数据叫 Packet）&lt;/li&gt;
&lt;li&gt;ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>promise</title>
    <link href="http://yoursite.com/2019/08/05/promise/"/>
    <id>http://yoursite.com/2019/08/05/promise/</id>
    <published>2019-08-05T11:44:02.000Z</published>
    <updated>2019-09-21T14:03:34.837Z</updated>
    
    <content type="html"><![CDATA[<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><h2 id="创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）"><a href="#创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）" class="headerlink" title="创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）"></a>创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）</h2><p>方法一：</p><p>创建一个用 Promise 把 XHR 处理包装起来的名为 <code>getURL</code> 的函数。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">"http://httpbin.org/get"</span>;</span><br><span class="line">getURL(URL)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxPromise</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: url,</span><br><span class="line">      type: data == <span class="literal">null</span> ? <span class="string">"GET"</span> : <span class="string">"POST"</span>,</span><br><span class="line">      dataType: <span class="string">"json"</span>,</span><br><span class="line">      data: data == <span class="literal">null</span> ? <span class="string">""</span> : <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">      <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">      contentType: <span class="string">"application/json"</span>,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        callback(res);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;,</span><br><span class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (XMLHttpRequest.status == <span class="string">"401"</span>) &#123;</span><br><span class="line">          <span class="built_in">window</span>.parent.location = <span class="string">"/enterprise/enterprise_login.html"</span>;</span><br><span class="line">          self.location = <span class="string">"/enterprise/enterprise_login.html"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(XMLHttpRequest.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        reject();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ajaxPromise(<span class="string">'/prefix/entity1/action1'</span>,<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//do something on response</span></span><br><span class="line">&#125;).then(</span><br><span class="line">     ajaxPromise(<span class="string">'/prefix/entity2/action2'</span>, someData, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">          <span class="comment">//do something on response</span></span><br><span class="line">     &#125;</span><br><span class="line">).then(</span><br><span class="line">     initVue() ;</span><br><span class="line">).then(</span><br><span class="line">     <span class="comment">//do  something else</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="promise-的实现和原理（用-js）"><a href="#promise-的实现和原理（用-js）" class="headerlink" title="promise 的实现和原理（用 js）"></a>promise 的实现和原理（用 js）</h2><p><a href="https://juejin.im/post/5b83cb5ae51d4538cc3ec354" target="_blank" rel="noopener">promise 实现原理</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">"function"</span>;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"PENDING"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"FULFILLED"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"REJECTED"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(handle) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"MyPromise must accept a function as a parameter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._fulfilledQueues = [];</span><br><span class="line">    <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._rejectedQueues = [];</span><br><span class="line">    <span class="comment">// 执行handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">  _resolve(val) &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._fulfilledQueues.shift())) &#123;</span><br><span class="line">          cb(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runRejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">/* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,</span></span><br><span class="line"><span class="comment">          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */</span></span><br><span class="line">      <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        val.then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = value;</span><br><span class="line">            <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">            runFulfilled(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = err;</span><br><span class="line">            <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">            runRejected(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = val;</span><br><span class="line">        <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">        runFulfilled(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">  _reject(err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">      <span class="keyword">this</span>._value = err;</span><br><span class="line">      <span class="keyword">let</span> cb;</span><br><span class="line">      <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">        cb(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加then方法</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">            onFulfilledNext(value);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onFulfilled(value);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">            onRejectedNext(error);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(error);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._fulfilledQueues.push(fulfilled);</span><br><span class="line">          <span class="keyword">this</span>._rejectedQueues.push(rejected);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilled(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejected(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加catch方法</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果参数是MyPromise实例，直接返回这个实例</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态reject方法</span></span><br><span class="line">  <span class="keyword">static</span> reject(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态all方法</span></span><br><span class="line">  <span class="keyword">static</span> all(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 返回值的集合</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">let</span> values = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [i, p] <span class="keyword">of</span> list.entries()) &#123;</span><br><span class="line">        <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            values[i] = res;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (count === list.length) resolve(values);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态race方法</span></span><br><span class="line">  <span class="keyword">static</span> race(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      value =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">      reason =&gt;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="promise-race-和超时处理"><a href="#promise-race-和超时处理" class="headerlink" title="promise.race 和超时处理"></a>promise.race 和超时处理</h2><p>函数 <code>timeoutPromise(比较对象promise, ms)</code> 接收两个参数，第一个是需要使用超时机制的 promise 对象，第二个参数是超时时间，它返回一个由 <code>Promise.race</code> 创建的相互竞争的 promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Operation timed out after "</span> + ms + <span class="string">" ms"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Operation timed out after "</span> + ms + <span class="string">" ms"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line"><span class="keyword">var</span> taskPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 随便一些什么处理</span></span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">2000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(delay + <span class="string">"ms"</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;);</span><br><span class="line">timeoutPromise(taskPromise, <span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"taskPromise在规定时间内结束 : "</span> + value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生超时"</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>虽然在发生超时的时候抛出了异常，但是这样的话我们就不能区分这个异常到底是<em>普通的错误</em>还是<em>超时错误</em>了。</p><p>为了能区分这个 <code>Error</code> 对象的类型，我们再来定义一个<code>Error</code> 对象的子类 <code>TimeoutError</code>。</p><ul><li><h4 id="定制-Error-对象"><a href="#定制-Error-对象" class="headerlink" title="定制 Error 对象"></a>定制 Error 对象</h4></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TimeoutError.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(source).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">      target,</span><br><span class="line">      propName,</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propName)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> superInstance = <span class="built_in">Error</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  copyOwnFrom(<span class="keyword">this</span>, superInstance);</span><br><span class="line">&#125;</span><br><span class="line">TimeoutError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line">TimeoutError.prototype.constructor = TimeoutError;</span><br></pre></td></tr></table></figure><p>我们定义了 <code>TimeoutError</code> 类和构造函数，这个类继承了 Error 的 prototype。</p><p>它的使用方法和普通的 <code>Error</code> 对象一样，使用 <code>throw</code> 语句即可，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> TimeoutError(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error <span class="keyword">instanceof</span> TimeoutError); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4></li></ul><p>取消 XHR 操作本身的话并不难，只需要调用 <code>XMLHttpRequest</code> 对象的 <code>abort()</code> 方法就可以了。</p><p>为了能在外部调用 <code>abort()</code> 方法，我们先对之前本节出现的 <a href="http://liubin.org/promises-book/#xhr-promise.js" target="_blank" rel="noopener"><code>getURL</code></a> 进行简单的扩展，<code>cancelableXHR</code> 方法除了返回一个包装了 XHR 的 promise 对象之外，还返回了一个用于取消该 XHR 请求的<code>abort</code>方法。</p><p>大体的流程就像下面这样。</p><ol><li>通过 <code>cancelableXHR</code> 方法取得包装了 XHR 的 promise 对象和取消该 XHR 请求的方法</li><li>在 <code>timeoutPromise</code> 方法中通过 <code>Promise.race</code> 让 XHR 的包装 promise 和超时用 promise 进行竞争。<ul><li>XHR 在超时前返回结果的话<ol><li>和正常的 promise 一样，通过 <code>then</code> 返回请求结果</li></ol></li><li>发生超时的时候<ol><li>抛出 <code>throw TimeoutError</code> 异常并被 <code>catch</code></li><li>catch 的错误对象如果是 <code>TimeoutError</code> 类型的话，则调用 <code>abort</code> 方法取消 XHR 请求</li></ol></li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(source).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">      target,</span><br><span class="line">      propName,</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propName)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> superInstance = <span class="built_in">Error</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  copyOwnFrom(<span class="keyword">this</span>, superInstance);</span><br><span class="line">&#125;</span><br><span class="line">TimeoutError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line">TimeoutError.prototype.constructor = TimeoutError;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(</span><br><span class="line">      <span class="keyword">new</span> TimeoutError(<span class="string">"Operation timed out after "</span> + ms + <span class="string">" ms"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelableXHR</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onabort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"abort this request"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> abort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果request还没有结束的话就执行abort</span></span><br><span class="line">    <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span></span><br><span class="line">    <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) &#123;</span><br><span class="line">      req.abort();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    promise: promise,</span><br><span class="line">    abort: abort</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> object = cancelableXHR(<span class="string">"http://httpbin.org/get"</span>);</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">timeoutPromise(object.promise, <span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Contents"</span>, contents);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> TimeoutError) &#123;</span><br><span class="line">      object.abort();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"XHR Error :"</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="promise-all-和顺序处理"><a href="#promise-all-和顺序处理" class="headerlink" title="promise.all 和顺序处理"></a>promise.all 和顺序处理</h2><ul><li>在 <a href="http://liubin.org/promises-book/#multiple-xhr.js" target="_blank" rel="noopener">重复使用多个 then 的方法</a> 中的实现方法如下。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [] 用来保存初始化的值</span></span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">    .comment()</span><br><span class="line">    .then(pushValue)</span><br><span class="line">    .then(request.people)</span><br><span class="line">    .then(pushValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>使用这种写法的话那么随着 <code>request</code> 中元素数量的增加，我们也需要不断增加对 <code>then</code> 方法的调用</p><ul><li>将处理内容统一放到数组里，再配合 for 循环进行处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [] 用来保存初始化值</span></span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="comment">// 返回promise对象的函数的数组</span></span><br><span class="line">  <span class="keyword">var</span> tasks = [request.comment, request.people];</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  <span class="comment">// 开始的地方</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> task = tasks[i];</span><br><span class="line">    promise = promise.then(task).then(pushValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>promise = promise.then(task).then(pushValue);</code> 的代码就是通过不断对 promise 进行处理，不断的覆盖 <code>promise</code> 变量的值，以达到对 promise 对象的累积处理效果。</p><p>但是这种方法需要 <code>promise</code> 这个临时变量，从代码质量上来说显得不那么简洁。</p><ul><li>Promise chain 和 reduce</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">var</span> tasks = [request.comment, request.people];</span><br><span class="line">  <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(task).then(pushValue);</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>Array.prototype.reduce</code> 的第二个参数用来设置盛放计算结果的初始值。在这个例子中， <code>Promise.resolve()</code> 会赋值给 <code>promise</code>，此时的 <code>task</code> 为 <code>request.comment</code> 。</p><p>在 reduce 中第一个参数中被 <code>return</code> 的值，则会被赋值为下次循环时的 <code>promise</code> 。也就是说，通过返回由 <code>then</code> 创建的新的 promise 对象，就实现了和 for 循环类似的 <a href="http://liubin.org/promises-book/#promise-chain" target="_blank" rel="noopener">Promise chain</a> 了。</p><p>使用 reduce 和 for 循环不同的地方是 reduce 不再需要临时变量 <code>promise</code> 了，因此也不用编写 <code>promise = promise.then(task).then(pushValue);</code> 这样冗长的代码了，这是非常大的进步。</p><ul><li>定义进行顺序处理的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(task).then(pushValue);</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，和 <code>Promise.all</code> 等不同，这个函数接收的参数是一个函数的数组。为什么传给这个函数的不是一个 promise 对象的数组呢？这是因为 promise 对象创建的时候，XHR 已经开始执行了，因此再对这些 promise 对象进行顺序处理的话就不能正常工作了。</p><p>重写上例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(task).then(pushValue);</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sequenceTasks([request.comment, request.people]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="如何实现-Promise-all"><a href="#如何实现-Promise-all" class="headerlink" title="如何实现 Promise.all ?"></a>如何实现 Promise.all ?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processValue</span>(<span class="params">i, data</span>) </span>&#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">//promises[i] 可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          data =&gt; &#123;</span><br><span class="line">            processValue(i, data);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="如何实现-Promise-finally"><a href="#如何实现-Promise-finally" class="headerlink" title="如何实现 Promise.finally ?"></a>如何实现 Promise.finally ?</h2><p>不管成功还是失败，都会走到 finally 中,并且 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p>输出结果：success</p><p>解题思路：Promise 状态一旦改变，无法在发生变更。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    reject(<span class="string">"error"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>输出结果：1</p><p>解题思路：Promise 的 then 方法的参数期望是函数，传入非函数则会发生值穿透。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>结果是：3 4 6 8 7 5 2 1</p><p>优先级关系如下：<code>process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate</code></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>V8 实现中，两个队列各包含不同的任务：</p><p><code>macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</code><br><code>microtasks: process.nextTick, Promises, Object.observe, MutationObserver</code></p><ol start="4"><li><p>实现一个简单的 Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> status = <span class="string">"pending"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">successNotify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status = <span class="string">"fulfilled"</span>; <span class="comment">//状态变为fulfilled</span></span><br><span class="line">    toDoThen.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">failNotify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status = <span class="string">"rejected"</span>; <span class="comment">//状态变为rejected</span></span><br><span class="line">    toDoThen.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toDoThen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 保证回调是异步执行的</span></span><br><span class="line">      <span class="keyword">if</span> (status === <span class="string">"fulfilled"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; successArray.length; i++) &#123;</span><br><span class="line">          successArray[i].apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行then里面的回掉函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="string">"rejected"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; failArray.length; i++) &#123;</span><br><span class="line">          failArray[i].apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行then里面的回掉函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> successArray = [];</span><br><span class="line">  <span class="keyword">var</span> failArray = [];</span><br><span class="line">  fn.call(<span class="literal">undefined</span>, successNotify, failNotify);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">successFn, failFn</span>) </span>&#123;</span><br><span class="line">      successArray.push(successFn);</span><br><span class="line">      failArray.push(failFn);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 此处应该返回一个Promise</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>解题思路：Promise 中的 resolve 和 reject 用于改变 Promise 的状态和传参，then 中的参数必须是作为回调执行的函数。因此，当 Promise 改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;promise&quot;&gt;&lt;a href=&quot;#promise&quot; class=&quot;headerlink&quot; title=&quot;promise&quot;&gt;&lt;/a&gt;promise&lt;/h1&gt;&lt;h2 id=&quot;创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）&quot;&gt;&lt;a href=&quot;#创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）&quot; class=&quot;headerlink&quot; title=&quot;创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）&quot;&gt;&lt;/a&gt;创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）&lt;/h2&gt;&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;创建一个用 Promise 把 XHR 处理包装起来的名为 &lt;code&gt;getURL&lt;/code&gt; 的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JS引擎执行机制</title>
    <link href="http://yoursite.com/2019/07/30/JS%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/30/JS引擎执行机制/</id>
    <published>2019-07-30T05:13:29.000Z</published>
    <updated>2019-09-21T14:26:18.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-引擎执行机制"><a href="#JS-引擎执行机制" class="headerlink" title="JS 引擎执行机制"></a>JS 引擎执行机制</h1><p><strong>(1) JS 是单线程语言</strong></p><p><strong>(2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop</strong></p><a id="more"></a><h2 id="JS-为什么是单线程的-为什么需要异步-单线程又是如何实现异步的呢"><a href="#JS-为什么是单线程的-为什么需要异步-单线程又是如何实现异步的呢" class="headerlink" title="JS 为什么是单线程的? 为什么需要异步? 单线程又是如何实现异步的呢?"></a>JS 为什么是单线程的? 为什么需要异步? 单线程又是如何实现异步的呢?</h2><ul><li><p>JS 最初被设计用在浏览器中,那么想象一下,如果浏览器中的 JS 是多线程的。</p><p>场景描述:</p><p>那么现在有 2 个线程,process1 process2,由于是多线程的 JS,所以他们对同一个 dom,同时进行操作。process1 删除了该 dom,而 process2 编辑了该 dom,同时下达 2 个矛盾的命令,浏览器究竟该如何执行呢?</p></li><li><p>JS 为什么需要异步?</p><p>如果 JS 中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。<br>对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验</p></li><li><p>JS 单线程又是如何实现异步的呢?</p><p><strong>是通过的事件循环(event loop),理解了 event loop 机制,就理解了 JS 的执行机制</strong></p></li></ul><h2 id="JS-中的-event-loop"><a href="#JS-中的-event-loop" class="headerlink" title="JS 中的 event loop"></a>JS 中的 event loop</h2><h3 id="event-loop（1）"><a href="#event-loop（1）" class="headerlink" title="event loop（1）"></a>event loop（1）</h3><p>JS 里的一种分类方式,就是将任务分为: 同步任务和异步任务</p><p>JS 的执行机制是：</p><ul><li>首先判断 JS 是同步还是异步,同步就进入主线程,异步就进入 event table</li><li>异步任务在 event table 中注册函数,当满足触发条件后,被推入 event queue</li><li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去 event queue 中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><h3 id="event-loop（2）"><a href="#event-loop（2）" class="headerlink" title="event loop（2）"></a>event loop（2）</h3><p>准确的划分方式是:</p><ul><li>macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise.then，process.nextTick</li></ul><p>JS 的执行机制是：</p><ul><li>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里</li><li>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</li></ul><p><strong>重复以上 2 步骤,结合 event loop(1) event loop(2) ,就是更为准确的 JS 执行机制了。</strong></p><h2 id="理解-JavaScript-的-async-await"><a href="#理解-JavaScript-的-async-await" class="headerlink" title="理解 JavaScript 的 async/await"></a>理解 JavaScript 的 async/await</h2><h3 id="async-和-await-在干什么"><a href="#async-和-await-在干什么" class="headerlink" title="async 和 await 在干什么"></a>async 和 await 在干什么</h3><p>先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><ul><li>async 函数返回的是一个 <strong>Promise</strong> 对象。<ul><li>如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</li><li>如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</li><li>Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</li></ul></li><li>await 等待的是一个表达式。<ul><li>这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</li><li>await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。</li></ul></li><li>await 等到了要等的，然后呢？<ul><li><code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</li><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul></li></ul><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p><h3 id="await-等待的表达式详解"><a href="#await-等待的表达式详解" class="headerlink" title="await 等待的表达式详解"></a>await 等待的表达式详解</h3><p><strong>await 等的是右侧「表达式」的结果</strong></p><p>await 是从<strong>右向左执行的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br></pre></td></tr></table></figure><p>先执行 async2 后，发现有 await 关键字，于是让出线程，阻塞代码</p><p>右侧表达式的结果:</p><ul><li>如果不是 promise , await 会阻塞后面的代码，先执行 async 外面的同步代码，同步代码执行完，再回到 async 内部，把这个非 promise 的东西，作为 await 表达式的结果</li><li>如果它等到的是一个 promise 对象，await 也会暂停 async 后面的代码，先执行 async 外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</li></ul><h3 id="async-await-的优势在于处理-then-链"><a href="#async-await-的优势在于处理-then-链" class="headerlink" title="async/await 的优势在于处理 then 链"></a>async/await 的优势在于处理 then 链</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。</p><ul><li>Async/await 代码清晰很多，几乎跟同步代码一样。</li><li>Promise 方案的死穴—— 链式调用参数传递太麻烦</li></ul><h2 id="async-await-和-promise-的执行顺序"><a href="#async-await-和-promise-的执行顺序" class="headerlink" title="async/await 和 promise 的执行顺序"></a>async/await 和 promise 的执行顺序</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script end"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p>宏任务和微任务的慨念，在我脑海中宏任务和为微任务如图所示</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izm5nu3ij30f204qq2z.jpg" alt="img"></p><p>也就是「宏任务」、「微任务」都是队列。</p><p>一段代码执行时，会先执行宏任务中的同步代码，</p><ul><li>如果执行中遇到 setTimeout 之类宏任务，那么就把这个 setTimeout 内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。</li><li>如果执行中遇到 promise.then()之类的微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行所有的微任务 1、2、3</li></ul><h3 id="例子分析执行顺序"><a href="#例子分析执行顺序" class="headerlink" title="例子分析执行顺序"></a>例子分析执行顺序</h3><h4 id="直接打印同步代码-console-log-‘script-start’"><a href="#直接打印同步代码-console-log-‘script-start’" class="headerlink" title="直接打印同步代码 console.log(‘script start’)"></a>直接打印同步代码 console.log(‘script start’)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是2个函数声明，虽然有async关键字，但不是调用我们就不看。然后首先是打印同步代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izmivm1ij30m801x745.jpg" alt="img"></p><h4 id="将-setTimeout-放入宏任务队列"><a href="#将-setTimeout-放入宏任务队列" class="headerlink" title="将 setTimeout 放入宏任务队列"></a>将 setTimeout 放入宏任务队列</h4><p>默认所包裹的代码，其实可以理解为是第一个宏任务，所以这里是宏任务 2</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izmvovzjj30m8034dft.jpg" alt="img"></p><h4 id="调用-async1，打印-同步代码-console-log-‘async1-start’"><a href="#调用-async1，打印-同步代码-console-log-‘async1-start’" class="headerlink" title="调用 async1，打印 同步代码 console.log( ‘async1 start’ )"></a>调用 async1，打印 同步代码 console.log( ‘async1 start’ )</h4><p>我们说过看到带有 async 关键字的函数，不用害怕，它的仅仅是把 return 值包装成了 promise，其他并没有什么不同的地方。所以就很普通的打印 console.log( ‘async1 start’ )</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izn7f29dj30m803dt8o.jpg" alt="img"></p><h4 id="分析一下-await-async2"><a href="#分析一下-await-async2" class="headerlink" title="分析一下 await async2()"></a>分析一下 await async2()</h4><p>前文提过 await，1.它先计算出右侧的结果，2.然后看到 await 后，中断 async 函数</p><ul><li>先得到 await 右侧表达式的结果。执行 async2()，打印同步代码 console.log(‘async2’), 并且 return Promise.resolve(undefined)</li><li>await 后，中断 async 函数，先执行 async 外的同步代码</li></ul><p>目前就直接打印 console.log(‘async2’)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iznit5adj30m803edfu.jpg" alt="img"></p><h4 id="被阻塞后，要执行-async-之外的代码"><a href="#被阻塞后，要执行-async-之外的代码" class="headerlink" title="被阻塞后，要执行 async 之外的代码"></a>被阻塞后，要执行 async 之外的代码</h4><p>执行 new Promise()，Promise 构造函数是直接调用的同步代码，所以 console.log( ‘promise1’ )</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iznu7o6jj30m803l74a.jpg" alt="img"></p><h4 id="代码运行到-promise-then"><a href="#代码运行到-promise-then" class="headerlink" title="代码运行到 promise.then()"></a>代码运行到 promise.then()</h4><p>代码运行到 promise.then()，发现这个是微任务，所以暂时不打印，只是推入当前宏任务的微任务队列中。</p><p><strong>注意：这里只是把 promise2 推入微任务队列，并没有执行。微任务会在当前宏任务的同步代码执行完毕，才会依次执行</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izo8rmlkj30m803c0sp.jpg" alt="img"></p><h4 id="打印同步代码-console-log-‘script-end’"><a href="#打印同步代码-console-log-‘script-end’" class="headerlink" title="打印同步代码 console.log(‘script end’)"></a>打印同步代码 console.log(‘script end’)</h4><p>执行完这个同步代码后，「async 外的代码」终于走了一遍</p><p>下面该回到 await 表达式那里，执行 await Promise.resolve(undefined)了<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izoj1zjkj30m803c749.jpg" alt="img"></p><h4 id="回到-async-内部，执行-await-Promise-resolve-undefined"><a href="#回到-async-内部，执行-await-Promise-resolve-undefined" class="headerlink" title="回到 async 内部，执行 await Promise.resolve(undefined)"></a>回到 async 内部，执行 await Promise.resolve(undefined)</h4><p>这部分可能不太好理解，我尽量表达我的想法。</p><p>对于 await Promise.resolve(undefined) 如何理解呢？</p><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">MDN</a> 原话我们知道</p><p><strong>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</strong></p><p>在我们这个例子中，就是 Promise.resolve(undefined)正常处理完成，并返回其处理结果。那么 await async2()就算是执行结束了。</p><p>目前这个 promise 的状态是 fulfilled，等其处理结果返回就可以执行 await 下面的代码了。</p><p>那何时能拿到处理结果呢？</p><p>回忆平时我们用 promise，调用 resolve 后，何时能拿到处理结果？是不是需要在 then 的第一个参数里，才能拿到结果。</p><p>（调用 resolve 时，会把 then 的参数推入微任务队列，等主线程空闲时，再调用它）</p><p>所以这里的 await Promise.resolve() 就类似于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">undefined</span>).then(<span class="function"><span class="params">undefined</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>把 then 的第一个回调参数 (undefined) =&gt; {} 推入微任务队列。</p><p>then 执行完，才是 await async2()执行结束。</p><p>await async2()执行结束，才能继续执行后面的代码</p><p>如图</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izovbp1aj30m8037q2y.jpg" alt="img"></p><h4 id="此时当前宏任务-1-都执行完了，要处理微任务队列里的代码。"><a href="#此时当前宏任务-1-都执行完了，要处理微任务队列里的代码。" class="headerlink" title="此时当前宏任务 1 都执行完了，要处理微任务队列里的代码。"></a>此时当前宏任务 1 都执行完了，要处理微任务队列里的代码。</h4><p>微任务队列，先进选出的原则，</p><ol><li>执行微任务 1，打印 promise2</li><li>执行微任务 2，没什么内容..</li></ol><p>但是微任务 2 执行后，await async2()语句结束，后面的代码不再被阻塞，所以打印</p><p>console.log(‘async1 end’)</p><h4 id="宏任务-1-执行完成后-执行宏任务-2"><a href="#宏任务-1-执行完成后-执行宏任务-2" class="headerlink" title="宏任务 1 执行完成后,执行宏任务 2"></a>宏任务 1 执行完成后,执行宏任务 2</h4><p>宏任务 2 的执行比较简单，就是打印</p><p>console.log(‘setTimeout’)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS-引擎执行机制&quot;&gt;&lt;a href=&quot;#JS-引擎执行机制&quot; class=&quot;headerlink&quot; title=&quot;JS 引擎执行机制&quot;&gt;&lt;/a&gt;JS 引擎执行机制&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;(1) JS 是单线程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS事件机制</title>
    <link href="http://yoursite.com/2019/07/24/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/24/JS事件机制/</id>
    <published>2019-07-24T07:22:00.000Z</published>
    <updated>2019-09-21T14:00:59.847Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-事件机制"><a href="#JS-事件机制" class="headerlink" title="JS 事件机制"></a>JS 事件机制</h1><h2 id="js-里一般的阻止事件默认行为怎么做？"><a href="#js-里一般的阻止事件默认行为怎么做？" class="headerlink" title="js 里一般的阻止事件默认行为怎么做？"></a>js 里一般的阻止事件默认行为怎么做？</h2><p>event.preventDefault()可以取消默认事件</p><p>event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = event || <span class="built_in">window</span>.event; <span class="comment">//兼容IE</span></span><br><span class="line">  <span class="comment">//取消事件相关的默认行为</span></span><br><span class="line">  <span class="keyword">if</span> (event.preventDefault)</span><br><span class="line">    <span class="comment">//标准技术</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (event.returnValue)</span><br><span class="line">    <span class="comment">//兼容IE9之前的IE</span></span><br><span class="line">    event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//用于处理使用对象属性注册的处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡的机制是什么？下面代码输出顺序是什么？（2-gt-button-gt-1）"><a href="#冒泡的机制是什么？下面代码输出顺序是什么？（2-gt-button-gt-1）" class="headerlink" title="冒泡的机制是什么？下面代码输出顺序是什么？（2-&gt;button-&gt;1）"></a>冒泡的机制是什么？下面代码输出顺序是什么？（2-&gt;button-&gt;1）</h2><ul><li>触发顺序：button-&gt;1-&gt;2</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"button"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>触发顺序：2-&gt;button-&gt;1</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"button"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>触发顺序：2-&gt;button-&gt;1</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"button"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS-事件机制&quot;&gt;&lt;a href=&quot;#JS-事件机制&quot; class=&quot;headerlink&quot; title=&quot;JS 事件机制&quot;&gt;&lt;/a&gt;JS 事件机制&lt;/h1&gt;&lt;h2 id=&quot;js-里一般的阻止事件默认行为怎么做？&quot;&gt;&lt;a href=&quot;#js-里一般的阻止事件默认行为怎么做？&quot; class=&quot;headerlink&quot; title=&quot;js 里一般的阻止事件默认行为怎么做？&quot;&gt;&lt;/a&gt;js 里一般的阻止事件默认行为怎么做？&lt;/h2&gt;&lt;p&gt;event.preventDefault()可以取消默认事件&lt;/p&gt;
&lt;p&gt;event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>JS静态作用域</title>
    <link href="http://yoursite.com/2019/07/11/JS%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/07/11/JS静态作用域/</id>
    <published>2019-07-11T03:01:34.000Z</published>
    <updated>2019-09-21T14:11:26.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-静态作用域"><a href="#JS-静态作用域" class="headerlink" title="JS 静态作用域"></a>JS 静态作用域</h1><h2 id="js-的作用域和别的编程语言的作用域有什么区别"><a href="#js-的作用域和别的编程语言的作用域有什么区别" class="headerlink" title="js 的作用域和别的编程语言的作用域有什么区别"></a>js 的作用域和别的编程语言的作用域有什么区别</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p><a id="more"></a><h3 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h3><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p><p>让我们认真看个例子就能明白之间的区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure><p>假设 JavaScript 采用静态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p><p>假设 JavaScript 采用动态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。</p><p>最后，让我们看一个《JavaScript 权威指南》中的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>猜猜两段代码各自的执行结果是多少？</p><p>这里直接告诉大家结果，两段代码都会打印：<code>local scope</code>。</p><p>原因也很简单，因为 JavaScript 采用的是词法作用域，函数的作用域基于函数创建的位置。</p><p>而引用《JavaScript 权威指南》的回答就是：</p><p>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。</p><p><strong>bash 就是动态作用域</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS-静态作用域&quot;&gt;&lt;a href=&quot;#JS-静态作用域&quot; class=&quot;headerlink&quot; title=&quot;JS 静态作用域&quot;&gt;&lt;/a&gt;JS 静态作用域&lt;/h1&gt;&lt;h2 id=&quot;js-的作用域和别的编程语言的作用域有什么区别&quot;&gt;&lt;a href=&quot;#js-的作用域和别的编程语言的作用域有什么区别&quot; class=&quot;headerlink&quot; title=&quot;js 的作用域和别的编程语言的作用域有什么区别&quot;&gt;&lt;/a&gt;js 的作用域和别的编程语言的作用域有什么区别&lt;/h2&gt;&lt;h3 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h3&gt;&lt;p&gt;作用域是指程序源代码中定义变量的区域。&lt;/p&gt;
&lt;p&gt;作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。&lt;/p&gt;
&lt;p&gt;JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>https中间人攻击及防御</title>
    <link href="http://yoursite.com/2019/07/03/https%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB%E5%8F%8A%E9%98%B2%E5%BE%A1/"/>
    <id>http://yoursite.com/2019/07/03/https中间人攻击及防御/</id>
    <published>2019-07-03T06:51:26.000Z</published>
    <updated>2019-09-21T14:00:13.180Z</updated>
    
    <content type="html"><![CDATA[<h1 id="https-中间人攻击及防御"><a href="#https-中间人攻击及防御" class="headerlink" title="https 中间人攻击及防御"></a>https 中间人攻击及防御</h1><p>HTTPS 也不是绝对安全的，在 HTTPS 握手的过程中，如果实施不当，还是会存在漏洞，很容被中间人攻击；</p><h2 id="什么是中间人攻击"><a href="#什么是中间人攻击" class="headerlink" title="什么是中间人攻击"></a>什么是中间人攻击</h2><p><strong>中间人攻击</strong>（Man-in-the-middle attack，<a href="https://zh.wikipedia.org/wiki/缩写" target="_blank" rel="noopener">缩写</a>：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。</p><a id="more"></a><h2 id="如何进行中间人攻击的呢？"><a href="#如何进行中间人攻击的呢？" class="headerlink" title="如何进行中间人攻击的呢？"></a>如何进行中间人攻击的呢？</h2><h3 id="攻击一：SSLSniff"><a href="#攻击一：SSLSniff" class="headerlink" title="攻击一：SSLSniff"></a>攻击一：SSLSniff</h3><p>攻击者在网关截获 SSL 会话，替换服务器公钥证书，将公钥<code>PKey</code>换成自己的公钥<code>PKey</code>，欺骗客户端。客户端使用<code>PKey</code>加密信息并发送会话，中间人用私钥<code>Skey</code>解密客户端返回会话，从而劫持会话。同时，中间人用<code>PKey</code>加密明文会话并返回服务器</p><p><strong>过程如下：</strong></p><ol><li><code>Attacker</code>截获了客户端的<code>say hello</code>，可以把<code>publicKey_attacker</code>返回给客户端，取得客户端的信任，至此<code>Attacker</code>与客户端建立了安全连接。</li><li><code>Attacker</code>冒充客户端向服务器发送<code>say hello</code>，至此<code>Attacker</code>与服务器建立了安全连接。</li></ol><p>这种攻击会存在一个问题会被感知到，就是<code>Attacker</code>的证书是伪造的不受信任的证书，所以客户端可以确认是否需要真的连接该服务器，不过如果有内鬼的话，伪造的受信任的证书的话，就当我啥也没说；</p><h3 id="攻击二：SSLStrip"><a href="#攻击二：SSLStrip" class="headerlink" title="攻击二：SSLStrip"></a>攻击二：SSLStrip</h3><p>这种攻击相对于攻击一复杂一点，但是也更加厉害，几乎可以在客户端无感知的情况下实施攻击，并且不需要伪造证书；简单来说就是这样：<code>Attacker</code>在客户端与服务器建立连接时，在<code>Attacker</code>与服务器之间形成 HTTPS 连接，而在客户端与<code>Attacker</code>之间形成<code>HTTP</code>连接，即将 SSL 层从原 HTTPS 连接中“剥离”。这样，既避免了在客户端验证证书时难以避免的弹框问题，又能够劫持 HTTP 明文数据，并同时保证客户端<code>HTTP</code>数据的传输，达到欺骗服务器与客户端的效果。</p><p><strong>过程如下：</strong></p><p>用户在浏览器地址栏中输入网址时，多数会采用直接输入网址的方式，而忽略了传输所采用的协议。例如，在登录 gmail 过程中，大多数用户会直接在地址栏中输入<code>www.gmail.com</code>，向<code>Google</code>服务器发送一个 HTTP 连接请求，而不是输入<code>https：//www.gmail.com</code>， 向服务器发送一个<code>HTTPS</code>连接请求。因此，用户通常接触到 HTTPS 的方式有两种：一种是 Web 上的连接，比如当用户在 gmail 上输入用户名和密码后，点击的登录键，将用户的用户名和密码以<code>HTTPS</code>的形式<code>POST</code>到服务器。另一种是通过 HTTP 的 302 状态。 当客户端向 gmail 提出 HTTP 连接请求时，gmail 服务器会返回一个<code>REDIRECT</code>网址，<code>https：//www.google.com/accounts/ServiceLogin?service=mail...</code>，用户端在接收到这个 URL 后，将页面重定位到该网页，并请求 HTTPS 连接。 从另外一个角度讲，用户通常是通过<code>HTTP</code>向服务器发起<code>HTTPS</code>连接的。而<code>HTTP</code>本身是以明文的形式对外传送，并不能保证数据的安全。因此，可以考虑通过对 HTTP 进行劫持，来实现对 HTTPS 劫持的目的。</p><ol><li>客户端向服务器发起<code>HTTP</code>连接请求；</li><li>中间人 MITM 监听客户端与服务器的<code>HTTP</code>数据；</li><li>服务器返回给客户端的 HTTP 数据包被在客户端与服务器之间的中间人截获。中间人解析原 HTTP 数据包，将其中<code>&lt;a href=”https：//...”&gt;</code>替换成<code>&lt;a href=”http//...”&gt;</code>，将 <code>Location： https：//...</code> 替换成<code>Location：http://..</code>，同时记录下所修改的 URL，并保存；</li><li>中间人将修改后的<code>HTTP</code>数据发送给客户端；</li><li>客户端向服务器发起<code>HTTP</code>连接请求；</li><li>中间人计算机解析客户端的<code>HTTP</code>连接请求，并与保存文件相比较。当发现存在有已修改过的<code>HTTP URL</code>时，将其替换成原<code>HTTPS URL</code>，并发送给服务器；</li><li>与服务器保持<code>HTTPS</code>连接，回到步骤 3；</li><li>与客户端保持<code>HTTP</code>连接，回到步骤 4。</li></ol><p><strong>效果就是：</strong> 服务器认为 HTTPS 是安全的。对于客户端而言，由于中间人 MITM 与客户端 Client 之间是 HTTP 连接，因此并不会对证书进行认证；</p><p><strong>HSTS</strong>:为了解决这个问题，IETF（互联网工程任务小组）引入了一个策略，叫做 <strong>HSTS</strong> (HTTP Strict Transport Security, HTTP 严格传输安全)。HSTS 的作用是强制客户端与服务端建立安全的 HTTPS 连接，而非不安全的 HTTP 连接。如果一个站点启用了 HSTS 策略，那么客户端在第一次与该站点建立连接之后，在未来的一段时间内（由一个 HTTP 头部控制，这个头部为：Strict-Transport-Security），客户端与该站点的所有连接都会直接使用 HTTPS，<em>即使客户端访问的是 HTTP，也会直接在客户端重定向到 HTTPS 连接。</em></p><p>假设 <code>https://example.com</code> 的响应头部含有 <code>Strict-Transport-Security: max-age=31536000; includeSubDomains</code>，这意味着：</p><ol><li>在未来的 1 年时间里（即 31536000 秒中），只要浏览器向 <code>example.com</code> 或者其子域名发送请求，必须采用 HTTPS 来发起连接。即使用户在地址栏里写的是 <code>http://example.com</code>，那也直接重写为 <code>https://example.com</code> 并直接发起 HTTPS 连接。</li><li>在接下去的一年中，如果服务器提供的 HTTPS 证书无效（不论是域名对不上还是自签名还是不在有效期内），用户都无法访问该站点。</li></ol><p>如果站点没有启用 HSTS，用户可以忽略证书无效的警告，继续建立连接，而如果站点启用了 HSTS，那么用户即使想冒风险，浏览器也不会继续访问。</p><p>HSTS 可以很大程度上防止 SSLTrip 攻击，不过这样还是有个问题，那就是要启用 HSTS，浏览器至少要和服务器建立一次 HTTPS 连接，如果中间人一直阻止浏览器与服务器建立 HTTPS 连接，那么 HSTS 就失效了。解决这个问题有个办法，那就是将 HSTS 站点列表内置到浏览器中，这样只要浏览器<strong>离线</strong>判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。</p><h2 id="如何防御中间人攻击？"><a href="#如何防御中间人攻击？" class="headerlink" title="如何防御中间人攻击？"></a>如何防御中间人攻击？</h2><p>中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在 SSL 握手的过程中缺乏相互认证而造成的漏洞</p><p>防御中间人攻击的方案通常基于以下几种技术</p><ul><li>公钥基础建设 PKI，更强力的相互认证</li></ul><p>使用 PKI 相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了 SSL 握手环节的漏洞，而如果使用相互认证的的话，基本可以保证</p><ul><li>延迟测试</li></ul><p>使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费 20 秒来计算，并且整个通讯花费了 60 秒计算才到达对方，这就能表明存在第三方中间人。</p><h2 id="https-通信安全性的保证"><a href="#https-通信安全性的保证" class="headerlink" title="https 通信安全性的保证"></a>https 通信安全性的保证</h2><p>通信过程的安全性<strong>自下而上</strong>就是这样保证的：</p><ol><li>双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以<em>安全性就由<strong>公钥</strong>的正确性来保证。</em></li><li>公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么<em>安全性就是由<strong>数字证书</strong>的正确性来保证了。</em></li><li>数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的<strong>数字签名</strong>来验证证书中的公钥是否是正确的。那么<em>安全性就是由*</em>上级 CA 证书<strong>的正确性保证的了。*（</strong>数字签名保证了数字证书没有被篡改**）</li><li>但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，<em>安全性就是靠系统<strong>根证书</strong>的私钥不被泄露或者其公钥不被篡改来保证的了。</em></li><li>根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中<strong>内置</strong>签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，<em>安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了。</em></li></ol><p>至此，整个信任链就建立起来了，只需要有一台设备上安装了可以信任的根证书，就可以用来分发更多安全的操作系统了。之后的所有信任链都是安全的了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;https-中间人攻击及防御&quot;&gt;&lt;a href=&quot;#https-中间人攻击及防御&quot; class=&quot;headerlink&quot; title=&quot;https 中间人攻击及防御&quot;&gt;&lt;/a&gt;https 中间人攻击及防御&lt;/h1&gt;&lt;p&gt;HTTPS 也不是绝对安全的，在 HTTPS 握手的过程中，如果实施不当，还是会存在漏洞，很容被中间人攻击；&lt;/p&gt;
&lt;h2 id=&quot;什么是中间人攻击&quot;&gt;&lt;a href=&quot;#什么是中间人攻击&quot; class=&quot;headerlink&quot; title=&quot;什么是中间人攻击&quot;&gt;&lt;/a&gt;什么是中间人攻击&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;中间人攻击&lt;/strong&gt;（Man-in-the-middle attack，&lt;a href=&quot;https://zh.wikipedia.org/wiki/缩写&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缩写&lt;/a&gt;：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。&lt;/p&gt;
    
    </summary>
    
      <category term="HTTP" scheme="http://yoursite.com/categories/HTTP/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="http://yoursite.com/2019/06/18/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2019/06/18/CSRF攻击/</id>
    <published>2019-06-18T12:05:23.000Z</published>
    <updated>2019-09-21T14:26:18.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSRF-攻击"><a href="#CSRF-攻击" class="headerlink" title="CSRF 攻击"></a>CSRF 攻击</h1><h2 id="1-什么是-CSRF"><a href="#1-什么是-CSRF" class="headerlink" title="1.什么是 CSRF"></a>1.什么是 CSRF</h2><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><p>一个典型的 CSRF 攻击有着如下的流程：</p><a id="more"></a><ul><li>受害者登录 a.com，并保留了登录凭证（Cookie）。</li><li>攻击者引诱受害者访问了 b.com。</li><li>b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。</li><li>a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。</li><li>a.com 以受害者的名义执行了 act=xx。</li><li>攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。</li></ul><h2 id="2-常见的攻击类型"><a href="#2-常见的攻击类型" class="headerlink" title="2.常见的攻击类型"></a>2.常见的攻击类型</h2><ul><li><strong>GET 类型的 CSRF</strong></li></ul><p>GET 类型的 CSRF 利用非常简单，只需要一个 HTTP 请求，一般会这样利用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://bank.example/withdraw?amount=10000&amp;for=hacker"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在受害者访问含有这个 img 的页面后，浏览器会自动向<code>http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker</code>发出一次 HTTP 请求。bank.example 就会收到包含受害者登录信息的一次跨域请求。</p><ul><li><strong>POST 类型的 CSRF</strong></li></ul><p>这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"http://bank.example/withdraw"</span> <span class="attr">method</span>=<span class="string">"POST"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"account"</span> <span class="attr">value</span>=<span class="string">"xiaoming"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"amount"</span> <span class="attr">value</span>=<span class="string">"10000"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">"for"</span> <span class="attr">value</span>=<span class="string">"hacker"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.forms[<span class="number">0</span>].submit();</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。</p><p>POST 类型的攻击通常比 GET 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面。</p><ul><li><strong>链接类型的 CSRF</strong></li></ul><p>链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">  <span class="attr">href</span>=<span class="string">"http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">taget</span>=<span class="string">"_blank"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">  重磅消息！！</span><br><span class="line">  <span class="tag">&lt;<span class="name">a</span></span></span><br><span class="line"><span class="tag">/&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>由于之前用户登录了信任的网站 A，并且保存登录状态，只要用户主动访问上面的这个 PHP 页面，则表示攻击成功。</p><h2 id="3-CSRF-的特点"><a href="#3-CSRF-的特点" class="headerlink" title="3.CSRF 的特点"></a>3.CSRF 的特点</h2><ul><li>攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。</li><li>攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。</li><li>整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。</li><li>跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。</li></ul><p>CSRF 通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。</p><h2 id="4-防护策略"><a href="#4-防护策略" class="headerlink" title="4.防护策略"></a>4.防护策略</h2><p>CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。</p><p>上文中讲了<strong>CSRF 的两个特点：</strong></p><ul><li>CSRF（通常）发生在第三方域名。</li><li>CSRF 攻击者不能获取到 Cookie 等信息，只是使用。</li></ul><p>针对这两点，我们可以专门制定防护策略，如下：</p><ul><li>阻止不明外域的访问<ul><li>同源检测</li><li>Samesite Cookie</li></ul></li><li>提交时要求附加本域才能获取的信息<ul><li>CSRF Token</li><li>双重 Cookie 验证</li></ul></li></ul><h3 id="同源检测"><a href="#同源检测" class="headerlink" title="同源检测"></a>同源检测</h3><p>既然 CSRF 大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。</p><p>我们如何判断请求是否来自外域呢？</p><p>在 HTTP 协议中，每一个<em>异步请求</em>都会携带两个 Header，用于标记来源域名：</p><ul><li>Origin Header</li><li>Referer Header</li></ul><p>这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且<em>不能由前端自定义内容。</em><br>服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。</p><h5 id="1-使用-Origin-Header-确定来源域名"><a href="#1-使用-Origin-Header-确定来源域名" class="headerlink" title="1. 使用 Origin Header 确定来源域名"></a>1. 使用 Origin Header 确定来源域名</h5><p>在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段。字段内包含请求的域名（不包含 path 及 query）。</p><p>如果 Origin 存在，那么直接使用 Origin 中的字段确认来源域名就可以。</p><p>但是 Origin 在以下两种情况下并不存在：</p><ul><li><strong>IE11 同源策略：</strong> IE 11 不会在跨站 CORS 请求上添加 Origin 标头，Referer 头将仍然是唯一的标识。最根本原因是因为 IE 11 对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考<a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy#IE_Exceptions" target="_blank" rel="noopener">MDN Same-origin_policy#IE_Exceptions</a></li><li><strong>302 重定向：</strong> 在 302 重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。对于 302 重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 Origin 泄漏到新的服务器上。</li></ul><h5 id="2-使用-Referer-Header-确定来源域名"><a href="#2-使用-Referer-Header-确定来源域名" class="headerlink" title="2. 使用 Referer Header 确定来源域名"></a>2. 使用 Referer Header 确定来源域名</h5><p>根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的来源地址。<br>对于 Ajax 请求，图片和 script 等资源请求，Referer 为发起请求的页面地址。对于页面跳转，Referer 为打开页面历史记录的前一个页面地址。因此我们使用 Referer 中链接的 Origin 部分可以得知请求的来源域名。</p><p>这种方法并非万无一失，Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的 Referer。</p><p>2014 年，W3C 的 Web 应用安全工作组发布了 Referrer Policy 草案，对浏览器该如何发送 Referer 做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的 Referer 策略了。新版的 Referrer Policy 规定了五种 Referer 策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。之前就存在的三种策略：never、default 和 always，在新标准里换了个名称。他们的对应关系如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyglvo3mj31bo0e63yy.jpg" alt="img"></p><p>根据上面的表格因此需要把 Referrer Policy 的策略设置成 same-origin，对于同源的链接和引用，会发送 Referer，referer 值为 Host 不带 Path；跨域访问则不携带 Referer。例如：<code>aaa.com</code>引用<code>bbb.com</code>的资源，不会发送 Referer。</p><p>设置 Referrer Policy 的方法有三种：</p><ol><li>在 CSP 设置</li><li>页面头部增加 meta 标签</li><li>a 标签增加 referrerpolicy 属性</li></ol><p><strong>攻击者可以在自己的请求中隐藏 Referer。</strong></p><p>另外在以下情况下 Referer 没有或者不可信：</p><ol><li>IE6、7 下使用 window.location.href=url 进行界面的跳转，会丢失 Referer。</li><li>IE6、7 下使用 window.open，也会缺失 Referer。</li><li>HTTPS 页面跳转到 HTTP 页面，所有浏览器 Referer 都丢失。</li><li>点击 Flash 上到达另外一个网站的时候，Referer 的情况就比较杂乱，不太可信。</li></ol><h5 id="无法确认来源域名情况"><a href="#无法确认来源域名情况" class="headerlink" title="无法确认来源域名情况"></a>无法确认来源域名情况</h5><p>当 Origin 和 Referer 头文件不存在时该怎么办？如果 Origin 和 Referer 都不存在，建议直接进行阻止，特别是如果您没有使用随机 CSRF Token（参考下方）作为第二次检查。</p><h5 id="如何阻止外域请求"><a href="#如何阻止外域请求" class="headerlink" title="如何阻止外域请求"></a>如何阻止外域请求</h5><p>通过 Header 的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。</p><p>CSRF 大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称 UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。</p><p>综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的 CSRF 攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。</p><h3 id="CSRF-Token"><a href="#CSRF-Token" class="headerlink" title="CSRF Token"></a>CSRF Token</h3><p>我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。</p><p>CSRF Token 的防护策略分为三个步骤：</p><ol><li><p>将 CSRF Token 输出到页面中</p><p>首先，用户打开页面的时候，服务器需要给这个用户生成一个 Token，该 Token 通过加密算法对数据进行加密，一般 Token 都包括随机字符串和时间戳的组合，显然在<strong>提交时 Token 不能再放在 Cookie 中了，否则又会被攻击者冒用。因此，为了安全起见 Token 最好还是存在服务器的 Session 中</strong>，之后在每次页面加载时，使用 JS 遍历整个 DOM 树，对于 DOM 中所有的 a 和 form 标签后加入 Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 HTML 代码，这种方法就没有作用，还需要程序员在编码时手动添加 Token。</p></li><li><p>页面提交的请求携带这个 Token</p><p>对于 GET 请求，Token 将附在请求地址之后，这样 URL 就变成 <a href="http://url/?csrftoken=tokenvalue" target="_blank" rel="noopener">http://url?csrftoken=tokenvalue</a>。 而对于 POST 请求来说，要在 form 的最后加上：</p></li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"”hidden”"</span> <span class="attr">name</span>=<span class="string">"”csrftoken”"</span> <span class="attr">value</span>=<span class="string">"”tokenvalue”"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>​ 这样，就把 Token 以参数的形式加入请求了。</p><ol start="3"><li><p>服务器验证 Token 是否正确</p><p>当用户从客户端得到了 Token，再次提交给服务器的时候，服务器需要判断 Token 的有效性，验证过程是先解密 Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个 Token 就是有效的。</p><p>这种方法要比之前检查 Referer 或者 Origin 要安全一些，Token 可以在产生并放于 Session 之中，然后在每次请求时把 Token 从 Session 中拿出，与请求中的 Token 进行比对，但这种方法的比较麻烦的在于如何把 Token 以参数的形式加入请求。</p><h3 id="分布式校验"><a href="#分布式校验" class="headerlink" title="分布式校验"></a>分布式校验</h3></li></ol><p>在大型网站中，使用 Session 存储 CSRF Token 会带来很大的压力。访问单台服务器 session 是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的 HTTP 请求通常要经过像 Ngnix 之类的负载均衡器之后，再路由到具体的服务器上，由于 Session 默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次 HTTP 请求可能会先后落到不同的服务器上，导致后面发起的 HTTP 请求无法拿到之前的 HTTP 请求存储在服务器中的 Session 数据，从而使得 Session 机制在分布式环境下失效，因此在分布式集群中 CSRF Token 需要存储在 Redis 之类的公共存储空间。</p><p>由于使用 Session 存储，读取和验证 CSRF Token 会引起比较大的复杂度和性能问题，目前很多网站采用 Encrypted Token Pattern 方式。这种方法的 Token 是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的 Token，只用再次计算一次即可。</p><p>这种 Token 的值通常是使用 UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的 Token 一致，又能保证 Token 不容易被破解。</p><p>在 token 解密成功之后，服务器可以访问解析值，Token 中包含的 UserID 和时间戳将会被拿来被验证有效性，将 UserID 与当前登录的 UserID 进行比较，并将时间戳与当前时间进行比较。</p><h3 id="双重-Cookie-验证"><a href="#双重-Cookie-验证" class="headerlink" title="双重 Cookie 验证"></a>双重 Cookie 验证</h3><p>使用双重提交 Cookie。利用 CSRF 攻击不能获取到用户 Cookie 的特点，我们可以要求 Ajax 和表单请求携带一个 Cookie 中的值。</p><p>双重 Cookie 采用以下流程：</p><ul><li>在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串（例如<code>csrfcookie=v8g9e4ksfhw</code>）。</li><li>在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例<code>POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw</code>）。</li><li>后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。</li></ul><p>此方法相对于 CSRF Token 就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储 Token。</p><p>由于任何跨域都会导致前端无法获取 Cookie 中的字段（包括子域名之间），于是发生了如下情况：</p><ul><li>如果用户访问的网站为<code>www.a.com</code>，而后端的 api 域名为<code>api.a.com</code>。那么在<code>www.a.com</code>下，前端拿不到<code>api.a.com</code>的 Cookie，也就无法完成双重 Cookie 认证。</li><li>于是这个认证 Cookie 必须被种在<code>a.com</code>下，这样每个子域都可以访问。</li><li>任何一个子域都可以修改<code>a.com</code>下的 Cookie。</li><li>某个子域名存在漏洞被 XSS 攻击（例如<code>upload.a.com</code>）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了<code>a.com</code>下的 Cookie。</li><li>攻击者可以直接使用自己配置的 Cookie，对 XSS 中招的用户再向<code>www.a.com</code>下，发起 CSRF 攻击。</li></ul><p><strong>总结</strong></p><p>用双重 Cookie 防御 CSRF 的优点：</p><ul><li>无需使用 Session，适用面更广，易于实施。</li><li>Token 储存于客户端中，不会给服务器带来压力。</li><li>相对于 Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。</li></ul><p>缺点：</p><ul><li>Cookie 中增加了额外的字段。</li><li>如果有其他漏洞（例如 XSS），攻击者可以注入 Cookie，那么该防御方式失效。</li><li>难以做到子域名的隔离。</li><li>为了确保 Cookie 传输安全，采用这种防御方式最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式也会有风险。</li></ul><h3 id="Samesite-Cookie-属性"><a href="#Samesite-Cookie-属性" class="headerlink" title="Samesite Cookie 属性"></a>Samesite Cookie 属性</h3><p>Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax</p><ol><li><h5 id="Samesite-Strict"><a href="#Samesite-Strict" class="headerlink" title="Samesite=Strict"></a>Samesite=Strict</h5><p>这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Set-Cookie</span>: foo=1; Samesite=Strict</span><br><span class="line"><span class="attribute">Set-Cookie</span>: bar=2; Samesite=Lax</span><br><span class="line"><span class="attribute">Set-Cookie</span>: baz=3</span><br></pre></td></tr></table></figure><p>我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。</p></li><li><h5 id="Samesite-Lax"><a href="#Samesite-Lax" class="headerlink" title="Samesite=Lax"></a>Samesite=Lax</h5><p>这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 Cookie 可以作为第三方 Cookie。</p><p>当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。</p></li></ol><p>生成 Token 放到 Cookie 中并且设置 Cookie 的 Samesite</p><h5 id="我们应该如何使用-SamesiteCookie"><a href="#我们应该如何使用-SamesiteCookie" class="headerlink" title="我们应该如何使用 SamesiteCookie"></a>我们应该如何使用 SamesiteCookie</h5><p>如果 SamesiteCookie 被设置为 Strict，浏览器在任何跨域请求中都不会携带 Cookie，新标签重新打开也不携带，所以说 CSRF 攻击基本没有机会。</p><p>但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的 Cookie 都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。</p><p>如果 SamesiteCookie 被设置为 Lax，那么其他网站通过页面跳转过来的时候可以使用 Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。</p><p>另外一个问题是 Samesite 的兼容性不是很好，现阶段除了从新版 Chrome 和 Firefox 支持以外，Safari 以及 iOS Safari 都还不支持，现阶段看来暂时还不能普及。</p><p>而且，SamesiteCookie 目前有一个致命的缺陷：不支持子域。例如，种在 topic.a.com 下的 Cookie，并不能使用 a.com 下种植的 SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用 SamesiteCookie 在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。</p><p>总之，SamesiteCookie 是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。</p><h2 id="5-防止网站被利用（防止攻击的发生）"><a href="#5-防止网站被利用（防止攻击的发生）" class="headerlink" title="5.防止网站被利用（防止攻击的发生）"></a>5.防止网站被利用（防止攻击的发生）</h2><p>CSRF 的攻击可以来自：</p><ul><li>攻击者自己的网站。</li><li>有文件上传漏洞的网站。</li><li>第三方论坛等用户内容。</li><li>被攻击网站自己的评论功能等。</li></ul><p>如何防止自己的网站被利用成为攻击的源头呢？</p><ul><li>严格管理所有的上传接口，防止任何预期之外的上传内容（例如 HTML）。</li><li>添加 Header <code>X-Content-Type-Options: nosniff</code> 防止黑客上传 HTML 内容的资源（例如图片）被解析为网页。</li><li>对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。</li><li>当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。</li></ul><h2 id="6-CSRF-其他防范措施"><a href="#6-CSRF-其他防范措施" class="headerlink" title="6.CSRF 其他防范措施"></a>6.CSRF 其他防范措施</h2><h4 id="CSRF-测试"><a href="#CSRF-测试" class="headerlink" title="CSRF 测试"></a>CSRF 测试</h4><p>CSRFTester 是一款 CSRF 漏洞的测试工具，CSRFTester 工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在 CSRFTester 中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被网站服务器接受，则说明存在 CSRF 漏洞，当然此款工具也可以被用来进行 CSRF 攻击。<br>CSRFTester 使用方法大致分下面几个步骤：</p><ul><li>步骤 1：设置浏览器代理</li></ul><p>CSRFTester 默认使用 Localhost 上的端口 8008 作为其代理，如果代理配置成功，CSRFTester 将为您的浏览器生成的所有后续 HTTP 请求生成调试消息。</p><ul><li>步骤 2：使用合法账户访问网站开始测试</li></ul><p>我们需要找到一个我们想要为 CSRF 测试的特定业务 Web 页面。找到此页面后，选择 CSRFTester 中的“开始录制”按钮并执行业务功能；完成后，点击 CSRFTester 中的“停止录制”按钮；正常情况下，该软件会全部遍历一遍当前页面的所有请求。</p><ul><li>步骤 3：通过 CSRF 修改并伪造请求</li></ul><p>之后，我们会发现软件上有一系列跑出来的记录请求，这些都是我们的浏览器在执行业务功能时生成的所有 GET 或者 POST 请求。通过选择列表中的某一行，我们现在可以修改用于执行业务功能的参数，可以通过点击对应的请求修改 query 和 form 的参数。当修改完所有我们希望诱导用户 form 最终的提交值，可以选择开始生成 HTML 报告。</p><ul><li>步骤 4：拿到结果如有漏洞进行修复</li></ul><p>首先必须选择“报告类型”。报告类型决定了我们希望受害者浏览器如何提交先前记录的请求。目前有 5 种可能的报告：表单、iFrame、IMG、XHR 和链接。一旦选择了报告类型，我们可以选择在浏览器中启动新生成的报告，最后根据报告的情况进行对应的排查和修复。</p><h4 id="CSRF-监控"><a href="#CSRF-监控" class="headerlink" title="CSRF 监控"></a>CSRF 监控</h4><p>对于一个比较复杂的网站系统，某些项目、页面、接口漏掉了 CSRF 防护措施是很可能的。</p><p>一旦发生了 CSRF 攻击，我们如何及时的发现这些攻击呢？</p><p>CSRF 攻击有着比较明显的特征：</p><ul><li>跨域请求。</li><li>GET 类型请求 Header 的 MIME 类型大概率为图片，而实际返回 Header 的 MIME 类型为 Text、JSON、HTML。</li></ul><p>我们可以在网站的代理层监控所有的接口请求，如果请求符合上面的特征，就可以认为请求有 CSRF 攻击嫌疑。我们可以提醒对应的页面和项目负责人，检查或者 Review 其 CSRF 防护策略。</p><h3 id="个人用户-CSRF-安全的建议"><a href="#个人用户-CSRF-安全的建议" class="headerlink" title="个人用户 CSRF 安全的建议"></a>个人用户 CSRF 安全的建议</h3><p>经常上网的个人用户，可以采用以下方法来保护自己：</p><ul><li>使用网页版邮件的浏览邮件或者新闻也会带来额外的风险，因为查看邮件或者新闻消息有可能导致恶意代码的攻击。</li><li>尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSRF-攻击&quot;&gt;&lt;a href=&quot;#CSRF-攻击&quot; class=&quot;headerlink&quot; title=&quot;CSRF 攻击&quot;&gt;&lt;/a&gt;CSRF 攻击&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-CSRF&quot;&gt;&lt;a href=&quot;#1-什么是-CSRF&quot; class=&quot;headerlink&quot; title=&quot;1.什么是 CSRF&quot;&gt;&lt;/a&gt;1.什么是 CSRF&lt;/h2&gt;&lt;p&gt;CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。&lt;/p&gt;
&lt;p&gt;一个典型的 CSRF 攻击有着如下的流程：&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>XSS攻击</title>
    <link href="http://yoursite.com/2019/06/13/XSS%E6%94%BB%E5%87%BB/"/>
    <id>http://yoursite.com/2019/06/13/XSS攻击/</id>
    <published>2019-06-13T10:29:55.000Z</published>
    <updated>2019-09-21T14:26:18.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XSS-攻击"><a href="#XSS-攻击" class="headerlink" title="XSS 攻击"></a>XSS 攻击</h1><h2 id="1-什么是-XSS"><a href="#1-什么是-XSS" class="headerlink" title="1.什么是 XSS"></a>1.什么是 XSS</h2><p>Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</p><p>为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p><p>XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p>  <a id="more"></a><p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p><p>在处理输入时，以下内容都不可信：</p><ul><li>来自用户的 UGC 信息</li><li>来自第三方的链接</li><li>URL 参数</li><li>POST 参数</li><li>Referer （可能来自不可信的来源）</li><li>Cookie （可能来自其他子域注入）</li></ul><h2 id="2-XSS-分类"><a href="#2-XSS-分类" class="headerlink" title="2.XSS 分类"></a>2.XSS 分类</h2><p>根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5yj76xtj31by0ecgm2.jpg" alt="img"></p><h4 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h4><p>存储型 XSS 的攻击步骤：</p><ol><li>攻击者将恶意代码提交到目标网站的数据库中。</li><li>用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p><h4 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h4><p>反射型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。</li><li>用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。</p><p>反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。</p><p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p><p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p><h4 id="DOM-型-XSS"><a href="#DOM-型-XSS" class="headerlink" title="DOM 型 XSS"></a>DOM 型 XSS</h4><p>DOM 型 XSS 的攻击步骤：</p><ol><li>攻击者构造出特殊的 URL，其中包含恶意代码。</li><li>用户打开带有恶意代码的 URL。</li><li>用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。</li><li>恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。</li></ol><p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p><h2 id="3-XSS-的预防"><a href="#3-XSS-的预防" class="headerlink" title="3.XSS 的预防"></a>3.XSS 的预防</h2><p>XSS 攻击有两大要素：</p><ol><li>攻击者提交恶意代码。</li><li>浏览器执行恶意代码。</li></ol><ul><li><h3 id="输入过滤"><a href="#输入过滤" class="headerlink" title="输入过滤"></a>输入过滤</h3><p>输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。</p><p>对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。</p><p>输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类：</p><ul><li>防止 HTML 中出现注入。</li><li>防止 JavaScript 执行时，执行恶意代码。</li></ul></li><li><h3 id="预防存储型和反射型-XSS-攻击"><a href="#预防存储型和反射型-XSS-攻击" class="headerlink" title="预防存储型和反射型 XSS 攻击"></a>预防存储型和反射型 XSS 攻击</h3><p>预防这两种漏洞，有两种常见做法：</p><ul><li><p>改成纯前端渲染，把代码和数据分隔开。</p><p>纯前端渲染的过程：</p><ol><li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li><li>然后浏览器执行 HTML 中的 JavaScript。</li><li>JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。</li></ol><p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（<code>.innerText</code>），还是属性（<code>.setAttribute</code>），还是样式（<code>.style</code>）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。</p><p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞</p></li><li><p>对 HTML 做充分转义。</p><p><strong>转义应该在输出 HTML 时进行，而不是在提交用户输入时。</strong></p><p>常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 <code>&amp; &lt; &gt; &quot; &#39; /</code> 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5yiazcnj31by0giaac.jpg" alt="img"></p></li><li><h3 id="预防-DOM-型-XSS-攻击"><a href="#预防-DOM-型-XSS-攻击" class="headerlink" title="预防 DOM 型 XSS 攻击"></a>预防 DOM 型 XSS 攻击</h3><ol><li>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</li><li>如果用 Vue/React 技术栈，并且不使用 <code>v-html</code>/<code>dangerouslySetInnerHTML</code> 功能，就在前端 render 阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</li><li>DOM 中的内联事件监听器，如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等，<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性，JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</li></ol></li></ul><h2 id="4-其他-XSS-防范措施"><a href="#4-其他-XSS-防范措施" class="headerlink" title="4.其他 XSS 防范措施"></a>4.其他 XSS 防范措施</h2><h3 id="Content-Security-Policy"><a href="#Content-Security-Policy" class="headerlink" title="Content Security Policy"></a>Content Security Policy</h3><p>严格的 CSP 在 XSS 的防范中可以起到以下的作用：</p><ul><li>禁止加载外域代码，防止复杂的攻击逻辑。</li><li>禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。</li><li>禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。</li><li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。</li><li>合理使用上报可以及时发现 XSS，利于尽快修复问题。</li></ul><h3 id="输入内容长度控制"><a href="#输入内容长度控制" class="headerlink" title="输入内容长度控制"></a>输入内容长度控制</h3><p>对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。</p><h3 id="其他安全措施"><a href="#其他安全措施" class="headerlink" title="其他安全措施"></a>其他安全措施</h3><ul><li>HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。</li><li>验证码：防止脚本冒充用户提交危险操作。</li></ul><h2 id="5-XSS-漏洞总结"><a href="#5-XSS-漏洞总结" class="headerlink" title="5.XSS 漏洞总结"></a>5.XSS 漏洞总结</h2><h3 id="漏洞总结"><a href="#漏洞总结" class="headerlink" title="漏洞总结"></a>漏洞总结</h3><ul><li>在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。</li><li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。</li><li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。</li><li>在标签的 href、src 等属性中，包含 <code>javascript:</code> 等可执行代码。</li><li>在 onload、onerror、onclick 等事件中，注入不受控制代码。</li><li>在 style 属性和标签中，包含类似 <code>background-image:url(&quot;javascript:...&quot;);</code> 的代码（新版本浏览器已经可以防范）。</li><li>在 style 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）。</li></ul><p>总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。</p><ul><li>内联 JSON 也是不安全的：<ul><li>当 JSON 中包含 <code>U+2028</code> 或 <code>U+2029</code> 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。</li><li>当 JSON 中包含字符串 <code>&lt;/script&gt;</code> 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 <code>&lt;script&gt;</code> 标签等方法就可以完成注入。</li></ul></li></ul><h2 id="6-减少漏洞产生的原则"><a href="#6-减少漏洞产生的原则" class="headerlink" title="6.减少漏洞产生的原则"></a>6.减少漏洞产生的原则</h2><ul><li><strong>利用模板引擎</strong><br>开启模板引擎自带的 HTML 转义功能。例如：<br>在 ejs 中，尽量使用 <code>&lt;%= data %&gt;</code> 而不是 <code>&lt;%- data %&gt;</code>；<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j6vu6iq2j30ns01gjr9.jpg" alt="img"><br>在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 <code>freemarker.core.OutputFormat</code>。</li><li><strong>避免内联事件</strong><br>尽量不要使用 <code>onLoad=&quot;onload(&#39;&#39;)&quot;</code>、<code>onClick=&quot;go(&#39;&#39;)&quot;</code> 这种拼接内联事件的写法。在 JavaScript 中通过 <code>.addEventlistener()</code> 事件绑定会更安全。</li><li><strong>避免拼接 HTML</strong><br>前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 <code>createElement</code>、<code>setAttribute</code> 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。</li><li><strong>时刻保持警惕</strong><br>在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。</li><li><strong>增加攻击难度，降低攻击后果</strong><br>通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。</li><li><strong>主动检测和发现</strong><br>可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。</li></ul><h2 id="7-vue-react-框架对-xss-的防护有做什么？"><a href="#7-vue-react-框架对-xss-的防护有做什么？" class="headerlink" title="7.vue react 框架对 xss 的防护有做什么？"></a>7.vue react 框架对 xss 的防护有做什么？</h2><ul><li><p>VUE</p><ul><li>尽量使用插值表达式(双花括号)，它会把要显示的内容转为字符串。</li><li><ul><li>如果使用<code>v-html</code>，要保证来自服务端的渲染数据都是安全的。</li></ul></li><li>在使用第三方 UI 组件库的的时候，要检查一下它们渲染页面的方式，是否使用了<code>v-html</code></li></ul></li><li><p>REACT</p><p>XSS 防御措施就是对任何用户输入的信息进行处理，只允许合法值，其它值一概过滤掉</p><ol><li>所有的用户输入都需要经过 HTML 实体编码，React 已经做了，它会在运行时动态创建 DOM 节点然后填入文本内容 (也可以强制设置 HTML 内容，不过这样比较危险)</li><li>序列化某些状态并且传给客户端的时候，也进行 HTML 实体编码，可以使用 Yahoo 的 Serialize JavaScript 中的 serialize 方法替换 JSON.stringify 方法，Serialize JavaScript 中的方法会自动将 HTML 和 JavaScript 代码进行转码，GitHub 访问地址 : <a href="https://github.com/yahoo/serialize-javascript" target="_blank" rel="noopener">https://github.com/yahoo/serialize-javascript</a></li></ol><p>默认情况下，React DOM 在重新渲染页面时将所有进行转码，官方宣称在 React 应用中确保不会注入任何没显式编写的数据，所有的数据在页面渲染之前都会被转换成字符串，这防止 XSS 进攻</p></li></ul><h2 id="8-xss-攻击后果？"><a href="#8-xss-攻击后果？" class="headerlink" title="8.xss 攻击后果？"></a>8.xss 攻击后果？</h2><p>恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</p><p>而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。</p><h2 id="9-需要转义的字符？"><a href="#9-需要转义的字符？" class="headerlink" title="9.需要转义的字符？"></a>9.需要转义的字符？</h2><ul><li><code>escapeHTML()</code> 按照如下规则进行转义：</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5yh9feqj30ne0gqglm.jpg" alt="img"></p><ul><li><p>连 <code>javascript:</code> 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。</p><p><code>%20javascript:alert(&#39;XSS&#39;)</code> 经过 URL 解析后变成 <code>javascript:alert(&#39;XSS&#39;)</code>，这个字符串以空格开头。这样攻击者可以绕过后端的关键词规则，又成功的完成了注入。</p></li><li><p>插入 JSON 的地方不能使用 <code>escapeHTML()</code>，因为转义 <code>&quot;</code> 后，JSON 格式会被破坏。</p><p>要实现一个 <code>escapeEmbedJSON()</code> 函数，对内联 JSON 进行转义。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5ygpakdj31bk0csq2y.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;XSS-攻击&quot;&gt;&lt;a href=&quot;#XSS-攻击&quot; class=&quot;headerlink&quot; title=&quot;XSS 攻击&quot;&gt;&lt;/a&gt;XSS 攻击&lt;/h1&gt;&lt;h2 id=&quot;1-什么是-XSS&quot;&gt;&lt;a href=&quot;#1-什么是-XSS&quot; class=&quot;headerlink&quot; title=&quot;1.什么是 XSS&quot;&gt;&lt;/a&gt;1.什么是 XSS&lt;/h2&gt;&lt;p&gt;Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。&lt;/p&gt;
&lt;p&gt;为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。&lt;/p&gt;
&lt;p&gt;XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。&lt;/p&gt;
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 的新特性总结</title>
    <link href="http://yoursite.com/2019/06/01/ES6%20%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/06/01/ES6 的新特性总结/</id>
    <published>2019-06-01T14:23:01.000Z</published>
    <updated>2019-09-21T13:58:53.270Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-的新特性"><a href="#ES6-的新特性" class="headerlink" title="ES6 的新特性"></a>ES6 的新特性</h1><h2 id="1-数组的拓展"><a href="#1-数组的拓展" class="headerlink" title="1. 数组的拓展"></a>1. 数组的拓展</h2><h3 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h3><ul><li><code>array.concat(array1, array2,…arrayN)</code>合并多个数组，返回合并后的新数组，原数组没有变化。</li><li><code>array.every(callback[, thisArg])</code>检测数组中的每一个元素是否都通过了 callback 测试，全部通过返回 true，否则返回 false。</li><li><code>array.filter(callback[, thisArg])</code>返回一个新数组，包含通过 callback 函数测试的所有元素。(callback 定义，三个参数： element:当前元素值；index：当前元素下标； array:当前数组)</li><li><code>array.find(callback[, thisArg])</code>返回通过 callback 函数测试的第一个元素，否则返回 undefined，callback 函数定义同上。<a id="more"></a></li><li><code>array.findIndex(callback[, thisArg])</code>返回通过 callback 函数测试的第一个元素的索引，否则返回-1，callback 函数定义同上。</li><li><code>array.includes(searchElement, fromIndex)</code>includes() 方法用来判断一个数组是否包含一个指定的值，返回 true 或 false。searchElement：要查找的元素；fromIndex：开始查找的索引位置。</li><li><code>array.indexOf(searchElement[, fromIndex = 0])</code>返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。searchElement：要查找的元素；fromIndex：开始查找的索引位置。</li><li><code>array.join(separator=&#39;,&#39;)</code>将数组中的元素通过 separator 连接成字符串，并返回该字符串，separator 默认为”,”。</li><li><code>array.map(callback[, thisArg])</code>返回一个新数组，新数组中的每个元素都是调用 callback 函数后返回的结果。注意：如果没有 return 值，则新数组会插入一个 undefined 值。array.map 由于不具有过滤的功能，因此 array 调用 map 函数时，如果 array 中的数据并不是每一个都会 return，则必须先 filter，然后再 map，即 map 调用时必须是对数组中的每一个元素都有效。</li><li><code>array.pop() 与 array.shift()</code>pop 为从数组中删除最后一个元素，并返回最后一个元素的值，原数组的最后一个元素被删除。数组为空时返回 undefined。shift 删除数组的第一个元素，并返回第一个元素，原数组的第一个元素被删除。数组为空返回 undefined。</li><li><code>array.push(element1, element2, ....elementN) 与 array.unshift(element1, element2, ...elementN)</code>push 是将一个或多个元素添加到数组的末尾，并返回新数组的长度; unshift 将一个或多个元素添加到数组的开头，并返回新数组的长度。唯一的区别就是插入的位置不同。</li><li><code>array.reduce(callback[, initialValue])</code>对数组中的每个元素（从左到右）执行 callback 函数累加，将其减少为单个值。</li><li><code>array.reverse()</code>将数组中元素的位置颠倒。</li><li><code>array.slice(begin, end)</code>返回一个新数组，包含原数组从 begin 到 end(不包含 end)索引位置的所有元素。</li><li><code>array.some(callback[, thisArg])</code>判断数组中是否包含可以通过 callback 测试的元素，与 every 不同的是，这里只要某一个元素通过测试，即返回 true。callback 定义同上。</li><li><code>array.sort([compareFunction])</code>对数组中的元素进行排序，compareFunction 不存在时，元素按照转换为的字符串的诸个字符的 Unicode 位点进行排序，慎用！请使用时一定要加 compareFunction 函数，而且该排序是不稳定的。</li><li><code>array.splice(start[, deleteCount, item1, item2, ...])</code>通过删除现有元素和/或添加新元素来更改一个数组的内容。start:指定修改的开始位置；deleteCount：从 start 位置开始要删除的元素个数；item…：要添加进数组的元素,从 start 位置开始。返回值是由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。</li></ul><p>注：push、 shift、 pop、 unshift、 reverse、 sort、 splice 方法会对原来的数组进行修改，其他的数组操作方法只有返回值不同，对原数组都没有影响，即原数组不变。</p><h3 id="ES6-中对数组的扩展"><a href="#ES6-中对数组的扩展" class="headerlink" title="ES6 中对数组的扩展"></a>ES6 中对数组的扩展</h3><ul><li><p>Array.from() : 将伪数组对象或可遍历对象转换为真数组</p></li><li><p>Array.of(v1, v2, v3) : 将一系列值转换成数组。</p><p>当使用单个数值参数来调用 Array 构造器时，数组的长度属性会被设置为该参数。 如果使用多个参数(无论是否为数值类型)来调用，这些参数也会成为目标数组的项。数组的这种行为既混乱又有风险，因为有时可能不会留意所传参数的类型。</p><p>Array.of( )方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> items = <span class="built_in">Array</span>.of(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">1</span>]); <span class="comment">// 2</span></span><br><span class="line">items = <span class="built_in">Array</span>.of(<span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(items.length); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(items[<span class="number">0</span>]); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p>Array.of 基本上可以用来替代 Array()或 newArray()，并且不存在由于参数不同而导致的重载，而且他们的行为非常统一。</p></li><li><p>数组实例的 find() 和 findIndex()</p><ul><li><p>find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>); <span class="comment">// -5</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(<span class="function"><span class="keyword">function</span>(<span class="params">value, index, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p>数组实例的 includes()</p><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值。该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">  .includes(<span class="number">2</span>) <span class="comment">// true</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>].includes(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。它内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>]</span><br><span class="line">  .indexOf(<span class="literal">NaN</span>) <span class="comment">// -1</span></span><br><span class="line">  [<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>数组实例的 entries()，keys() 和 values()</p><p>它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">"a"</span>, <span class="string">"b"</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="2-箭头函数"><a href="#2-箭头函数" class="headerlink" title="2. 箭头函数"></a>2. 箭头函数</h2><ul><li>缩减代码和改变 this 指向</li><li>使用注意点：<ul><li>函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。</li><li>不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。</li><li>不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</li><li>不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。</li></ul></li></ul><h2 id="3-rest-参数"><a href="#3-rest-参数" class="headerlink" title="3. rest 参数"></a>3. rest 参数</h2><ul><li>用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</li><li>注意点：<ul><li>每个函数最多只能声明一个 rest 参数，而且 rest 参数必须是最后一个参数，否则报错。</li><li>rest 参数不能用于对象字面量 setter 之中</li></ul></li></ul><h2 id="4-展开运算符"><a href="#4-展开运算符" class="headerlink" title="4. 展开运算符"></a>4. 展开运算符</h2><p>剩余参数允许你把多个独立的参数合并到一个数组中；而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。</p><h2 id="5-解构赋值—-更方便的数据访问"><a href="#5-解构赋值—-更方便的数据访问" class="headerlink" title="5. 解构赋值—-更方便的数据访问"></a>5. 解构赋值—-更方便的数据访问</h2><h2 id="6-模板字符串"><a href="#6-模板字符串" class="headerlink" title="6. 模板字符串"></a>6. 模板字符串</h2><p>用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量和函数，需要将变量名写在${}之中。</p><h2 id="7-class-类"><a href="#7-class-类" class="headerlink" title="7. class 类"></a>7. class 类</h2><h2 id="8-promise"><a href="#8-promise" class="headerlink" title="8. promise"></a>8. promise</h2><h2 id="9-Iterator-和-for…of-循环"><a href="#9-Iterator-和-for…of-循环" class="headerlink" title="9. Iterator 和 for…of 循环"></a>9. Iterator 和 for…of 循环</h2><p>JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 添加了 Map 和 Set。</p><p>任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。</p><ul><li>Iterator 的作用：<ul><li>为各种数据结构，提供一个统一的、简便的访问接口；</li><li>使得数据结构的成员能够按某种次序排列</li><li>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。</li></ul></li><li>原生具备 iterator 接口的数据(可用 for of 遍历)<ul><li>Array</li><li>set 容器</li><li>map 容器</li><li>String</li><li>函数的 arguments 对象</li><li>NodeList 对象</li></ul></li><li>几种遍历方式比较<ul><li>for of 循环不仅支持数组、大多数伪数组对象，也支持字符串遍历，此外还支持 Map 和 Set 对象遍历</li><li>for in 循环可以遍历字符串、对象、数组，不能遍历 Set/Map</li><li>forEach 循环不能遍历字符串、对象,可以遍历 Set/Map</li></ul></li></ul><h2 id="10-ES6-模块化"><a href="#10-ES6-模块化" class="headerlink" title="10. ES6 模块化"></a>10. ES6 模块化</h2><p>其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-的新特性&quot;&gt;&lt;a href=&quot;#ES6-的新特性&quot; class=&quot;headerlink&quot; title=&quot;ES6 的新特性&quot;&gt;&lt;/a&gt;ES6 的新特性&lt;/h1&gt;&lt;h2 id=&quot;1-数组的拓展&quot;&gt;&lt;a href=&quot;#1-数组的拓展&quot; class=&quot;headerlink&quot; title=&quot;1. 数组的拓展&quot;&gt;&lt;/a&gt;1. 数组的拓展&lt;/h2&gt;&lt;h3 id=&quot;数组的方法&quot;&gt;&lt;a href=&quot;#数组的方法&quot; class=&quot;headerlink&quot; title=&quot;数组的方法&quot;&gt;&lt;/a&gt;数组的方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;array.concat(array1, array2,…arrayN)&lt;/code&gt;合并多个数组，返回合并后的新数组，原数组没有变化。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.every(callback[, thisArg])&lt;/code&gt;检测数组中的每一个元素是否都通过了 callback 测试，全部通过返回 true，否则返回 false。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.filter(callback[, thisArg])&lt;/code&gt;返回一个新数组，包含通过 callback 函数测试的所有元素。(callback 定义，三个参数： element:当前元素值；index：当前元素下标； array:当前数组)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;array.find(callback[, thisArg])&lt;/code&gt;返回通过 callback 函数测试的第一个元素，否则返回 undefined，callback 函数定义同上。
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>CSS元素居中</title>
    <link href="http://yoursite.com/2019/05/23/CSS%E5%85%83%E7%B4%A0%E5%B1%85%E4%B8%AD/"/>
    <id>http://yoursite.com/2019/05/23/CSS元素居中/</id>
    <published>2019-05-23T10:06:01.000Z</published>
    <updated>2019-09-21T14:26:18.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-元素居中"><a href="#CSS-元素居中" class="headerlink" title="CSS 元素居中"></a>CSS 元素居中</h1><h2 id="1-水平居中"><a href="#1-水平居中" class="headerlink" title="1.水平居中"></a>1.水平居中</h2><ul><li><h3 id="行内元素水平居中"><a href="#行内元素水平居中" class="headerlink" title="行内元素水平居中"></a>行内元素水平居中</h3></li></ul><p><strong>利用 text-align: center 可以实现在块级元素内部的行内元素水平居中</strong>。此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。</p><a id="more"></a><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  //在父容器设置</span><br><span class="line">  <span class="selector-tag">text-align</span>: <span class="selector-tag">center</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，如果块级元素内部包着也是一个块级元素，<strong>我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    text-align: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">    display: inline-block;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="块级元素的水平居中"><a href="#块级元素的水平居中" class="headerlink" title="块级元素的水平居中"></a>块级元素的水平居中</h3></li></ul><p>这种情形可以有多种实现方式，下面我们详细介绍:</p><h4 id="①-将该块级元素左右外边距-margin-left-和-margin-right-设置为-auto"><a href="#①-将该块级元素左右外边距-margin-left-和-margin-right-设置为-auto" class="headerlink" title="① 将该块级元素左右外边距 margin-left 和 margin-right 设置为 auto"></a>① 将该块级元素左右外边距 margin-left 和 margin-right 设置为 auto</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  width: 100px; //确保该块级元素定宽</span><br><span class="line">  <span class="selector-tag">margin</span>: 0 <span class="selector-tag">auto</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-使用-table-margin"><a href="#②-使用-table-margin" class="headerlink" title="② 使用 table+margin"></a>② 使用 table+margin</h4><p>先将子元素设置为块级表格来显示（类似），再将其设置水平居中</p><p>display:table 在表现上类似 block 元素，但是宽度为内容宽。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">    display: table;</span><br><span class="line">    margin: 0 auto;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="③-使用-absolute-transform"><a href="#③-使用-absolute-transform" class="headerlink" title="③ 使用 absolute+transform"></a>③ 使用 absolute+transform</h4><p>先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">    position: absolute;</span><br><span class="line">    left: 50%;</span><br><span class="line">    transform: translateX(-50%);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    position: relative;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过 transform 属于 css3 内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀</p><h4 id="④-使用-flex-justify-content"><a href="#④-使用-flex-justify-content" class="headerlink" title="④ 使用 flex+justify-content"></a>④ 使用 flex+justify-content</h4><p>通过 CSS3 中的布局利器 flex 中的 justify-content 属性来达到水平居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    display: flex;</span><br><span class="line">    justify-content: center;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="⑤-使用-flex-margin"><a href="#⑤-使用-flex-margin" class="headerlink" title="⑤ 使用 flex+margin"></a>⑤ 使用 flex+margin</h4><p>通过 flex 将父容器设置为为 Flex 布局，再设置子元素居中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;parent&quot;&gt;</span><br><span class="line">  &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;style&gt;</span><br><span class="line">  .parent &#123;</span><br><span class="line">    display: flex;</span><br><span class="line">  &#125;</span><br><span class="line">  .child &#123;</span><br><span class="line">    margin:0 auto;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li><h3 id="多块级元素水平居中"><a href="#多块级元素水平居中" class="headerlink" title="多块级元素水平居中"></a>多块级元素水平居中</h3></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iywusnatj30gg03q3yv.jpg" alt="img"></p><h4 id="①-利用-flex-布局"><a href="#①-利用-flex-布局" class="headerlink" title="① 利用 flex 布局"></a>① 利用 flex 布局</h4><p><strong>利用弹性布局(flex)，实现水平居中，其中 justify-content 用于设置弹性盒子元素在主轴（默认横轴）方向上的对齐方式</strong>，本例中设置子元素水平居中显示。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="②-利用-inline-block"><a href="#②-利用-inline-block" class="headerlink" title="② 利用 inline-block"></a>② 利用 inline-block</h4><p>将要水平排列的块状元素设为 display:inline-block，然后在父级元素上设置 text-align:center，达到与上面的行内元素的水平居中一样的效果。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.inline-block</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="浮动元素水平居中"><a href="#浮动元素水平居中" class="headerlink" title="浮动元素水平居中"></a>浮动元素水平居中</h3><ul><li>对于定宽的浮动元素，通过子元素设置 relative + 负 margin</li><li>对于不定宽的浮动元素，父子容器都用相对定位</li><li>通用方法(不管是定宽还是不定宽)：flex 布局</li></ul></li></ul><h4 id="①-定宽的非浮动元素"><a href="#①-定宽的非浮动元素" class="headerlink" title="① 定宽的非浮动元素"></a>① 定宽的非浮动元素</h4><p><strong>通过子元素设置 relative + 负 margin,原理见下图：</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyzsq98xj30i80acmx5.jpg" alt="img"><br><strong>注意：样式设置在浮动元素本身</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.child &#123; position:relative; left:50%; margin-left:-250px; &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"child"</span> <span class="attr">style</span>=<span class="string">"float: left;width: 500px;"</span></span></span><br><span class="line"><span class="tag">    &gt;</span>我是要居中的浮动元素<span class="tag">&lt;/<span class="name">span</span></span></span><br><span class="line"><span class="tag">  &gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②-不定宽的浮动元素"><a href="#②-不定宽的浮动元素" class="headerlink" title="② 不定宽的浮动元素"></a>② 不定宽的浮动元素</h4><p>通过父子容器都相对定位，偏移位移见下图：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyxlpetcj30pw06tmx8.jpg" alt="img"><br><strong>注意：要清除浮动，给外部元素加上 float。这里的父元素就是外部元素</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是浮动的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我也是居中的<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.box&#123; float:left; position:relative; left:50%; &#125; p&#123; float:left;</span><br><span class="line">position:relative; right:50%; &#125;</span><br></pre></td></tr></table></figure><h4 id="③-通用办法-flex-布局-不管是定宽还是不定宽"><a href="#③-通用办法-flex-布局-不管是定宽还是不定宽" class="headerlink" title="③ 通用办法 flex 布局(不管是定宽还是不定宽)"></a>③ 通用办法 flex 布局(不管是定宽还是不定宽)</h4><p><strong>利用弹性布局(flex)的 justify-content 属性，实现水平居中</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.parent &#123; display:flex; justify-content:center; &#125; .chlid&#123; float: left; width:</span><br><span class="line">200px;//有无宽度不影响居中 &#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"chlid"</span>&gt;</span>我是要居中的浮动元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="绝对定位元素水平居中"><a href="#绝对定位元素水平居中" class="headerlink" title="绝对定位元素水平居中"></a>绝对定位元素水平居中</h3></li></ul><p>这种方式非常独特，<strong>通过子元素绝对定位，外加 margin: 0 auto 来实现</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>让绝对定位的元素水平居中对齐。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width:</span><br><span class="line">200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0;</span><br><span class="line">/*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125;</span><br></pre></td></tr></table></figure><h2 id="2-垂直居中"><a href="#2-垂直居中" class="headerlink" title="2.垂直居中"></a>2.垂直居中</h2><ul><li><h3 id="单行内联元素垂直居中"><a href="#单行内联元素垂直居中" class="headerlink" title="单行内联元素垂直居中"></a>单行内联元素垂直居中</h3></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"box"</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>单行内联元素垂直居中。<span class="tag">&lt;/<span class="name">span</span>&gt;</span>。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#box</span> &#123;</span></span><br><span class="line">    height: 120px;</span><br><span class="line">    line-height: 120px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">dashed</span> <span class="selector-id">#f69c55</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="多行内联元素垂直居中"><a href="#多行内联元素垂直居中" class="headerlink" title="多行内联元素垂直居中"></a>多行内联元素垂直居中</h3></li></ul><h4 id="①-利用-flex-布局（flex）"><a href="#①-利用-flex-布局（flex）" class="headerlink" title="① 利用 flex 布局（flex）"></a>① 利用 flex 布局（flex）</h4><p><strong>利用 flex 布局实现垂直居中，其中 flex-direction: column 定义主轴方向为纵向</strong>。这种方式在较老的浏览器存在兼容性问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Dance like nobody is watching, code like everybody is. Dance like nobody is</span><br><span class="line">    watching, code like everybody is. Dance like nobody is watching, code like</span><br><span class="line">    everybody is.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    height: 140px;</span><br><span class="line">    display: flex;</span><br><span class="line">    flex-direction: column;</span><br><span class="line">    justify-content: center;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">dashed</span> <span class="selector-id">#f69c55</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iz0f2donj30k504ejrj.jpg" alt="img"></p><h4 id="②-利用表布局（table）"><a href="#②-利用表布局（table）" class="headerlink" title="② 利用表布局（table）"></a>② 利用表布局（table）</h4><p><strong>利用表布局的 vertical-align: middle 可以实现子元素的垂直居中</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span></span><br><span class="line">    The more technology you learn, the more you realize how little you know. The</span><br><span class="line">    more technology you learn, the more you realize how little you know. The</span><br><span class="line">    more technology you learn, the more you realize how little you know.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    display: table;</span><br><span class="line">    height: 140px;</span><br><span class="line"><span class="css">    <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">dashed</span> <span class="selector-id">#f69c55</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.child</span> &#123;</span></span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="块级元素垂直居中"><a href="#块级元素垂直居中" class="headerlink" title="块级元素垂直居中"></a>块级元素垂直居中</h3></li></ul><h4 id="①-使用-absolute-负-margin-已知高度宽度"><a href="#①-使用-absolute-负-margin-已知高度宽度" class="headerlink" title="① 使用 absolute+负 margin(已知高度宽度)"></a>① 使用 absolute+负 margin(已知高度宽度)</h4><p><strong>通过绝对定位元素距离顶部 50%，并设置 margin-top 向上偏移元素高度的一半，就可以实现了</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>固定高度的块级元素垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; height:</span><br><span class="line">100px; margin-top: -50px; &#125;</span><br></pre></td></tr></table></figure><h4 id="②-使用-absolute-transform"><a href="#②-使用-absolute-transform" class="headerlink" title="② 使用 absolute+transform"></a>② 使用 absolute+transform</h4><p><strong>当垂直居中的元素的高度和宽度未知时，可以借助 CSS3 中的 transform 属性向 Y 轴反向偏移 50%的方法实现垂直居中</strong>。但是部分浏览器存在兼容性的问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>未知高度的块级元素垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%;</span><br><span class="line">transform: translateY(-50%); &#125;</span><br></pre></td></tr></table></figure><h4 id="③-使用-flex-align-items"><a href="#③-使用-flex-align-items" class="headerlink" title="③ 使用 flex+align-items"></a>③ 使用 flex+align-items</h4><p><strong>通过设置 flex 布局中的属性 align-items，使子元素垂直居中</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>未知高度的块级元素垂直居中。<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">.parent &#123; display:flex; align-items:center; &#125;</span><br></pre></td></tr></table></figure><h4 id="④-使用-table-cell-vertical-align"><a href="#④-使用-table-cell-vertical-align" class="headerlink" title="④ 使用 table-cell+vertical-align"></a>④ 使用 table-cell+vertical-align</h4><p><strong>通过将父元素转化为一个表格单元格显示（类似 <td> 和 <th>），再通过设置 vertical-align 属性，使表格单元格内容垂直居中。</th></td></strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span>Demo<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">    display: table-cell;</span><br><span class="line">    vertical-align: middle;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-水平垂直居中"><a href="#3-水平垂直居中" class="headerlink" title="3.水平垂直居中"></a>3.水平垂直居中</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// html部分(这部分不做变化,下面例子直接共用)</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"center"</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;background-color: #666"</span>&gt;</span></span><br><span class="line">      center</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="绝对定位与负边距实现（已知高度宽度）"><a href="#绝对定位与负边距实现（已知高度宽度）" class="headerlink" title="绝对定位与负边距实现（已知高度宽度）"></a>绝对定位与负边距实现（已知高度宽度）</h3></li></ul><p><strong>这种方式需要知道被垂直居中元素的高和宽，才能计算出 margin 值，兼容所有浏览器</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// css部分</span><br><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="绝对定位与-margin-auto（已知高度宽度）"><a href="#绝对定位与-margin-auto（已知高度宽度）" class="headerlink" title="绝对定位与 margin:auto（已知高度宽度）"></a>绝对定位与 margin:auto（已知高度宽度）</h3></li></ul><p><strong>这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的 IE 浏览器。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  height: 100px; //必须有个高度</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  margin: auto; //注意此处的写法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="绝对定位-transform-未知元素的高宽"><a href="#绝对定位-transform-未知元素的高宽" class="headerlink" title="绝对定位+transform(未知元素的高宽)"></a>绝对定位+transform(未知元素的高宽)</h3></li></ul><p><strong>利用 Css3 的 transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中</strong>。<br>CSS3 的 transform 固然好用，但在项目的实际运用中必须考虑兼容问题，大量的 hack 代码可能会导致得不偿失。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h3></li></ul><p><strong>利用 flex 布局，其中 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而 align-items 属性定义 flex 子项在 flex 容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的 IE 浏览器。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  //直接在父容器设置即可</span><br><span class="line">  height: 100vh; //必须有高度</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">flex</span>;</span><br><span class="line">  <span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;</span><br><span class="line">  <span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="flex-grid-与-margin-auto-最简单写法"><a href="#flex-grid-与-margin-auto-最简单写法" class="headerlink" title="flex/grid 与 margin:auto(最简单写法)"></a>flex/grid 与 margin:auto(最简单写法)</h3></li></ul><p><strong>容器元素设为 flex 布局或是 grid 布局，子元素只要写 margin: auto 即可,不能兼容低版本的 IE 浏览器。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#container</span> &#123;</span><br><span class="line">  height: 100vh; //必须有高度</span><br><span class="line">  <span class="selector-tag">display</span>: <span class="selector-tag">grid</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#center</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS-元素居中&quot;&gt;&lt;a href=&quot;#CSS-元素居中&quot; class=&quot;headerlink&quot; title=&quot;CSS 元素居中&quot;&gt;&lt;/a&gt;CSS 元素居中&lt;/h1&gt;&lt;h2 id=&quot;1-水平居中&quot;&gt;&lt;a href=&quot;#1-水平居中&quot; class=&quot;headerlink&quot; title=&quot;1.水平居中&quot;&gt;&lt;/a&gt;1.水平居中&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;h3 id=&quot;行内元素水平居中&quot;&gt;&lt;a href=&quot;#行内元素水平居中&quot; class=&quot;headerlink&quot; title=&quot;行内元素水平居中&quot;&gt;&lt;/a&gt;行内元素水平居中&lt;/h3&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;利用 text-align: center 可以实现在块级元素内部的行内元素水平居中&lt;/strong&gt;。此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS多列布局</title>
    <link href="http://yoursite.com/2019/05/08/CSS%E5%A4%9A%E5%88%97%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2019/05/08/CSS多列布局/</id>
    <published>2019-05-08T03:25:33.000Z</published>
    <updated>2019-09-21T14:26:18.053Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-单列布局"><a href="#1-单列布局" class="headerlink" title="1.单列布局"></a>1.单列布局</h2><p>常见的单列布局有两种：</p><ul><li>header,content 和 footer 等宽的单列布局</li><li>header 与 footer 等宽,content 略窄的单列布局<a id="more"></a></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iysrsoe5j31100h2q3f.jpg" alt="img"></p><h3 id="第一种："><a href="#第一种：" class="headerlink" title="第一种："></a>第一种：</h3><p>对于第一种，先通过对 header,content,footer 统一设置 width：1000px;或者 max-width：1000px(这两者的区别是当屏幕小于 1000px 时，前者会出现滚动条，后者则不会，显示出实际宽度);然后设置 margin:auto 实现居中即可得到。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二种："><a href="#第二种：" class="headerlink" title="第二种："></a>第二种：</h3><p>对于第二种，header、footer 的内容宽度不设置，块级元素充满整个屏幕，但 header、content 和 footer 的内容区设置同一个 width，并通过 margin:auto 实现居中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.header</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.nav</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: darkgray;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aquamarine;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">max-width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: aqua;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-两列自适应布局"><a href="#2-两列自适应布局" class="headerlink" title="2.两列自适应布局"></a>2.两列自适应布局</h2><p><strong>两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式</strong></p><h3 id="float-overflow-hidden"><a href="#float-overflow-hidden" class="headerlink" title="float+overflow:hidden"></a>float+overflow:hidden</h3><p>如果是普通的两列布局，<strong>浮动+普通元素的 margin</strong>便可以实现，但如果是自适应的两列布局，利用<strong>float+overflow:hidden</strong>便可以实现，<strong>这种办法主要通过 overflow 触发 BFC,而 BFC 不会重叠浮动元素</strong>。由于设置 overflow:hidden 并不会触发 IE6-浏览器的 haslayout 属性，所以需要设置 zoom:1 来兼容 IE6-浏览器。具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span> <span class="attr">style</span>=<span class="string">"background-color: lightgrey;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span> <span class="attr">style</span>=<span class="string">"background-color: lightblue;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span> <span class="attr">style</span>=<span class="string">"background-color: lightgreen;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意点:如果侧边栏在右边时，注意渲染顺序。即在 HTML 中，先写侧边栏后写主内容</p><h3 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h3><p>Flex 布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//html部分同上</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="grid-布局"><a href="#grid-布局" class="headerlink" title="grid 布局"></a>grid 布局</h3><p>Grid 布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//html部分同上</span><br><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: auto <span class="number">1</span>fr;</span><br><span class="line">  <span class="attribute">grid-gap</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-三栏布局"><a href="#3-三栏布局" class="headerlink" title="3.三栏布局"></a>3.三栏布局</h2><p><strong>特征：中间列自适应宽度，旁边两侧固定宽度</strong></p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><ul><li><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4></li></ul><p><strong>比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是 dom 结构必须是先写中间列部分，这样实现中间列可以优先加载</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>圣杯布局<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  padding-left: 220px; //为左右栏腾出空间</span><br><span class="line">  <span class="selector-tag">padding-right</span>: 220<span class="selector-tag">px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">220px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>三个部分都设定为左浮动，<strong>否则左右两边内容上不去，就不可能与中间列同一行</strong>。然后设置 center 的宽度为 100%(<strong>实现中间列内容自适应</strong>)，此时，left 和 right 部分会跳到下一行</li><li>通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行</li><li>通过设置父容器的 padding-left 和 padding-right，让左右两边留出间隙。</li><li>通过设置相对定位，让 left 和 right 部分移动到两边。</li></ul></li><li><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>center 部分的最小宽度不能小于 left 部分的宽度，否则会 left 部分掉到下一行</li><li>如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正 padding+负 margin 可解决，下文会介绍)</li></ul></li></ul><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><ul><li><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4></li></ul><p><strong>同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"inner"</span>&gt;</span>双飞翼布局<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  min-width: 600px; //确保中间内容可以显示出来，两倍left宽+right宽</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.center</span> <span class="selector-class">.inner</span> &#123;</span><br><span class="line">  margin: 0 200px; //新增部分</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="实现步骤-前两步与圣杯布局一样"><a href="#实现步骤-前两步与圣杯布局一样" class="headerlink" title="实现步骤(前两步与圣杯布局一样)"></a>实现步骤(前两步与圣杯布局一样)</h4><ul><li>三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行；</li><li>通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行；</li><li>center 部分增加一个内层 div，并设 margin: 0 200px；</li></ul></li><li><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p><strong>多加一层 dom 树节点，增加渲染树生成的计算量</strong>。</p></li><li><h4 id="两种布局实现方式对比"><a href="#两种布局实现方式对比" class="headerlink" title="两种布局实现方式对比:"></a>两种布局实现方式对比:</h4><ul><li>两种布局方式都是把主列放在文档流最前面，使主列优先加载。</li><li>两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。</li><li>两种布局方式的不同之处在于如何处理中间主列的位置：<br><strong>圣杯布局是利用父容器的左、右内边距+两个从列相对定位</strong>；<br><strong>双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整</strong></li></ul></li></ul><h3 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-right-center"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  // 右栏部分要写在中间内容之前</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>浮动解决方案<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案；</span><br><span class="line">    3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案；</span><br><span class="line">    5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案；</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.float</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: right;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种布局方式，dom 结构必须是先写浮动部分，然后再中间块，否则右浮动块会掉到下一行。<br><strong>浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等</strong>。</p><h3 id="绝对布局"><a href="#绝对布局" class="headerlink" title="绝对布局"></a>绝对布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>绝对定位解决方案<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案；</span><br><span class="line">    3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案；</span><br><span class="line">    5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案；</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left-center-right</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  position: absolute; //三块都是绝对定位</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">300px</span>;</span><br><span class="line">  left: 300px; //离左右各三百</span><br><span class="line">  <span class="selector-tag">background</span>: <span class="selector-tag">yellow</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.absolute</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。</strong></p><h3 id="flexbox-布局"><a href="#flexbox-布局" class="headerlink" title="flexbox 布局"></a>flexbox 布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>flexbox解决方案<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案；</span><br><span class="line">    3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案；</span><br><span class="line">    5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案；</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.left-center-right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.flexbox</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>flexbox 布局是 css3 里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用 flexbox。 flexbox 的缺点就是 IE10 开始支持，但是 IE10 的是-ms 形式的。</strong></p><h3 id="表格布局"><a href="#表格布局" class="headerlink" title="表格布局"></a>表格布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>表格布局解决方案<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案；</span><br><span class="line">    3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案；</span><br><span class="line">    5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案；</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">150px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left-center-right</span> &gt; <span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.table</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>表格布局的兼容性很好(见下图)，在 flex 布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素</strong>。</p><p><strong>表格布局也是有缺陷:① 无法设置栏边距；② 对 seo 不友好；③ 当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。</strong></p><h3 id="网格布局"><a href="#网格布局" class="headerlink" title="网格布局"></a>网格布局</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"left-center-right"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>网格布局解决方案<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案；</span><br><span class="line">    3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案；</span><br><span class="line">    5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案；</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left-center-right</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">300px</span> auto <span class="number">300px</span>;</span><br><span class="line">  grid-template-rows: 150px; //行高</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.layout</span><span class="selector-class">.grid</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>CSS Grid 是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让 Web 设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位</strong>。</p><p><strong>但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性</strong>。</p><h2 id="4-等高布局"><a href="#4-等高布局" class="headerlink" title="4.等高布局"></a>4.等高布局</h2><p>等高布局是指子元素在父元素中高度相等的布局方式。接下来我们介绍常见几种实现方式：</p><ul><li><h4 id="利用正-padding-负-margin"><a href="#利用正-padding-负-margin" class="headerlink" title="利用正 padding+负 margin"></a>利用正 padding+负 margin</h4></li></ul><p>我们通过等高布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，<strong>设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉</strong>。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。新增代码如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.center</span>,</span><br><span class="line"><span class="selector-class">.left</span>,</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">10000px</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: -<span class="number">10000px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">220px</span>;</span><br><span class="line">  <span class="attribute">padding-right</span>: <span class="number">220px</span>;</span><br><span class="line">  overflow: hidden; //把溢出背景切掉</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="利用背景图片"><a href="#利用背景图片" class="headerlink" title="利用背景图片"></a>利用背景图片</h4></li></ul><p>这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行 Y 轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的 css 样式就可以轻松实现,但此方法不适合流体布局等高列的布局。</p><p>在制作样式之前需要一张类似下面的背景图：</p><p><a href="https://camo.githubusercontent.com/7b26b4a48392ca95709486320efc031dd8e9ea58/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32312f313637636633633031343664323436343f773d35303026683d313226663d67696626733d333133" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/7b26b4a48392ca95709486320efc031dd8e9ea58/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32312f313637636633633031343664323436343f773d35303026683d313226663d67696626733d333133" alt="img"></a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"”container"</span> <span class="attr">clearfix</span>”&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"”left”"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"”content”"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"”right”"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">"column.png"</span>) repeat-y;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">480px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="模仿表格布局"><a href="#模仿表格布局" class="headerlink" title="模仿表格布局"></a>模仿表格布局</h4></li></ul><p>这是一种非常简单，易于实现的方法。不过兼容性不好，在 ie6-7 无法正常运行。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"container table"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"containerInner tableRow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column tableCell cell1"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left aside"</span>&gt;</span></span><br><span class="line">        ....</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column tableCell cell2"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content section"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"column tableCell cell3"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right aside"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.table</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">min-width</span>: <span class="number">1000px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tableRow</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-row;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.tableCell</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">33%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cell1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cell2</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#0f0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.cell3</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#00f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="使用边框和定位"><a href="#使用边框和定位" class="headerlink" title="使用边框和定位"></a>使用边框和定位</h4></li></ul><p>这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrapper"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"mainContent"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"sidebar"</span>&gt;</span>...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">960px</span>;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#mainContent</span> &#123;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">220px</span> solid <span class="number">#dfdfdf</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">740px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#dfdfdf</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">740px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">800px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">220px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-粘连布局"><a href="#5-粘连布局" class="headerlink" title="5.粘连布局"></a>5.粘连布局</h2><ul><li><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><ul><li>有一块内容<code>&lt;main&gt;</code>，当<code>&lt;main&gt;</code>的高康足够长的时候，紧跟在<code>&lt;main&gt;</code>后面的元素<code>&lt;footer&gt;</code>会跟在<code>&lt;main&gt;</code>元素的后面。</li><li>当<code>&lt;main&gt;</code>元素比较短的时候(比如小于屏幕的高度),我们期望这个<code>&lt;footer&gt;</code>元素能够“粘连”在屏幕的底部</li></ul></li></ul><p>具体代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"main"</span>&gt;</span></span><br><span class="line">    main <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    main <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    main <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  height: 100%; //高度一层层继承下来</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#wrap</span> <span class="selector-class">.main</span> &#123;</span><br><span class="line">  <span class="attribute">padding-bottom</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#footer</span> &#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">background</span>: deeppink;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><h4 id="实现步骤-1"><a href="#实现步骤-1" class="headerlink" title="实现步骤"></a>实现步骤</h4><ul><li>footer 必须是一个独立的结构，与 wrap 没有任何嵌套关系</li><li>wrap 区域的高度通过设置 min-height，变为视口高度</li><li>footer 要使用 margin 为负来确定自己的位置</li><li>在 main 区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-单列布局&quot;&gt;&lt;a href=&quot;#1-单列布局&quot; class=&quot;headerlink&quot; title=&quot;1.单列布局&quot;&gt;&lt;/a&gt;1.单列布局&lt;/h2&gt;&lt;p&gt;常见的单列布局有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;header,content 和 footer 等宽的单列布局&lt;/li&gt;
&lt;li&gt;header 与 footer 等宽,content 略窄的单列布局
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS常用布局方式</title>
    <link href="http://yoursite.com/2019/05/02/CSS%E5%B8%B8%E7%94%A8%E5%B8%83%E5%B1%80%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/05/02/CSS常用布局方式/</id>
    <published>2019-05-02T07:44:43.000Z</published>
    <updated>2019-09-21T14:26:18.053Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-常用布局方式"><a href="#CSS-常用布局方式" class="headerlink" title="CSS 常用布局方式"></a>CSS 常用布局方式</h1><h2 id="1-静态布局（固定布局）"><a href="#1-静态布局（固定布局）" class="headerlink" title="1.静态布局（固定布局）"></a>1.静态布局（固定布局）</h2><h3 id="布局特点"><a href="#布局特点" class="headerlink" title="布局特点"></a>布局特点</h3><p>不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。</p>  <a id="more"></a><h3 id="设计方法"><a href="#设计方法" class="headerlink" title="设计方法"></a>设计方法</h3><ul><li>PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个 Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分；</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">640px</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 有固定的版型大小，例如 640px，然后设置 margin：0 auto；来居中。小于 640 时出现滚动条。</p><ul><li>移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如 wap.或 m.。在 <code>&lt;viewport meta&gt;</code> 标签上设置 <code>width</code>，页面的各个元素也采用<code>px</code>作为单位。通过用 JS 动态修改标签的<code>initial-scale</code>使得页面等比缩放，从而刚好占满整个屏幕。</li></ul><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>普通/文档流 布局</li><li>Float 布局</li><li>绝对布局</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：这种布局方式对设计师和 CSS 编写者来说都是最简单的，亦没有兼容性问题。</p><p>缺点：显而易见，不能根据用户的屏幕尺寸做出不同的展现。当前，大部分门户网站、大部分企业的 PC 宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。</p><ul><li>窄屏幕滚动条体验很差</li><li>宽屏有大片空白，不利于空间利用</li></ul><h2 id="2-流式布局"><a href="#2-流式布局" class="headerlink" title="2.流式布局"></a>2.流式布局</h2><p>流式布局（Liquid）的特点（也叫”Fluid”) 是<strong>页面元素的宽度</strong>按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。网页中主要的划分区域的<strong>尺寸使用百分数</strong>（搭配 min-<em>、max-</em>属性使用），例如，设置网页主体的宽度为 80%，min-width 为 960px。图片也作类似处理（width:100%, max-width 一般设定为图片本身的尺寸，防止被拉伸而失真）。</p><h3 id="布局特点-1"><a href="#布局特点-1" class="headerlink" title="布局特点"></a>布局特点</h3><p>屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示。</p><h3 id="设计方法-1"><a href="#设计方法-1" class="headerlink" title="设计方法"></a>设计方法</h3><p><strong>使用%百分比定义宽度，而高度大都是用 px 来固定住</strong>，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。</p><p><strong>这种布局方式在 Web 前端开发的早期历史上，用来应对不同尺寸的 PC 屏幕</strong>（那时屏幕尺寸的差异不会太大），<strong>在当今的移动端开发也是常用布局方式</strong>。流式布局目的是在不同大小的设备上<strong>满屏呈现同样网页</strong>。它是用于解决类似的设备不同分辨率之间的兼容(一般分辨率差异较少)。</p><p><strong>百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。</strong></p><ul><li>如果用百分比写 width，那么指的是父元素 width 的百分之多少。</li><li>如果用百分比写 height，那么指的是父元素 height 的百分之多少。</li><li>如果用百分比写 padding，那么指的是*<em>父元素 width *</em>的百分之多少，无论是水平的 padding 还是竖直的 padding。</li><li>如果用百分比写 margin，那么指的是<strong>父元素 width</strong> 的百分之多少，无论是水平的 margin 还是竖直的 margin。</li><li>不能用百分比写 border 的宽度</li></ul><h3 id="实现方法-1"><a href="#实现方法-1" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li>允许网页宽度自动调整：<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt;</code></li><li>不使用绝对尺寸（包括容器/字体/图片），使用百分比、em、rem、vw、vh 等</li><li>可使用 flex 等弹性盒子（不要使用 px 定尺寸）</li></ul><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：页面左右满屏。</p><p>但缺点明显：</p><p>主要的问题**是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用 px 来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调</p><ul><li>使用百分比定义，所以在大屏幕的手机/Pad 下（或者横屏下）显示效果会变成有些页面元素被拉的很大，但是内容数量却不变，显得稀疏不紧凑，空间利用率低下。</li><li>如果文字也按照百分比放大，则整体效果会非常不协调（老人机效果）。</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p><a href="https://www.trip.com/flightsh5/status/" target="_blank" rel="noopener">https://www.trip.com/flightsh5/status/</a></p><h2 id="3-自适应布局"><a href="#3-自适应布局" class="headerlink" title="3.自适应布局"></a>3.自适应布局</h2><p>自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个合集。</p><h3 id="布局特点-2"><a href="#布局特点-2" class="headerlink" title="布局特点"></a>布局特点</h3><p>屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。</p><h3 id="设计方法-2"><a href="#设计方法-2" class="headerlink" title="设计方法"></a>设计方法</h3><p>使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。</p><h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>静态布局方法</li><li>分辨率 detector（media query/server-side detector/UA）</li></ul><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：自适应布局<strong>页面里面元素的位置会变化，很好的解决了流式布局中的大屏空间利用率不高弊端</strong>。</p><p>缺点：单个布局容器无法灵活伸缩，未触发布局切换的情况下，容器仍然容易出现静态布局中提到的问题。</p><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.baidu.com%2F" target="_blank" rel="noopener">www.baidu.com/</a></p><h3 id="自适应设计（AWD）"><a href="#自适应设计（AWD）" class="headerlink" title="自适应设计（AWD）"></a>自适应设计（AWD）</h3><p>自适应设计是通过<strong>服务端检测设备类型、从 site 的不同版本中选择最合适该设备类型的设计布局/尺寸的版本进行展示。</strong>它可以使用到所有（包括响应式布局）布局方案。</p><p>实现方式：</p><ul><li><p>server-side detection</p></li><li><p>different versions to different devices</p><p>对于 PC: 可使用流式布局；</p><p>对于 Mobile: 可使用流式布局。推荐一个 Rem 解决方案：</p><ul><li>设置元素（可以包括字体等）大小为 <code>rem</code> （<code>rem</code> 是以跟元素<code>font-size</code>为基准的单位）</li><li>按照屏幕宽度的不同，JS 动态设置 <code>&lt;html&gt;</code> 的 <code>font-size</code> 大小，元素同样会按照屏幕宽度等比例放大缩小</li></ul></li></ul><p>举个栗子：<a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.trip.com%2F" target="_blank" rel="noopener">www.trip.com/</a></p><h2 id="4-响应式布局（媒体查询）"><a href="#4-响应式布局（媒体查询）" class="headerlink" title="4.响应式布局（媒体查询）"></a>4.响应式布局（媒体查询）</h2><p>随着 CSS3 出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的 PC、手机、手表、冰箱的 Web 浏览器等等）都能显示出令人满意的效果，对 CSS 编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。改变屏幕分辨率可以通过 CSS Media query 实时地切换不同的布局（页面元素位置可能发生改变），在每个布局中，页面元素会随窗口大小的调整发生流式布局中的自动尺寸变化。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。</p><p>响应式几乎已经成为优秀页面布局的标准。</p><h3 id="布局特点-3"><a href="#布局特点-3" class="headerlink" title="布局特点"></a>布局特点</h3><p>每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。</p><h3 id="设计方法-3"><a href="#设计方法-3" class="headerlink" title="设计方法"></a>设计方法</h3><p>媒体查询+流式布局。通常使用 @media 媒体查询和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。</p><h3 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h3><ul><li>流式布局</li><li>CSS media query</li></ul><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：适应 pc 和移动端，如果足够耐心，效果完美。融合了流式布局和自适应布局的优势。</p><p>缺点：</p><ul><li>媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。</li><li>要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。</li><li>CSS 代码繁琐，对于特定的设备有较多冗余，适用于对于各个终端（特别是移动端）性能要求不高的 Blog Dos 站点。</li></ul><p>响应式页面在头部会加上这一段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"applicable-device"</span> <span class="attr">content</span>=<span class="string">"pc,mobile"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Cache-Control"</span> <span class="attr">content</span>=<span class="string">"no-transform "</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p><a href="https://link.juejin.im/?target=http%3A%2F%2Felevenbeans.github.io%2F" target="_blank" rel="noopener">elevenbeans.github.io/</a></p><h3 id="响应式设计（RWD）"><a href="#响应式设计（RWD）" class="headerlink" title="响应式设计（RWD）"></a>响应式设计（RWD）</h3><p>响应式设计基于响应式布局，<strong>使用同一套页面在各种各样不同大小的设备上进行大小合适、布局（甚至功能）合理的展现。</strong></p><p>响应式设计会根据识别屏幕宽度对于展示的具体内容块进行位置调整，甚至展示和隐藏。</p><p>实现方式：</p><ul><li>响应式布局</li><li>特性检测 （用于网页功能的渐进增强）</li></ul><blockquote><p>举个栗子：<a href="https://link.juejin.im/?target=http%3A%2F%2Felevenbeans.github.io%2F，" target="_blank" rel="noopener">elevenbeans.github.io/，</a></p></blockquote><h3 id="RWD-和-AWD-的异同"><a href="#RWD-和-AWD-的异同" class="headerlink" title="RWD 和 AWD 的异同"></a>RWD 和 AWD 的异同</h3><p>相同点：</p><ul><li>均针对不同的分辨率/device 采用不同的样式和布局达到页面展示最优</li><li>布局方式本质没有差别（AWD 也 including responsive layout）</li></ul><p>不同点：</p><ul><li>前者强调同一套页面多端兼容展示，而后者给出多套页面，对于不同 device 进行了分类处理</li><li>前者是通过 CSS Media query 进行分辨率检测，可以实时的响应浏览器尺寸变化，改变元素尺寸/布局，而后者一般是 server side detection，一次性渲染既定布局和样式</li></ul><h3 id="媒体查询用法"><a href="#媒体查询用法" class="headerlink" title="媒体查询用法"></a>媒体查询用法</h3><ul><li><h4 id="开始在-html-中写入-Media"><a href="#开始在-html-中写入-Media" class="headerlink" title="开始在 html 中写入 Media"></a>开始在 html 中写入 Media</h4></li></ul><p>在 html 头部添加以下代码，用来显示兼容移动设备的显示效果</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">  <span class="attr">name</span>=<span class="string">"viewport"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><p>参数详解：</p><p><code>width=device-width</code> ：宽度等于当前设备的宽度</p><p><code>initial-scale=1</code> ：初始的缩放比例。（默认为 1）</p><p><code>minimum-scale=1</code> ：允许用户缩放到的最小比例。（默认为 1）</p><p><code>maximum-scale=1</code> ：允许用户缩放到的最大比例。（默认为 1）</p><p><code>user-scalable=no</code> ：用户是否可以手动缩放（默认为 no）</p><ul><li><h4 id="引入包含-Media-的-css-文件"><a href="#引入包含-Media-的-css-文件" class="headerlink" title="引入包含 Media 的 css 文件"></a>引入包含 Media 的 css 文件</h4><p><strong>我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。</strong>(<strong>IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。</strong>)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: grey;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (min-width: <span class="number">700px</span>) and (max-width: <span class="number">1200px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">700px</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: orange;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol><li><p>媒体类型</p><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">all</td><td align="left">用于所有设备</td></tr><tr><td align="left">aural</td><td align="left">已废弃。用于语音和声音合成器</td></tr><tr><td align="left">braille</td><td align="left">已废弃。 应用于盲文触摸式反馈设备</td></tr><tr><td align="left">embossed</td><td align="left">已废弃。 用于打印的盲人印刷设备</td></tr><tr><td align="left">handheld</td><td align="left">已废弃。 用于掌上设备或更小的装置，如 PDA 和小型电话</td></tr><tr><td align="left">print</td><td align="left">用于打印机和打印预览</td></tr><tr><td align="left">projection</td><td align="left">已废弃。 用于投影设备</td></tr><tr><td align="left">screen</td><td align="left">用于电脑屏幕，平板电脑，智能手机等。</td></tr><tr><td align="left">speech</td><td align="left">应用于屏幕阅读器等发声设备</td></tr><tr><td align="left">tty</td><td align="left">已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备</td></tr><tr><td align="left">tv</td><td align="left">已废弃。 用于电视和网络电视</td></tr></tbody></table></li><li><p>逻辑操作符</p><ul><li><code>and</code>操作符用来把多个<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries#Media_features" target="_blank" rel="noopener">媒体属性</a>组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。</li><li><code>not</code>操作符用来对一条媒体查询的结果进行取反。</li><li><code>only</code>操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。</li><li>也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于<code>or</code>操作符。</li><li>若使用了<code>not</code>或<code>only</code>操作符，必须明确指定一个媒体类型。</li></ul></li><li><p>媒体功能</p><table><thead><tr><th align="left">值</th><th align="left">描述</th><th>值</th><th>媒体</th><th>是否接受 min/max 前缀</th></tr></thead><tbody><tr><td align="left">aspect-ratio</td><td align="left">定义输出设备中的页面可见区域宽度与高度的比率</td><td><ratio></ratio></td><td>visual/tactile</td><td>是</td></tr><tr><td align="left">color</td><td align="left">定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于 0</td><td><integer></integer></td><td>visual</td><td>是</td></tr><tr><td align="left">color-index</td><td align="left">定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于 0</td><td><integer></integer></td><td>visual</td><td>是</td></tr><tr><td align="left">device-aspect-ratio</td><td align="left">定义输出设备的屏幕可见宽度与高度的比率。</td><td><ratio></ratio></td><td>visual/tactile</td><td>是</td></tr><tr><td align="left">device-height</td><td align="left">定义输出设备的屏幕可见高度。</td><td><length></length></td><td>visual/tactile</td><td>是</td></tr><tr><td align="left">device-width</td><td align="left">定义输出设备的屏幕可见宽度。</td><td><length></length></td><td>visual/tactile</td><td>是</td></tr><tr><td align="left">grid</td><td align="left">用来查询输出设备是否使用栅格或点阵。</td><td><integer></integer></td><td>all</td><td>否</td></tr><tr><td align="left">height</td><td align="left">定义输出设备中的页面可见区域高度。</td><td><length></length></td><td>visual/tactile</td><td>是</td></tr><tr><td align="left">monochrome</td><td align="left">定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于 0</td><td><integer></integer></td><td>visual</td><td>是</td></tr><tr><td align="left">orientation</td><td align="left">定义输出设备中的页面可见区域高度是否大于或等于宽度。</td><td>landscape`</td><td>`portrait</td><td>visual</td></tr><tr><td align="left">resolution</td><td align="left">定义设备的分辨率。如：96dpi, 300dpi, 118dpcm</td><td><resolution></resolution></td><td>bitmap</td><td>是</td></tr><tr><td align="left">scan</td><td align="left">定义电视类设备的扫描工序。</td><td>progressive`</td><td>`interlace</td><td>tv</td></tr><tr><td align="left">width</td><td align="left">定义输出设备中的页面可见区域宽度。</td><td><length></length></td><td>visual/tactile</td><td>是</td></tr></tbody></table></li></ol><h2 id="5-弹性布局（flex）"><a href="#5-弹性布局（flex）" class="headerlink" title="5.弹性布局（flex）"></a>5.弹性布局（flex）</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间（他会根据页面的剩余宽度自动分配空间）。</p><p>采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。</p><p>容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。</p><p>项目默认沿主轴排列。单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。</p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><p><strong>基本语法：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* 或者 inline-flex */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述写法，定义了一个 flex 容器，根据设值的不同可以是块状容器或内联容器。这使得直接子结点拥有了一个 flex 上下文。</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><h4 id="1-flex-direction"><a href="#1-flex-direction" class="headerlink" title="1.flex-direction"></a>1.flex-direction</h4><p>属性决定主轴的方向（即项目的排列方向）。</p><ul><li><code>row</code>（默认值）：主轴为水平方向，起点在左端。</li><li><code>row-reverse</code>：主轴为水平方向，起点在右端。</li><li><code>column</code>：主轴为垂直方向，起点在上沿。</li><li><code>column-reverse</code>：主轴为垂直方向，起点在下沿。</li></ul><h4 id="2-flex-wrap"><a href="#2-flex-wrap" class="headerlink" title="2.flex-wrap"></a>2.flex-wrap</h4><p>默认情况下，项目都排在一条线（又称”轴线”）上。<code>flex-wrap</code>属性定义，如果一条轴线排不下，如何换行。</p><ul><li><code>nowrap</code>（默认）：不换行。</li><li><code>wrap</code>：换行，第一行在上方。</li><li><code>wrap-reverse</code>：换行，第一行在下方。</li></ul><h4 id="3-flex-flow"><a href="#3-flex-flow" class="headerlink" title="3.flex-flow"></a>3.flex-flow</h4><p><code>flex-flow</code>属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式，默认值为<code>row nowrap</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-justify-content"><a href="#4-justify-content" class="headerlink" title="4.justify-content"></a>4.justify-content</h4><p>定义了项目在主轴上的对齐方式。</p><ul><li><code>flex-start</code>（默认值）：左对齐</li><li><code>flex-end</code>：右对齐</li><li><code>center</code>： 居中</li><li><code>space-between</code>：两端对齐，项目之间的间隔都相等。</li><li><code>space-around</code>：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyhrshycj30hp0l7dg9.jpg" alt="img"></p><h4 id="5-align-items"><a href="#5-align-items" class="headerlink" title="5.align-items"></a>5.align-items</h4><p>定义项目在交叉轴上如何对齐。</p><ul><li><code>flex-start</code>：交叉轴的起点对齐。</li><li><code>flex-end</code>：交叉轴的终点对齐。</li><li><code>center</code>：交叉轴的中点对齐。</li><li><code>baseline</code>: 项目的第一行文字的基线对齐。</li><li><code>stretch</code>（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyikbcvij30h50lujrx.jpg" alt="img"></li></ul><h4 id="6-align-content"><a href="#6-align-content" class="headerlink" title="6.align-content"></a>6.align-content</h4><p>定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</p><ul><li><code>flex-start</code>：与交叉轴的起点对齐。</li><li><code>flex-end</code>：与交叉轴的终点对齐。</li><li><code>center</code>：与交叉轴的中点对齐。</li><li><code>space-between</code>：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li><code>space-around</code>：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li><code>stretch</code>（默认值）：轴线占满整个交叉轴。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyj94lshj30h80lumxy.jpg" alt="img"></li></ul><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li><code>order</code></li><li><code>flex-grow</code></li><li><code>flex-shrink</code></li><li><code>flex-basis</code></li><li><code>flex</code></li><li><code>align-self</code></li></ul><h4 id="1-order"><a href="#1-order" class="headerlink" title="1.order"></a>1.order</h4><p>定义项目的排列顺序。数值越小，排列越靠前，默认为 0。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyk0vxo7j30kv0dct8w.jpg" alt="img"></p><h4 id="2-flex-grow"><a href="#2-flex-grow" class="headerlink" title="2.flex-grow"></a>2.flex-grow</h4><p>定义项目的放大比例，默认为<code>0</code>，即如果存在剩余空间，也不放大。</p><p>如果所有项目的<code>flex-grow</code>属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的<code>flex-grow</code>属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iylyev7sj30ma05v0sq.jpg" alt="img"></p><h4 id="3-flex-shrink"><a href="#3-flex-shrink" class="headerlink" title="3.flex-shrink"></a>3.flex-shrink</h4><p>定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。</p><p>如果所有项目的<code>flex-shrink</code>属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的<code>flex-shrink</code>属性为 0，其他项目都为 1，则空间不足时，前者不缩小。</p><p>负值对该属性无效。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iymkslb9j30jg041glp.jpg" alt="img"></p><h4 id="4-flex-basis"><a href="#4-flex-basis" class="headerlink" title="4.flex-basis"></a>4.flex-basis</h4><p>定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为<code>auto</code>，即项目的本来大小。</p><p>它可以设为跟<code>width</code>或<code>height</code>属性一样的值（比如 350px），则项目将占据固定空间。</p><h4 id="5-flex"><a href="#5-flex" class="headerlink" title="5.flex"></a>5.flex</h4><p><code>flex</code>属性是<code>flex-grow</code>, <code>flex-shrink</code> 和 <code>flex-basis</code>的简写，默认值为<code>0 1 auto</code>。后两个属性可选。</p><p>该属性有两个快捷值：<code>auto</code> (<code>1 1 auto</code>) 和 none (<code>0 0 auto</code>)。</p><p>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p><h4 id="6-align-self"><a href="#6-align-self" class="headerlink" title="6.align-self"></a>6.align-self</h4><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性。默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>。</p><p>该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iynadp42j30kn0aut8r.jpg" alt="img"></p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><table><thead><tr><th>Chrome</th><th>Safari</th><th>Firefox</th><th>Opera</th><th>IE</th><th>Android</th><th>iOS</th></tr></thead><tbody><tr><td>21+</td><td>6.1+</td><td>22+</td><td>12.1+</td><td>11+</td><td>4.4+</td><td>7.1+</td></tr></tbody></table><p>Flexbox 需要一些特定的前缀以支持大多数的浏览器。甚至还存在完全不同的属性名称或属性值。这就需要<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fpostcss%2Fautoprefixer" target="_blank" rel="noopener">Autoprefixer</a>或类似的 CSS 后处理器的辅助，具体内容请参考相关文档。</p><h2 id="6-REM-布局"><a href="#6-REM-布局" class="headerlink" title="6.REM 布局"></a>6.REM 布局</h2><h3 id="rem-em-区别"><a href="#rem-em-区别" class="headerlink" title="rem/em 区别"></a>rem/em 区别</h3><p><strong>rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的</strong></p><p><strong>em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)</strong>em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border。</p><p>rem 作用于非根元素时，相对于根元素字体大小；rem 作用于根元素字体大小时，相对于其出初始字体大小（16px）。</p><p><strong>rem 有一点优势就是可以和媒体查询配合，实现响应式布局：</strong></p><p>使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为 em 是相对父级元素的原因没有得到推广。【中国站点制作网页的时候，习惯用 CSS 强制定义字体大小，保证每个人都看到一致的效果，包括网易、搜狐这些门户网站在内的大部分站点，用的都是绝对单位 px（像素）。但是，如果从网站<strong>易用性</strong>方面考虑，字体大小应该是可变的，一些视力不是那么好的人需要放大字体才能看得清页面内容。然而，占据大部分浏览器市场的 IE 无法调整那些使用 px 作为单位的字体大小。国外人士非常重视网站的易用性，相当一部分外国站点已经使用 em 作为字体单位。</p><h3 id="布局特点-4"><a href="#布局特点-4" class="headerlink" title="布局特点"></a>布局特点</h3><p><strong>包裹文字的各元素的尺寸采用 em/rem 做单位，而页面的主要划分区域的尺寸仍使用百分数或 px 做单位（同「流式布局」或「静态/固定布局」）</strong>。<strong>早期浏览器不支持整个页面按比例缩放</strong>，仅支持网页内文字尺寸的放大，这种情况下。使用 em/rem 做单位，可以使包裹文字的元素随着文字的缩放而缩放。</p><p>浏览器的默认字体高度一般为<code>16px</code>，即 1em:16px，但是 1:16 的比例不方便计算，为了使单位 em/rem 更直观，CSS 编写者常常将页面跟节点字体设为 62.5%，比如选择用 rem 控制字体时，先需要设置根节点 html 的字体大小，因为浏览器默认字体大小 16px*62.5%=10px。这样 1rem 便是 10px，方便了计算。</p><h3 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h3><ol><li>一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值</li><li>高度值可以设置固定值,设计稿有多大,我们就严格写多大</li><li>所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值)</li><li>JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>更能适应缩进/以字体单位 padding 或 margin／浏览器设置字体尺寸等情况（因为 em/rem 相对于字体大小，会同步改变）。例如：p{ text-indent: 2em; }。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">text-indent</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rem 单位对于（根据屏幕尺寸）调整页面的各元素的尺寸、文字大小时比较好用</p><h3 id="Rem-布局的-js-实现"><a href="#Rem-布局的-js-实现" class="headerlink" title="Rem 布局的 js 实现"></a>Rem 布局的 js 实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// px转rem，方便模拟小程序 rpx</span></span><br><span class="line">px2rem($px) &#123;</span><br><span class="line">  $px / <span class="number">750</span> * <span class="number">10</span> * <span class="number">1</span>rem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> remlayout</span><br><span class="line">      script.</span><br><span class="line">        (<span class="function"><span class="keyword">function</span> <span class="title">flexible</span> (<span class="params">window, document</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement</span><br><span class="line">          <span class="keyword">var</span> dpr = <span class="built_in">window</span>.devicePixelRatio || <span class="number">1</span></span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">setBodyFontSize</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">document</span>.body) &#123;</span><br><span class="line">              <span class="built_in">document</span>.body.style.fontSize = (<span class="number">12</span> * dpr) + <span class="string">'px'</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>, setBodyFontSize)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          setBodyFontSize()</span><br><span class="line">          <span class="function"><span class="keyword">function</span> <span class="title">setRemUnit</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> rem = docEl.clientWidth / <span class="number">10</span></span><br><span class="line">            docEl.style.fontSize = rem + <span class="string">'px'</span></span><br><span class="line">          &#125;</span><br><span class="line">          setRemUnit()</span><br><span class="line">          <span class="built_in">window</span>.addEventListener(<span class="string">'resize'</span>, setRemUnit)</span><br><span class="line">          <span class="built_in">window</span>.addEventListener(<span class="string">'pageshow'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (e.persisted) &#123; setRemUnit() &#125;</span><br><span class="line">          &#125;)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (dpr &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> fakeBody = <span class="built_in">document</span>.createElement(<span class="string">'body'</span>)</span><br><span class="line">            <span class="keyword">var</span> testElement = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">            testElement.style.border = <span class="string">'.5px solid transparent'</span></span><br><span class="line">            fakeBody.appendChild(testElement)</span><br><span class="line">            docEl.appendChild(fakeBody)</span><br><span class="line">            <span class="keyword">if</span> (testElement.offsetHeight === <span class="number">1</span>) &#123;</span><br><span class="line">              docEl.classList.add(<span class="string">'hairlines'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            docEl.removeChild(fakeBody)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;(<span class="built_in">window</span>, <span class="built_in">document</span>))</span><br></pre></td></tr></table></figure><h3 id="对比三种方式（响应式-amp-amp-REM-amp-amp-viewport）"><a href="#对比三种方式（响应式-amp-amp-REM-amp-amp-viewport）" class="headerlink" title="对比三种方式（响应式&amp;&amp;REM&amp;&amp;viewport）"></a>对比三种方式（响应式&amp;&amp;REM&amp;&amp;viewport）</h3><h4 id="响应式的优缺点"><a href="#响应式的优缺点" class="headerlink" title="响应式的优缺点"></a>响应式的优缺点</h4><p>优点：兼容性好，@media 在 ie9 以上是支持的，PC 和 MOBILE 是同一套代码的，不用分开。</p><p>缺点：要写得 css 相对另外两个多很多，而且各个断点都要做好。css 样式会稍微大点，更麻烦。</p><h4 id="REM-优缺点"><a href="#REM-优缺点" class="headerlink" title="REM 优缺点"></a>REM 优缺点</h4><p>优点：能维持能整体的布局效果，移动端兼容性好，不用写多个 css 代码，而且还可以利用@media 进行优化。</p><p>缺点：开头要引入一段 js 代码，单位都要改成 rem(font-size 可以用 px)，计算 rem 比较麻烦(可以引用预处理器，但是增加了编译过程，相对麻烦了点)。pc 和 mobile 要分开。</p><h4 id="设置-viewport-中的-width"><a href="#设置-viewport-中的-width" class="headerlink" title="设置 viewport 中的 width"></a>设置 viewport 中的 width</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=750"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>优点：和 REM 相同，而且不用写 rem，直接使用 px，更加快捷。</p><p>缺点：效果可能没 rem 的好，图片可能会相对模糊，而且无法使用@media 进行断点，不同 size 的手机上显示，高度间距可能会相差很大。</p><h2 id="7-Grid-布局（BOOTSTRAP-布局）"><a href="#7-Grid-布局（BOOTSTRAP-布局）" class="headerlink" title="7.Grid 布局（BOOTSTRAP 布局）"></a>7.Grid 布局（BOOTSTRAP 布局）</h2><p>网格布局（Grid）是最强大的 CSS 布局方案。</p><p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。容器里面的水平区域称为”行”（row），垂直区域为”列”（column）。行和列的交叉区域，称为”单元格”（cell）。划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><h3 id="容器的属性-1"><a href="#容器的属性-1" class="headerlink" title="容器的属性"></a>容器的属性</h3><h4 id="1-display"><a href="#1-display" class="headerlink" title="1.display"></a>1.display</h4><p><code>display: grid</code>指定一个容器采用网格布局。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。<code>display: inline-grid;</code></p><p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p><h4 id="2-grid-template-columns-属性，-grid-template-rows-属性"><a href="#2-grid-template-columns-属性，-grid-template-rows-属性" class="headerlink" title="2.grid-template-columns 属性， grid-template-rows 属性"></a>2.grid-template-columns 属性， grid-template-rows 属性</h4><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用绝对单位，也可以使用百分比</p><ul><li><p>repeat()：接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。重复某种模式也是可以的。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: <span class="selector-tag">repeat</span>(2, 100<span class="selector-tag">px</span> 20<span class="selector-tag">px</span> 80<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure></li><li><p>auto-fill 关键字：有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(auto-fill, 100px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>fr 关键字：为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。（<code>fr</code>可以与绝对长度的单位结合使用）</p></li><li><p>minmax()：<code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-columns</span>: 1<span class="selector-tag">fr</span> 1<span class="selector-tag">fr</span> <span class="selector-tag">minmax</span>(100<span class="selector-tag">px</span>, 1<span class="selector-tag">fr</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p></li><li><p>auto 关键字：表示由浏览器自己决定长度</p></li><li><p>网格线的名称：<code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。（网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: [c1] <span class="number">100px</span> [c2] <span class="number">100px</span> [c3] auto [c4];</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: [r1] <span class="number">100px</span> [r2] <span class="number">100px</span> [r3] auto [r4];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="3.grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>3.grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h4><ul><li><code>grid-row-gap</code>属性设置行与行的间隔（行间距）</li><li><code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</li><li><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式：<code>grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;</code>(如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值。)</li></ul><ol><li>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</li></ol><h4 id="4-grid-template-areas-属性"><a href="#4-grid-template-areas-属性" class="headerlink" title="4.grid-template-areas 属性"></a>4.grid-template-areas 属性</h4><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">grid-template-areas</span>:</span><br><span class="line">  "<span class="selector-tag">header</span> <span class="selector-tag">header</span> <span class="selector-tag">header</span>"</span><br><span class="line">  "<span class="selector-tag">main</span> <span class="selector-tag">main</span> <span class="selector-tag">sidebar</span>"</span><br><span class="line">  "<span class="selector-tag">footer</span> <span class="selector-tag">footer</span> <span class="selector-tag">footer</span>";</span><br></pre></td></tr></table></figure><p>区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><h4 id="5-grid-auto-flow-属性"><a href="#5-grid-auto-flow-属性" class="headerlink" title="5.grid-auto-flow 属性"></a>5.grid-auto-flow 属性</h4><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyo19otvj30au0b6glp.jpg" alt="img"></p><ul><li>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。</li><li>也可以将它设成<code>column</code>，变成”先列后行”。</li><li>设为<code>row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</li><li><code>column dense</code>，表示”先列后行”，并且尽量填满空格。</li></ul><h4 id="6-justify-items-属性，-align-items-属性，-place-items-属性"><a href="#6-justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="6.justify-items 属性， align-items 属性， place-items 属性"></a>6.justify-items 属性， align-items 属性， place-items 属性</h4><ul><li><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右）</p></li><li><p><code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></li><li><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。（如果省略第二个值，则浏览器认为与第一个值相等。）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-items</span>: &lt;<span class="selector-tag">align-items</span>&gt; &lt;<span class="selector-tag">justify-items</span>&gt;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="7-justify-content-属性，-align-content-属性，-place-content-属性"><a href="#7-justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="7.justify-content 属性， align-content 属性， place-content 属性"></a>7.justify-content 属性， align-content 属性， place-content 属性</h4><ul><li><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右）</p></li><li><p><code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><p>这两个属性的写法完全相同，都可以取下面这些值。</p><p>只是将水平方向改成垂直方向。）</p><ul><li>start - 对齐容器的起始边框。</li><li>end - 对齐容器的结束边框。</li><li>center - 容器内部居中。</li><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul></li><li><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。（如果省略第二个值，浏览器就会假定第二个值等于第一个值。）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-content</span>: &lt;<span class="selector-tag">align-content</span>&gt; &lt;<span class="selector-tag">justify-content</span>&gt;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="8-grid-auto-columns-属性，-grid-auto-rows-属性"><a href="#8-grid-auto-columns-属性，-grid-auto-rows-属性" class="headerlink" title="8.grid-auto-columns 属性， grid-auto-rows 属性"></a>8.grid-auto-columns 属性， grid-auto-rows 属性</h4><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p>划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> <span class="number">100px</span> <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码指定新增的行高统一为 50px（原始的行高为 100px）。</p><h4 id="9-grid-template-属性，-grid-属性"><a href="#9-grid-template-属性，-grid-属性" class="headerlink" title="9.grid-template 属性， grid 属性"></a>9.grid-template 属性， grid 属性</h4><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><h4 id="1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="1.grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>1.grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h4><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-column-start</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-column-end</span>: <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h4 id="2-grid-column-属性，-grid-row-属性"><a href="#2-grid-column-属性，-grid-row-属性" class="headerlink" title="2.grid-column 属性， grid-row 属性"></a>2.grid-column 属性， grid-row 属性</h4><ul><li><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式</p></li><li><p><code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。斜杠以及后面的部分可以省略，默认跨越一个网格。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 等同于 */</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b03532</span>;</span><br><span class="line">  <span class="attribute">grid-column</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">grid-row</span>: <span class="number">1</span> / span <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-grid-area-属性"><a href="#3-grid-area-属性" class="headerlink" title="3.grid-area 属性"></a>3.grid-area 属性</h4><p><code>grid-area</code>属性指定项目放在哪一个区域。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">grid-area</span>: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-justify-self-属性，-align-self-属性，-place-self-属性"><a href="#4-justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="4.justify-self 属性， align-self 属性， place-self 属性"></a>4.justify-self 属性， align-self 属性， place-self 属性</h4><ul><li><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p></li><li><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><p>这两个属性都可以取下面四个值。</p><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></li><li><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">place-self</span>: &lt;<span class="selector-tag">align-self</span>&gt; &lt;<span class="selector-tag">justify-self</span>&gt;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyqd0osoj326m0rok1w.jpg" alt="img"></p><h3 id="对比-Bootstrap"><a href="#对比-Bootstrap" class="headerlink" title="对比 Bootstrap"></a>对比 Bootstrap</h3><ul><li>标签会更加简洁：相比<code>Bootstrap</code>，使用 grid 会使你的 HTML 更加干净。<code>Bootstrap</code>需要创建的标签，每个 row 都需要一个<code>&lt;div&gt;</code>标签，使用了 class name 来指定布局(<code>col-xs-2</code>)。grid 用来布局看起来更简单，丑陋的类名和每行所需的额外的 div 标签一去不复返了，简简单单一个 container 和里面的 item。与<code>Bootstrap</code>不同的是，随着布局复杂度的增加，Grid 布局标签的复杂度将不会增加太多。</li><li>更灵活：用<code>CSS Grid</code>的话会非常简单，我们只需要添加一个<code>media query</code>就可以重新排列布局。而如果想在<code>Bootstrap</code>中做同样的事情，就必须得修改 HTML 了，需要调整标签的顺序。</li><li>不再限死 12 列：<code>Bootstrap</code>的 grid 系统分为了 12 列，如果你想要一个 5 列的布局就会纠结，或是 7 列、9 列、任何不会合为 12 列的。<code>CSS Grid</code>就没有任何限制，你可以让 grid 正好有你想要的数量。</li><li>浏览器支持：全球 75%的网站流量支持<code>CSS Grid</code></li></ul><h2 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h2><ol><li>如果只做 pc 端，那么静态布局（定宽度）是最好的选择；</li><li>如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份 css+一份 js 调节 font-size 搞定；</li><li>如果 pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局.</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS-常用布局方式&quot;&gt;&lt;a href=&quot;#CSS-常用布局方式&quot; class=&quot;headerlink&quot; title=&quot;CSS 常用布局方式&quot;&gt;&lt;/a&gt;CSS 常用布局方式&lt;/h1&gt;&lt;h2 id=&quot;1-静态布局（固定布局）&quot;&gt;&lt;a href=&quot;#1-静态布局（固定布局）&quot; class=&quot;headerlink&quot; title=&quot;1.静态布局（固定布局）&quot;&gt;&lt;/a&gt;1.静态布局（固定布局）&lt;/h2&gt;&lt;h3 id=&quot;布局特点&quot;&gt;&lt;a href=&quot;#布局特点&quot; class=&quot;headerlink&quot; title=&quot;布局特点&quot;&gt;&lt;/a&gt;布局特点&lt;/h3&gt;&lt;p&gt;不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新特性</title>
    <link href="http://yoursite.com/2019/04/28/CSS3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2019/04/28/CSS3新特性/</id>
    <published>2019-04-28T04:37:08.000Z</published>
    <updated>2019-09-21T13:56:29.728Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h1><h2 id="1-选择器"><a href="#1-选择器" class="headerlink" title="1. 选择器"></a>1. 选择器</h2><p>CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。</p><ul><li>element1~element2: 选择前面有 element1 元素的每个 element2 元素。</li><li>[attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。</li><li>[attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。</li><li>[attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。</li><li>E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。</li><li>E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。</li><li>E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。</li><li>E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。</li><li>E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。</li><li>E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。</li><li>E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。</li><li>E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。</li><li>E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。</li><li>:root: 选择文档的根元素。</li><li>E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。</li><li>E:target: 选择当前活动的 E 元素。</li><li>E:enabled: 选择每个启用的 E 元素。</li><li>E:disabled: 选择每个禁用的 E 元素。</li><li>E:checked: 选择每个被选中的 E 元素。</li><li>E:not(selector): 选择非 selector 元素的每个元素。</li><li>E::selection: 选择被用户选取的元素部分。<a id="more"></a></li></ul><h2 id="2-Transition-Transform-和-Animation"><a href="#2-Transition-Transform-和-Animation" class="headerlink" title="2. Transition,Transform 和 Animation"></a>2. Transition,Transform 和 Animation</h2><p>这三个特性是 CSS3 新增的和动画相关的特性。</p><ul><li><p>Transition</p><p>Transition 可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用 Flash 动画或 JavaScript。<br>Transition 有如下属性：</p><ul><li>transition-property: 规定应用过渡的 CSS 属性的名称。</li><li>transition-duration: 规定完成过渡效果需要多长时间。</li><li>transition-delay: 规定过渡效果何时开始，默认是 0。</li><li>transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有 linear、ease-in、ease-out、ease-in-out 和 cubic-bezier 等过渡类型。</li><li>transition: 简写属性，用于在一个属性中设置四个过渡属性。</li></ul></li><li><p>Transform</p><p>Transform 用来向元素应用各种 2D 和 3D 转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。</p><p>变换类型：</p><ul><li>none: 定义不进行转换。</li><li>matrix(n,n,n,n,n,n): 定义 2D 转换，使用六个值的矩阵。</li><li>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义 3D 转换，使用 16 个值的 4x4 矩阵。</li><li>translate(x,y): 定义 2D 位移转换。</li><li>translate3d(x,y,z): 定义 3D 位移转换。</li><li>translateX(x): 定义位移转换，只是用 X 轴的值。</li><li>translateY(y): 定义位移转换，只是用 Y 轴的值。</li><li>translateZ(z): 定义 3D 位移转换，只是用 Z 轴的值。</li><li>scale(x,y): 定义 2D 缩放转换。</li><li>scale3d(x,y,z): 定义 3D 缩放转换。</li><li>scaleX(x): 通过设置 X 轴的值来定义缩放转换。</li><li>scaleY(y): 通过设置 Y 轴的值来定义缩放转换。</li><li>scaleZ(z): 通过设置 Z 轴的值来定义 3D 缩放转换。</li><li>rotate(angle): 定义 2D 旋转，在参数中规定角度。</li><li>rotate3d(x,y,z,angle): 定义 3D 旋转。</li><li>rotateX(angle): 定义沿着 X 轴的 3D 旋转。</li><li>rotateY(angle): 定义沿着 Y 轴的 3D 旋转。</li><li>rotateZ(angle): 定义沿着 Z 轴的 3D 旋转。</li><li>skew(x-angle,y-angle): 定义沿着 X 和 Y 轴的 2D 倾斜转换。</li><li>skewX(angle): 定义沿着 X 轴的 2D 倾斜转换。</li><li>skewY(angle): 定义沿着 Y 轴的 2D 倾斜转换。</li><li>perspective(n): 为 3D 转换元素定义透视视图。</li></ul></li><li><p>Animation</p><p>Animation 让 CSS 拥有了可以制作动画的功能。使用 CSS3 的 Animation 制作动画我们可以省去复杂的 js 代码。</p></li></ul><h2 id="3-边框"><a href="#3-边框" class="headerlink" title="3. 边框"></a>3. 边框</h2><p>CSS3 新增了三个边框属性，分别是 border-radius、box-shadow 和 border-image。</p><ul><li>border-radius 可以创建圆角边框</li><li>box-shadow 可以为元素添加阴影</li><li>border-image 可以使用图片来绘制边框。</li></ul><h2 id="4-背景"><a href="#4-背景" class="headerlink" title="4. 背景"></a>4. 背景</h2><p>CSS3 新增了几个关于背景的属性，分别是 background-clip、background-origin、background-size 和 background-break。</p><ul><li><p>background-clip</p><p>background-clip 属性用于确定背景画区，有以下几种可能的属性：</p><ul><li>background-clip: border-box; 背景从 border 开始显示</li><li>background-clip: padding-box; 背景从 padding 开始显示</li><li>background-clip: content-box; 背景显 content 区域开始显示</li><li>background-clip: no-clip; 默认属性，等同于 border-box</li></ul><p>通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。</p></li><li><p>background-origin</p><p>background-clip 属性用于确定背景的位置，它通常与 background-position 联合使用，可以从 border、padding、content 来计算 background-position（就像 background-clip）。</p><ul><li>background-origin: border-box; 从 border 开始计算 background-position</li><li>background-origin: padding-box; 从 padding 开始计算 background-position</li><li>background-origin: content-box; 从 content 开始计算 background-position</li></ul></li><li><p>background-size</p><p>background-size 属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性：</p><ul><li>background-size: contain; 缩小图片以适合元素（维持像素长宽比）</li><li>background-size: cover; 扩展元素以填补元素（维持像素长宽比）</li><li>background-size: 100px 100px; 缩小图片至指定的大小</li><li>background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸</li></ul></li><li><p>background-break</p><p>CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。</p><ul><li>background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样）</li><li>background-break: bounding-box; 把盒之间的距离计算在内；</li><li>background-break: each-box; 为每个盒子单独重绘背景。</li></ul></li></ul><h2 id="5-文字效果"><a href="#5-文字效果" class="headerlink" title="5. 文字效果"></a>5. 文字效果</h2><ul><li><p>word-wrap</p><p>CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行，即这意味着会对单词进行拆分。所有主流浏览器都支持 word-wrap 属性。</p></li><li><p>text-overflow</p><p>它与 word-wrap 是协同工作的，word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。</p></li><li><p>text-shadow</p><p>CSS3 中，text-shadow 可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。</p></li><li><p>text-decoration</p><p>CSS3 里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置：</p><ul><li>text-fill-color: 设置文字内部填充颜色</li><li>text-stroke-color: 设置文字边界填充颜色</li><li>text-stroke-width: 设置文字边界宽度</li></ul></li></ul><h2 id="6-渐变"><a href="#6-渐变" class="headerlink" title="6. 渐变"></a>6. 渐变</h2><p>CSS3 新增了渐变效果，包括 linear-gradient(线性渐变)和 radial-gradient(径向渐变)。</p><h2 id="7-font-face-特性"><a href="#7-font-face-特性" class="headerlink" title="7. @font-face 特性"></a>7. @font-face 特性</h2><p>通过 CSS3，web 设计师可以使用他们喜欢的任意字体。当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。字体是在 CSS3 @font-face 规则中定义的。Firefox、Chrome、Safari 以及 Opera 支持 .ttf(True Type Fonts)和 .otf(OpenType Fonts)类型的字体。IE9+ 支持新的@font-face 规则，但是仅支持 .eot 类型的字体(Embedded OpenType)。</p><p>在新的@font-face 规则中，必须首先定义字体的名称（比如 myFont），然后指向该字体文件。<br>如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFont)</p><h2 id="8-多列布局"><a href="#8-多列布局" class="headerlink" title="8. 多列布局"></a>8. 多列布局</h2><p>通过 CSS3，能够创建多个列来对文本进行布局，IE10 和 Opera 支持多列属性。Firefox 需要前缀-moz-，Chrome 和 Safari 需要前缀-webkit-。主要有如下三个属性：</p><ul><li>column-count: 规定元素应该被分隔的列数。</li><li>column-gap: 规定列之间的间隔。</li><li>column-rule: 设置列之间的宽度、样式和颜色规则</li></ul><h2 id="9-用户界面"><a href="#9-用户界面" class="headerlink" title="9. 用户界面"></a>9. 用户界面</h2><p>CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。Firefox、Chrome 以及 Safari 支持 resize 属性。IE、Chrome、Safari 以及 Opera 支持 box-sizing 属性。Firefox 需要前缀-moz-。<br>所有主流浏览器都支持 outline-offset 属性，除了 IE。</p><ul><li><p>resize</p><p>resize 属性规定是否可由用户调整元素尺寸。如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll。</p></li><li><p>box-sizing</p><p>box-sizing 属性可设置的值有 content-box、border-box 和 inherit。</p><ul><li>content-box: padding 和 border 不被包含在定义的 width 和 height 之内。对象的实际宽度等于设置的 width 值和 border、padding 之和，即 (Element width = width + border + padding)，此属性表现为标准模式下的盒模型。</li><li>border-box: padding 和 border 被包含在定义的 width 和 height 之内。对象的实际宽度就等于设置的 width 值，即使定义有 border 和 padding 也不会改变对象的实际宽度，即 (Element width = width)，此属性表现为怪异模式下的盒模型。</li></ul></li><li><p>outline-offset</p><p>outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CSS3-新特性&quot;&gt;&lt;a href=&quot;#CSS3-新特性&quot; class=&quot;headerlink&quot; title=&quot;CSS3 新特性&quot;&gt;&lt;/a&gt;CSS3 新特性&lt;/h1&gt;&lt;h2 id=&quot;1-选择器&quot;&gt;&lt;a href=&quot;#1-选择器&quot; class=&quot;headerlink&quot; title=&quot;1. 选择器&quot;&gt;&lt;/a&gt;1. 选择器&lt;/h2&gt;&lt;p&gt;CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;element1~element2: 选择前面有 element1 元素的每个 element2 元素。&lt;/li&gt;
&lt;li&gt;[attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。&lt;/li&gt;
&lt;li&gt;[attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。&lt;/li&gt;
&lt;li&gt;[attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。&lt;/li&gt;
&lt;li&gt;E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。&lt;/li&gt;
&lt;li&gt;E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。&lt;/li&gt;
&lt;li&gt;:root: 选择文档的根元素。&lt;/li&gt;
&lt;li&gt;E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。&lt;/li&gt;
&lt;li&gt;E:target: 选择当前活动的 E 元素。&lt;/li&gt;
&lt;li&gt;E:enabled: 选择每个启用的 E 元素。&lt;/li&gt;
&lt;li&gt;E:disabled: 选择每个禁用的 E 元素。&lt;/li&gt;
&lt;li&gt;E:checked: 选择每个被选中的 E 元素。&lt;/li&gt;
&lt;li&gt;E:not(selector): 选择非 selector 元素的每个元素。&lt;/li&gt;
&lt;li&gt;E::selection: 选择被用户选取的元素部分。
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>BFC</title>
    <link href="http://yoursite.com/2019/04/10/BFC/"/>
    <id>http://yoursite.com/2019/04/10/BFC/</id>
    <published>2019-04-10T00:11:20.000Z</published>
    <updated>2019-09-21T13:55:55.782Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h1><h2 id="BFC-的定义："><a href="#BFC-的定义：" class="headerlink" title="BFC 的定义："></a>BFC 的定义：</h2><p>BFC(Block formatting context)直译为”块级格式化上下文”。它<strong>是一个独立的渲染区域</strong>，只有<strong>Block-level box</strong>参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。<strong>通俗地讲，BFC 是一个容器，用于管理块级元素。</strong></p> <a id="more"></a><h2 id="触发-BFC-的方式（以下任意一条就可以）"><a href="#触发-BFC-的方式（以下任意一条就可以）" class="headerlink" title="触发 BFC 的方式（以下任意一条就可以）"></a>触发 BFC 的方式（以下任意一条就可以）</h2><ol><li>根元素，即 HTML 元素</li><li>float 的值不为 none（为 <code>left</code>或<code>right</code>）</li><li>overflow 的值不为 visible（为<code>hidden</code>或<code>auto</code>或<code>scroll</code>）</li><li>display 的值为<code>table-cell</code>、<code>table-caption</code>、<code>inline-flex</code>、<code>flex</code>和<code>inline-block</code>之一</li><li>position 的值不为 static 或者 releative 中任何一个(为<code>absolute</code>或<code>fixed</code>)</li></ol><h2 id="BFC-的布局规则"><a href="#BFC-的布局规则" class="headerlink" title="BFC 的布局规则"></a>BFC 的布局规则</h2><ol><li>内部的 Box 会在垂直方向，一个接一个地放置。</li><li>Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠（<strong>margin 重叠三个条件:同属于一个 BFC;相邻;块级元素</strong>），两个相邻的 BFC 上下 margin 不会重叠</li><li>每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li><li>BFC 的区域不会与 float box 重叠。非浮动元素不会覆盖浮动元素的位置。</li><li>BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。（触发 BFC，回流的局部渲染）</li><li>计算 BFC 的高度时，浮动元素也参与计算（清除浮动 haslayout）</li><li>margin 不会传递给父级（父级触发了 BFC）</li></ol><h3 id="对比普通文档流的布局规则"><a href="#对比普通文档流的布局规则" class="headerlink" title="对比普通文档流的布局规则"></a>对比普通文档流的布局规则</h3><ol><li>浮动的元素是不会被父级计算高度</li><li>非浮动元素会覆盖浮动元素的位置</li><li>margin 会传递给父级</li><li>两个相邻的元素上下 margin 会重叠</li></ol><h2 id="BFC-有哪些作用："><a href="#BFC-有哪些作用：" class="headerlink" title="BFC 有哪些作用："></a>BFC 有哪些作用：</h2><ol><li>自适应两栏布局（规则 4）</li><li>可以阻止元素被浮动元素覆盖（规则 4）</li><li>可以包含浮动元素——清除内部浮动（规则 6）</li><li>分属于不同的 BFC 时可以阻止 margin 重叠（规则 2）</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;BFC&quot;&gt;&lt;a href=&quot;#BFC&quot; class=&quot;headerlink&quot; title=&quot;BFC&quot;&gt;&lt;/a&gt;BFC&lt;/h1&gt;&lt;h2 id=&quot;BFC-的定义：&quot;&gt;&lt;a href=&quot;#BFC-的定义：&quot; class=&quot;headerlink&quot; title=&quot;BFC 的定义：&quot;&gt;&lt;/a&gt;BFC 的定义：&lt;/h2&gt;&lt;p&gt;BFC(Block formatting context)直译为”块级格式化上下文”。它&lt;strong&gt;是一个独立的渲染区域&lt;/strong&gt;，只有&lt;strong&gt;Block-level box&lt;/strong&gt;参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。&lt;strong&gt;通俗地讲，BFC 是一个容器，用于管理块级元素。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
</feed>
