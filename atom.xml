<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>01不是包子脸</title>
  
  <subtitle>小01的程序猿成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-29T14:16:07.901Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Linyi Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于01的2019</title>
    <link href="http://yoursite.com/2019/12/31/%E5%85%B3%E4%BA%8E01%E7%9A%842019/"/>
    <id>http://yoursite.com/2019/12/31/关于01的2019/</id>
    <published>2019-12-31T15:59:59.000Z</published>
    <updated>2019-12-29T14:16:07.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于01的2019"><a href="#关于01的2019" class="headerlink" title="关于01的2019"></a>关于01的2019</h1><p>这是 01 第一篇非技术的博客，想记录一下我的 2019 年，因为这一年对我来说，真的意义非凡、与众不同。这篇博客，可能絮絮叨叨，可能思路不清。没有期待看到的你会生出什么样的情绪，只是对自己的一个小小交代，希望自己可以记得这一年来的欢笑与艰难。</p><p>为什么说 2019 年，对我来说意义非凡与众不同呢？首先，这一年，是我 24 岁的本命年。不同于上一次 12 岁的那一年，24 岁，我拥有了更清晰的对世界和周遭的认识，有了属于自己独立的看法与见解，也变得在一些时候开始封建迷信，啊哈哈哈哈。比如，老老实实带起了保命红绳，认认真真买了火红的内衣，换上了「猪事顺利」的红色手机壳，疯狂的为各种事儿转发了各种功能性锦鲤。当然，更重要的是，2019 年里，真的发生了很多大事儿。有的是我从未想到也不敢想象的事儿，有的是即将改变我人生轨迹的事儿。那么，我们一件一件缓缓道来。</p><p>最重要的，放在第一个来说。这件事儿，叫做「爸爸」。我不知道该怎么开始写这件事儿，那就直接一点。2019 年 3 月 3 日，我爸爸去世了。那是一个平常的星期天，前一天，我刚染了蓝色的头发，早上我在厕所里拍了第一张蓝头发的自拍，洗脸刷牙，化妆，中午和好朋友约了一顿海底捞，点了很多菜，等着火锅开涮，一个陌生的号码打进了我的手机，是一个带着哭腔的声音，很像我小姑。海底捞里很吵，听不清电话那头都说了些什么，就听清一句，“你爸死了，你赶快回来”。嗯，我是懵的，本能的觉得，应该是个诈骗电话吧。走出海底捞，给奶奶家的座机打了个电话，接电话的人不是奶奶是我大姑父，我心里想，真的出事儿了。挂了电话买了一张晚上的机票回家。那时候的我，真的反应不过来发生了什么，甚至还安静的吃完了那顿海底捞。</p><p>我其实不能接受这件事儿，一直到现在。</p><p>回到家，奶奶抱着我哭了，我没有哭。小姑哭的泣不成声，我没有哭。烧纸的时候，我妈说，你要喊你爸来拾钱，我喊不出来，我一句话也说不出来，我就沉默的跪在那儿。身边知道这件事儿的朋友问我，我都是笑着说一句没事儿啊，你看我不是好好的吗。在火葬场，我看见我爸穿戴整齐的躺在那儿，西装皮鞋，是我不熟悉的样子，很安详，却一点也不像睡着了，我爸睡觉才不会这么规矩，明明呼噜震天响。我说了悼词，说的乱七八糟，毕竟这是我第一次说悼词，都不知道要说些什么内容，甚至还在控诉他一点都不是一个负责任的好爸爸。我抱着我爸的骨灰盒，真的很沉，得用手指死死抠着才能保证在走到墓地前的这段路上，我不会把他摔下去。</p><p>我以为我没什么事儿，我以为我消化的了，毕竟我之前 23 年的人生，也不怎么平坦。处理完丧事儿回到学校，在操场上，是我第一次崩溃的放声大哭。一边哭一边笑，笑完哭的更大声，想小时候，也想，我真的没有爸爸了。真的就像过电影一样，记忆在这件事儿之后变得异常鲜活，很多以前想不起来的小细节都变得十分清晰。我记得我感冒发烧咳嗽到话也说不出来，却任性的要爸爸去给我买黄桃罐头。我记得小时候我爸开出租我坐在副驾驶玩耍睡觉。我记得每次爸爸让我帮他跑腿下楼买包醋的时候都会多给我五毛钱的跑腿费。我也记得去年和爸爸奶奶一起坐在床上玩激萌的时候他看着那些可爱的表情加在他脸上时笑的有多憨厚。太多太多，都只有回忆了。再也没有人在火车站外期盼放假回家的我，带着刚下火车的我去吃一碗牛肉拉面。再也没有人叫我臭小子，打来电话十分腼腆的说句“老爸想你了”。也不会有人明明厨艺很好，却要在每次做饭的时候不停的呼喊我去厨房给他试菜，想要听我的那句“再加点醋”或者“刚刚好、完美！”。我一直想要带他去看场电影，imax或者3D的，想要挣钱给他买辆好车，也想过他老了我推着他晒太阳的场景。从小到大，我爸，都是那个最惯着我的人。他还说，他在网上学了好多菜，要做给我吃。可是，我还没放假回家，爸爸，你去哪儿了呢？</p><p>我以为，哭过这一场之后，我还是那个积极坚强的 01，生活还是如常。但是这一次，好像真的有些难。</p><p>本命年第二件事儿，彻底和过去的感情说再见。其实这是个开心的事儿，只不过经历的过程惨痛了些。感情上的事儿嘛，总是剪不断理还乱，更何况我还是一个念旧又烂好心的人。我有个异国的前男友，我们之间有很多故事，很多折磨我的故事。之所以是折磨我的故事，显然是三个人的故事，之所以有很多，显然是我的不甘心和泛滥的同情心在作祟。很老套的情节，很多时候，放不下的只是自己在这份感情里的付出加上一张会骗人的渣男的嘴。即便分手了。</p><p>我不得不承认，我这个前男友对我的影响有多大。他让我变得小心翼翼，变得更加没有安全感。对于一些情侣间的小事儿，却搞的小心谨慎，总是朝着最不利的方向去想。换情侣头像或者在社交平台上秀恩爱，不再是为所欲为凭自己开心，而是谨小慎微的试探对方的心思，因为一条微博换来的可能是争吵到心寒。对于节日或者纪念日的仪式感耿耿于怀，我喜欢，他却不在意，OK，那我一定要过的隆重，只是不是和他。对于向身边的人大方公开我在谈恋爱，不可能，因为他只会把我藏起来谈地下情，那么我只能追求变态的公平。分手后的烂好心，又让我继续沦为一个被欺骗的“朋友”，拖拖拉拉没个完。对于感情，我期待的很少，甚至只希望，对方能是个好人，我们能做到善待彼此，就好了。我埋藏自己的想法，用“善解人意”来对待每一个人。我知道我变得越来越扭曲，越来越不是自己喜欢的 01。</p><p>在感情里日渐扭曲把自己往角落里逼的我，在家里发生大变故下终于意识到我彻底失去了爱我的爸爸的我，在春招如火如荼进行却才意识到我该开始学习了还什么都不会的我，彻底崩溃了。</p><p>2019 年 3 月 3 日到 2019 年 8 月 3 日。我其实记不清我这五个月具体都发生了什么，我还是正常的实习上班、为秋招学习、跟朋友扯淡逗逼。但是我知道，我不太正常。我记得我走着走着路就崩溃到蹲在马路边大哭。我记得我在公交车上看到对面的中年男人穿着和我爸爸一样的 polo 衫眼泪就止不住而引起了旁边人的奇怪的眼神。我记得我每隔一天就会做梦梦到爸爸，压抑的喘不过气难受的哭醒。我记得我下班不想回宿舍在操场放空一圈一圈的走着。每一次哭完我都以为，这次哭完就好了，可是没有。我恶语怼着身边关心我的人，也在偶尔清闲的工作日下午非常丧的想着工作的无趣、生活的无聊。我做了很多份网上抑郁症的测试，非常真实的填了答案，看着最后抑郁的结果。真的时刻都在叹气，随时陷入对人生的大思考。我疯狂的找各种人聊天诉说，但是没有缓解。我出去旅行，在微博上开了一个穿搭话题，希望自己每天至少能有一点开心和寄托。每次给家里打电话，都要做很久的心里准备，因为每次打完电话，我都会更丧一些，我能听到奶奶在电话里每一句话中间都夹杂着的叹气，我能听到她的孤单，她一遍遍强调的“以后你只能靠着你自己了，家里也没人能帮你了”，我还能感受到来自很多关心我的人的心疼与可怜。说实话，这些，都挺令我窒息的。可能是我矫情，但是有时候我就是执拗的想着，我才 24 岁，还没有到大多数人面对父母离去的年纪，为什么，我就没有爸爸了。</p><p>对不起，到这里，我都只写了不好的事儿与矫情的压抑。在这儿，我还是想说句，Fuck you！我的本命年，真的很丧。</p><p>但是我想说的第三件事儿，是件幸福的小事儿。我不想吝啬我能想到的任何语言来表达我的开心与幸福，还有对这趴主角的感谢。他叫李煊。存在于我博客「关于」中的男孩子。他是我的老友，以前。是一个我可以随意跟他说生活三两事儿的老友。我认识他多久呢？两三年。见过几次面？约过几次饭？啊哈哈哈哈，我印象中真的没几次。但是你要问我他在我的朋友中排名几何，我真的会说，是在好友榜的前几位。我对他的评价很高，一个相处舒服，温柔绅士且优秀的男孩子。2019 年 8 月 3 号，一个平常的周五，又跟他在微信上逼逼了一天。然后，他表白了，所以，现在，他是我的男朋友。</p><p>他好像是开玩笑的表白，随口说了句，要不你直接当我女朋友算了。我的回答也是啊哈哈哈哈哈哈 我懵逼了。然后，我开始开心，开始走心，开始认认真真动了心。微博里，我秀了恩爱，说了很多我喜欢他的故事，玩他喜欢的游戏，听他喜欢的电台和歌曲，尝试他喜欢的酒。但在这里，我想说说我感受到的他的喜欢和温柔。在网易云，我建了一个歌单，叫「给煊宝的」，里面收藏了一些我听到的甜甜的歌，我没告诉他，但是他自己看到了，就默默的添加了收藏。他会在聊天中不经意的表达爱意与喜欢，说一些彩虹屁，夸我的照骗好看的一匹，说衣服一般但主要还是看谁穿。在我磨叽他的时候突然的语气温柔，说“别闹了～乖～”。他会在我跟他说可能还有两个月才能见面的时候语气失落。也会在被工作折磨的苦逼不堪的时候给我打电话疯狂吐槽三万字。会认真把我脱下来乱放的鞋整齐的摆在鞋柜前。会温柔的吻我抱紧我笑着捏我身上的肉肉挠我的痒痒。会在我追星大喊千玺老公的时候给予我一句包容的“小傻子”。也会在我因为误解他的话闹别扭的时候一句句的认真解释，告诉我他想让我在去找他的时候住的舒服，过得开心，他焦虑着因为工作太忙而陪伴我的时间太少。会默默的记住我害怕蟑螂，在帮我找房子看房子的时候仔细甄选。会用心的给我准备节日礼物。会在繁忙的工作中尽可能的抽时间陪我。他的温柔很多，我，在慢慢感受。我们从未认真讨论过以后，承诺过至死不渝，但是在我为不知道能不能去他的城市工作结束异地而不安的时候，他看似随便的告诉我，如果我不能去，他就来。他让我感受到踏实与安定。我从未遇到过一个男人可以如此温柔。虽然我是一个非典型工科女，也会说矫情的话，可是我真的想不到还有什么比一句我爱你更加深情的表达。看着他的眼睛，三秒我就败下阵来，忍不住笑开了花。听着他的声音，我希望不要停下来，我要听他说好多好多话，情话和废话。</p><p>我说他是我的幸运星，是来帮我「冲喜」的。啊哈哈哈哈哈哈。是因为，从他表白之后，我的生活真的在一点点变好。他解救了我丧气的心情。而且，2019 年第四件事儿，一个决定了我离开学校步入社会的生活轨迹的事儿，来了。秋招，offer，工作。很想骄傲的说，做一个小小的 offer 收割机，真好。除了字节无缘，面试过的公司，百度、京东、滴滴、美团、顺丰、华为、快手，还有我的秋招初心，腾讯，全都发了 offer。没错，这里，我就是来秀的。在 2019 年的愿望清单里，我有写到，想要在深圳找到一份满意的工作。现在年度总结里，我想说，我做到了。拿到了自己心仪的 offer，去自己喜欢的城市，还有，那座城市里，有他～真的很开心。</p><p>现在的 01，很好。在努力的消化着爸爸的离去，也在认真的朝着自己想要的生活努力。我爱我亲爱的家人，也真心的谢谢那些一直陪伴着我的好朋友们～我的鹭宝宝，我的群群脑婆，我的大喵，我的龙龙北北，3308 的小仙女们，梁良，晓宇，志强，朱雪，还有我洋葱的小伙伴们和美团的弟弟、老哥们。01 一直都很幸运，一路都有很多人陪，不管是相伴到如今的挚友，还是同行一段路的曾经的朋友。</p><p>我还是很爱自己，爱这个爱笑的 01。</p><p>2019 年度总结的最后，是 2020 年的愿望清单：</p><ul><li>顺利完成论文，顺利毕业</li><li>拍好看的毕业照</li><li>去日本毕业旅行</li><li>在深圳租个不错的房子，室友 nice</li><li>养一只猫</li><li>健身是永恒的主题</li><li>多看些书</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于01的2019&quot;&gt;&lt;a href=&quot;#关于01的2019&quot; class=&quot;headerlink&quot; title=&quot;关于01的2019&quot;&gt;&lt;/a&gt;关于01的2019&lt;/h1&gt;&lt;p&gt;这是 01 第一篇非技术的博客，想记录一下我的 2019 年，因为这一年对我来说，真
      
    
    </summary>
    
      <category term="01的小生活" scheme="http://yoursite.com/categories/01%E7%9A%84%E5%B0%8F%E7%94%9F%E6%B4%BB/"/>
    
    
      <category term="年度总结" scheme="http://yoursite.com/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>Vue计算属性(computed)和侦听属性(watch)</title>
    <link href="http://yoursite.com/2019/12/29/Vue%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7(computed)%E5%92%8C%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7(watch)/"/>
    <id>http://yoursite.com/2019/12/29/Vue计算属性(computed)和侦听属性(watch)/</id>
    <published>2019-12-29T01:52:21.000Z</published>
    <updated>2019-12-29T07:18:55.892Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue计算属性-computed-和侦听属性-watch"><a href="#Vue计算属性-computed-和侦听属性-watch" class="headerlink" title="Vue计算属性(computed)和侦听属性(watch)"></a>Vue计算属性(computed)和侦听属性(watch)</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点：</p><ul><li>数据可以进行逻辑处理，减少模板中计算逻辑。</li><li>对计算属性中的数据进行监视</li><li>依赖固定的数据类型（响应式数据）</li></ul><p>计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。默认只有get，如果需要set，要自己添加。另外set设置属性，并不是直接修改计算属性，而是修改它的依赖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="comment">// getter</span></span><br><span class="line">    <span class="keyword">get</span>: function () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.firstName + <span class="string">' '</span> + <span class="keyword">this</span>.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// setter</span></span><br><span class="line">    <span class="keyword">set</span>: function (newValue) &#123;</span><br><span class="line">      <span class="comment">//this.fullName = newValue 这种写法会报错</span></span><br><span class="line">      <span class="keyword">var</span> names = newValue.split(<span class="string">' '</span>)</span><br><span class="line">      <span class="keyword">this</span>.firstName = names[<span class="number">0</span>]<span class="comment">//对它的依赖进行赋值</span></span><br><span class="line">      <span class="keyword">this</span>.lastName = names[names.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性-vs-普通属性"><a href="#计算属性-vs-普通属性" class="headerlink" title="计算属性 vs 普通属性"></a>计算属性 vs 普通属性</h3><p>可以像绑定普通属性一样在模板中绑定计算属性，在定义上有区别：计算属性的属性值必须是一个函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data:&#123; <span class="comment">//普通属性</span></span><br><span class="line">  msg:<span class="string">'浪里行舟'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">computed:&#123; <span class="comment">//计算属性</span></span><br><span class="line">  msg2:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="comment">//该函数必须有返回值，用来获取属性，称为get函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'浪里行舟'</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  reverseMsg:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//可以包含逻辑处理操作，同时reverseMsg依赖于msg,一旦msg发生变化，reverseMsg也会跟着变化</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.msg.split(<span class="string">' '</span>).reverse().join(<span class="string">' '</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="计算属性-vs-方法"><a href="#计算属性-vs-方法" class="headerlink" title="计算属性 vs 方法"></a>计算属性 vs 方法</h3><p><strong>两者最主要的区别：computed 是可以缓存的，methods 不能缓存；</strong></p><p><strong>只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。</strong>网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，计算属性可以通过闭包来实现传参：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">:data=<span class="string">"closure(item, itemName, blablaParams)"</span></span><br><span class="line">computed: &#123;</span><br><span class="line"> closure () &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">        <span class="comment">/** do something */</span></span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="侦听属性"><a href="#侦听属性" class="headerlink" title="侦听属性"></a>侦听属性</h2><p>Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性watch。<strong>watch中可以执行任何逻辑，如函数节流，Ajax异步获取数据，甚至操作 DOM（不建议）。</strong></p><h3 id="常规用法"><a href="#常规用法" class="headerlink" title="常规用法"></a>常规用法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;attr&quot;&gt;</span><br><span class="line">    &lt;h1&gt;watch属性&lt;/h1&gt;</span><br><span class="line">    &lt;h2&gt;&#123;&#123; $data &#125;&#125;&lt;/h2&gt;</span><br><span class="line">    &lt;button @click=&quot;() =&gt; (a += 1)&quot;&gt;修改a的值&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      a: 1,</span><br><span class="line">      b: &#123; c: 2, d: 3 &#125;,</span><br><span class="line">      e: &#123;</span><br><span class="line">        f: &#123;</span><br><span class="line">          g: 4</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      h: []</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    a: function(val, oldVal) &#123;</span><br><span class="line">      this.b.c += 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b.c&quot;: function(val, oldVal) &#123;</span><br><span class="line">      this.b.d += 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;b.d&quot;: function(val, oldVal) &#123;</span><br><span class="line">      this.e.f.g += 1;</span><br><span class="line">    &#125;,</span><br><span class="line">    e: &#123;</span><br><span class="line">      handler: function(val, oldVal) &#123;</span><br><span class="line">        this.h.push(&quot;浪里行舟&quot;);</span><br><span class="line">      &#125;,</span><br><span class="line">      deep: true //用于监听e对象内部值的变化</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="使用-watch-的深度遍历和立即调用功能"><a href="#使用-watch-的深度遍历和立即调用功能" class="headerlink" title="使用 watch 的深度遍历和立即调用功能"></a>使用 watch 的深度遍历和立即调用功能</h3><p>使用 watch 来监听数据变化的时候除了常用到 handler 回调，其实其还有两个参数，便是：</p><ul><li>deep 设置为 true 用于监听对象内部值的变化</li><li>immediate 设置为 true 将立即以表达式的当前值触发回调</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    data() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            obj: &#123;</span><br><span class="line">                a: 1,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    watch: &#123;</span><br><span class="line">        obj: &#123;</span><br><span class="line">            handler: function(newVal, oldVal) &#123;</span><br><span class="line">                console.log(newVal); </span><br><span class="line">            &#125;,</span><br><span class="line">            deep: true,</span><br><span class="line">            immediate: true </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>以上代码我们修改了 obj 对象中 a 属性的值，我们可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 deep: true，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 immediate: true 配置，其会立即以 obj 的当前值触发回调。</p><h2 id="computed和watch两者之间对比"><a href="#computed和watch两者之间对比" class="headerlink" title="computed和watch两者之间对比"></a>computed和watch两者之间对比</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5tpjgacj30ip078q2z.jpg" alt></p><p>从上面流程图中，我们可以看出它们之间的区别：</p><ul><li>watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。</li><li>computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。</li></ul><p>除此之外，有点很重要的区别是：<strong>计算属性不能执行异步任务，计算属性必须同步执行</strong>。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。</p><p>计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。</p><ul><li>computed能做的，watch都能做，反之则不行</li><li>能用computed的尽量用computed</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue计算属性-computed-和侦听属性-watch&quot;&gt;&lt;a href=&quot;#Vue计算属性-computed-和侦听属性-watch&quot; class=&quot;headerlink&quot; title=&quot;Vue计算属性(computed)和侦听属性(watch)&quot;&gt;&lt;/a&gt;V
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js学习笔记（二）</title>
    <link href="http://yoursite.com/2019/12/19/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/19/深入浅出Node.js学习笔记（二）/</id>
    <published>2019-12-19T09:25:43.000Z</published>
    <updated>2019-12-29T07:15:07.580Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Node-js学习笔记（二）"><a href="#深入浅出Node-js学习笔记（二）" class="headerlink" title="深入浅出Node.js学习笔记（二）"></a>深入浅出Node.js学习笔记（二）</h1><h2 id="第四章-异步编程"><a href="#第四章-异步编程" class="headerlink" title="第四章 异步编程"></a>第四章 异步编程</h2><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>高阶函数是可以把函数作为参数，或是将函数作为返回值的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x; </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后续传递风格(Continuation Passing Style)的结果接收 方式，而非单一的返回值形式。后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>ECMAScript5中提供的一些数组方法(sort()、forEach()、 map()、reduce()、reduceRight()、filter()、every()、some())十分典型</p><h4 id="偏函数用法"><a href="#偏函数用法" class="headerlink" title="偏函数用法"></a>偏函数用法</h4><p>偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line"><span class="keyword">var</span> isString = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object String]'</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isFunction = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object Function]'</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们需要重复去定义一些相似的函数，如果有更多的isXXX()，就会出现更多的冗余代码.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isType = <span class="function"><span class="keyword">function</span> (<span class="params">type</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> toString.call(obj) == <span class="string">'[object '</span> + type + <span class="string">']'</span>; </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> isString = isType(<span class="string">'String'</span>);</span><br><span class="line"><span class="keyword">var</span> isFunction = isType(<span class="string">'Function'</span>);</span><br></pre></td></tr></table></figure><p>这 种通过指定部分参数来产生一个新的定制函数的形式就是偏函数</p><h3 id="异步编程的优势与难点"><a href="#异步编程的优势与难点" class="headerlink" title="异步编程的优势与难点"></a>异步编程的优势与难点</h3><h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><p>最大的特性：基于事件驱动的非阻塞I/O模型</p><p>非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用</p><p>并行带来的想象空间更大，延展而开的是分布式和云。并行使得各个单点之间能够更有效地组织起来</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ux6kboyzj30qc0iu3zv.jpg" alt="image-20191213111035164"></p><h4 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h4><h5 id="难点1-异常处理"><a href="#难点1-异常处理" class="headerlink" title="难点1:异常处理"></a>难点1:异常处理</h5><p>异步I/O的实现主要包含两个阶段:提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">async</span> = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  process.nextTick(callback);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">async</span>(callback); </span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123; </span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用async()方法后，callback被存放起来，直到下一个事件循环(Tick)才会取出来执行。尝试对异步方法进行try/catch操作只能捕获当次事件循环内的异常，对callback执行时抛出的异常将无能为力。</p><p>Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>自行编写的异步方法上，需要去遵循这样一些原则: </p><ul><li>原则一:必须执行调用者传入的回调函数; </li><li>原则二:正确传递回异常供调用者判断。</li></ul><h5 id="难点2-函数嵌套过深"><a href="#难点2-函数嵌套过深" class="headerlink" title="难点2:函数嵌套过深"></a>难点2:函数嵌套过深</h5><h5 id="难点3-阻塞代码"><a href="#难点3-阻塞代码" class="headerlink" title="难点3:阻塞代码"></a>难点3:阻塞代码</h5><p>没有sleep()这样的线程沉睡功能</p><p>setInterval()和setTimeout()并不能阻塞后续代码的持续执行</p><h5 id="难点4-多线程编程"><a href="#难点4-多线程编程" class="headerlink" title="难点4:多线程编程"></a>难点4:多线程编程</h5><p>对于服务器端而言，如果服务器是多核CPU，单个Node进程实质上是没有充分利用多核CPU的。</p><p>Node借鉴了这个模式，child_process是其基础API，cluster模块是更深层次的应用。借助Web Workers的模式，开发人员要更多地去面临跨线程的编程，这对于以往的JavaScript编程经验是较少考虑的。</p><h5 id="难点5-异步转同步"><a href="#难点5-异步转同步" class="headerlink" title="难点5:异步转同步"></a>难点5:异步转同步</h5><p>Node中试图同步式编程，但并不能得到原生支持，需要借助库或者编译等手段来实现</p><h3 id="异步编程解决方案"><a href="#异步编程解决方案" class="headerlink" title="异步编程解决方案"></a>异步编程解决方案</h3><h4 id="事件发布-订阅模式"><a href="#事件发布-订阅模式" class="headerlink" title="事件发布/订阅模式"></a>事件发布/订阅模式</h4><p>事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">emitter.on(<span class="string">"event1"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(message); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">emitter.emit(<span class="string">'event1'</span>, <span class="string">"I am message!"</span>);</span><br></pre></td></tr></table></figure><p>事件发布/订阅模式可以实现一个事件与多 个回调函数的关联，这些回调函数又称为事件侦听器。通过emit()发布事件后，消息会立即传递给当前事件的所有侦听器执行。侦听器可以很灵活地添加和删除，使得事件和具体处理逻辑之间可以很轻松地关联和解耦。</p><p>Node对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的:</p><ul><li>如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0);可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。</li><li>为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理。</li></ul><h5 id="1-继承events模块"><a href="#1-继承events模块" class="headerlink" title="1. 继承events模块"></a>1. 继承events模块</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> events = <span class="built_in">require</span>(<span class="string">'events'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stream</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  events.EventEmitter.call(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">util.inherits(Stream, events.EventEmitter);</span><br></pre></td></tr></table></figure><p>Node在util模块中封装了继承的方法，所以此处可以很便利地调用。开发者可以通过这样的方式轻松继承EventEmitter类，利用事件机制解决业务问题。在Node提供的核心模块中，有近半数都继承自EventEmitter。</p><h5 id="2-利用事件队列解决雪崩问题"><a href="#2-利用事件队列解决雪崩问题" class="headerlink" title="2. 利用事件队列解决雪崩问题"></a>2. 利用事件队列解决雪崩问题</h5><p>雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> events.EventEmitter();</span><br><span class="line"><span class="keyword">var</span> status = <span class="string">"ready"</span>;</span><br><span class="line"><span class="keyword">var</span> select = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  proxy.once(<span class="string">"selected"</span>, callback); </span><br><span class="line">  <span class="keyword">if</span> (status === <span class="string">"ready"</span>) &#123;</span><br><span class="line">    status = <span class="string">"pending"</span>;</span><br><span class="line">    db.select(<span class="string">"SQL"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">results</span>) </span>&#123;</span><br><span class="line">      proxy.emit(<span class="string">"selected"</span>, results);</span><br><span class="line">      status = <span class="string">"ready"</span>; </span><br><span class="line">    &#125;);</span><br><span class="line"> &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用了once()方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每一个回调只会被执行一次。对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。</p><h5 id="3-多异步之间的协作方案"><a href="#3-多异步之间的协作方案" class="headerlink" title="3. 多异步之间的协作方案"></a>3. 多异步之间的协作方案</h5><p>由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间互相没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量</p><h5 id="4-EventProxy的原理"><a href="#4-EventProxy的原理" class="headerlink" title="4. EventProxy的原理"></a>4. EventProxy的原理</h5><p>EventProxy来自于Backbone的事件模块，Backbone的事件模块是Model、View模块的基础功能，在前端有广泛的使用。它在每个非all事件触发时都会触发一次all事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Trigger an event, firing all bound callbacks. Callbacks are passed the </span></span><br><span class="line"><span class="comment">// same arguments as `trigger` is, apart from the event name.</span></span><br><span class="line"><span class="comment">// Listening for `"all"` passes the true event name as the first argument </span></span><br><span class="line">trigger : <span class="function"><span class="keyword">function</span>(<span class="params">eventName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list, calls, ev, callback, args;</span><br><span class="line">  <span class="keyword">var</span> both = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">if</span> (!(calls = <span class="keyword">this</span>._callbacks)) <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">while</span> (both--) &#123;</span><br><span class="line">    ev = both ? eventName : <span class="string">'all'</span>; </span><br><span class="line">    <span class="keyword">if</span> (list = calls[ev]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = list.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!(callback = list[i])) &#123;</span><br><span class="line">          list.splice(i, <span class="number">1</span>); i--; l--; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          args = both ? <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>) : <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">          callback[<span class="number">0</span>].apply(callback[<span class="number">1</span>] || <span class="keyword">this</span>, args); </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EventProxy则是将all当做一个事件流的拦截层，在其中注入一些业务来处理单一事件无法解决的异步处理问题。类似的扩展方法还有all()、tail()、after()、not()和any()等。</p><h5 id="5-EventProxy的异常处理"><a href="#5-EventProxy的异常处理" class="headerlink" title="5. EventProxy的异常处理"></a>5. EventProxy的异常处理</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">exports.getContent = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> ep = <span class="keyword">new</span> EventProxy();</span><br><span class="line">  ep.all(<span class="string">'tpl'</span>, <span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">tpl, data</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 成功回调</span></span><br><span class="line">    callback(<span class="literal">null</span>, &#123;</span><br><span class="line">      template: tpl,</span><br><span class="line">      data: data </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;); </span><br><span class="line">  <span class="comment">//绑定错误处理函数 </span></span><br><span class="line">  ep.fail(callback);</span><br><span class="line">  fs.readFile(<span class="string">'template.tpl'</span>, <span class="string">'utf-8'</span>, ep.done(<span class="string">'tpl'</span>));</span><br><span class="line">  db.get(<span class="string">'some sql'</span>, ep.done(<span class="string">'data'</span>)); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EventProxy提供了fail()和done()这两个实例方法来优化异常处理，使得开发者将精力关注在业务部分，而不是在异常捕获上。</p><h6 id="fail-方法的实现"><a href="#fail-方法的实现" class="headerlink" title="fail()方法的实现"></a>fail()方法的实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ep.fail(callback);</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep.fail(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; </span><br><span class="line">  callback(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>又等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ep.bind(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 卸载掉所有处理函数 </span></span><br><span class="line">  ep.unbind();</span><br><span class="line">  <span class="comment">// 异常回调</span></span><br><span class="line">  callback(err); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="done-方法的实现"><a href="#done-方法的实现" class="headerlink" title="done()方法的实现"></a>done()方法的实现</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ep.done(<span class="string">'tpl'</span>);</span><br></pre></td></tr></table></figure><p>等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">  <span class="comment">// 一旦发生异常，一律交给error事件处理函数处理</span></span><br><span class="line">  <span class="keyword">return</span> ep.emit(<span class="string">'error'</span>, err); </span><br><span class="line">  &#125;</span><br><span class="line">  ep.emit(<span class="string">'tpl'</span>, content); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-Deferred模式"><a href="#Promise-Deferred模式" class="headerlink" title="Promise/Deferred模式"></a>Promise/Deferred模式</h4><p>先执行异步调用，延迟传递处理的方式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api') </span><br><span class="line">  .success(onSuccess) </span><br><span class="line">  .error(onError) </span><br><span class="line">  .complete(onComplete);</span><br></pre></td></tr></table></figure><p>这使得即使不调用success()、error()等方法，Ajax也会执行，这样的调用方式比预先传入回调让人觉得舒适一些。</p><p>在原始的API中，一个事件只能处理一个回调，而通过Deferred对象，可以对事件加入任意的业务处理逻辑。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="keyword">get</span>('/api') </span><br><span class="line">  .success(onSuccess1) </span><br><span class="line">  .success(onSuccess2);</span><br></pre></td></tr></table></figure><p>CommonJS草案目前已经抽象出了Promises/A、 Promises/B、Promises/D这样典型的异步Promise/Deferred模型，这使得异步操作可以以一种优雅的方式出现。</p><h5 id="Promises-A"><a href="#Promises-A" class="headerlink" title="Promises/A"></a>Promises/A</h5><ul><li>Promise操作只会处在3种状态的一种:未完成态、完成态和失败态。</li><li>Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。</li><li>Promise的状态一旦转化，将不能被更改。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yev5y4i1j30gs0c4q3v.jpg" alt="image-20191216113903367"></p><h6 id="Promise对象的then"><a href="#Promise对象的then" class="headerlink" title="Promise对象的then()"></a>Promise对象的then()</h6><p>一个Promise对象只要具备then()方法即可</p><ul><li>接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。</li><li>可选地支持progress事件回调作为第三个方法。</li><li>then()方法只接受function对象，其余对象将被忽略。 </li><li>then()方法继续返回Promise对象，以实现链式调用。</li></ul><h6 id="Deferred，延迟对象"><a href="#Deferred，延迟对象" class="headerlink" title="Deferred，延迟对象"></a>Deferred，延迟对象</h6><p>触发执行这些回调函数的地方，实现这些功能的对象通常被称为Deferred，即延迟对象</p><h6 id="Promise和Deferred的差别"><a href="#Promise和Deferred的差别" class="headerlink" title="Promise和Deferred的差别"></a>Promise和Deferred的差别</h6><p>Deferred主要是用于内部， 用于维护异步模型的状态;Promise则作用于外部，通过then()方法暴露给外部以添加自定义逻辑。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9yf1x7tvnj30ws0coabq.jpg" alt="image-20191216114535955"></p><h5 id="Promise中的多异步协作"><a href="#Promise中的多异步协作" class="headerlink" title="Promise中的多异步协作"></a>Promise中的多异步协作</h5><p>通过all()方法抽象多个异步操作。只有所有异步操作成功，这个异步操作才算成功， 一旦其中一个异步操作失败，整个异步操作就失败。</p><h5 id="Promise的进阶知识"><a href="#Promise的进阶知识" class="headerlink" title="Promise的进阶知识"></a>Promise的进阶知识</h5><ul><li><p>支持序列执行的Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">promise()</span><br><span class="line">  .then(obj.api1) </span><br><span class="line">  .then(obj.api2) </span><br><span class="line">  .then(obj.api3) </span><br><span class="line">  .then(obj.api4) </span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">value4</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Do something with value4 </span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Handle any error from step1 through step4 </span></span><br><span class="line">&#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure><p>改造一下代码以实现链式调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Deferred = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成态</span></span><br><span class="line">Deferred.prototype.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">this</span>.promise;</span><br><span class="line">  <span class="keyword">var</span> handler;</span><br><span class="line">  <span class="keyword">while</span> ((handler = promise.queue.shift())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler &amp;&amp; handler.fulfilled) &#123; </span><br><span class="line">      <span class="keyword">var</span> ret = handler.fulfilled(obj); </span><br><span class="line">      <span class="keyword">if</span> (ret &amp;&amp; ret.isPromise) &#123;</span><br><span class="line">        ret.queue = promise.queue; </span><br><span class="line">        <span class="keyword">this</span>.promise = ret; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 失败态</span></span><br><span class="line">Deferred.prototype.reject = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">this</span>.promise;</span><br><span class="line">  <span class="keyword">var</span> handler;</span><br><span class="line">  <span class="keyword">while</span> ((handler = promise.queue.shift())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (handler &amp;&amp; handler.error) &#123; </span><br><span class="line">      <span class="keyword">var</span> ret = handler.error(err); </span><br><span class="line">      <span class="keyword">if</span> (ret &amp;&amp; ret.isPromise) &#123;</span><br><span class="line">        ret.queue = promise.queue; </span><br><span class="line">        <span class="keyword">this</span>.promise = ret;</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 生成回调函数 </span></span><br><span class="line">Deferred.prototype.callback = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> that.reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">    that.resolve(file); </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="built_in">Promise</span> = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 队列用于存储待执行的回调函数 </span></span><br><span class="line">  <span class="keyword">this</span>.queue = [];</span><br><span class="line">  <span class="keyword">this</span>.isPromise = <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">fulfilledHandler, errorHandler, progressHandler</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> handler = &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fulfilledHandler === <span class="string">'function'</span>) &#123;</span><br><span class="line">    handler.fulfilled = fulfilledHandler; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> errorHandler === <span class="string">'function'</span>) &#123; </span><br><span class="line">    handler.error = errorHandler;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">this</span>.queue.push(handler); </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>读取第二个文件是依 赖于第一个文件中的内容的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile1 = <span class="function"><span class="keyword">function</span> (<span class="params">file, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  fs.readFile(file, encoding, deferred.callback());</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> readFile2 = <span class="function"><span class="keyword">function</span> (<span class="params">file, encoding</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">  fs.readFile(file, encoding, deferred.callback());</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;;</span><br><span class="line">readFile1(<span class="string">'file1.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">file1</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> readFile2(file1.trim(), <span class="string">'utf8'</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">file2</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(file2);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>要让Promise支持链式执行，主要通过以下两个步骤。<br> (1) 将所有的回调都存到队列中。<br> (2) Promise完成时，逐个执行回调，一旦检测到返回了新的Promise对象，停止执行，然后将当前Deferred对象的promise引用改变为新的Promise对象，并将队列中余下的回调转交给它。</p><ul><li>将API Promise化</li></ul><p>可以 批量将方法Promise化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// smooth(fs.readFile);</span></span><br><span class="line"><span class="keyword">var</span> smooth = <span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> deferred = <span class="keyword">new</span> Deferred();</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">0</span>); </span><br><span class="line">    args.push(deferred.callback());</span><br><span class="line">    method.apply(<span class="literal">null</span>, args);</span><br><span class="line">    <span class="keyword">return</span> deferred.promise;</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>于是前面的两次文件读取的构造可以简化为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = smooth(fs.readFile);</span><br></pre></td></tr></table></figure><p>于是代码锐减到：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = smooth(fs.readFile); readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf8'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">file1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(file1.trim(), <span class="string">'utf8'</span>); &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">file2</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// file2 =&gt; I am file2</span></span><br><span class="line">  <span class="built_in">console</span>.log(file2); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="流程控制库"><a href="#流程控制库" class="headerlink" title="流程控制库"></a>流程控制库</h4><h5 id="1-尾触发与Next"><a href="#1-尾触发与Next" class="headerlink" title="1. 尾触发与Next"></a>1. 尾触发与Next</h5><p>需要手工调用才能持续执行后续调用的</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ykp64h0pj314a0bggn2.jpg" alt="image-20191216150057148"></p><p>中间件机制使得在处理网络请求时，可以像面向切面编程一样进行过滤、验证、日志等功能， 而不与具体业务逻辑产生关联，以致产生耦合</p><p>尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每 个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的 处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者 Promise完成的，这样业务在纵向和横向都能够各自清晰。</p><p>在Connect中，尾触发十分适合处理网络请求的场景。将复杂的处理逻辑拆解为简洁、单一 的处理单元，逐层次地处理请求对象和响应对象。</p><h5 id="2-async"><a href="#2-async" class="headerlink" title="2. async"></a>2. async</h5><h6 id="异步的串行执行"><a href="#异步的串行执行" class="headerlink" title="异步的串行执行"></a>异步的串行执行</h6><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.series([</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码等价于:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> callback(err); </span><br><span class="line">  &#125;</span><br><span class="line">  fs.readFile(<span class="string">'file2.txt '</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    callback(<span class="literal">null</span>, [content, data]); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>series()方法中传入的函数callback()并非由使用者指定。事实上，此处的回调函数由async通过高阶函数的方式注入，这里隐含了特殊的逻 辑。每个callback()执行时会将结果保存起来，然后执行下一个调用，直到结束所有调用。最终的回调函数执行时，队列里的异步调用保存的结果以数组的方式传入。这里的异常处理规则是一 旦出现异常，就结束所有调用，并将异常传递给最终回调函数的第一个参数。</p><h6 id="异步的并行执行"><a href="#异步的并行执行" class="headerlink" title="异步的并行执行"></a>异步的并行执行</h6><p>当我们需要通过并行来提升性能时，async提供了parallel()方法，用以并行执行一些异步操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallel([ </span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// results =&gt; [file1.txt, file2.txt] </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面这段代码等价于下面的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> results = [];</span><br><span class="line"><span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">  results[index] = value; </span><br><span class="line">  counter--;</span><br><span class="line">  <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">    callback(<span class="literal">null</span>, results); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只传递第一个异常</span></span><br><span class="line"><span class="keyword">var</span> hasErr = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">var</span> fail = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!hasErr) &#123; </span><br><span class="line">    hasErr = <span class="literal">true</span>; </span><br><span class="line">    callback(err);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> fail(err); </span><br><span class="line">  &#125;</span><br><span class="line">  done(<span class="number">0</span>, content); </span><br><span class="line">&#125;);</span><br><span class="line">fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="keyword">return</span> fail(err); </span><br><span class="line">  &#125;</span><br><span class="line">  done(<span class="number">1</span>, data); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过async编写的代码既没有深度的嵌套，也没有复杂的状态判断，它的诀窍依然来 自于注入的回调函数</p><p>parallel()方法对于异常的判断依然是一旦某个异步调用产生了异常，就 会将异常作为第一个参数传入给最终的回调函数。只有所有异步调用都正常完成时，才会将结果 以数组的方式传入。</p><h6 id="异步调用的依赖处理"><a href="#异步调用的依赖处理" class="headerlink" title="异步调用的依赖处理"></a>异步调用的依赖处理</h6><p>series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了</p><p>async提供了<strong>waterfall()</strong>方法来满足</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.waterfall([ </span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123; </span><br><span class="line">      callback(err, content);</span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">arg1, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// arg1 =&gt; file2.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">arg1, callback</span>)</span>&#123; </span><br><span class="line">    <span class="comment">// arg1 =&gt; file3.txt</span></span><br><span class="line">    fs.readFile(arg1, <span class="string">'utf-8'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">      callback(err, content); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="function"><span class="keyword">function</span> (<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// result =&gt; file4.txt </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>自动依赖处理</li></ul><p>auto()方法能根据依赖关系自动分析，以最佳的顺序执行业务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.auto(deps);</span><br></pre></td></tr></table></figure><h5 id="3-Step"><a href="#3-Step" class="headerlink" title="3. Step"></a>3. Step</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Step(task1, task2, task3);</span><br></pre></td></tr></table></figure><p>Step接受任意数量的任务，所有的任务都将会串行依次执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Step(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFile1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFile2</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">err, content</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(content); </span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参 数，并调用执行。</p><ul><li>并行任务执行</li></ul><p>this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Step(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFile1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>.parallel());</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, <span class="keyword">this</span>.parallel()); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">done</span>(<span class="params">err, content1, content2</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// content1 =&gt; file1</span></span><br><span class="line">    <span class="comment">// content2 =&gt; file2 </span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>);</span><br><span class="line">  &#125; </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数</p><p>Step的parallel()方法的原理是每次执行时将内部的计数器加1，然后返回一个回调函数，这个回调函数在异步调用结束时才执行。当回调函数执行时，将计数器减1。当计数器为0的时候， 告知Step所有异步调用结束了，Step会执行下一个方法。</p><p>Step与async相同的是异常处理，一旦有一个异常产生，这个异常会作为下一个方法的第一个 参数传入</p><ul><li>结果分组</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Step(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readDir</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    fs.readdir(__dirname, <span class="keyword">this</span>); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">readFiles</span>(<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="comment">// Create a new group</span></span><br><span class="line">    <span class="keyword">var</span> group = <span class="keyword">this</span>.group();</span><br><span class="line">    results.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">filename</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/\.js$/</span>.test(filename)) &#123;</span><br><span class="line">        fs.readFile(__dirname + <span class="string">"/"</span> + filename, <span class="string">'utf8'</span>, group());</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showAll</span>(<span class="params">err, files</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.dir(files); </span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们注意到有两次group()的调用。第一次调用是告知Step要并行执行，第二次调用的结果将会生成一个回调函数，而回调函数接受的返回值将会按组存储。</p><p>parallel()传递给下一个任务的 结果是如下形式:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err, result1, result2, ...</span>);</span></span><br></pre></td></tr></table></figure><p>group()传递的结果是:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>);</span></span><br></pre></td></tr></table></figure><p>这个函数返回的数据保存在数组中。</p><h5 id="4-wind"><a href="#4-wind" class="headerlink" title="4. wind"></a>4. wind</h5><ul><li>异步任务定义</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span>(Wind.compile(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;));</span><br><span class="line">Wind.Async.sleep(<span class="number">20</span>);</span><br></pre></td></tr></table></figure><p>Wind.compile()会将普通的函数进行编译，然后交给eval()执行。</p><p>eval(Wind.compile(“async”, function () {}));定义了异步任务。Wind.Async.sleep();内置了对setTimeout()的封装。</p><p>除了通过eval(Wind.compile(“async”, function () {}));定义任务外，正式的任务创建方法为Task.create()。</p><ul><li>$await()与任务模型</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="keyword">await</span>()</span><br></pre></td></tr></table></figure><p>事实上，它并不是一个方法，也不存在于上下文中，只是一个等待的占位符，告之编译器这里需要等待。</p><p>$await()接受的参数是一个任务对象，表示等待任务结束后才会执行后续操作。每一个异步 操作都可以转化为一个任务，wind正是基于任务模型实现的。</p><p>wind提供了whenAll()来处理并发，通过$await关键字将等待配置的所有任务完成后才向下继续执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parallel = <span class="built_in">eval</span>(Wind.compile(<span class="string">"async"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> result = $<span class="keyword">await</span>(Task.whenAll(&#123;</span><br><span class="line">    file1: readFileAsync(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>),</span><br><span class="line">    file2: readFileAsync(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>) </span><br><span class="line">  &#125;));</span><br><span class="line">  <span class="built_in">console</span>.log(result.file1);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(result.file2); &#125;));</span><br><span class="line">parallel().start();</span><br><span class="line"><span class="comment">//得到输出:</span></span><br><span class="line">file1 file2</span><br></pre></td></tr></table></figure><ul><li>异步方法转换辅助函数</li></ul><p>这种近同步编程的体验需要我们额外 或者提前完成的事情是:将异步方法任务化。</p><p>wind提供了两个 方法来辅助转换:</p><ol><li>Wind.Async.Binding.fromCallback 用于转换这类无异常的异步调用为wind中的任务</li><li>Wind.Async.Binding.fromStandard 用于转换这类带异常的异步调用到wind中的任务。</li></ol><h3 id="异步并发控制"><a href="#异步并发控制" class="headerlink" title="异步并发控制"></a>异步并发控制</h3><p>同步I/O因为每个I/O都是彼此阻塞的，在循环体 中，总是一个接着一个调用，不会出现耗用文件描述符太多的情况，同时性能也是低下的;对于 异步I/O，虽然并发容易实现，但是由于太容易实现，依然需要控制。换言之，尽管是要压榨底 层系统的性能，但还是需要给予一定的过载保护，以防止过犹不及。</p><h4 id="bagpipe的解决方案"><a href="#bagpipe的解决方案" class="headerlink" title="bagpipe的解决方案"></a>bagpipe的解决方案</h4><ul><li>通过一个队列来控制并发量。</li><li>如果当前活跃(指调用发起但未执行回调)的异步调用量小于限定值，从队列中取出执行。 </li><li>如果活跃调用达到限定值，调用暂时存放在队列中。</li><li>每个异步调用结束时，从队列中取出新的异步调用执行</li></ul><p>用户传入的回调函数被真正执行前，被封装替换过。这个封装的回调函数内部的逻辑将活跃 值的计数器减1后，主动调用next()执行后续等待的异步调用。</p><p>bagpipe类似于打开了一道窗口，允许异步调用并行进行，但是严格限定上限。仅仅在调用 push()时分开传递，并不对原有API有任何侵入。</p><h5 id="拒绝模式"><a href="#拒绝模式" class="headerlink" title="拒绝模式"></a>拒绝模式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定最大并发数为10</span></span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>, &#123;</span><br><span class="line">  refuse: <span class="literal">true</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返给它一个队列太忙的 拒绝异常。</p><h5 id="超时控制"><a href="#超时控制" class="headerlink" title="超时控制"></a>超时控制</h5><p>造成队列拥塞的主要原因是异步调用耗时太久，调用产生的速度远远高于执行的速度。为了防止某些异步调用使用了太多的时间，我们需要设置一个时间基线，将那些执行时间太久的异步调用 清理出活跃队列，让排队中的异步调用尽快执行。否则在拒绝模式下，会有太多的调用因为某个执 行得慢，导致得到拒绝异常。</p><p>超时控制是为异步调用设置一个时间阈值，如果异步调用 没有在规定时间内完成，我们先执行用户传入的回调函数，让用户得到一个超时异常，以尽早返 回。然后让下一个等待队列中的调用执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设定最大并发数为10</span></span><br><span class="line"><span class="keyword">var</span> bagpipe = <span class="keyword">new</span> Bagpipe(<span class="number">10</span>, &#123;</span><br><span class="line">  timeout: <span class="number">3000</span> </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="async的解决方案"><a href="#async的解决方案" class="headerlink" title="async的解决方案"></a>async的解决方案</h4><p>async也提供了一个方法用于处理异步调用的限制:parallelLimit()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>.parallelLimit([ </span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file1.txt'</span>, <span class="string">'utf-8'</span>, callback); </span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    fs.readFile(<span class="string">'file2.txt'</span>, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">  &#125;</span><br><span class="line">], <span class="number">1</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, results</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO </span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同 时并发一定数量，而不是无限制并发。</p><p>parallelLimit()方法的缺陷在于无法动态地增加并行任务。async提供了queue()方法 来满足该需求.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> q = <span class="keyword">async</span>.queue(<span class="function"><span class="keyword">function</span> (<span class="params">file, callback</span>) </span>&#123;</span><br><span class="line">  fs.readFile(file, <span class="string">'utf-8'</span>, callback);</span><br><span class="line">&#125;,<span class="number">2</span>);</span><br><span class="line">q.drain=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 完成了队列中的所有任务 </span></span><br><span class="line">&#125;;</span><br><span class="line">fs.readdirSync(<span class="string">'.'</span>).forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">  q.push(file, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// TODO </span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>尽管queue()实现了动态添加并行任务，但是相比parallelLimit()，由于queue()接收的参数是固定的，它丢失了parallelLimit()的多样性</p><h2 id="第五章-内存控制"><a href="#第五章-内存控制" class="headerlink" title="第五章 内存控制"></a>第五章 内存控制</h2><h3 id="V8-的垃圾回收机制与内存限制"><a href="#V8-的垃圾回收机制与内存限制" class="headerlink" title="V8 的垃圾回收机制与内存限制"></a>V8 的垃圾回收机制与内存限制</h3><h4 id="V8-的内存限制"><a href="#V8-的内存限制" class="headerlink" title="V8 的内存限制"></a>V8 的内存限制</h4><p>在Node中通过JavaScript 使用内存时就会发现只能使用部分内存(64位系统下约为1.4 GB，32位系统下约为0.7 GB)。在 这样的限制下，将会导致Node无法直接操作大内存对象。</p><p>造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上 都是通过V8自己的方式来进行分配和管理的。V8的这套内存管理机制在浏览器的应用场景下使 用起来绰绰有余，足以胜任前端页面中的所有需求。但在Node中，这却限制了开发者随心所欲使 用大内存的想法。</p><h4 id="V8-的对象分配"><a href="#V8-的对象分配" class="headerlink" title="V8 的对象分配"></a>V8 的对象分配</h4><h5 id="内存使用量的查看"><a href="#内存使用量的查看" class="headerlink" title="内存使用量的查看"></a>内存使用量的查看</h5><p>在V8中，所有的JavaScript对象都是通过堆来进行分配的。Node提供了V8中内存使用量的查 看方式，执行下面的代码，将得到输出的内存信息:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage(); </span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">14958592</span>,</span><br><span class="line">  heapTotal: <span class="number">7195904</span>, </span><br><span class="line">  heapUsed: <span class="number">2821496</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>heapTotal和heapUsed是V8的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。</p><p>当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲 内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。</p><h5 id="V8限制堆大小的原因"><a href="#V8限制堆大小的原因" class="headerlink" title="V8限制堆大小的原因"></a>V8限制堆大小的原因</h5><p>以1.5 GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一 次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在 这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受， 前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。</p><h5 id="调整内存限制的大小"><a href="#调整内存限制的大小" class="headerlink" title="调整内存限制的大小"></a>调整内存限制的大小</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node --max-old-space-size=<span class="number">1700</span> test.js <span class="comment">// 单位为MB </span></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line">node --max-<span class="keyword">new</span>-space-size=<span class="number">1024</span> test.js <span class="comment">// 单位为KB</span></span><br></pre></td></tr></table></figure><h4 id="V8-的垃圾回收机制"><a href="#V8-的垃圾回收机制" class="headerlink" title="V8 的垃圾回收机制"></a>V8 的垃圾回收机制</h4><h5 id="V8主要的垃圾回收算法"><a href="#V8主要的垃圾回收算法" class="headerlink" title="V8主要的垃圾回收算法"></a>V8主要的垃圾回收算法</h5><p>V8的垃圾回收策略主要基于分代式垃圾回收机制</p><ul><li><p>V8的内存分代</p><p>在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga27phiuq7j30r005q74q.jpg" alt="image-20191219183341084"></p><p>V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面我们提及的 –max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，–max-new-space-size 命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就 指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值 时，就会引起进程出错。</p><ul><li>对于新生代内存，它由两个reserved_semispace_size_所构成.按机器位数不同，reserved_semispace_size_在64位系统和32位系统上分别为16 MB和8 MB。所以新生 代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB。</li><li>默认情况下，V8堆内存的最大值在64位系统上为1464 MB，32位系统上则为732 MB。 这个数值可以解释为何在64位系统下只能使用约1.4 GB内存和在32位系统下只能使用约0.7 GB 内存。</li></ul></li><li><p>Scavenge算法</p><p>新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法。</p><ul><li><p>Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处 于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象 时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这 些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空 间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个 semispace空间之间进行复制。</p></li><li><p>Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时 间效率上有优异的表现。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga27wgek1uj30rm07wq3m.jpg" alt="image-20191219184025403"></p><p>当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中 的过程称为晋升。</p><p>在分代式垃圾回收的前提下，From空间中的存活对 象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中， 也就是完成对象晋升。</p><p>对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。当要从From空间复制一个对象到To空间时，如果 To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中</p><p>（设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接 下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。）</p></li><li><p>Mark-Sweep &amp; Mark-Compact</p><p>Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。<strong>Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。</strong></p><p>Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种 内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有 的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。</p><p>在整理的 过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga283qesgnj317y08sq4f.jpg" alt="image-20191219184724646"></p><p>V8主要使用Mark-Sweep，在空间不足以对从新 生代中晋升过来的对象进行分配时才使用Mark-Compact。</p></li><li><p>Incremental Marking</p><p>为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全 停顿”(stop-the-world)。</p><p>为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成 的动作改为增量标记(incremental marking)，也就是拆分为许多小“步进”，每做完一“步进” 就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga287h5jwqj30sk09qt9k.jpg" alt="image-20191219185100781"></p><p>V8在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。</p><p>V8后续还引入了延迟清理(lazy sweeping)与增量式整理(incremental compaction)，让清 理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低 每次停顿的时间。</p></li></ul><h4 id="查看垃圾回收日志"><a href="#查看垃圾回收日志" class="headerlink" title="查看垃圾回收日志"></a>查看垃圾回收日志</h4><p>查看垃圾回收日志的方式主要是在启动时添加–trace_gc参数。在进行垃圾回收时，将会从 标准输出中打印垃圾回收的日志信息。通过分析垃圾回收日志，可以了解垃圾回收的运行状况，找出垃圾回收的哪些阶段比较耗时， 触发的原因是什么。</p><p>通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾 回收执行时占用的时间。</p><p>（V8提供了linux-tick-processor工具用于统计日志信息。该工具可以从Node源码的 deps/v8/tools目录下找到，Windows下的对应命令文件为windows-tick-processor.bat。将该目录添 加到环境变量PATH中，即可直接调用）</p><h3 id="高效使用内存"><a href="#高效使用内存" class="headerlink" title="高效使用内存"></a>高效使用内存</h3><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><h5 id="1-标识符查找"><a href="#1-标识符查找" class="headerlink" title="1. 标识符查找"></a>1. 标识符查找</h5><p>标识符，可以理解为变量名。</p><h5 id="2-作用域链"><a href="#2-作用域链" class="headerlink" title="2. 作用域链"></a>2. 作用域链</h5><p>JavaScript在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作 用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。这样的查找方式使得作 用域像一个链条。由于标识符的查找方向是向上的，所以变量只能向外访问，而不能向内访问。</p><h5 id="3-变量的主动释放"><a href="#3-变量的主动释放" class="headerlink" title="3. 变量的主动释放"></a>3. 变量的主动释放</h5><ul><li><p>如果变量是全局变量(不通过var声明或定义在global变量上)，由于全局作用域需要直到 进程退出才能释放，此时将导致引用的对象常驻内存(常驻在老生代中)。如果需要释放常驻内 存的对象，可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理的过程中，会被回收释放。</p></li><li><p>在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。</p></li><li><p>虽然 delete操作和重新赋值具有相同的效果，但是在V8中通过delete删除对象的属性有可能干扰V8 的优化，所以通过赋值方式解除引用更好。</p></li></ul><h4 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h4><p>实现外部作用域访问内部作用域中变量的方法叫做闭包(closure)</p><p>这得益 于高阶函数的特性:函数可以作为参数或者返回值。</p><p>一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域 中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。</p><h3 id="内存指标"><a href="#内存指标" class="headerlink" title="内存指标"></a>内存指标</h3><p>os模块中的 totalmem()和freemem()方法也可以查看内存使用情况</p><h4 id="查看内存使用情况"><a href="#查看内存使用情况" class="headerlink" title="查看内存使用情况"></a>查看内存使用情况</h4><h5 id="1-查看进程的内存占用"><a href="#1-查看进程的内存占用" class="headerlink" title="1. 查看进程的内存占用"></a>1. 查看进程的内存占用</h5><p>调用process.memoryUsage()可以看到Node进程的内存占用情况</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; process.memoryUsage() </span><br><span class="line">&#123; <span class="attr">rss</span>: <span class="number">13852672</span>,</span><br><span class="line">  heapTotal: <span class="number">6131200</span>, </span><br><span class="line">  heapUsed: <span class="number">2757120</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区(swap)或者文件系统(filesystem)中。</p><p>除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内 存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节。</p><h5 id="2-查看系统的内存占用"><a href="#2-查看系统的内存占用" class="headerlink" title="2. 查看系统的内存占用"></a>2. 查看系统的内存占用</h5><p>os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; os.totalmem() </span><br><span class="line"><span class="number">8589934592</span></span><br><span class="line">&gt; os.freemem() </span><br><span class="line"><span class="number">4527833088</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><h4 id="堆外内存"><a href="#堆外内存" class="headerlink" title="堆外内存"></a>堆外内存</h4><p>堆中的内存用量总是小于进程的常驻内存用 量，这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存。</p><p>Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不 会有堆内存的大小限制。</p><p>利用堆外内存可以突破内存限制的问题。</p><p><strong>Node的内存构成主要由通过V8进行分配的部分和Node自行分配的 部分。受V8的垃圾回收限制的主要是V8的堆内存。</strong></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>造成内存泄漏的原因：</p><ul><li>缓存。</li><li>队列消费不及时。</li><li>作用域未释放。</li></ul><h4 id="慎将内存当做缓存"><a href="#慎将内存当做缓存" class="headerlink" title="慎将内存当做缓存"></a>慎将内存当做缓存</h4><ul><li><p>在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常 驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描 10 和整理时，对这些对象做无用功</p></li><li><p>JavaScript开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上 的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。</p></li></ul><h5 id="1-缓存限制策略"><a href="#1-缓存限制策略" class="headerlink" title="1. 缓存限制策略"></a>1. 缓存限制策略</h5><p>为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。</p><p>模块机制：为了加速模块的引入，所有模块都会通 过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量， 这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。</p><h5 id="2-缓存的解决方案"><a href="#2-缓存的解决方案" class="headerlink" title="2. 缓存的解决方案"></a>2. 缓存的解决方案</h5><p>进 程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用 是一种浪费。</p><p>采用进程外的缓存，进程自身不存储状态。外 部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。</p><p>在Node中主要可以解决以下两个问题。</p><p>(1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。<br> (2) 进程之间可以共享缓存。</p><p>市面上较好的缓存有Redis和Memcached</p><h4 id="关注队列状态"><a href="#关注队列状态" class="headerlink" title="关注队列状态"></a>关注队列状态</h4><p>队列在消费者-生产者模型中经常充当中间产物。一旦消费速度低于生产速度， 将会形成堆积。</p><p>深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关 人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应， 通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个 下限值。</p><h3 id="内存泄漏排查"><a href="#内存泄漏排查" class="headerlink" title="内存泄漏排查"></a>内存泄漏排查</h3><p>常见的定位Node应用的内存泄漏的工具：</p><ul><li>v8-profiler。由Danny Coates提供，它可以用于对V8堆内存抓取快照和对CPU进行分析，但该项目已经有3年没有维护了。</li><li>node-heapdump。这是Node核心贡献者之一Ben Noordhuis编写的模块，它允许对V8堆内存抓取快照，用于事后分析。</li></ul><ul><li>node-mtrace。由Jimb Esser提供，它使用了GCC的mtrace工具来分析堆的使用。</li><li>dtrace。在Joyent的SmartOS系统上，有完善的dtrace工具用来分析内存泄漏。</li><li>node-memwatch。来自Mozilla的Lloyd Hilaiel贡献的模块，采用WTFPL许可发布。</li></ul><h4 id="node-heapdump"><a href="#node-heapdump" class="headerlink" title="node-heapdump"></a>node-heapdump</h4><p>先构造如下一份包含内存泄 漏的代码示例，并将其存为server.js文件：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line"><span class="keyword">var</span> leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  leak();</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>); </span><br><span class="line">&#125;).listen(<span class="number">1337</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure><p>在上面这段代码中，每次访问服务进程都将引起leakArray数组中的元素增加，而且得不到回收。我们可以用curl工具输入<a href="http://127.0.0.1:1337/命令来模拟用户访问。" target="_blank" rel="noopener">http://127.0.0.1:1337/命令来模拟用户访问。</a></p><h5 id="安装node-heapdump"><a href="#安装node-heapdump" class="headerlink" title="安装node-heapdump"></a>安装node-heapdump</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install heapdump</span><br></pre></td></tr></table></figure><p>安装node-heapdump后，在代码的第一行添加如下代码将其引入:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var heapdump = require(&apos;heapdump&apos;);</span><br></pre></td></tr></table></figure><p>引入node-heapdump后，就可以启动服务进程，并接受客户端的请求。访问多次之后， leakArray中就会具备大量的元素。这个时候我们通过向服务进程发送SIGUSR2信号，让 10 node-heapdump抓拍一份堆内存的快照。发送信号的命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kill -USR2 &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>这份抓取的快照将会在文件目录下以heapdump-<sec>.<usec>.heapsnapshot的格式存放。这是一份较大的JSON文件，需要通过Chrome的开发者工具打开查看。</usec></sec></p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga362sgilrj31400qmwq7.jpg" alt="image-20191220142253073"></p><p>可以看到有大量的leak字符串存在，这些字符串就是一直未能得到回收的数据。 通过在开发者工具的面板中查看内存分布，我们可以找到泄漏的数据，然后根据这些信息找到造 成泄漏的代码。</p><h4 id="node-memwatch"><a href="#node-memwatch" class="headerlink" title="node-memwatch"></a>node-memwatch</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memwatch = <span class="built_in">require</span>(<span class="string">'memwatch'</span>); memwatch.on(<span class="string">'leak'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">info</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'leak:'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(info); </span><br><span class="line">&#125;);</span><br><span class="line">memwatch.on(<span class="string">'stats'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">stats</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'stats:'</span>) </span><br><span class="line">  <span class="built_in">console</span>.log(stats);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line"><span class="keyword">var</span> leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random()); </span><br><span class="line">&#125;;</span><br><span class="line">http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  leak();</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>); </span><br><span class="line">&#125;).listen(<span class="number">1337</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure><h5 id="1-stats事件"><a href="#1-stats事件" class="headerlink" title="1. stats事件"></a>1. stats事件</h5><p>在进程中使用node-memwatch之后，每次进行全堆垃圾回收时，将会触发一次stats事件，这 4 个事件将会传递内存的统计信息。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga366z9jroj30mi0a6q4r.jpg" alt="image-20191220142653590"></p><p>num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况</p><h5 id="2-leak事件"><a href="#2-leak事件" class="headerlink" title="2. leak事件"></a>2. leak事件</h5><p>如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga36evbve4j30uk05wgmj.jpg" alt="image-20191220143429405"></p><p>这个数据能显示5次垃圾回收的过程中内存增长了多少。</p><h5 id="3-堆内存比较"><a href="#3-堆内存比较" class="headerlink" title="3. 堆内存比较"></a>3. 堆内存比较</h5><p>最终得到的leak事件的信息只能告知我们应用中存在内存泄漏，具体问题产生在何处还需要从V8的堆内存上定位。node-memwatch提供了抓取快照和比较快照的功能，它能够比较堆上对象 的名称和分配数量，从而找出导致内存泄漏的元凶。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> memwatch = <span class="built_in">require</span>(<span class="string">'memwatch'</span>);</span><br><span class="line"><span class="keyword">var</span> leakArray = [];</span><br><span class="line"><span class="keyword">var</span> leak = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  leakArray.push(<span class="string">"leak"</span> + <span class="built_in">Math</span>.random());</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take first snapshot</span></span><br><span class="line"><span class="keyword">var</span> hd = <span class="keyword">new</span> memwatch.HeapDiff();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123; </span><br><span class="line">  leak();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Take the second snapshot and compute the diff </span></span><br><span class="line"><span class="keyword">var</span> diff = hd.end(); </span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">JSON</span>.stringify(diff, <span class="literal">null</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure><p>执行上面这段代码，得到的输出结果如下所示:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">$ node diff.js </span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"before"</span>: &#123;</span><br><span class="line">    <span class="attr">"nodes"</span>: <span class="number">11719</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="string">"2013-10-07T06:32:07.000Z"</span>,</span><br><span class="line">    <span class="attr">"size_bytes"</span>: <span class="number">1493304</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="string">"1.42 mb"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"after"</span>: &#123;</span><br><span class="line">    <span class="attr">"nodes"</span>: <span class="number">31618</span>,</span><br><span class="line">    <span class="attr">"time"</span>: <span class="string">"2013-10-07T06:32:07.000Z"</span>, </span><br><span class="line">    <span class="attr">"size_bytes"</span>: <span class="number">2684864</span>,</span><br><span class="line">    <span class="attr">"size"</span>: <span class="string">"2.56 mb"</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="attr">"change"</span>: &#123;</span><br><span class="line">    <span class="attr">"size_bytes"</span>: <span class="number">1191560</span>, </span><br><span class="line">    <span class="attr">"size"</span>: <span class="string">"1.14 mb"</span>, </span><br><span class="line">    <span class="attr">"freed_nodes"</span>: <span class="number">129</span>, </span><br><span class="line">    <span class="attr">"allocated_nodes"</span>: <span class="number">20028</span>,</span><br><span class="line">    <span class="attr">"details"</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"what"</span>: <span class="string">"Array"</span>, </span><br><span class="line">        <span class="attr">"size_bytes"</span>: <span class="number">323720</span>, </span><br><span class="line">        <span class="attr">"size"</span>: <span class="string">"316.13 kb"</span>, </span><br><span class="line">        <span class="attr">"+"</span>: <span class="number">15</span>,</span><br><span class="line">        <span class="attr">"-"</span>: <span class="number">65</span></span><br><span class="line">      &#125;, </span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"what"</span>: <span class="string">"Code"</span>, </span><br><span class="line">        <span class="attr">"size_bytes"</span>: <span class="number">-10944</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="string">"-10.69 kb"</span>,</span><br><span class="line">        <span class="attr">"+"</span>: <span class="number">8</span>,</span><br><span class="line">        <span class="attr">"-"</span>: <span class="number">28</span> </span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">"what"</span>: <span class="string">"String"</span>,</span><br><span class="line">        <span class="attr">"size_bytes"</span>: <span class="number">879424</span>,</span><br><span class="line">        <span class="attr">"size"</span>: <span class="string">"858.81 kb"</span>,</span><br><span class="line">        <span class="attr">"+"</span>: <span class="number">20001</span>,</span><br><span class="line">        <span class="attr">"-"</span>: <span class="number">1</span></span><br><span class="line">      &#125; </span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>change节点下的freed_nodes和allocated_nodes，它们记录了 释放的节点数量和分配的节点数量。这里由于有内存泄漏，分配的节点数量远远多余释放的节点 数量。在details下可以看到具体每种类型的分配和释放数量。</p><p>加号和减号分别表示分配和释放的字符串对象数量。</p><h3 id="大内存应用"><a href="#大内存应用" class="headerlink" title="大内存应用"></a>大内存应用</h3><p><strong>Node提供了stream模块用于处理大文件</strong></p><p>stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自 定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node中的大多数模块都有 stream的应用，比如fs的createReadStream()和createWriteStream()方法可以分别用于创建文件 的可读流和可写流，process模块中的stdin和stdout则分别是可读流和可写流的示例。</p><h2 id="第六章-理解Buffer"><a href="#第六章-理解Buffer" class="headerlink" title="第六章 理解Buffer"></a>第六章 理解Buffer</h2><h3 id="Buffer-结构"><a href="#Buffer-结构" class="headerlink" title="Buffer 结构"></a>Buffer 结构</h3><p>Buffer是一个像Array的对象，但它主要用于操作字节。</p><h4 id="模块结构"><a href="#模块结构" class="headerlink" title="模块结构"></a>模块结构</h4><p>Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga370u7oazj30ja09ewf3.jpg" alt="image-20191220145535868"></p><p>Node在进程启动时就已经加载了它，并将其放在全局对象(global) 上。所以在使用Buffer时，无须通过require()即可直接使用</p><h4 id="Buffer-对象"><a href="#Buffer-对象" class="headerlink" title="Buffer 对象"></a>Buffer 对象</h4><p>Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"深入浅出node.js"</span>;</span><br><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(str, <span class="string">'utf-8'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(buf);</span><br><span class="line"><span class="comment">// =&gt; &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt;</span></span><br></pre></td></tr></table></figure><p>不同编码的字符串占用的元素个数各不相同，上面代码中的中文字在 UTF-8编码下占用3个元素，字母和半角标点符号占用1个元素。</p><p>Buffer可以访问length属性得到长度，也可以通过下标访问元素，在构造对象时也与Array相似。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = <span class="keyword">new</span> Buffer(<span class="number">100</span>); </span><br><span class="line"><span class="built_in">console</span>.log(buf.length); <span class="comment">// =&gt; 100</span></span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">10</span>]);<span class="comment">//会得到一个比较奇怪的结果，它的元素值是一个0到255的随机值。</span></span><br></pre></td></tr></table></figure><p>如果给元素赋值不是0到255的整数而是小数时会怎样呢?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">buf[<span class="number">20</span>] = <span class="number">-100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">20</span>]); <span class="comment">// 156 </span></span><br><span class="line">buf[<span class="number">21</span>] = <span class="number">300</span>; </span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">21</span>]); <span class="comment">// 44 </span></span><br><span class="line">buf[<span class="number">22</span>] = <span class="number">3.1415</span>; </span><br><span class="line"><span class="built_in">console</span>.log(buf[<span class="number">22</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到 的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只 保留整数部分。</p><h4 id="Buffer-内存分配"><a href="#Buffer-内存分配" class="headerlink" title="Buffer 内存分配"></a>Buffer 内存分配</h4><p>Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的。因 为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大 量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++ 层面申请内存、在JavaScript中分配内存的策略。</p><p>Node采用了slab分配机制，slab是一种动态内存管理机制。slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态。 </p><ul><li>full:完全分配状态。</li><li>partial:部分分配状态。</li><li>empty:没有被分配状态。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(size);</span><br></pre></td></tr></table></figure><p>Node以8 KB为界限来区分Buffer是大对象还是小对象。8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配。</p><h5 id="1-分配小Buffer对象"><a href="#1-分配小Buffer对象" class="headerlink" title="1. 分配小Buffer对象"></a>1. 分配小Buffer对象</h5><p>如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocPool</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  pool = <span class="keyword">new</span> SlowBuffer(Buffer.poolSize); </span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga3g2jgvmhj30x408ot97.jpg" alt="image-20191220200835681"></p><p><strong>slab处于empty状态。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><p>这次构造将会去检查pool对象，如果pool没有被创建，将会创建一个新的slab单元指向它:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!pool || pool.length - pool.used &lt; <span class="keyword">this</span>.length) allocPool();</span><br></pre></td></tr></table></figure><p>同时当前Buffer对象的parent属性指向该slab，并记录下是从这个slab的哪个位置(offset) 开始使用的，slab对象自身也记录被使用了多少字节</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.parent = pool;</span><br><span class="line"><span class="keyword">this</span>.offset = pool.used;</span><br><span class="line">pool.used += <span class="keyword">this</span>.length;</span><br><span class="line"><span class="keyword">if</span> (pool.used &amp; <span class="number">7</span>) pool.used = (pool.used + <span class="number">8</span>) &amp; ~<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga3g75sbkjj30w80ccmy1.jpg" alt="image-20191220201258838"></p><p><strong>这时候的slab状态为partial。</strong></p><p>当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足 够，使用剩余空间，并更新slab的分配状态。如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费。</p><p>由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对 象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象， 但是如果不释放它，实际可能是8 KB的内存没有释放。</p><h5 id="2-分配大Buffer对象"><a href="#2-分配大Buffer对象" class="headerlink" title="2. 分配大Buffer对象"></a>2. 分配大Buffer对象</h5><p>如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab 单元将会被这个大Buffer对象独占。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Big buffer, just alloc one</span></span><br><span class="line"><span class="keyword">this</span>.parent = <span class="keyword">new</span> SlowBuffer(<span class="keyword">this</span>.length); <span class="keyword">this</span>.offset = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="Buffer-的转换"><a href="#Buffer-的转换" class="headerlink" title="Buffer 的转换"></a>Buffer 的转换</h3><p>Buffer对象可以与字符串之间相互转换。目前支持的字符串编码类型有如下这几种。</p><ul><li>ASCII</li><li>UTF-8</li><li>UTF-16LE/UCS-2</li><li>Base64</li><li>Binary</li><li>Hex</li></ul><h4 id="字符串转Buffer"><a href="#字符串转Buffer" class="headerlink" title="字符串转Buffer"></a>字符串转Buffer</h4><p>字符串转Buffer对象主要是通过构造函数完成的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Buffer(str, [encoding]);</span><br></pre></td></tr></table></figure><p>通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储。</p><p>一个Buffer对象可以存储不同编码类型的字符串转码的值，调用write()方法可以实现该目的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.write(string, [offset], [length], [encoding])</span><br></pre></td></tr></table></figure><p>由于可以不断写入内容到Buffer对象中，并且每次写入可以指定编码，所以Buffer对象中可 以存在多种编码转化后的内容。需要小心的是，每种编码所用的字节长度不同，将Buffer反转回 字符串时需要谨慎处理。</p><h4 id="Buffer-转字符串"><a href="#Buffer-转字符串" class="headerlink" title="Buffer 转字符串"></a>Buffer 转字符串</h4><p>Buffer对象的toString()可以将Buffer对象转换为字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding], [start], [end])</span><br></pre></td></tr></table></figure><p>可以设置encoding(默认为UTF-8)、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。</p><h4 id="Buffer-不支持的编码类型"><a href="#Buffer-不支持的编码类型" class="headerlink" title="Buffer 不支持的编码类型"></a>Buffer 不支持的编码类型</h4><p>Buffer提供了一个isEncoding()函数来判断编码是否支持转换</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.isEncoding(encoding)</span><br></pre></td></tr></table></figure><p>将编码类型作为参数传入上面的函数，如果支持转换返回值为true，否则为false。</p><h3 id="Buffer-的拼接"><a href="#Buffer-的拼接" class="headerlink" title="Buffer 的拼接"></a>Buffer 的拼接</h3><p>Buffer在使用场景中，通常是以一段一段的方式传输。</p><h4 id="乱码是如何产生的"><a href="#乱码是如何产生的" class="headerlink" title="乱码是如何产生的"></a>乱码是如何产生的</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>);</span><br><span class="line"><span class="keyword">var</span> data = <span class="string">''</span>;</span><br><span class="line">rs.on(<span class="string">"data"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>)</span>&#123; </span><br><span class="line">  data += chunk; &#125;);</span><br><span class="line">rs.on(<span class="string">"end"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>data += chunk;</code>这句代码里隐藏了toString()操作，等价于<code>data = data.toString() + chunk.toString();</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123;<span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br></pre></td></tr></table></figure><p>搭配该代码的测试数据为李白的《静夜思》。执行该程序，将会得到以下输出:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">床前明���光，疑���地上霜;举头���明月，���头思故乡。</span><br></pre></td></tr></table></figure><p>产生这个输出结果的原因在于文件可读流在读取时会逐个读取Buffer。这首诗的原始Buffer应存储为:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e5 ba <span class="number">8</span>a e5 <span class="number">89</span> <span class="number">8</span>d e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c <span class="number">88</span> e5 <span class="number">85</span> <span class="number">89</span> ef bc <span class="number">8</span>c e7 <span class="number">96</span> <span class="number">91</span> e6 <span class="number">98</span> af e5 <span class="number">9</span>c b0 e4 b8 <span class="number">8</span>a e9 <span class="number">9</span>c <span class="number">9</span>c ef bc <span class="number">9</span>b e4 b8 be e5 a4 b4 e6 <span class="number">9</span>c <span class="number">9</span>b e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c <span class="number">88</span> ...&gt;</span><br></pre></td></tr></table></figure><p>由于我们限定了Buffer对象的长度为11，因此只读流需要读取7次才能完成完整的读取，结果 是以下几个Buffer对象依次输出:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Buffer e5 ba <span class="number">8</span>a e5 <span class="number">89</span> <span class="number">8</span>d e6 <span class="number">98</span> <span class="number">8</span>e e6 <span class="number">9</span>c&gt; </span><br><span class="line">&lt;Buffer <span class="number">88</span> e5 <span class="number">85</span> <span class="number">89</span> ef bc <span class="number">8</span>c e7 <span class="number">96</span> <span class="number">91</span> e6&gt; </span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>buf.toString()方法默认以UTF-8为编码，中文字在UTF-8下占3个字节。所以第 一个Buffer对象在输出时，只能显示3个字符，Buffer中剩下的2个字节(e6 9c)将会以乱码的形 式显示。第二个Buffer对象的第一个字节也不能形成文字，只能显示乱码。于是形成一些文字无 法正常显示的问题。</p><p>在这个示例中我们构造了11这个限制，但是对于任意长度的Buffer而言，宽字节字符串都有 可能存在被截断的情况，只不过Buffer的长度越大出现的概率越低而已，但该问题依然不可忽视。</p><h4 id="setEncoding-与-string-decoder"><a href="#setEncoding-与-string-decoder" class="headerlink" title="setEncoding()与 string_decoder()"></a>setEncoding()与 string_decoder()</h4><p>可读流还有一个设置编码的方法setEncoding()，该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readable.setEncoding(encoding)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> rs = fs.createReadStream(<span class="string">'test.md'</span>, &#123; <span class="attr">highWaterMark</span>: <span class="number">11</span>&#125;);</span><br><span class="line">rs.setEncoding(<span class="string">'utf8'</span>);</span><br></pre></td></tr></table></figure><p>重新执行程序，得到输出:</p><p><code>床前明月光，疑是地上霜;举头望明月，低头思故乡。</code></p><p><strong>设置编码并未改变按 段读取的基本方式。</strong>在调用setEncoding()时，可读流对象在内部设置了一个decoder对象。每次data事 件都通过该decoder对象进行Buffer到字符串的解码，然后传递给调用者。置编码后，data 不再收到原始的Buffer对象。</p><p>decoder对象来自于string_decoder 模块StringDecoder的实例对象。StringDecoder在得到编码后，知道宽字节字符串在UTF-8编码下是 以3个字节的方式存储的，所以第一次write()时，只输出前9个字节转码形成的字符，“月”字的 前两个字节被保留在StringDecoder实例内部。第二次write()时，会将这2个剩余字节和后续11 个字节组合在一起，再次用3的整数倍字节进行转码。于是乱码问题通过这种中间形式被解决了。</p><p><strong>string_decoder目前只能处理UTF-8、Base64和 UCS-2/UTF-16LE这3种编码。</strong></p><h4 id="正确拼接Buffer"><a href="#正确拼接Buffer" class="headerlink" title="正确拼接Buffer"></a>正确拼接Buffer</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunks = [];</span><br><span class="line"><span class="keyword">var</span> size = <span class="number">0</span>;</span><br><span class="line">res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">  chunks.push(chunk);</span><br><span class="line">  size += chunk.length;</span><br><span class="line">&#125;)</span><br><span class="line">res.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> buf = Buffer.concat(chunks, size); </span><br><span class="line">  <span class="keyword">var</span> str = iconv.decode(buf, <span class="string">'utf8'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度， 然后调用Buffer.concat()方法生成一个合并的Buffer对象。Buffer.concat()方法封装了从小 Buffer对象向大Buffer对象的复制过程，实现十分细腻</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat = <span class="function"><span class="keyword">function</span>(<span class="params">list, length</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(list)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Usage: Buffer.concat(list, [length])'</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (list.length === <span class="number">0</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Buffer(<span class="number">0</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (list.length === <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="keyword">return</span> list[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> length !== <span class="string">'number'</span>) &#123;</span><br><span class="line">    length = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> buf = list[i];</span><br><span class="line">      length += buf.length; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> buffer = <span class="keyword">new</span> Buffer(length);</span><br><span class="line">  <span class="keyword">var</span> pos = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> buf = list[i]; </span><br><span class="line">    buf.copy(buffer, pos); </span><br><span class="line">    pos += buf.length;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> buffer; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Buffer-与性能"><a href="#Buffer-与性能" class="headerlink" title="Buffer 与性能"></a>Buffer 与性能</h3><p>一旦在网络中传输，都需要转换为Buffer，以进行二进制数据传输。</p><p>通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。 在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通 过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变 内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。</p><h4 id="文件读取"><a href="#文件读取" class="headerlink" title="文件读取"></a>文件读取</h4><p>在文件的读取时，有一个highWaterMark设置对性能的影响至关重要。</p><p>在fs.createReadStream(path, opts)时，我们可以传入一些参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  flags: <span class="string">'r'</span>,</span><br><span class="line">  encoding: <span class="literal">null</span>,</span><br><span class="line">  fd: <span class="literal">null</span>,</span><br><span class="line">  mode: <span class="number">0666</span>, </span><br><span class="line">  highWaterMark: <span class="number">64</span> * <span class="number">1024</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以传递start和end来指定读取文件的位置范围</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">start</span>: <span class="number">90</span>, <span class="attr">end</span>: <span class="number">99</span>&#125;</span><br></pre></td></tr></table></figure><p>fs.createReadStream()的工作方式是在内存中准备一段Buffer，然后在fs.read()读取时逐步 从磁盘中将字节复制到Buffer中。完成一次读取时，则从这个Buffer中通过slice()方法取出部分 数据作为一个小Buffer对象，再通过data事件传递给调用方。如果Buffer用完，则重新分配一个; 如果还有剩余，则继续使用。</p><p>分配一个新的Buffer对象的操作:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pool;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">allocNewPool</span>(<span class="params">poolSize</span>) </span>&#123; </span><br><span class="line">  pool = <span class="keyword">new</span> Buffer(poolSize); </span><br><span class="line">  pool.used = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在理想的状况下，每次读取的长度就是用户指定的highWaterMark。但是有可能读到了文件结尾，或者文件本身就没有指定的highWaterMark那么大，这个预先指定的Buffer对象将会有部分 剩余，不过好在这里的内存可以分配给下次读取时使用。pool是常驻内存的，只有当pool单元剩 余数量小于128(kMinPoolSpace)字节时，才会重新分配一个新的Buffer对象。</p><p>highWaterMark的大小对性能有两个影响的点</p><ul><li>highWaterMark设置对Buffer内存的分配和使用有一定影响。</li><li>highWaterMark设置过小，可能导致系统调用次数过多。</li></ul><p>文件流读取基于Buffer分配，Buffer则基于SlowBuffer分配</p><p>由于fs.createReadStream()内部采用fs.read()实现，将会引起对磁盘的系统调用，对于大 文件而言，highWaterMark的大小决定会触发系统调用和data事件的次数。</p><p>读取一个相同的大文件时，highWaterMark值的大小与读取速 度的关系:该值越大，读取速度越快。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Node-js学习笔记（二）&quot;&gt;&lt;a href=&quot;#深入浅出Node-js学习笔记（二）&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Node.js学习笔记（二）&quot;&gt;&lt;/a&gt;深入浅出Node.js学习笔记（二）&lt;/h1&gt;&lt;h2 id=&quot;第
      
    
    </summary>
    
      <category term="Node.js" scheme="http://yoursite.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js学习笔记（一）</title>
    <link href="http://yoursite.com/2019/12/13/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/13/深入浅出Node.js学习笔记（一）/</id>
    <published>2019-12-13T07:04:52.000Z</published>
    <updated>2019-12-29T07:11:37.454Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Node-js学习笔记（一）"><a href="#深入浅出Node-js学习笔记（一）" class="headerlink" title="深入浅出Node.js学习笔记（一）"></a>深入浅出Node.js学习笔记（一）</h1><p>高并发、高性能</p><h2 id="第一章-Node简介"><a href="#第一章-Node简介" class="headerlink" title="第一章 Node简介"></a>第一章 Node简介</h2><ul><li><p>高性能、符合事件驱动、没有历史包袱这3个主要原因，JavaScript成为了Node的实现语言。</p></li><li><p>Node发展为一个强制不共享任何资源的 单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目 标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多 Node，非常容易通过扩展来达成构建大型网络应用的目的。每一个Node进程都构成这个网络应 用中的一个节点，这是它名字所含意义的真谛。</p></li><li><p>它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱 动来服务I/O</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mu9fwye3j30s80g875q.jpg" alt="image-20191206112453524"></p></li></ul><h3 id="Node的特点"><a href="#Node的特点" class="headerlink" title="Node的特点"></a>Node的特点</h3><h4 id="异步I-O"><a href="#异步I-O" class="headerlink" title="异步I/O"></a>异步I/O</h4><ul><li><p>在Node中，绝大多数的操作都以异步的方式进行调用。</p></li><li><p>在Node中，我们可 以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。</p></li></ul><h4 id="事件与回调函数"><a href="#事件与回调函数" class="headerlink" title="事件与回调函数"></a>事件与回调函数</h4><ul><li><p>事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下， 事件与事件之间各自独立，如何协作是一个问题。</p></li><li><p>回调函数无处不在。回调函数是最好的接受异步调用返回数据的方式</p></li></ul><h4 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h4><p>Node保持了JavaScript在浏览器中单线程的特点。</p><ul><li><p>在Node中，JavaScript与其余线程是无 法共享任何状态的。（单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里 没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。）</p></li><li><p>单线程的弱点：</p><ul><li>无法利用多核CPU</li><li>错误会引起整个应用退出，应用的健壮性值得考验</li><li>大量计算占用CPU导致无法继续调用异步I/O</li></ul></li><li><p>在Node中，长时间的CPU占用也会导致后续的异步I/O发不出调用，已完成的异步I/O的 回调函数也会得不到及时执行。解决单线程中大计算量的问题——child_process</p></li><li><p>子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问 题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来 传递结果，这可以很好地保持应用模型的简单和低依赖。通过Master-Worker的管理方式，也可以 很好地管理各个工作进程，以达到更高的健壮性。</p></li></ul><h4 id="跨平台"><a href="#跨平台" class="headerlink" title="跨平台"></a>跨平台</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9mzbqn9c1j30l80fct9g.jpg" alt="image-20191206142014972"></p><p>它在操作系统与Node上层模块 系统之间构建了一层平台层架构，即libuv。（libuv已经成为许多系统实现跨平台的基础组件）</p><h3 id="Node-的应用场景"><a href="#Node-的应用场景" class="headerlink" title="Node 的应用场景"></a>Node 的应用场景</h3><h4 id="I-O-密集型"><a href="#I-O-密集型" class="headerlink" title="I/O 密集型"></a>I/O 密集型</h4><p>Node擅长I/O密集型的应用场景。Node面向网络且擅长并行I/O，能够有效 地组织起更多的硬件资源，从而提供更多好的服务。</p><p>I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请 求服务，资源占用极少。</p><h4 id="CPU密集型"><a href="#CPU密集型" class="headerlink" title="CPU密集型"></a>CPU密集型</h4><p>CPU密集型应用给Node 带来的挑战主要是:由于JavaScript单线程的原因，如果有长时间运行的计算(比如大循环)，将 会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个 小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好 处，又能充分利用CPU。</p><ul><li>Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。</li><li>如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。</li></ul><p><strong>CPU密集不可怕，如何合理调度是诀窍。</strong></p><h4 id="分布式应用"><a href="#分布式应用" class="headerlink" title="分布式应用"></a>分布式应用</h4><p>Node高效利用并行I/O的过程，也是高效使用数 据库的过程</p><h2 id="第二章-模块机制"><a href="#第二章-模块机制" class="headerlink" title="第二章 模块机制"></a>第二章 模块机制</h2><h3 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h3><h4 id="JavaScript缺陷"><a href="#JavaScript缺陷" class="headerlink" title="JavaScript缺陷"></a>JavaScript缺陷</h4><ul><li>没有模块系统</li><li>标准库较少</li><li>没有标准接口</li><li>缺乏包管理系统</li></ul><p>CommonJS规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9nalsobqcj310m0awq4f.jpg" alt="image-20191206205027614"></p><h4 id="CommonJS-的模块规范"><a href="#CommonJS-的模块规范" class="headerlink" title="CommonJS 的模块规范"></a>CommonJS 的模块规范</h4><ul><li>模块引用</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br></pre></td></tr></table></figure><ul><li>模块定义</li></ul><p>上下文提供了 exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。</p><p>在模块中，还存在 一个module对象，它代表模块自身，而exports是module的属性。</p><p>在Node中，一个文件就是一个 模块，将方法挂载在exports对象上作为属性即可定义导出的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line">exports.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="number">0</span>, </span><br><span class="line">      i = <span class="number">0</span>,</span><br><span class="line">args = <span class="built_in">arguments</span>,</span><br><span class="line">l = args.length; </span><br><span class="line">  <span class="keyword">while</span> (i &lt; l) &#123;</span><br><span class="line">sum += args[i++]; </span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> sum; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>模块标识</li></ul><p>模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者 以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。</p><p>它的意义在于将类聚的方法和变量等限定在私有的 作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9qatnbzkaj30mi0byt98.jpg" alt="image-20191209111442609"></p><h3 id="Node-的模块实现"><a href="#Node-的模块实现" class="headerlink" title="Node 的模块实现"></a>Node 的模块实现</h3><p>在Node中引入模块，需要经历如下3个步骤。</p><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><p>在Node中，模块分为两类:一类是Node提供的模块，称为核心模块;另一类是用户编写的模块，称为文件模块。</p><ul><li>核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动 时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编 译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最 快的。</li><li>文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速 度比核心模块慢。</li></ul><h4 id="优先从缓存加载"><a href="#优先从缓存加载" class="headerlink" title="优先从缓存加载"></a>优先从缓存加载</h4><p>Node对引入过的模块都会进行缓存，以减少二次引入时的开销。Node缓存的事编译和执行之后的对象。</p><p>不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的 方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。</p><h4 id="路径分析和文件定位"><a href="#路径分析和文件定位" class="headerlink" title="路径分析和文件定位"></a>路径分析和文件定位</h4><h5 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h5><p>模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。</p><p>模块路径的生成规则：</p><ul><li>当前文件目录下的node_modules目录。</li><li>父目录下的node_modules目录。</li><li>父目录的父目录下的node_modules目录。</li><li>沿路径向上逐级递归，直到根目录下的node_modules目录。</li></ul><h5 id="模块标识符分析"><a href="#模块标识符分析" class="headerlink" title="模块标识符分析"></a>模块标识符分析</h5><p>模块标识符在Node中主要分为以下几类。</p><ul><li>核心模块，如http、fs、path等。</li><li>.或..开始的相对路径文件模块。</li><li>以/开始的绝对路径文件模块。</li><li>非路径形式的文件模块，如自定义的connect模块。</li></ul><ol><li><p>核心模块</p><p>核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码， 其加载过程最快。</p><p>（如果加载一个与核心模块标识符相同的自定义模块，不会成功。如果自己编写了一个http用户模块，想要加载成功，必须选择不同的标识符或换用路径方式）</p></li><li><p>路径形式的文件模块</p><p>在分析文件模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二 次加载时更快。</p><p>（文件模块指明了确切的文件位置，在查找中会节约时间，加载速度慢于核心模块）</p></li><li><p>自定义模块</p><p>它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</p><p>在加载的过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。</p></li></ol><h5 id="文件定位"><a href="#文件定位" class="headerlink" title="文件定位"></a>文件定位</h5><ul><li><p>文件扩展名分析：</p><p>require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，<strong>Node会按.js、.json、.node的次序补 足扩展名，依次尝试。</strong></p><p><strong>在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。</strong>因为Node是单线程的， 所以这里是一个会引起性能问题的地方。</p><p>（如果是.node和.json文件，在传递给require() 的标识符中带上扩展名，会加快一点速度。同步配合缓存，可以大幅度缓解Node 单线程中阻塞式调用的缺陷。）</p></li><li><p>目录分析和包</p><p>在分析标识符的过程中，require()通过分析文件扩展名之后，可能<strong>没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。</strong></p><ul><li>Node在当前目录下 查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。</li><li>而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node。</li><li>如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查 找。</li><li>如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。</li></ul></li></ul><h4 id="模块编译"><a href="#模块编译" class="headerlink" title="模块编译"></a>模块编译</h4><p>在Node中，每个文件模块都是一个对象</p><p>定位到具体的文件后，Node会新建一个模块对 象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法有所不同</p><ul><li>.js文件。通过fs模块同步读取文件后编译执行。</li><li>.node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。</li><li>.json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。</li><li>其余扩展名文件。它们都被当做.js文件载入。</li></ul><p>每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二 次引入的性能。</p><p>在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。</p><h5 id="JavaScript模块的编译"><a href="#JavaScript模块的编译" class="headerlink" title="JavaScript模块的编译"></a>JavaScript模块的编译</h5><p>在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。</p><ul><li><p>在头部添加 了(function (exports, require, module, __filename, __dirname) {\n，在尾部添加了\n});。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">exports, require, module, __filename, __dirname</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> math = <span class="built_in">require</span>(<span class="string">'math'</span>);</span><br><span class="line">  exports.area = <span class="function"><span class="keyword">function</span> (<span class="params">radius</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius; </span><br><span class="line">  &#125;;</span><br><span class="line"> &#125;);</span><br></pre></td></tr></table></figure><p>这样每个模块文件之间都进行了作用域隔离。</p></li><li><p>包装之后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的 function对象。</p></li><li><p>将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。</p></li></ul><p>exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。(<strong>如果要达到require引入一个类的效果，请赋值给module.exports对象。</strong>)</p><h5 id="C-C-模块的编译"><a href="#C-C-模块的编译" class="headerlink" title="C/C++模块的编译"></a>C/C++模块的编译</h5><p>Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows 和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。</p><p>它是编写C/C++模块之后编译生成的，所以这 里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返 回给调用者。</p><ul><li>优势：执行效率</li><li>劣势：编写门槛高</li></ul><h5 id="JSON文件的编译"><a href="#JSON文件的编译" class="headerlink" title="JSON文件的编译"></a>JSON文件的编译</h5><p>Node利用fs模块同步读取JSON文件的内容之 后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用。</p><p>（定义了一个JSON文件作为配置，那就 不必调用fs模块去异步读取和解析，直接调用require()引入即可）</p><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块C/C++文件存放在Node项目的src目录下， JavaScript文件存放在lib目录下。</p><h4 id="JavaScript-核心模块的编译过程"><a href="#JavaScript-核心模块的编译过程" class="headerlink" title="JavaScript 核心模块的编译过程"></a>JavaScript 核心模块的编译过程</h4><h5 id="转存为C-C-代码"><a href="#转存为C-C-代码" class="headerlink" title="转存为C/C++代码"></a>转存为C/C++代码</h5><p>Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码(src/node.js和lib/*.js)转换 成C++里的数组，生成node_natives.h头文件</p><p>JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。</p><p>在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经 历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。</p><h5 id="编译JavaScript核心模块"><a href="#编译JavaScript核心模块" class="headerlink" title="编译JavaScript核心模块"></a>编译JavaScript核心模块</h5><p>lib目录下的所有模块文件也没有定义require、module、exports这些变量。在引入JavaScript 核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块有区别的地方在于:<strong>获取源代码的方式(核心模块是从内存中加载的)以及缓存执行结果的位置。</strong></p><p>源文件通过process.binding(‘natives’)取出， 编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上</p><h4 id="C-C-核心模块的编译过程"><a href="#C-C-核心模块的编译过程" class="headerlink" title="C/C++核心模块的编译过程"></a>C/C++核心模块的编译过程</h4><p>C++模块主内完成核心，JavaScript 主外实现封装的模式是Node能够提高性能的常见方式。</p><p>由纯C/C++编写的部分统一称为<strong>内建模块</strong>，因为它们通常不被用户直接调 用。</p><h5 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h5><p>Node提供了get_builtin_module()方法从node_module_list 数组中取出这些模块</p><h6 id="内建模块的优势在于："><a href="#内建模块的优势在于：" class="headerlink" title="内建模块的优势在于："></a>内建模块的优势在于：</h6><ul><li>它们本身由C/C++编写，性能上优于脚本语言</li><li>在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再 次做标识符定位、文件定位、编译等过程，直接就可执行。</li></ul><p>在Node的所有模块类型中，存在着如图2-4所示的一种依赖层级关系，即文件模块可能会依 赖核心模块，核心模块可能会依赖内建模块。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rvjz8pitj30gc0gsmxx.jpg" alt="image-20191210195732891"></p><h6 id="加载内建模块："><a href="#加载内建模块：" class="headerlink" title="加载内建模块："></a>加载内建模块：</h6><ul><li>在加载内建模块时，先创建一个exports空对象</li><li>然后调用get_builtin_module()方法取 出内建模块对象，通过执行register_func()填充exports对象</li><li>最后将exports对象按模块名缓存，并返回给调用方完成导出。</li></ul><h4 id="核心模块的引入流程"><a href="#核心模块的引入流程" class="headerlink" title="核心模块的引入流程"></a>核心模块的引入流程</h4><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rvzu27c2j30m40qa75t.jpg" alt="image-20191210201250065"></p><h4 id="编写核心模块"><a href="#编写核心模块" class="headerlink" title="编写核心模块"></a>编写核心模块</h4><ul><li>编写头文件</li><li>编写C/C++文件</li></ul><h3 id="C-C-扩展模块"><a href="#C-C-扩展模块" class="headerlink" title="C/C++扩展模块"></a>C/C++扩展模块</h3><p>C/C++扩展模块属于文件模块中的一类。</p><p>为了实现跨平台，dlopen()方法在内部实现时区 分了平台，分别用的是加载.so和.dll的方式。（一个平台下的.node文件在另一个平台下是无法加载执行的，必须重新用各 自平台下的编译器编译为正确的.node文件。）</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rwa1zemkj30p60wi0vf.jpg" alt="image-20191210202239589"></p><p>require()在引入.node文件的过程中：</p><ul><li>调用uv_dlopen()方法去打开动态链接库</li><li>调用uv_dlsym()方法找到动态链接库中通过NODE_MODULE宏定义的方法地址</li></ul><p>这 两个过程都是通过libuv库进行封装的:在*nix平台下实际上调用的是dlfcn.h头文件中定义的 dlopen()和dlsym()两个方法;在Windows平台则是通过LoadLibraryExW()和GetProcAddress()这两 个方法实现的，它们分别加载.so和.dll文件(实际为.node文件)。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9rxappw9mj30pq0lkdhm.jpg" alt="image-20191210205752782"></p><h3 id="模块调用栈"><a href="#模块调用栈" class="headerlink" title="模块调用栈"></a>模块调用栈</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sxcy1mw1j30qm0hy3zw.jpg" alt="image-20191211174120316"></p><ul><li>C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和 第三方JavaScript文件模块调用。</li><li>JavaScript核心模块主要扮演的职责有两类:<ul><li>一类是作为C/C++内建模块的封装层和桥接层， 供文件模块调用;</li><li>一类是纯粹的功能模块</li></ul></li><li>文件模块通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块。</li></ul><h3 id="包与NPM"><a href="#包与NPM" class="headerlink" title="包与NPM"></a>包与NPM</h3><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9sz0nu3v7j30uc0laq4c.jpg" alt="image-20191211184259742"></p><p>由包结构和包描述文件两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。</p><h4 id="包结构"><a href="#包结构" class="headerlink" title="包结构"></a>包结构</h4><p>包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。</p><p>完全符合CommonJS规范的包目录应该包含如下这些文件：</p><ul><li>package.json:包描述文件。</li><li>bin:用于存放可执行二进制文件的目录。 </li><li>lib:用于存放JavaScript代码的目录。</li><li>doc:用于存放文档的目录。</li><li>test:用于存放单元测试用例的代码。</li></ul><h4 id="包描述文件与NPM"><a href="#包描述文件与NPM" class="headerlink" title="包描述文件与NPM"></a>包描述文件与NPM</h4><p>包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于 包的根目录下，是包的重要组成部分。</p><h5 id="必需字段："><a href="#必需字段：" class="headerlink" title="必需字段："></a>必需字段：</h5><ul><li>name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。</li><li>description。包简介。</li><li>version。版本号。一个语义化的版本号，该版本号十分重要，常常用于一些版本控制的场合。</li><li>keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。</li><li>maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。NPM通过该属性进行权限认证。</li><li>contributors。贡献者列表。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。</li><li>bugs。一个可以反馈bug的网页地址或邮件地址。</li><li>licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。</li><li>repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。</li><li>dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。</li></ul><h5 id="可选字段："><a href="#可选字段：" class="headerlink" title="可选字段："></a>可选字段：</h5><ul><li>homepage。当前包的网站地址。</li><li>os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。</li><li>cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。</li><li>engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。</li><li>builtin。标志当前包是否是内建在底层系统的标准组件。 </li><li>directories。包目录说明。</li><li>implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。</li><li>scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。</li></ul><p><strong>在包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、 repositories、author、bin、main、scripts、engines、dependencies、devDependencies。</strong></p><ul><li>author。包作者。 </li><li>bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。</li><li>main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余 模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。</li><li>devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包。</li></ul><h3 id="前后端共用模块"><a href="#前后端共用模块" class="headerlink" title="前后端共用模块"></a>前后端共用模块</h3><h4 id="AMD-规范"><a href="#AMD-规范" class="headerlink" title="AMD 规范"></a>AMD 规范</h4><p>AMD规范是CommonJS模块规范的一个延伸</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure><p>它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> exports = &#123;&#125;; </span><br><span class="line">  exports.sayHello = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">'Hello from module: '</span> + <span class="built_in">module</span>.id); &#125;;</span><br><span class="line">  <span class="keyword">return</span> exports; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>不同之处在于AMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的， 它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局 命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现 导出。</p><h4 id="CMD-规范"><a href="#CMD-规范" class="headerlink" title="CMD 规范"></a>CMD 规范</h4><p>与AMD规范的主要区别在于定义模块和依赖引入的部分。</p><p>AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中。</p><p>在依赖部分，CMD支持动态引入。</p><h2 id="第三章-异步I-O"><a href="#第三章-异步I-O" class="headerlink" title="第三章 异步I/O"></a>第三章 异步I/O</h2><h3 id="为什么要异步I-O"><a href="#为什么要异步I-O" class="headerlink" title="为什么要异步I/O"></a>为什么要异步I/O</h3><h4 id="用户体验"><a href="#用户体验" class="headerlink" title="用户体验"></a>用户体验</h4><ul><li><p>前端通过异步可以消除掉UI阻塞的现象。但是前端获取资源的速度也取决于后端的响应速度。采用异步方式，第一个资源的获取并不会阻塞第二个资源。</p></li><li><p>随着网站或应用不断膨胀，数据将会分布到多台服务器上，分布式将会是常态。分布也意味着M与N的值（M/N分别为两个请求消耗的时间）会线性增长，这也会放大异步和同步在性能方面的差异。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9ty7mwa38j317s0ce400.jpg" alt="image-20191212150038480"></p></li></ul><p>只有后端能够快速响应资源，才能让前端的体验变好。</p><h4 id="资源分配"><a href="#资源分配" class="headerlink" title="资源分配"></a>资源分配</h4><p>利用单线程，远离多线程死锁、状态同步等问题;利用异 步I/O，让单线程远离阻塞，以更好地使用CPU。</p><p>Node提供了类似前端浏览器中Web Workers的子 进程，该子进程可以通过工作进程高效地利用CPU和I/O</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2861hzfj30lu0lit9x.jpg" alt="image-20191212171933363"></p><h3 id="异步I-O实现现状"><a href="#异步I-O实现现状" class="headerlink" title="异步I/O实现现状"></a>异步I/O实现现状</h3><h4 id="异步I-O与非阻塞I-O"><a href="#异步I-O与非阻塞I-O" class="headerlink" title="异步I/O与非阻塞I/O"></a>异步I/O与非阻塞I/O</h4><p>异步/同步和阻塞/非阻塞实际上是两回事</p><p>操作系统内核对于I/O只有两种方式:阻塞与非阻塞。</p><h5 id="阻塞："><a href="#阻塞：" class="headerlink" title="阻塞："></a>阻塞：</h5><p>在调用阻塞I/O时，应用程序需要等待 I/O完成才返回结果</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2e5a4fnj30j80k6t9l.jpg" alt="image-20191212172518477"></p><ul><li><p>特点：调用之后一定要等到系统内核层面完成所有操作后，调用才结束。</p></li><li><p>阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用</p></li></ul><h5 id="非阻塞："><a href="#非阻塞：" class="headerlink" title="非阻塞："></a>非阻塞：</h5><p>非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2g0l7cmj30jm0kkq3q.jpg" alt="image-20191212172706537"></p><ul><li><p>非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的。</p></li><li><p>问题：由于完整的I/O并没有完成，立即返回的并不是业务层期望的 数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认 是否完成。这种重复调用判断操作是否完成的技术叫做轮询。</p></li><li><p>轮询技术：</p><ul><li><p>read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2jpnno5j30ku0l8gmy.jpg" alt="image-20191212173038848"></p></li><li><p>select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2klirw7j30k20l6wfu.jpg" alt="image-20191212173129915"></p><p>select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态， 所以它最多可以同时检查1024个文件描述符。</p></li><li><p>poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2ly78zij30j40km75l.jpg" alt="image-20191212173248351"></p></li><li><p>epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到 I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调 的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2na09ynj30jw0leta2.jpg" alt="image-20191212173403901"></p></li><li><p>kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。</p></li></ul></li></ul><h4 id="现实的异步I-O"><a href="#现实的异步I-O" class="headerlink" title="现实的异步I/O"></a>现实的异步I/O</h4><p>通过让部分线程进行阻塞I/O或者非阻塞I/O加 轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进 行传递，这就轻松实现了异步I/O</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2rft4wij30pq0iwgmo.jpg" alt="image-20191212173804605"></p><ul><li>ibeio 实质上依然是采用线程池与阻塞I/O模拟异步I/O</li><li>IOCP：调用异步方法，等待I/O完成之后的通知，执行回调，用户无须考虑轮询。但是它的 内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u339w1rrj30g80ekq3m.jpg" alt="image-20191212174138825"></p><p>Node是单线程的，这里的单线程仅仅只是 JavaScript执行在单线程中罢了。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的 另有线程池。</p><h3 id="Node-的异步-I-O"><a href="#Node-的异步-I-O" class="headerlink" title="Node 的异步 I/O"></a>Node 的异步 I/O</h3><p>事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。</p><p>Windows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事 件循环，以此完成异步I/O的过程。在Linux下通过epoll实现这个过程，FreeBSD下通过kqueue实 现，Solaris下通过Event ports实现。不同的是线程池在Windows下由内核(IOCP)直接提供，*nix 系列下由libuv自行实现。</p><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p><strong>Node自身的执行模型——事件循环</strong></p><p>每执行一次循环体的过程我 们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调 函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u2zihuruj30km0o6dhb.jpg" alt="image-20191212174548717"></p><h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问 是否有要处理的事件。</p><ul><li>观察者将事件进行分类。在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的 观察者有文件I/O观察者、网络I/O观察者等。</li><li>在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。</li></ul><h4 id="请求对象"><a href="#请求对象" class="headerlink" title="请求对象"></a>请求对象</h4><p>从JavaScript发起调用到内核执行完I/O操作的 过渡过程中，存在一种中间产物，它叫做请求对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.open = <span class="function"><span class="keyword">function</span>(<span class="params">path, flags, mode, callback</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  binding.open(pathModule._makeLong(path), stringToFlags(flags),mode,callback); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u38jib15j30ss0q40uj.jpg" alt="image-20191212175431157"></p><ul><li><p>从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用</p></li><li><p>这里libuv作为封装层，有两个平台的实现，实质上是调 用了uv_fs_open()方法。在uv_fs_open()的调用过程中，我们创建了一个FSReqWrap请求对象</p></li><li><p>回调函数则 被设置在这个对象的oncomplete_sym属性上</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req_wrap-&gt;object_-&gt;<span class="built_in">Set</span>(oncomplete_sym, callback);</span><br></pre></td></tr></table></figure></li><li><p>对象包装完毕后，在Windows下，则调用QueueUserWorkItem()方法将这个FSReqWrap对象推入线程池中等待执行</p><ul><li>QueueUserWorkItem()方法接受3个参数:第一个参数是将要执行的方法的引用，这里引用的是uv_fs_thread_proc，第二个参数是uv_fs_thread_proc方法运行时所需要的参数;第三个参数是 执行的标志。</li></ul></li><li><p>当线程池中有可用线程时，我们会调用uv_fs_thread_proc()方法。uv_fs_thread_ proc()方法会根据传入参数的类型调用相应的底层函数</p></li><li><p>至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。</p></li></ul><p>JavaScript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它 是否阻塞I/O，都不会影响到JavaScript线程的后续执行，如此就达到了异步的目的。</p><p><strong>请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中</strong>，包括送入线程池等待执行以及I/O操作完毕后的回调处理</p><h4 id="执行回调"><a href="#执行回调" class="headerlink" title="执行回调"></a>执行回调</h4><ul><li>线程池中的I/O操作调用完毕之后，会将获取的结果储存在req-&gt;result属性上，然后调用 PostQueuedCompletionStatus()通知IOCP，告知当前对象操作已经完成</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PostQueuedCompletionStatus((loop)-&gt;iocp, <span class="number">0</span>, <span class="number">0</span>, &amp;((req)-&gt;overlapped))</span><br></pre></td></tr></table></figure><ul><li><p>PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还线程池。通过PostQueuedCompletionStatus()方法提交的状态，可以通过GetQueuedCompletionStatus()提取。</p></li><li><p>在每次Tick的执行中，它会调用 IOCP相关的GetQueuedCompletionStatus()方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。</p></li><li><p>I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u5u87afbj30uu0u0q6o.jpg" alt="image-20191212192431768"></p></li></ul><h3 id="非I-O的异步API"><a href="#非I-O的异步API" class="headerlink" title="非I/O的异步API"></a>非I/O的异步API</h3><p>I/O无关的异步API:setTimeout()、setInterval()、 setImmediate()和process.nextTick()</p><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4><p>setTimeout()和setInterval()</p><p>它们的实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。</p><p>调用setTimeout()或者 setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会 从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的 回调函数将立即执行。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u6f2b0goj30u60nu76w.jpg" alt="image-20191212194435097"></p><h4 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// on the way out, don't bother.</span></span><br><span class="line">  <span class="comment">// it won't get fired anyway</span></span><br><span class="line">  <span class="keyword">if</span> (process._exiting) <span class="keyword">return</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tickDepth &gt;= process.maxTickDepth) </span><br><span class="line">    maxTickWarn();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> tock = &#123; <span class="attr">callback</span>: callback &#125;;</span><br><span class="line">  <span class="keyword">if</span> (process.domain) tock.domain = process.domain;</span><br><span class="line">  nextTickQueue.push(tock);</span><br><span class="line">  <span class="keyword">if</span> (nextTickQueue.length) &#123;</span><br><span class="line">    process._needTickCallback(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。 定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。</p><h4 id="setImmediate"><a href="#setImmediate" class="headerlink" title="setImmediate()"></a>setImmediate()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'nextTick延迟执行'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">setImmediate(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setImmediate延迟执行'</span>); </span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'正常执行'</span>);</span><br></pre></td></tr></table></figure><p>其执行结果如下:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">正常执行 </span><br><span class="line">nextTick延迟执行 </span><br><span class="line">setImmediate延迟执行</span><br></pre></td></tr></table></figure><ul><li><p>process.nextTick()中的回调函数执行的优先级要高于setImmediate()。</p></li><li><p>原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者， setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。</p></li><li><p>process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果 则是保存在链表中</p></li><li><p>在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。</p></li><li><p>之所以这样设计，是为了保证每轮循环能够较快地执行结束，防止CPU占用过多而阻塞后续I/O 调用的情况。</p></li></ul><h3 id="事件驱动与高性能服务器"><a href="#事件驱动与高性能服务器" class="headerlink" title="事件驱动与高性能服务器"></a>事件驱动与高性能服务器</h3><p>事件驱动的实质：</p><p>通过主循环加事件触发的方式来运行程序。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1g9u77vrg44j30vo0nm77g.jpg" alt="image-20191212201217702"></p><h4 id="几种经典的服务器模型，对比优缺点"><a href="#几种经典的服务器模型，对比优缺点" class="headerlink" title="几种经典的服务器模型，对比优缺点"></a>几种经典的服务器模型，对比优缺点</h4><ul><li>同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。 </li><li>每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。</li><li>每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。</li></ul><h4 id="高性能："><a href="#高性能：" class="headerlink" title="高性能："></a>高性能：</h4><p>Node通过事件驱动的方式处理请求，无须为 每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任 务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的一个原因。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Node-js学习笔记（一）&quot;&gt;&lt;a href=&quot;#深入浅出Node-js学习笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Node.js学习笔记（一）&quot;&gt;&lt;/a&gt;深入浅出Node.js学习笔记（一）&lt;/h1&gt;&lt;p&gt;高并发、高性
      
    
    </summary>
    
      <category term="Node.js" scheme="http://yoursite.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>scrollWidth,clientWidth,offsetWidth的区别</title>
    <link href="http://yoursite.com/2019/12/07/scrollWidth,clientWidth,offsetWidth%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/12/07/scrollWidth,clientWidth,offsetWidth的区别/</id>
    <published>2019-12-07T14:01:34.000Z</published>
    <updated>2019-12-29T07:11:43.885Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scrollWidth-clientWidth-offsetWidth的区别"><a href="#scrollWidth-clientWidth-offsetWidth的区别" class="headerlink" title="scrollWidth,clientWidth,offsetWidth的区别"></a>scrollWidth,clientWidth,offsetWidth的区别</h1><h2 id="总体说明"><a href="#总体说明" class="headerlink" title="总体说明"></a>总体说明</h2><h3 id="元素对象："><a href="#元素对象：" class="headerlink" title="元素对象："></a>元素对象：</h3><ul><li>offsetLeft、offsetTop属性：获取元素相对于文档左上角的坐标位置。</li></ul><ul><li><p>scrollWidth：对象的<strong>实际内容</strong>的宽度，不包括边线宽度，会随对象中内容超过可视区后而变大。</p><p>scrollWidth=元素的width+padding</p></li><li><p>clientWidth：对象内容的<strong>可视区的宽度</strong>，不包括滚动条等边线，会随对象显示大小的变化而改变。</p><p>clientWidth=元素的width+padding</p></li><li><p>offsetWidth：对象<strong>整体的实际宽度</strong>，包括滚动条等边线，会随对象显示大小的变化而改变。</p><p>offsetWidth=元素的width+padding+border</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aq0kktmyj30gx0gqtam.jpg" alt="img"></p><p>###window对象：</p><ul><li><p>innerWidth：窗口中文档显示区域的宽度，不包括菜单栏、工具栏等部分。该属性可读可写。浏览器窗口的内部宽度（对于IE9+、Chrome、Firefox、Opera 以及 Safari）</p></li><li><p>pageXOffset：整数只读属性，表示文档向右滚动过的像素数。IE不支持该属性，使用body元素的scrollLeft属性替代。</p></li><li></li></ul><p>##情况一</p><p>元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下。</p><ul><li>scrollWidth=clientWidth，两者皆为内容可视区的宽度。</li><li>offsetWidth为元素的实际宽度。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aoj7ezc9j30eo07hjs6.jpg" alt="img"></p><p>##情况二</p><p>元素的内容超过可视区，滚动条出现和可用的情况下。</p><ul><li>scrollWidth&gt;clientWidth。</li><li>scrollWidth为实际内容的宽度。</li><li>clientWidth是内容可视区的宽度。</li><li>offsetWidth是元素的实际宽度。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7aokjodirj30h40a1q41.jpg" alt="img"></p><h2 id="针对文档-document-的各个height、width、top、left的说明"><a href="#针对文档-document-的各个height、width、top、left的说明" class="headerlink" title="针对文档(document)的各个height、width、top、left的说明"></a>针对文档(document)的各个height、width、top、left的说明</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7apu7784cj30dw0fa0tw.jpg" alt="img"></p><h2 id="针对网页中一个div的各个属性值的说明"><a href="#针对网页中一个div的各个属性值的说明" class="headerlink" title="针对网页中一个div的各个属性值的说明"></a>针对网页中一个div的各个属性值的说明</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7apvi51ygj30jg0ga400.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;scrollWidth-clientWidth-offsetWidth的区别&quot;&gt;&lt;a href=&quot;#scrollWidth-clientWidth-offsetWidth的区别&quot; class=&quot;headerlink&quot; title=&quot;scrollWidth,clie
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>循环中的异步操作问题小结</title>
    <link href="http://yoursite.com/2019/11/26/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%20copy/"/>
    <id>http://yoursite.com/2019/11/26/JS事件机制 copy/</id>
    <published>2019-11-26T05:29:24.000Z</published>
    <updated>2019-11-26T05:36:52.906Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环中的异步操作问题小结"><a href="#循环中的异步操作问题小结" class="headerlink" title="循环中的异步操作问题小结"></a>循环中的异步操作问题小结</h1><p>循环的异步操作主要有两个问题：</p><ul><li>如何确保循环的所有异步操作完成之后执行某个其他操作</li><li>循环中的下一步操作依赖于前一步的操作，如何解决</li></ul><h2 id="不需等待结果"><a href="#不需等待结果" class="headerlink" title="不需等待结果"></a>不需等待结果</h2><p>要处理这个问题，我们可以把这个匿名函数定义为异步的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> (item)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> delayedLog(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的话 forEach 方法就相当于异步的了，不会等待遍历完所有的 item 将会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Done!</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>如果你不需要等待这个循环完成，这样就已经可以了。但是大部分情况我们还是需要等待这个循环完成才进行之后的操作。</p><h2 id="如何确保循环的所有异步操作完成之后执行某个其他操作"><a href="#如何确保循环的所有异步操作完成之后执行某个其他操作" class="headerlink" title="如何确保循环的所有异步操作完成之后执行某个其他操作"></a>如何确保循环的所有异步操作完成之后执行某个其他操作</h2><h3 id="方法一：设置一个flag，在每个异步操作中对flag进行检测"><a href="#方法一：设置一个flag，在每个异步操作中对flag进行检测" class="headerlink" title="方法一：设置一个flag，在每个异步操作中对flag进行检测"></a>方法一：设置一个flag，在每个异步操作中对flag进行检测</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  flag++;</span><br><span class="line">  Database.save_method().exec().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(flag === len) &#123;</span><br><span class="line">            <span class="comment">// your code</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：将所有的循环放在一个promise中，使用then处理"><a href="#方法二：将所有的循环放在一个promise中，使用then处理" class="headerlink" title="方法二：将所有的循环放在一个promise中，使用then处理"></a>方法二：将所有的循环放在一个promise中，使用then处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">      resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           Database.save_method().exec()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法三：串行遍历"><a href="#方法三：串行遍历" class="headerlink" title="方法三：串行遍历"></a>方法三：串行遍历</h3><p>要等待所有的结果返回，我们还是要回到老式的 for 循环写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> array)&#123;</span><br><span class="line">    <span class="keyword">await</span> delayedLog(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果符合我们的预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure><h3 id="方法四：并行遍历"><a href="#方法四：并行遍历" class="headerlink" title="方法四：并行遍历"></a>方法四：并行遍历</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c606vfgvj30tg081mxe.jpg" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//map array to promise</span></span><br><span class="line">  <span class="keyword">const</span> promises=array.map(delayedLog)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（注意：对于特别大的数组不建议使用这种写法，太多的并行任务会加重 CPU 和内存的负荷）</p><h2 id="循环中的下一步操作依赖于前一步的操作，如何解决"><a href="#循环中的下一步操作依赖于前一步的操作，如何解决" class="headerlink" title="循环中的下一步操作依赖于前一步的操作，如何解决"></a>循环中的下一步操作依赖于前一步的操作，如何解决</h2><h3 id="方法一：使用递归，在异步操作完成之后调用下一次异步操作"><a href="#方法一：使用递归，在异步操作完成之后调用下一次异步操作" class="headerlink" title="方法一：使用递归，在异步操作完成之后调用下一次异步操作"></a>方法一：使用递归，在异步操作完成之后调用下一次异步操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  Database.save_method().exec().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      loop(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：使用async和await（串行遍历）"><a href="#方法二：使用async和await（串行遍历）" class="headerlink" title="方法二：使用async和await（串行遍历）"></a>方法二：使用async和await（串行遍历）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">         <span class="keyword">await</span> Database.save_method().exec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何优雅地写js异步循环"><a href="#如何优雅地写js异步循环" class="headerlink" title="如何优雅地写js异步循环"></a>如何优雅地写js异步循环</h1><h2 id="循环的方式"><a href="#循环的方式" class="headerlink" title="循环的方式"></a>循环的方式</h2><p>假设我们有个数组，包含 5 个数字：<code>let times = [100, 150, 200, 250, 300]</code>；<br>还有一个异步的睡觉方法：<code>sleep(time, cb)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有 cb 时，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time, cb</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        setTimeout(cb, time);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, time);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在要去循环睡这几个数字，问你有哪些睡法？🤔</p><p>为了方便交流，我就给这几个睡法起个名字：</p><ol><li>All in：你如果赶时间又不担心消耗过度，你可以一次性都睡了；</li><li>One by one：你想细水长流，你可以一个一个睡；</li><li>With concurrency：你害羞地低下头，说一次能不能睡两个。</li></ol><blockquote><p>作为一段有节操的代码，肯定要告诉其他人你睡完了，也就是必须有全部完成的回调，否则我们接下来的交流会毫无意义。</p></blockquote><p>本文目的是和大家探讨如何写出优雅的异步循环代码，并不是去实现这些循环控制的逻辑；而保持代码优雅，个人以为最好的办法是使用较新的语言特性，其次是使用优秀的开源项目，最后才是自己撸。下面会使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcaolan%2Fasync" target="_blank" rel="noopener">Async</a>、<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fpetkaantonov%2Fbluebird" target="_blank" rel="noopener">Promise(bluebird)</a> 和 ES7 中的 <code>async/await</code> 对比下实现这几种循环的区别。</p><h3 id="All-in"><a href="#All-in" class="headerlink" title="All in"></a>All in</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c606vfgvj30tg081mxe.jpg" alt="All in"></p><p>这种方式效率是最高的，耗时取决于循环中最慢的那个异步方法。对资源的消耗也是最大的，如果大量循环请求后端服务，很有可能造成瞬时拥堵的情况。</p><p>如果自己实现，这也是最简单的场景，加一个完成计数器，每个异步方法完就给这个完成计数器加 1，然后检查完成数是不是等于数组长度，一旦相等就表示所有的异步方法执行完毕，通知全部完成的回调。</p><h4 id="使用-async-each："><a href="#使用-async-each：" class="headerlink" title="使用 async.each："></a>使用 async.each：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; each &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async all in'</span>);  </span><br><span class="line">each(times, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async all in: 304.627ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-all："><a href="#使用-Promise-all：" class="headerlink" title="使用 Promise.all："></a>使用 Promise.all：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise all in'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.all(times.map(<span class="function"><span class="params">time</span> =&gt;</span> sleep(time))).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise all in: 305.509ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await："><a href="#使用ES7-async-await：" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 all in'</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> times.map(<span class="function"><span class="params">time</span> =&gt;</span> sleep(time))) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 all in: 305.986ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h3 id="One-by-one"><a href="#One-by-one" class="headerlink" title="One by one"></a>One by one</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c65nlncwj30tg04374g.jpg" alt="One by one"></p><p>这种方式效率最低，有点类似于同步语言中的循环，一个接着一个执行，耗时自然也就是所有异步方法耗时的总和。对资源的消耗最小。</p><p>这个实现起来也比较简单，把数组看做一个队列，每次从队列<code>shift</code>出一个代入异步方法执行，执行完成就开始递归调用这个过程，当队列长度为空就表示所有的异步方法执行完毕，结束递归，通知全部完成的回调。</p><h4 id="使用-async-eachSeries："><a href="#使用-async-eachSeries：" class="headerlink" title="使用 async.eachSeries："></a>使用 async.eachSeries：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eachSeries &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async one by one'</span>);  </span><br><span class="line">eachSeries(times, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async one by one: 1020.078ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-reduce："><a href="#使用-Promise-reduce：" class="headerlink" title="使用 Promise.reduce："></a>使用 Promise.reduce：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise one by one'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.reduce(times, (last, curr) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">return</span> sleep(curr);</span><br><span class="line">&#125;, <span class="number">0</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise one by one: 1023.014ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await：-1"><a href="#使用ES7-async-await：-1" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 one by one'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> time <span class="keyword">of</span> times) &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 one by one: 1025.513ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h3 id="With-concurrency"><a href="#With-concurrency" class="headerlink" title="With concurrency"></a>With concurrency</h3><p>这种方式稍微复杂些，但也是最灵活的方式，可以随心控制并发数。效率和耗时取决于魔法数字 <code>concurrency</code>，当 <code>concurrency</code> 大于或等于数组长度时，它就等同于 <strong>All in</strong> 方式；当 <code>concurrency</code> 为 1 时，它就等同于 <strong>One by one</strong> 方式。所以耗时和对资源的消耗都会介于以上两种方式之间。</p><p><strong>With concurrency</strong> 本身在实现上也会有不同的方式，分别是预分组和任务池。</p><h4 id="预分组"><a href="#预分组" class="headerlink" title="预分组"></a>预分组</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c66v9wx3j30tg05074j.jpg" alt="Pre Group"></p><p>顾名思义，就是提前将数组内容按 <code>concurrency</code> 分好组，组内是以 <strong>All in</strong> 方式执行，组之间则是以 <strong>One by one</strong> 的方式执行。</p><p>就以上文的例子，假如 <code>concurrency</code> 为 2，<code>times</code> 预先分组成：<code>[[100, 150], [200, 250], [300]]</code>，这样耗时会是 700（150 + 250 + 300）。</p><p>这个实现方式可以有效地控制并发数，优点就是简单，缺点是并不能达到效率最大化。</p><h4 id="任务池"><a href="#任务池" class="headerlink" title="任务池"></a>任务池</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c67an02oj30tg066q38.jpg" alt="Task Pool"></p><p>任务池的方式就是设置一个容量为 <code>concurrency</code> 的池子，比如容量为 2，初始化放入两个任务，每当有任务完成，就继续往池子添加新的任务，直到所有任务都完成。上文的例子执行过程大致如下：</p><ol><li><code>time = 0; pool = [100, 150]</code>：放入 <code>100</code> 和 <code>150</code></li><li><code>time = 100; pool = [150, 200]</code>：<code>100</code> 结束，放入 <code>200</code></li><li><code>time = 150; pool = [200, 250]</code>：<code>150</code> 结束，放入 <code>250</code></li><li><code>time = 300; pool = [250, 300]</code>：<code>200</code> 结束，放入 <code>300</code></li><li><code>time = 400; pool = [300]</code>：<code>250</code> 结束，没有更多任务</li><li><code>time = 600; pool = []</code>：<code>300</code> 结束，循环完毕</li></ol><p>得出来的耗时是 600，比预分组的方式效率更高，而且同样能有效控制并发个数。async 和 bluebird 也有相关的方法供直接使用。</p><h4 id="使用-async-eachLimit："><a href="#使用-async-eachLimit：" class="headerlink" title="使用 async.eachLimit："></a>使用 async.eachLimit：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eachLimit &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async with concurrency'</span>);  </span><br><span class="line">eachLimit(times, <span class="number">2</span>, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async with concurrency'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async with concurrency: 611.498ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-map（bluebird-特有-api）："><a href="#使用-Promise-map（bluebird-特有-api）：" class="headerlink" title="使用 Promise.map（bluebird 特有 api）："></a>使用 Promise.map（bluebird 特有 api）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise one by one'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.map(times, (time) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">return</span> sleep(time);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    concurrency: <span class="number">2</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise with concurrency: 616.601ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await：-2"><a href="#使用ES7-async-await：-2" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><blockquote><p><code>pool</code> 方法来自<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdavetemplin%2Fasync-parallel%2Fblob%2Fmaster%2Findex.ts%23L153" target="_blank" rel="noopener">davetemplin/async-parallel</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 with concurrency'</span>);</span><br><span class="line">    <span class="keyword">await</span> pool(<span class="number">2</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(times.shift());</span><br><span class="line">        <span class="keyword">return</span> times.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 with concurrency'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pool</span>(<span class="params">size, task</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> active = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> errors = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (active &lt; size &amp;&amp; !done) &#123;</span><br><span class="line">                active += <span class="number">1</span>;</span><br><span class="line">                task()</span><br><span class="line">                    .then(<span class="function"><span class="params">more</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (--active === <span class="number">0</span> &amp;&amp; (done || !more))</span><br><span class="line">                            errors.length === <span class="number">0</span> ? resolve() : reject(errors);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (more)</span><br><span class="line">                            next();</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            done = <span class="literal">true</span>;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        errors.push(err);</span><br><span class="line">                        done = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (--active === <span class="number">0</span>)</span><br><span class="line">                            reject(errors);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 with concurrency: 612.197ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这应该可以给这三种循环方式打下分了：</p><table><thead><tr><th><strong>循环方式</strong></th><th>效率</th><th>消耗</th><th>灵活度</th><th>复杂度</th></tr></thead><tbody><tr><td><strong>All in</strong></td><td>高</td><td>高</td><td>低</td><td>低</td></tr><tr><td><strong>One by one</strong></td><td>低</td><td>低</td><td>低</td><td>低</td></tr><tr><td><strong>With concurrency</strong></td><td>中</td><td>中</td><td>高</td><td>高</td></tr></tbody></table><p>乍一看 <strong>With concurrency</strong> 是完胜，其实并没有。<strong>All in</strong> 和 <strong>One by one</strong> 虽然灵活度低，但是应用的场景还是非常广泛的。要求效率优先就使用 <strong>All in</strong>；如果有下一次循环依赖上一次循环结果的场景，就必须使用 <strong>One by One</strong>。</p><p>再说下上面 async、bluebird、ES7 对这三种循环方式的实现。需求一直在变，async 需要修改的代码非常少，甚至只要改下方法名就可以，方法定义简单优雅，这可能也是 async 易上手的原因；bluebird 在 <code>Promise</code> 标准基础上添加的方法非常实用，如：map、join…，以至于我几乎是没有使用过原生 <code>Promise</code> 😂；ES7 新增的 <code>async/await</code> 语法特性确实减轻了编写异步代码的痛苦，同时还增强了代码的可读性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;循环中的异步操作问题小结&quot;&gt;&lt;a href=&quot;#循环中的异步操作问题小结&quot; class=&quot;headerlink&quot; title=&quot;循环中的异步操作问题小结&quot;&gt;&lt;/a&gt;循环中的异步操作问题小结&lt;/h1&gt;&lt;p&gt;循环的异步操作主要有两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>伪类和伪元素</title>
    <link href="http://yoursite.com/2019/11/16/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/11/16/伪类和伪元素/</id>
    <published>2019-11-16T11:40:32.000Z</published>
    <updated>2019-11-16T11:49:57.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p><code>css</code>引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分。</p><ul><li>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过<code>:hover</code>来描述这个元素的状态。虽然它和普通的<code>css</code>类相似，可以为已有的元素添加样式，但是它只有处于<code>dom</code>树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</li><li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过<code>:before</code>来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</li></ul><p>伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p><p>伪类和伪元素的根本区别在于：它们是否创造了<strong>新</strong>的元素,,   这个新创造的元素就叫  “伪无素” 。</p><p>##伪类</p><p>伪类前面是一个冒号，<code>E:first-child</code>会对现有的元素进行筛选</p><ul><li><p><code>:link</code>:选择未访问的链接</p></li><li><p><code>:visited</code>:选择已访问的链接</p></li><li><p><code>:hover</code>:选择鼠标指针浮动在其上的元素</p></li><li><p><code>:active</code>:选择活动的链接</p></li><li><p><code>:focus</code>:选择获取焦点的输入字段</p></li><li><p><code>:not()</code>:一个否定伪类，用于匹配不符合参数选择器的元素。</p></li><li><p><code>:first-child</code>:匹配元素的第一个子元素。</p></li><li><p><code>:last-child</code>:匹配元素的最后一个子元素。</p></li><li><p><code>:first-of-type</code>:匹配属于其父元素的首个特定类型的子元素的每个元素。</p></li><li><p><code>:last-of-type</code>:匹配属于其父元素的最后一个特定类型的子元素的每个元素。</p></li><li><p><code>:nth-child</code>:<code>:nth-child</code>根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素</p></li><li><p><code>:nth-last-child</code>:<code>:nth-last-child</code> 与<code>:nth-child</code>相似，不同之处在于它是从最后一个子元素开始计数的。</p></li><li><p><code>:nth-of-type</code>:<code>:nth-of-type</code> 与 <code>nth-child</code>相似，不同之处在于它是只匹配特定类型的元素。</p></li><li><p><code>:nth-last-type</code>:<code>:nth-last-of-type</code> 与 <code>nth-of-type</code>相似，不同之处在于它是从最后一个子元素开始计数的。</p></li><li><p><code>:only-child</code> :当元素是其父元素中唯一一个特定类型的子元素时，<code>:only-child</code>匹配该元素。</p></li><li><p><code>:target</code> :当URL带有锚名称，指向文档内某个具体的元素时，<code>:target</code>匹配该元素。</p></li><li><p><code>:checked</code>:<code>:checked</code>匹配被选中的 input 元素，这个 input 元素包括 radio 和 checkbox。</p></li><li><p><code>:default</code>: 匹配默认选中的元素</p></li><li><p><code>:disabled</code>: 匹配禁用的表单元素。</p></li><li><p><code>:empty</code> :匹配没有子元素的元素</p></li><li><p><code>:enabled</code>: 匹配没有设置 disabled 属性的表单元素。</p></li><li><p><code>:in-range</code>: 匹配在指定区域内元素。</p></li><li><p><code>:out-of-range</code>: 与<code>:in-range</code>相反，它匹配不在指定区域内的元素。</p></li><li><p><code>:indeterminate</code>:indeterminate 的英文意思是“ 不确定的”。当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。</p></li><li><p><code>:valid</code> :匹配条件验证正确的表单元素。</p></li><li><p><code>:invalid</code>: 与<code>:valid</code> 相反，匹配条件验证错误的表单元素。</p></li><li><p><code>:optional</code>:匹配是具有 optional 属性的表单元素。当表单元素没有设置为 required 时，即为 optional 属性。</p></li><li><p><code>:required</code>: 与<code>:optional</code>相反匹配设置了 required 属性的表单元素。</p></li><li><p><code>:read-only</code>: 匹配设置了只读属性的元素，表单元素可以通过设置“readonly” 属性来定义元素只读。</p></li><li><p><code>:read-write</code>: 匹配处于编辑状态的元素。input，textarea 和设置了 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。</p></li><li><p><code>:scope</code>: 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。</p></li><li><p><code>:dir</code>:匹配指定阅读方向的元素，当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持:dir 伪类，并在火狐浏览器中使用时需要添加前缀 ( -moz-dir() )。</p></li><li><p><code>:lang</code>:匹配设置了特定语言的元素，设置特定语言可以通过为了 HTML 元素设置 lang=”” 属性，设置 meta 元素的 charset=”” 属性，或者是在 http 头部上设置语言属性。</p><p>实际上，lang=”” 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。</p></li></ul><ul><li><code>:root</code>:匹配文档的根元素。一般的 html 文件的根元素是 html 元素，而 SVG 或 XML 文件的根元素则可能是其他元素。</li><li><code>:fullscreen</code>: 匹配处于全屏模式下的元素。全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79wl6d5ouj30gi0exq4h.jpg" alt="img"></p><p>##伪元素</p><p>伪元素前面是两个冒号，<code>E::first-line</code>会创造出不存在的新元素，由于css对单冒号的伪元素也支持，所以这样很容易让新学者混淆。但实际上现在css3已经明确规定了伪类单冒号，伪元素双冒号的规则。</p><ul><li><p><code>::before/:before</code>在被选元素前插入内容。需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</p></li><li><p><code>::after/:after</code> 在被元素后插入内容，其用法和特性与<code>:before</code>相似。</p><p>对于伪元素 <code>:before</code> 和 <code>:after</code> 而言，属性 <code>content</code> 是必须设置的，我们知道属性的值可以为字符串，也可以有其它形式，比如指向一张图片的 <code>URL:</code></p><p><code>content: url(&#39;img/icon.png&#39;)</code></p></li><li><p><code>::first-letter/:first-letter</code> 匹配元素中文本的首字母。被修饰的首字母不在文档树中</p></li><li><p><code>::first-line/:first-line</code> 匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。</p></li><li><p><code>::selection</code> 匹配用户被用户选中或者处于高亮状态的部分。在火狐浏览器使用时需要添加<code>-moz</code>前缀。该伪元素只支持双冒号的形式。</p></li><li><p><code>::placeholder</code> 匹配占位符的文本，只有元素设置了<code>placeholder</code>属性时，该伪元素才能生效。</p><p>伪元素不是<code>CSS</code>的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（<code>IE10</code>和<code>Firefox18</code>及其以下版本）会使用单冒号的形式。</p></li></ul><ul><li><code>::backdrop</code> 用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式</li></ul><p>注意：</p><ul><li>配合伪类使用<ul><li>伪元素 <code>:before</code> 还可以配合伪类使用，这里举经常与 <code>:before</code> 配合使用的伪类 <code>:hover</code> 为例：</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.before</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:before</span>&#123;<span class="attribute">content</span>:<span class="string">'you before'</span>; <span class="attribute">color</span>:red;&#125;</span><br><span class="line">&lt;div class="before"&gt; me&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>配合取值函数 <code>attr()</code> 使用</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">::before</span>&#123;<span class="attribute">content</span>: <span class="built_in">attr</span>(title)&#125;</span><br><span class="line">&lt;a href="https://blog.ihoey.com" title="梦魇小栈"&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line">&lt;a href="https://blog.ihoey.com" title="梦魇小栈"&gt;梦魇小栈&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79wlwrg6aj30dn05w3yy.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;伪类和伪元素&quot;&gt;&lt;a href=&quot;#伪类和伪元素&quot; class=&quot;headerlink&quot; title=&quot;伪类和伪元素&quot;&gt;&lt;/a&gt;伪类和伪元素&lt;/h1&gt;&lt;p&gt;&lt;code&gt;css&lt;/code&gt;引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="伪元素" scheme="http://yoursite.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
      <category term="伪类" scheme="http://yoursite.com/tags/%E4%BC%AA%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>sass&amp;less对比</title>
    <link href="http://yoursite.com/2019/11/11/sass&amp;less%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2019/11/11/sass&amp;less对比/</id>
    <published>2019-11-11T06:09:00.000Z</published>
    <updated>2019-11-10T15:36:08.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sass-amp-less"><a href="#sass-amp-less" class="headerlink" title="sass&amp;less"></a>sass&amp;less</h1><p>##为什么要使用 CSS 预处理器？</p><p>作为前端开发人员，大家都知道，Js 中可以自定义变量，而 CSS 仅仅是一个标记语言，不是编程语言，因此不可以自定义变量，不可以引用等等。</p><p><strong>CSS 有具体以下几个缺点：</strong></p><p>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</p><p>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</p><p>这就导致了我们在工作中无端增加了许多工作量。而使用 CSS 预处理器，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了我们的开发效率。</p><p>但是，CSS 预处理器也不是万金油，CSS 的好处在于简便、随时随地被使用和调试。预编译 CSS 步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。</p><p>所以我们在实际项目中衡量预编译方案时，还是得想想，比起带来的额外维护开销，CSS 预处理器有没有解决更大的麻烦。</p><h2 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h2><p>首先 sass 和 less 都是 css 的预编译处理语言，他们引入了 mixins，参数，嵌套规则，运算，颜色，名字空间，作用域，JavaScript 赋值等 加快了 css 开发效率,当然这两者都可以配合 gulp 和 grunt 等前端构建工具使用</p><p>sass 和 less<strong>主要区别:在于实现方式 less 是基于 JavaScript 的在客户端处理 所以安装的时候用 npm，sass 是基于 ruby 所以在服务器处理。</strong></p><h2 id="SASS-介绍"><a href="#SASS-介绍" class="headerlink" title="SASS 介绍"></a>SASS 介绍</h2><p>Sass 是 Ruby 开发者为前端开发提供的处理 CSS 的工具。它为 CSS 提供更动态的设定方式，允许编译、变量、函数……总之，使 CSS 更动态，也更像一门真正的可编程语言。</p><ol><li>Sass 是基于 Ruby 开发的，所以开发环境首先需要安装 Ruby。</li><li>浏览器中无法编译 Sass，所以要先编译好 css 文件，再交给浏览器。Sass<strong>不能</strong>在浏览器环境中直接运行。</li></ol><p>##Less 介绍</p><p>Less 是晚些产生的语言，基于 JS 进行开发，在 Node 中进行编译。所以使用时不需要安装其他语言，不过要记得<strong>先导入 less 文件，然后导入 less.js</strong>。提供 CDN 地址在这里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/less.js/3.0.4/less.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/less.js/3.0.4/less.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然 Less 也提供服务器端的编译功能。</p><h2 id="Stylus-介绍"><a href="#Stylus-介绍" class="headerlink" title="Stylus 介绍"></a>Stylus 介绍</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2F" target="_blank" rel="noopener">Stylus</a>相对前两者较新，可以看官方文档介绍的功能。</p><p>1.来自 NodeJS 社区，所以和 NodeJS 走得很近，与 JavaScript 联系非常紧密。还有专门 JavaScript API：<a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2Fdocs%2Fjs.html" target="_blank" rel="noopener">learnboost.github.io/stylus/docs…</a></p><p>2.支持 Ruby 之类等等框架</p><p>3.更多更强大的支持和功能</p><p>以 stylus 的角度来说,stylus 更加注重对 javascript( <a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2Fdocs%2Fjs.html" target="_blank" rel="noopener">learnboost.github.io/stylus/docs…</a> ) 的利用。 当用户觉得写 stylus 函数遇到了过于复杂或者无法测试，stylus 语法不支持等需求时， 也可以直接用 js 来实现这个函数并且在 stylus 中调用。</p><p>其次从编译器源码上来看：stylus 应该比 less.js 更有条理， 感觉如果未来社区添加功能的话，stylus 的源码添加起功能来会更简单，同样，目前 stylus 的功能也更复杂。</p><p>stylus 和 sass 另一个区别在于 sass 本身会建议，以下划线(_) 打头的文件在静态资源打包的时候不会被编译成 .css 文件【只是作为一种 import 存在】。而 stylus 没有这方面的规范。</p><p>同时写过 stylus 和 sass， 就语法简洁来看， stylus 在这方面占了很大的便宜。</p><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a><a href="https://cloud.tencent.com/developer/article/1092653" target="_blank" rel="noopener">三者对比</a></h2><ul><li><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3></li></ul><p>Sass: $var<br>Less: @var<br>两种语言都会有作用域的问题。一个变量只能在它被定义的代码块中使用。重复定义的变量会报错。</p><p>Stylus 对变量名没有任何限定，你可以是 $ 开始，也可以是任意的字符，而且与变量值之间可以用冒号、空格隔开，需要注意的是 Stylus (0.22.4) 将会编译 @ 开始的变量，但其对应的值并不会赋予该变量，换句话说，在 Stylus 的变量名不要用 @ 开头。</p><ul><li><h3 id="运算赋值："><a href="#运算赋值：" class="headerlink" title="运算赋值："></a>运算赋值：</h3></li></ul><p>只要保持单位统一或可相互转换，就可以进行运算，包括颜色在内：<br>Sass:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: e + -resize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="comment">// p &#123;</span></span><br><span class="line"><span class="comment">//   cursor: e-resize;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: (<span class="number">14px</span>/<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span> + <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="variable">$var</span> * <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Less:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base:</span> <span class="number">5%</span>;</span><br><span class="line"><span class="variable">@filler:</span> <span class="variable">@base</span> * <span class="number">2</span>;</span><br><span class="line"><span class="variable">@other:</span> <span class="variable">@base</span> + <span class="variable">@filler</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#888</span> / <span class="number">4</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@base-color</span> + <span class="number">#111</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span> / <span class="number">2</span> + <span class="variable">@filler</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">@var:</span> <span class="number">1px</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">width</span>: (<span class="variable">@var</span> + <span class="number">5</span>) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: (<span class="variable">@width</span> * <span class="number">2</span>) solid black;</span><br></pre></td></tr></table></figure><ul><li><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3></li></ul><p>Sass 和 Less 均允许元素嵌套。如果父子选择器均用逗号分开，那么编译时会按结合律拆开编译。<br>Sass 和 Less 指代上层元素均使用<code>&amp;</code>符号。</p><ul><li><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></li></ul><p>Sass 中，写好的选择器进行集成，需要<code>@extend</code>关键字。（sytlus 与 sass 相同）<br>Less 中，直接写入即可：<code>.be-extend-class;</code></p><ul><li><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3></li></ul><p>Sass 中，需要进行 Mixin 操作的选择器需要<code>@mixin</code>关键字，选择器后可以传入变量和默认值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> left(<span class="variable">$value</span>: 10px) padding: <span class="variable">$value</span>;</span><br></pre></td></tr></table></figure><p>使用时使用<code>@include</code>关键字，并可以更新变量：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">include</span> left @<span class="keyword">include</span> left(<span class="number">20px</span>);</span><br></pre></td></tr></table></figure><p>Less 中 Mixin 和继承感觉更相似，选择器在书写时就留好了变量，直接继承或更新变量即可：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.be-extend-class</span>(<span class="variable">@width</span>: <span class="number">10px</span>) &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">@width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="selector-class">.be-extend-class</span>;</span><br><span class="line"><span class="selector-class">.be-extend-class</span>(<span class="number">20px</span>);</span><br></pre></td></tr></table></figure><p>sass：在 sass 定义 Mixins 和 less、stylus 有所不同，在声明 Mixins 时需要使用“@mixin”,然后后面紧跟 Mixins 的名，他也可以定义参数，同时可以给这个参数设置一个默认值，但参数名是使用“$”符号开始，而且和参数值之间需要使用冒号（：）分开。另外在 sass 中调用 Mixins 需要使用“@include”，然后在其后紧跟你要调用的 Mixins 名。</p><p>less：less 中声明 Mixins 和 CSS 定义样式非常类似，可以将 Mixins 看成是一个选择器，当然 Mixins 也可以设置参数，并给参数设置默认值。不过设置参数的变量名是使用“@”开始，同样参数和默认参数值之间需要使用冒号（：）分开。</p><p>stylus：stylus 和前两者也略有不同，他可以不使用任何符号，就是直接定义 Mixins 名，然后在定义参数和默认值之间用等号（=）来连接。</p><ul><li><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3></li></ul><p>两种语言相同：多行注释格式可保留，单行注释格式会在编译时被删除。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 会被保留的注释格式 */</span></span><br><span class="line"><span class="comment">// 不保存的注释格式</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="颜色运算："><a href="#颜色运算：" class="headerlink" title="颜色运算："></a>颜色运算：</h3></li></ul><p>CSS 预处理器提供一系列<strong>颜色函数</strong>帮助生成主题系列颜色：<br>Sass：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lighten(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #d6d65c</span></span><br><span class="line">darken(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #a3a329</span></span><br><span class="line">grayscale(<span class="selector-id">#cc3</span>) <span class="comment">// #808080 灰度</span></span><br><span class="line">complement(<span class="selector-id">#cc3</span>) <span class="comment">// #33c</span></span><br></pre></td></tr></table></figure><p>Less：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lighten</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color which is 10% *lighter* than @color</span></span><br><span class="line"><span class="selector-tag">darken</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color which is 10% *darker* than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">saturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);    <span class="comment">// return a color 10% *more* saturated than @color</span></span><br><span class="line"><span class="selector-tag">desaturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);  <span class="comment">// return a color 10% *less* saturated than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">fadein</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color 10% *less* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fadeout</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color 10% *more* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fade</span>(<span class="variable">@color</span>, <span class="number">50%</span>);        <span class="comment">// return @color with 50% transparency</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, <span class="number">10</span>);         <span class="comment">// return a color with a 10 degree larger in hue than @color</span></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, -<span class="number">10</span>);        <span class="comment">// return a color with a 10 degree smaller hue than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mix</span>(<span class="variable">@color1</span>, <span class="variable">@color2</span>);    <span class="comment">// return a mix of @color1 and @color2</span></span><br></pre></td></tr></table></figure><p>stylus：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lighten(color, 10%); /* 返回的颜色在'color'基础上变亮10% */</span><br><span class="line">darken(color, 10%);  /* 返回的颜色在'color'基础上变暗10% */</span><br><span class="line">saturate(color, 10%);   /* 返回的颜色在'color'基础上饱和度增加10% */</span><br><span class="line">desaturate(color, 10%); /* 返回的颜色在'color'基础上饱和度降低10% */</span><br></pre></td></tr></table></figure><ul><li><h3 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a>插入文件</h3></li></ul><p>两种语言相同，使用@import 关键字引入。注意后缀名，可以直接导入 css 文件。后缀名为 css 的文件不会被预处理器处理。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"path/filename.scss"</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"lib.less"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"lib.css"</span>;</span><br></pre></td></tr></table></figure><ul><li><h3 id="高级语法："><a href="#高级语法：" class="headerlink" title="==高级语法：=="></a>==高级语法：==</h3></li></ul><h4 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h4><p>在 Sass 中，需要用 Sass 自己的一套语言编程：</p><ol><li>条件 if-else</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">if</span> lightness(<span class="variable">$color</span>) &gt; 30% &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>循环</li></ol><p>for:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 10 &#123;</span><br><span class="line">  <span class="selector-class">.border-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">border</span>: #&#123;<span class="variable">$i</span>&#125;px solid blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line">@<span class="keyword">while</span> <span class="variable">$i</span> &gt; 0 &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>each:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$member</span> in a, b, c, d &#123;</span><br><span class="line">  .#&#123;<span class="variable">$member</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">"/image/#&#123;$member&#125;.jpg"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义函数</li></ol><p>需要<code>@function</code>、<code>@return</code>关键字。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function double(<span class="variable">$n</span>) &#123;</span><br><span class="line">  @return <span class="variable">$n</span> * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: double(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><p>Less 是使用 JS 作为编译环境的，所以它支持 JS 语法。</p><ol><li>字符串插值</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base-url:</span> <span class="string">"http://assets.fnord.com"</span>;</span><br><span class="line"><span class="attribute">background-image</span>: url(<span class="string">"@&#123;base-url&#125;/images/bg.png"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>用反引号使用 JS 语法：</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> <span class="built_in">` "hello" .toUpperCase() + "!" `</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接访问 JS 环境</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@height:</span> <span class="built_in">`document.body.clientHeight`</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sass-amp-less&quot;&gt;&lt;a href=&quot;#sass-amp-less&quot; class=&quot;headerlink&quot; title=&quot;sass&amp;amp;less&quot;&gt;&lt;/a&gt;sass&amp;amp;less&lt;/h1&gt;&lt;p&gt;##为什么要使用 CSS 预处理器？&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="SASS" scheme="http://yoursite.com/tags/SASS/"/>
    
      <category term="LESS" scheme="http://yoursite.com/tags/LESS/"/>
    
  </entry>
  
  <entry>
    <title>oh-my-zsh git 命令缩写</title>
    <link href="http://yoursite.com/2019/11/05/oh-my-zsh%20git%20%E5%91%BD%E4%BB%A4%E7%BC%A9%E5%86%99/"/>
    <id>http://yoursite.com/2019/11/05/oh-my-zsh git 命令缩写/</id>
    <published>2019-11-05T13:08:23.000Z</published>
    <updated>2019-11-10T14:37:39.026Z</updated>
    
    <content type="html"><![CDATA[<p>#oh-my-zsh git 命令缩写</p><p>喜欢用 git 命令行，平时能少打几个字还是会节省不少时间的。</p><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alias ga=<span class="string">'git add'</span></span><br><span class="line">alias gb=<span class="string">'git branch'</span></span><br><span class="line">alias gba=<span class="string">'git branch -a'</span></span><br><span class="line">alias gbd=<span class="string">'git branch -d'</span></span><br><span class="line">alias gcam=<span class="string">'git commit -a -m'</span></span><br><span class="line">alias gcb=<span class="string">'git checkout -b'</span></span><br><span class="line">alias gco=<span class="string">'git checkout'</span></span><br><span class="line">alias gcp=<span class="string">'git cherry-pick'</span></span><br><span class="line">alias gd=<span class="string">'git diff'</span></span><br><span class="line">alias gfo=<span class="string">'git fetch origin'</span></span><br><span class="line">alias ggpush=<span class="string">'git push origin $(git_current_branch)'</span></span><br><span class="line">alias ggsup=<span class="string">'git branch --set-upstream-to=origin/$(git_current_branch)'</span></span><br><span class="line">alias glgp=<span class="string">'git log --stat -p'</span></span><br><span class="line">alias gm=<span class="string">'git merge'</span></span><br><span class="line">alias gp=<span class="string">'git push'</span></span><br><span class="line">alias gst=<span class="string">'git status'</span></span><br><span class="line">alias gsta=<span class="string">'git stash save'</span></span><br><span class="line">alias gstp=<span class="string">'git stash pop'</span></span><br></pre></td></tr></table></figure><h2 id="全部"><a href="#全部" class="headerlink" title="全部"></a>全部</h2><p>参考：<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">alias g=<span class="string">'git'</span></span><br><span class="line"></span><br><span class="line">alias ga=<span class="string">'git add'</span></span><br><span class="line">alias gaa=<span class="string">'git add --all'</span></span><br><span class="line">alias gapa=<span class="string">'git add --patch'</span></span><br><span class="line">alias gau=<span class="string">'git add --update'</span></span><br><span class="line"></span><br><span class="line">alias gb=<span class="string">'git branch'</span></span><br><span class="line">alias gba=<span class="string">'git branch -a'</span></span><br><span class="line">alias gbd=<span class="string">'git branch -d'</span></span><br><span class="line">alias gbda=<span class="string">'git branch --no-color --merged | command grep -vE "^(\*|\s*(master|develop|dev)\s*$)" | command xargs -n 1 git branch -d'</span></span><br><span class="line">alias gbl=<span class="string">'git blame -b -w'</span></span><br><span class="line">alias gbnm=<span class="string">'git branch --no-merged'</span></span><br><span class="line">alias gbr=<span class="string">'git branch --remote'</span></span><br><span class="line">alias gbs=<span class="string">'git bisect'</span></span><br><span class="line">alias gbsb=<span class="string">'git bisect bad'</span></span><br><span class="line">alias gbsg=<span class="string">'git bisect good'</span></span><br><span class="line">alias gbsr=<span class="string">'git bisect reset'</span></span><br><span class="line">alias gbss=<span class="string">'git bisect start'</span></span><br><span class="line"></span><br><span class="line">alias gc=<span class="string">'git commit -v'</span></span><br><span class="line">alias gc!=<span class="string">'git commit -v --amend'</span></span><br><span class="line">alias gcn!=<span class="string">'git commit -v --no-edit --amend'</span></span><br><span class="line">alias gca=<span class="string">'git commit -v -a'</span></span><br><span class="line">alias gca!=<span class="string">'git commit -v -a --amend'</span></span><br><span class="line">alias gcan!=<span class="string">'git commit -v -a --no-edit --amend'</span></span><br><span class="line">alias gcans!=<span class="string">'git commit -v -a -s --no-edit --amend'</span></span><br><span class="line">alias gcam=<span class="string">'git commit -a -m'</span></span><br><span class="line">alias gcsm=<span class="string">'git commit -s -m'</span></span><br><span class="line">alias gcb=<span class="string">'git checkout -b'</span></span><br><span class="line">alias gcf=<span class="string">'git config --list'</span></span><br><span class="line">alias gcl=<span class="string">'git clone --recursive'</span></span><br><span class="line">alias gclean=<span class="string">'git clean -fd'</span></span><br><span class="line">alias gpristine=<span class="string">'git reset --hard &amp;&amp; git clean -dfx'</span></span><br><span class="line">alias gcm=<span class="string">'git checkout master'</span></span><br><span class="line">alias gcd=<span class="string">'git checkout develop'</span></span><br><span class="line">alias gcmsg=<span class="string">'git commit -m'</span></span><br><span class="line">alias gco=<span class="string">'git checkout'</span></span><br><span class="line">alias gcount=<span class="string">'git shortlog -sn'</span></span><br><span class="line">compdef _git gcount</span><br><span class="line">alias gcp=<span class="string">'git cherry-pick'</span></span><br><span class="line">alias gcpa=<span class="string">'git cherry-pick --abort'</span></span><br><span class="line">alias gcpc=<span class="string">'git cherry-pick --continue'</span></span><br><span class="line">alias gcs=<span class="string">'git commit -S'</span></span><br><span class="line"></span><br><span class="line">alias gd=<span class="string">'git diff'</span></span><br><span class="line">alias gdca=<span class="string">'git diff --cached'</span></span><br><span class="line">alias gdct=<span class="string">'git describe --tags `git rev-list --tags --max-count=1`'</span></span><br><span class="line">alias gdt=<span class="string">'git diff-tree --no-commit-id --name-only -r'</span></span><br><span class="line">alias gdw=<span class="string">'git diff --word-diff'</span></span><br><span class="line"></span><br><span class="line">gdv() &#123; git diff -w <span class="string">"$@"</span> | view - &#125;</span><br><span class="line">compdef _git gdv=git-diff</span><br><span class="line"></span><br><span class="line">alias gf=<span class="string">'git fetch'</span></span><br><span class="line">alias gfa=<span class="string">'git fetch --all --prune'</span></span><br><span class="line">alias gfo=<span class="string">'git fetch origin'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gfg</span>(<span class="params"></span>) </span>&#123; git ls-files | grep $@ &#125;</span><br><span class="line">compdef _grep gfg</span><br><span class="line"></span><br><span class="line">alias gg=<span class="string">'git gui citool'</span></span><br><span class="line">alias gga=<span class="string">'git gui citool --amend'</span></span><br><span class="line"></span><br><span class="line">ggf() &#123;</span><br><span class="line">  [[ <span class="string">"$#"</span> != <span class="number">1</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">  git push --force origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggf=git-checkout</span><br><span class="line"></span><br><span class="line">ggl() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> != <span class="number">0</span> ]] &amp;&amp; [[ <span class="string">"$#"</span> != <span class="number">1</span> ]]; then</span><br><span class="line">    git pull origin <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    [[ <span class="string">"$#"</span> == <span class="number">0</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">    git pull origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggl=git-checkout</span><br><span class="line"></span><br><span class="line">ggp() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> != <span class="number">0</span> ]] &amp;&amp; [[ <span class="string">"$#"</span> != <span class="number">1</span> ]]; then</span><br><span class="line">    git push origin <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    [[ <span class="string">"$#"</span> == <span class="number">0</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">    git push origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggp=git-checkout</span><br><span class="line"></span><br><span class="line">ggpnp() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> == <span class="number">0</span> ]]; then</span><br><span class="line">    ggl &amp;&amp; ggp</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ggl <span class="string">"$&#123;*&#125;"</span> &amp;&amp; ggp <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggpnp=git-checkout</span><br><span class="line"></span><br><span class="line">ggu() &#123;</span><br><span class="line">  [[ <span class="string">"$#"</span> != <span class="number">1</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">  git pull --rebase origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggu=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpur=<span class="string">'ggu'</span></span><br><span class="line">compdef _git ggpur=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpull=<span class="string">'git pull origin $(git_current_branch)'</span></span><br><span class="line">compdef _git ggpull=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpush=<span class="string">'git push origin $(git_current_branch)'</span></span><br><span class="line">compdef _git ggpush=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggsup=<span class="string">'git branch --set-upstream-to=origin/$(git_current_branch)'</span></span><br><span class="line">alias gpsup=<span class="string">'git push --set-upstream origin $(git_current_branch)'</span></span><br><span class="line"></span><br><span class="line">alias ghh=<span class="string">'git help'</span></span><br><span class="line"></span><br><span class="line">alias gignore=<span class="string">'git update-index --assume-unchanged'</span></span><br><span class="line">alias gignored=<span class="string">'git ls-files -v | grep "^[[:lower:]]"'</span></span><br><span class="line">alias git-svn-dcommit-push=<span class="string">'git svn dcommit &amp;&amp; git push github master:svntrunk'</span></span><br><span class="line">compdef _git git-svn-dcommit-push=git</span><br><span class="line"></span><br><span class="line">alias gk=<span class="string">'\gitk --all --branches'</span></span><br><span class="line">compdef _git gk=<span class="string">'gitk'</span></span><br><span class="line">alias gke=<span class="string">'\gitk --all $(git log -g --pretty=%h)'</span></span><br><span class="line">compdef _git gke=<span class="string">'gitk'</span></span><br><span class="line"></span><br><span class="line">alias gl=<span class="string">'git pull'</span></span><br><span class="line">alias glg=<span class="string">'git log --stat'</span></span><br><span class="line">alias glgp=<span class="string">'git log --stat -p'</span></span><br><span class="line">alias glgg=<span class="string">'git log --graph'</span></span><br><span class="line">alias glgga=<span class="string">'git log --graph --decorate --all'</span></span><br><span class="line">alias glgm=<span class="string">'git log --graph --max-count=10'</span></span><br><span class="line">alias glo=<span class="string">'git log --oneline --decorate'</span></span><br><span class="line">alias glol=<span class="string">"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">alias glola=<span class="string">"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --all"</span></span><br><span class="line">alias glog=<span class="string">'git log --oneline --decorate --graph'</span></span><br><span class="line">alias gloga=<span class="string">'git log --oneline --decorate --graph --all'</span></span><br><span class="line">alias glp=<span class="string">"_git_log_prettily"</span></span><br><span class="line">compdef _git glp=git-log</span><br><span class="line"></span><br><span class="line">alias gm=<span class="string">'git merge'</span></span><br><span class="line">alias gmom=<span class="string">'git merge origin/master'</span></span><br><span class="line">alias gmt=<span class="string">'git mergetool --no-prompt'</span></span><br><span class="line">alias gmtvim=<span class="string">'git mergetool --no-prompt --tool=vimdiff'</span></span><br><span class="line">alias gmum=<span class="string">'git merge upstream/master'</span></span><br><span class="line"></span><br><span class="line">alias gp=<span class="string">'git push'</span></span><br><span class="line">alias gpd=<span class="string">'git push --dry-run'</span></span><br><span class="line">alias gpoat=<span class="string">'git push origin --all &amp;&amp; git push origin --tags'</span></span><br><span class="line">compdef _git gpoat=git-push</span><br><span class="line">alias gpu=<span class="string">'git push upstream'</span></span><br><span class="line">alias gpv=<span class="string">'git push -v'</span></span><br><span class="line"></span><br><span class="line">alias gr=<span class="string">'git remote'</span></span><br><span class="line">alias gra=<span class="string">'git remote add'</span></span><br><span class="line">alias grb=<span class="string">'git rebase'</span></span><br><span class="line">alias grba=<span class="string">'git rebase --abort'</span></span><br><span class="line">alias grbc=<span class="string">'git rebase --continue'</span></span><br><span class="line">alias grbi=<span class="string">'git rebase -i'</span></span><br><span class="line">alias grbm=<span class="string">'git rebase master'</span></span><br><span class="line">alias grbs=<span class="string">'git rebase --skip'</span></span><br><span class="line">alias grh=<span class="string">'git reset HEAD'</span></span><br><span class="line">alias grhh=<span class="string">'git reset HEAD --hard'</span></span><br><span class="line">alias grmv=<span class="string">'git remote rename'</span></span><br><span class="line">alias grrm=<span class="string">'git remote remove'</span></span><br><span class="line">alias grset=<span class="string">'git remote set-url'</span></span><br><span class="line">alias grt=<span class="string">'cd $(git rev-parse --show-toplevel || echo ".")'</span></span><br><span class="line">alias gru=<span class="string">'git reset --'</span></span><br><span class="line">alias grup=<span class="string">'git remote update'</span></span><br><span class="line">alias grv=<span class="string">'git remote -v'</span></span><br><span class="line"></span><br><span class="line">alias gsb=<span class="string">'git status -sb'</span></span><br><span class="line">alias gsd=<span class="string">'git svn dcommit'</span></span><br><span class="line">alias gsi=<span class="string">'git submodule init'</span></span><br><span class="line">alias gsps=<span class="string">'git show --pretty=short --show-signature'</span></span><br><span class="line">alias gsr=<span class="string">'git svn rebase'</span></span><br><span class="line">alias gss=<span class="string">'git status -s'</span></span><br><span class="line">alias gst=<span class="string">'git status'</span></span><br><span class="line">alias gsta=<span class="string">'git stash save'</span></span><br><span class="line">alias gstaa=<span class="string">'git stash apply'</span></span><br><span class="line">alias gstc=<span class="string">'git stash clear'</span></span><br><span class="line">alias gstd=<span class="string">'git stash drop'</span></span><br><span class="line">alias gstl=<span class="string">'git stash list'</span></span><br><span class="line">alias gstp=<span class="string">'git stash pop'</span></span><br><span class="line">alias gsts=<span class="string">'git stash show --text'</span></span><br><span class="line">alias gsu=<span class="string">'git submodule update'</span></span><br><span class="line"></span><br><span class="line">alias gts=<span class="string">'git tag -s'</span></span><br><span class="line">alias gtv=<span class="string">'git tag | sort -V'</span></span><br><span class="line"></span><br><span class="line">alias gunignore=<span class="string">'git update-index --no-assume-unchanged'</span></span><br><span class="line">alias gunwip=<span class="string">'git log -n 1 | grep -q -c "\-\-wip\-\-" &amp;&amp; git reset HEAD~1'</span></span><br><span class="line">alias gup=<span class="string">'git pull --rebase'</span></span><br><span class="line">alias gupv=<span class="string">'git pull --rebase -v'</span></span><br><span class="line">alias glum=<span class="string">'git pull upstream master'</span></span><br><span class="line"></span><br><span class="line">alias gwch=<span class="string">'git whatchanged -p --abbrev-commit --pretty=medium'</span></span><br><span class="line">alias gwip=<span class="string">'git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m "--wip-- [skip ci]"'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#oh-my-zsh git 命令缩写&lt;/p&gt;
&lt;p&gt;喜欢用 git 命令行，平时能少打几个字还是会节省不少时间的。&lt;/p&gt;
&lt;h2 id=&quot;常用&quot;&gt;&lt;a href=&quot;#常用&quot; class=&quot;headerlink&quot; title=&quot;常用&quot;&gt;&lt;/a&gt;常用&lt;/h2&gt;&lt;figure
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Object.prototype.toString方法的原理</title>
    <link href="http://yoursite.com/2019/10/28/Object.prototype.toString%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/28/Object.prototype.toString方法的原理/</id>
    <published>2019-10-28T04:33:37.000Z</published>
    <updated>2019-11-10T14:37:39.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-prototype-toString-方法的原理"><a href="#Object-prototype-toString-方法的原理" class="headerlink" title="Object.prototype.toString 方法的原理"></a>Object.prototype.toString 方法的原理</h1><h2 id="ECMAScript-3"><a href="#ECMAScript-3" class="headerlink" title="ECMAScript 3"></a>ECMAScript 3</h2><h3 id="Object-prototype-toString-方法的规范"><a href="#Object-prototype-toString-方法的规范" class="headerlink" title="Object.prototype.toString 方法的规范"></a>Object.prototype.toString 方法的规范</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>获取 this 对象的[[Class]]属性的值.</li><li>计算出三个字符串<strong>“[object “,</strong>第一步的操作结果 Result(1), 以及 <strong>“]”</strong>连接后的新字符串.</li><li>返回第二步的操作结果 Result(2).</li></ol><h3 id="Class"><a href="#Class" class="headerlink" title="[[Class]]"></a>[[Class]]</h3><p>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的</p><table><thead><tr><th>内部属性</th><th>描述</th></tr></thead><tbody><tr><td>[[Class]]</td><td>一个字符串值,表明了该对象的类型.</td></tr></tbody></table><p>然后给了一段解释:</p><blockquote><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过<strong>Object.prototype.toString</strong>方法之外,本规范没有提供任何其他方式来让程序访问该属性的值</p></blockquote><p>也就是说,把 Object.prototype.toString 方法返回的字符串,去掉前面固定的<strong>“[object “</strong>和后面固定的<strong>“]”,</strong>就是内部属性[[class]]的值,也就达到了判断对象类型的目的。</p><h3 id="Class-的值"><a href="#Class-的值" class="headerlink" title="[[Class]]的值"></a>[[Class]]的值</h3><p>在 ES3 中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有 10 种.分别是:<code>&quot;Array&quot;</code>, <code>&quot;Boolean&quot;</code>, <code>&quot;Date&quot;</code>, <code>&quot;Error&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;Math&quot;</code>, <code>&quot;Number&quot;</code>, <code>&quot;Object&quot;</code>, <code>&quot;RegExp&quot;</code>, <code>&quot;String&quot;.</code></p><h2 id="ECMAScript-5"><a href="#ECMAScript-5" class="headerlink" title="ECMAScript 5"></a>ECMAScript 5</h2><h3 id="Object-prototype-toString-方法的规范-1"><a href="#Object-prototype-toString-方法的规范-1" class="headerlink" title="Object.prototype.toString 方法的规范"></a>Object.prototype.toString 方法的规范</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用 ToObject(<strong>this)</strong>的结果.</li><li>让<em>class</em>成为<em>O</em>的内部属性[[Class]]的值.</li><li>返回三个字符串<strong>“[object “,</strong> <em>class</em>, 以及 <strong>“]”</strong>连接后的新字符串.</li></ol><p>可以看出,ES5 比 ES3 多了 1,2,3 步.第 1,2 步属于新规则,比较特殊,因为”<code>Undefined&quot;</code>和”<code>Null&quot;</code>并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this 的值才会保持 undefined 或 null,非严格模式下会自动成为全局对象).第 3 步并不算是新规则,因为在 ES3 的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.</p><h3 id="Class-1"><a href="#Class-1" class="headerlink" title="[[Class]]"></a>[[Class]]</h3><p>ES5 中,[[Class]]属性的解释更加详细:</p><blockquote><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过<strong>Object.prototype.toString</strong>方法之外,本规范没有提供任何其他方式来让程序访问该属性的值</p></blockquote><h3 id="对比-ES3"><a href="#对比-ES3" class="headerlink" title="对比 ES3"></a>对比 ES3</h3><ul><li>第一个差别就是[[class]]内部属性的值多了两种,成了 12 种<ul><li>一种是 arguments 对象的[[class]]成了”Arguments”,而不是以前的”Object”</li><li>多个了全局对象 JSON,它的[[class]]值为”JSON”.</li></ul></li><li>第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这 12 种值冲突（不过在支持 ES3 的浏览器中,貌似也没有发现哪些宿主对象故意使用那 10 个值）</li></ul><h2 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h2><p><strong>[[class]]内部属性没有了</strong>,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的:</p><table><thead><tr><th>内部属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>[[NativeBrand]]</td><td>枚举 NativeBrand 的一个成员.</td><td>该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型.</td></tr></tbody></table><h3 id="NativeBrand-属性（internal-slot）"><a href="#NativeBrand-属性（internal-slot）" class="headerlink" title="[[NativeBrand]]属性（internal slot）"></a>[[NativeBrand]]属性（<code>internal slot</code>）</h3><p>[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的 ECMAScript 原生对象.只有在表 10 中明确指出的对象类型才有[[NativeBrand]]内部属性.</p><table><thead><tr><th>属性值</th><th>对应类型</th></tr></thead><tbody><tr><td>NativeFunction</td><td>Function objects</td></tr><tr><td>NativeArray</td><td>Array objects</td></tr><tr><td>StringWrapper</td><td>String objects</td></tr><tr><td>BooleanWrapper</td><td>Boolean objects</td></tr><tr><td>NumberWrapper</td><td>Number objects</td></tr><tr><td>NativeMath</td><td>The Math object</td></tr><tr><td>NativeDate</td><td>Date objects</td></tr><tr><td>NativeRegExp</td><td>RegExp objects</td></tr><tr><td>NativeError</td><td>Error objects</td></tr><tr><td>NativeJSON</td><td>The JSON object</td></tr><tr><td>NativeArguments</td><td>Arguments objects</td></tr><tr><td>NativePrivateName</td><td>Private Name objects</td></tr></tbody></table><p>可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].</p><h3 id="Object-prototype-toString-方法的规范-2"><a href="#Object-prototype-toString-方法的规范-2" class="headerlink" title="Object.prototype.toString 方法的规范:"></a>Object.prototype.toString 方法的规范:</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用 ToObject(<strong>this)</strong>的结果.</li><li>如果<em>O</em>有[[NativeBrand]]内部属性,让<em>tag</em>成为表 29 中对应的值.</li><li>否则<ol><li>让<em>hasTag</em>成为调用<em>O</em>的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>hasTag</em>为<strong>false</strong>,则让<em>tag</em>为<code>&quot;Object&quot;</code>.</li><li>否则,<ol><li>让<em>tag</em>成为调用<em>O</em>的[[Get]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>tag</em>是一个 abrupt completion,则让<em>tag</em>成为 NormalCompletion(<code>&quot;???&quot;</code>).</li><li>让<em>tag<em>成为</em>tag</em>.[[value]].</li><li>如果 Type(<em>tag</em>)不是字符串,则让<em>tag 成为</em><code>&quot;???&quot;</code>.</li><li>如果<em>tag</em>的值为<code>&quot;Arguments&quot;</code>, <code>&quot;Array&quot;</code>, <code>&quot;Boolean&quot;</code>, <code>&quot;Date&quot;</code>, <code>&quot;Error&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;JSON&quot;</code>, <code>&quot;Math&quot;</code>, <code>&quot;Number&quot;</code>, <code>&quot;Object&quot;</code>, <code>&quot;RegExp&quot;</code>,<code>或者&quot;String&quot;中的任一个,则让</code><em>tag</em>成为字符串<code>&quot;~&quot;和</code><em>tag</em>当前的值连接后的结果.</li></ol></li></ol></li><li>返回三个字符串”[object “, tag, and “]”连接后的新字符串.</li></ol><h3 id="ES6-里的新类型-Map-Set"><a href="#ES6-里的新类型-Map-Set" class="headerlink" title="ES6 里的新类型 Map,Set"></a>ES6 里的新类型 Map,Set</h3><p>ES6 里的新类型 Map,Set 等,都没有在表 29 中.它们在执行 toString 方法的时候返回的是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Map</span>())); <span class="comment">//"[object Map]"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Set</span>())); <span class="comment">//"[object Set]"</span></span><br></pre></td></tr></table></figure><p>Map.prototype.@@toStringTag</p><p>@@toStringTag 属性的初始值为字符串<strong>“Map”</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object-prototype-toString-方法的原理&quot;&gt;&lt;a href=&quot;#Object-prototype-toString-方法的原理&quot; class=&quot;headerlink&quot; title=&quot;Object.prototype.toString 方法的原
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://yoursite.com/2019/10/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/21/函数式编程/</id>
    <published>2019-10-21T03:15:12.000Z</published>
    <updated>2019-11-10T14:37:39.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>函数式编程是一种编程范式，主要是利用函数把运算过程封装起来，通过组合各种函数来计算结果。函数式编程意味着你可以在更短的时间内编写具有更少错误的代码。</p><p>举个简单的例子，假设我们要把字符串 <code>functional programming is great</code> 变成每个单词首字母大写，我们可以这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"functional programming is great"</span>;</span><br><span class="line"><span class="keyword">var</span> result = string</span><br><span class="line">  .split(<span class="string">" "</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">v</span> =&gt;</span> v.slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + v.slice(<span class="number">1</span>))</span><br><span class="line">  .join(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure><p>上面的例子先用 split 把字符串转换数组，然后再通过 map 把各元素的首字母转换成大写，最后通过 join 把数组转换成字符串。 整个过程就是 <code>join(map(split(str)))</code>,体现了函数式编程的核心思想： <strong>通过函数对数据进行转换</strong>。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>由此我们可以得到，函数式编程有两个基本特点：</p><ul><li>通过函数来对数据进行转换</li><li>通过串联多个函数来求结果</li></ul><h2 id="对比声明式与命令式"><a href="#对比声明式与命令式" class="headerlink" title="对比声明式与命令式"></a>对比声明式与命令式</h2><ul><li>命令式：我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。命令式代码中频繁使用语句,来完成某个行为。比如 for、if、switch、throw 等这些语句。</li><li>声明式：我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; companies.length; i++) &#123;</span><br><span class="line">  CEOs.push(companies[i].CEO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = companies.map(<span class="function"><span class="params">c</span> =&gt;</span> c.CEO);</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到声明式的写法是一个表达式，无需关心如何进行计数器迭代，返回的数组如何收集，它指明的是做什么，而不是怎么做。<strong>函数式编程的一个明显的好处就是这种声明式的代码</strong>，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。</p><h2 id="常见特性"><a href="#常见特性" class="headerlink" title="常见特性"></a>常见特性</h2><h3 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h3><p>指调用函数时不会修改外部状态，即一个函数调用 n 次后依然返回同样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 含有副作用，它修改了外部变量 a</span></span><br><span class="line"><span class="comment">// 多次调用结果不一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无副作用，没有修改外部状态</span></span><br><span class="line"><span class="comment">// 多次调用结果一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明引用"><a href="#透明引用" class="headerlink" title="透明引用"></a>透明引用</h3><p>指一个函数只会用到传递给它的变量以及自己内部创建的变量，不会使用到其他变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 函数内部使用的变量并不属于它的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数内部使用的变量是显式传递进去的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h3><p>指的是一个变量一旦创建后，就不能再进行修改，任何修改都会生成一个新的变量。使用不可变变量最大的好处是线程安全。多个线程可以同时访问同一个不可变变量，让并行变得更容易实现。 由于 JavaScript 原生不支持不可变变量，需要通过第三方库来实现。 (如 Immutable.js，Mori 等等)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = obj.set(<span class="string">"a"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Immutable(&#123; a: 1 &#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// Immutable(&#123; a: 2 &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>我们常说函数是 JavaScript 的”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。下文将要介绍的闭包、高阶函数、函数柯里化和函数组合都是围绕这一特性的应用</p><h2 id="常见的函数式编程模型"><a href="#常见的函数式编程模型" class="headerlink" title="常见的函数式编程模型"></a>常见的函数式编程模型</h2><h3 id="1-闭包（Closure）"><a href="#1-闭包（Closure）" class="headerlink" title="1.闭包（Closure）"></a>1.闭包（Closure）</h3><p>如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。</p><p>闭包的形成条件：</p><ul><li>存在内、外两层函数</li><li>内层函数对外层函数的局部变量进行了引用</li></ul><p>闭包的用途:<br><strong>可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的缓存工具</span></span><br><span class="line"><span class="comment">// 匿名函数创造了一个闭包</span></span><br><span class="line"><span class="keyword">const</span> cache = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">      <span class="keyword">return</span> store[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(key, val) &#123;</span><br><span class="line">      store[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(cache); <span class="comment">//&#123;get: ƒ, set: ƒ&#125;</span></span><br><span class="line">cache.set(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">cache.get(<span class="string">"a"</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。</p><p>闭包的弊端:<strong>持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费</strong>，所以一般需要一些额外手动的清理机制。</p><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2.高阶函数"></a>2.高阶函数</h3><p>函数式编程倾向于复用一组通用的函数功能来处理数据，它通过使用高阶函数来实现。<strong>高阶函数指的是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值</strong>。</p><p>高阶函数经常用于：</p><ul><li>抽象或隔离行为、作用，异步控制流程作为回调函数，promises，monads 等</li><li>创建可以泛用于各种数据类型的功能</li><li>部分应用于函数参数（偏函数应用）或创建一个柯里化的函数，用于复用或函数复合。</li><li>接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。</li></ul><p>JavaScript 语言是原生支持高阶函数的, 例如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce 是 JavaScript 中内置的一些高阶函数，使用高阶函数会让我们的代码更清晰简洁。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。map 不会改变原数组。</p><p>假设我们有一个包含名称和种类属性的对象数组，我们想要这个数组中所有名称属性放在一个新数组中，如何实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  names.push(animals[i].name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(names); <span class="comment">//["Fluffykins", "Caro", "Hamilton", "Harold", "Ursula", "Jimmy"]</span></span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = animals.map(<span class="function"><span class="params">x</span> =&gt;</span> x.name);</span><br><span class="line"><span class="built_in">console</span>.log(names); <span class="comment">//["Fluffykins", "Caro", "Hamilton", "Harold", "Ursula", "Jimmy"]</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter() 方法会创建一个新数组，其中包含所有通过回调函数测试的元素。filter 为数组中的每个元素调用一次 callback 函数， callback 函数返回 true 表示该元素通过测试，保留该元素，false 则不保留。filter 不会改变原数组，它返回过滤后的新数组。</p><p>假设我们有一个包含名称和种类属性的对象数组。 我们想要创建一个只包含狗（species: “dog”）的数组。如何实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> dogs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (animals[i].species === <span class="string">"dog"</span>) dogs.push(animals[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dogs);</span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> dogs = animals.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.species === <span class="string">"dog"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogs); <span class="comment">// &#123;name: "Caro", species: "dog"&#125;</span></span><br><span class="line"><span class="comment">// &#123; name: "Hamilton", species: "dog" &#125;</span></span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce 方法对调用数组的每个元素执行回调函数，最后生成一个单一的值并返回。 reduce 方法接受两个参数：1）reducer 函数（回调），2）一个可选的 initialValue。</p><p>假设我们要对一个数组的求和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  sum = sum + arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.reduce(</span><br><span class="line">  (accumulator, currentValue) =&gt; accumulator + currentValue,</span><br><span class="line">  <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br></pre></td></tr></table></figure><p>我们可以通过下图，形象生动展示三者的区别：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ixh3e6euj30ml0bnwf2.jpg" alt="img"></p><h3 id="3-函数柯里化"><a href="#3-函数柯里化" class="headerlink" title="3.函数柯里化"></a>3.函数柯里化</h3><p>柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候，再一次性把所有传入的参数进行求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 函数柯里化</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line">increment(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。那么，我们如何来实现一个简易的柯里化函数呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数fn函数的参数个数</span></span><br><span class="line">  <span class="keyword">var</span> n = fn.length;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    args.push(arg);</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; n) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>.callee; <span class="comment">// 返回这个函数的引用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = curryIt(add);</span><br><span class="line"><span class="keyword">var</span> c1 = c(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = c1(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> c3 = c2(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c3); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>由此我们可以看出，柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法！</p><h3 id="4-函数组合-Composition"><a href="#4-函数组合-Composition" class="headerlink" title="4.函数组合 (Composition)"></a>4.函数组合 (Composition)</h3><p>前面提到过，函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。<br>假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数的组合</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> f(g(x));</span><br><span class="line"><span class="keyword">var</span> add1 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mul5 = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">5</span>;</span><br><span class="line">compose(</span><br><span class="line">  mul5,</span><br><span class="line">  add1</span><br><span class="line">)(<span class="number">2</span>); <span class="comment">// =&gt;15</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h1&gt;&lt;h2 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>IP</title>
    <link href="http://yoursite.com/2019/10/13/IP/"/>
    <id>http://yoursite.com/2019/10/13/IP/</id>
    <published>2019-10-13T07:41:22.000Z</published>
    <updated>2019-11-10T14:37:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p>IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“<strong>实现终端节点之间的通信</strong>”。这种终端节点之间的通信也叫“点对点通信”。</p><p>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p><p><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></p><h2 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h2><p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhns2grvj30lc0eojse.jpg" alt="img"></p><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhmr7ldbj30fk0dz751.jpg" alt="img"></p><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸。</strong></p><h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhpvepe5j30lg0lkdis.jpg" alt="img"></p><ol><li>应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li><li>TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li><li>IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li><li>网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li><li>网络接口（以太网驱动）的处理<br>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li><li>IP 模块的处理<br>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li><li>TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li><li>应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li></ol><h2 id="IP-服务的主要特点"><a href="#IP-服务的主要特点" class="headerlink" title="IP 服务的主要特点"></a>IP 服务的主要特点</h2><p>IP 协议为上层协议提供无状态、无连接、不可靠的服务。</p><ul><li><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6></li></ul><p>无状态是指 IP 通信双方不同步传输数据的状态信息，所有 IP 数据报的发送、传输、接受都是相互独立、没有上下文关系的。这种服务优点在于简单、高效。最大的缺点是无法处理乱序和重复的 IP 数据报，确保 IP 数据报完整的工作只能交给上层协议来完成。</p><ul><li><h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6></li></ul><p>无连接是指 IP 通信双方都不长久地维持对方的任何信息。上层协议每次发送数据的时候，都需要明确指出对方的 IP 地址。</p><ul><li><h6 id="不可靠"><a href="#不可靠" class="headerlink" title="不可靠"></a>不可靠</h6></li></ul><p>不可靠是指 IP 协议不能保证 IP 数据报准确到达接收端，它指承诺尽最大努力交付。IP 模块一旦检测到数据报发送失败，就通知上层协议，而不会试图重传。</p><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><h3 id="IP-地址概述"><a href="#IP-地址概述" class="headerlink" title="IP 地址概述"></a>IP 地址概述</h3><ul><li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li><li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“<strong>连接到网络中的所有主机中识别出进行通信的目标地址</strong>”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li><li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li><li>IP 地址（IPv4 地址）由 32 位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将 32 位的 IP 地址以每 8 位为一组，分成 4 组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li></ul><table><thead><tr><th>2^8</th><th>2^8</th><th>2^8</th><th>2^8</th><th></th></tr></thead><tbody><tr><td>10101100</td><td>00010100</td><td>00000001</td><td>00000001</td><td>（2 进制）</td></tr><tr><td>172.</td><td>20.</td><td>1.</td><td>1</td><td>（10 进制）</td></tr></tbody></table><h3 id="IP-地址由网络和主机两部分标识组成"><a href="#IP-地址由网络和主机两部分标识组成" class="headerlink" title="IP 地址由网络和主机两部分标识组成"></a>IP 地址由网络和主机两部分标识组成</h3><ul><li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 <strong>IP 地址具有了唯一性</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l2qlpa6j30k80hiwhe.jpg" alt="img"></p><ul><li>如下图，IP 包被转发到途中某个路由器时，正是<strong>利用目标 IP 地址的网络标识进行路由</strong>。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l4my99cj30k40auabx.jpg" alt="img"></p><h3 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h3><p><strong>IP 地址分为四个级别，分别为 A 类、B 类、C 类、D 类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></p><ul><li><strong>A 类 IP 地址是首位以 “0” 开头的地址。</strong>从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 16,777,214 个。</li><li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 65,534 个。</li><li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 254 个。</li><li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li><li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li></ul><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><ul><li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li><li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li></ul><h3 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h3><ul><li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p></li><li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l8g7veoj30f70jjn02.jpg" alt="img"></p></li><li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</p></li><li><p>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p></li></ul><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li><li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li><li>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr></tbody></table><ul><li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th><th>/ 26</th></tr></thead><tbody><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td><td>/ 26</td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td><td>/ 26</td></tr></tbody></table><ul><li>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。</li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li><li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li><li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li></ul><h3 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h3><ul><li>IP 地址的网络地址部分用于进行路由控制。</li><li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li><li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70ldgjh6gj30ka0gen0n.jpg" alt="img"></p><h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>路由匹配顺序：<br>1） 直接匹配，查找路由表中是否由与目标 IP 地址完全匹配的主机 IP 地址，找到则匹配成功，没有的话转 2；<br>2）查找是否有与目标 IP 地址具有相同网络 ID 的 IP 地址，找到则匹配成功，没有的话转 3；<br>3）查看是否有默认网关，有则转发给它，没有的话，路由查找失败，由 ICMP 返回错误信息。</p><h3 id="路由更新"><a href="#路由更新" class="headerlink" title="路由更新"></a>路由更新</h3><p>通过 route 命令或其他工具可以手工修改路由表，是静态路由更新方式。对于大型路由器，它们通常通过 BGP、RIP、OSPF 等协议进行动态路由更新。</p><h2 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h2><ul><li>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li><li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li><li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li></ul><h3 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h3><ul><li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li><li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li><li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li></ul><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="IPv4-头部"><a href="#IPv4-头部" class="headerlink" title="IPv4 头部"></a>IPv4 头部</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lsqccjaj30eh064dge.jpg" alt="img"></p><ul><li><h6 id="头部长度"><a href="#头部长度" class="headerlink" title="头部长度"></a>头部长度</h6></li></ul><p>标识该 IP 头部有多少个 32 位 bit 字（4 字节），由于 4 位最大描述 15，所以 IP 头部最大长度为 60 字节。</p><ul><li><h6 id="8-为服务位"><a href="#8-为服务位" class="headerlink" title="8 为服务位"></a>8 为服务位</h6></li></ul><p>包括 3 位优先权位，4 为 TOS 字段和 1 位保留字段。<br>4 为 TOS 字段分别表示：最小延时，最大吞吐量、最高可靠性和最小费用。其中最多能选择一位置 1，应用程序根据实际需要来设置服务类型。</p><ul><li><h6 id="16-位标识"><a href="#16-位标识" class="headerlink" title="16 位标识"></a>16 位标识</h6></li></ul><p>唯一标识主机发送的每一个数据报。其初始值由系统随机生成；每发一个数据报就加 1。每个分片中具有相同的标识值。</p><ul><li><h6 id="分片偏移"><a href="#分片偏移" class="headerlink" title="分片偏移"></a>分片偏移</h6></li></ul><p>有 3 位用于标识偏移，第一位保留，第二位 DF 字段（禁止分片标识），第三位 MF 字段（更多分片标识，最后一个分片为 0，其他分片置 1）。13 位偏移是勇敢将实际值左移三位得到的，因此要求数据部分的长度是 8 的倍数。</p><ul><li><h6 id="8-位协议"><a href="#8-位协议" class="headerlink" title="8 位协议"></a>8 位协议</h6></li></ul><p>标识上层协议，1 是 ICMP，6 是 TCP，17 是 UDP。</p><ul><li><h6 id="16-位头部校验和"><a href="#16-位头部校验和" class="headerlink" title="16 位头部校验和"></a>16 位头部校验和</h6></li></ul><p>IP 模块接受数据后，首先对数据报头部做 CRC 校验，确保 IP 头部在传输过程中无损坏后，再分析其头部具体信息。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</p><p>IPv6 协议并不是 IPv4 的简单扩展，而是完全独立的协议。从以太网帧封装的数据类型来看，前者类型是 0X86dd，后者是 0x8600，是完全不同的类型。</p><p>IPv6 解决了网络地址不足的问题，其头部增加了多播和流的功能，引入了自动配置功能，还增加了网络安全的功能。</p><h3 id="IPv6-头部固定部分"><a href="#IPv6-头部固定部分" class="headerlink" title="IPv6 头部固定部分"></a>IPv6 头部固定部分</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lv0wgqij30em05ydg6.jpg" alt="img"></p><ul><li><h6 id="流标签"><a href="#流标签" class="headerlink" title="流标签"></a>流标签</h6></li></ul><p>是 IPv6 新增加的字段，用于对某些连接的服务质量有特殊要求的通信，比如音频或者视频等实时数据传递。</p><ul><li><h6 id="下一个包头"><a href="#下一个包头" class="headerlink" title="下一个包头"></a>下一个包头</h6></li></ul><p>指出紧跟 IPv6 固定头部后的包头类型，如拓展头，或者某个上层协议头（ICMP，TCP，UDP），它类似 IPv4 中的协议字段，且相同的取值具有相同的含义。</p><h3 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h3><ul><li>IP 得知的扩大与路由控制表的聚合。</li><li>性能提升。包首部长度采用固定的值（40 字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li><li>支持即插即用功能。即使没有 DHCP 服务器也可以实现自动分配 IP 地址。</li><li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li><li>多播、Mobile IP 成为扩展功能。</li></ul><h3 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h3><ul><li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li><li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li></ul><h3 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h3><ul><li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li><li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li></ul><table><thead><tr><th>未定义</th><th>0000 … 0000（128 比特）</th><th>：：/ 128</th></tr></thead><tbody><tr><td>环回地址</td><td>0000 … 0001（128 比特）</td><td>：：1 / 128</td></tr><tr><td>唯一本地地址</td><td>1111 110</td><td>FC00：/ 7</td></tr><tr><td>链路本地单播地址</td><td>1111 1110 10</td><td>FE80：：/ 10</td></tr><tr><td>多播地址</td><td>1111 1111</td><td>FF00：：/ 8</td></tr><tr><td>全局单播地址</td><td>（其他）</td><td></td></tr></tbody></table><h3 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h3><ul><li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li><li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lktamkvj30lt08qmxq.jpg" alt="img"></p><h3 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h3><p>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70llnrbecj30lg052weo.jpg" alt="img"></p><h3 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h3><ul><li>唯一本地地址是不进行互联网通信时所用的地址。</li><li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li><li>L 通常被置为 1</li><li>全局 ID 的值随机决定</li><li>子网 ID 是指该域子网地址</li><li>接口 ID 即为接口的 ID</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lmkuopyj30ms053mxf.jpg" alt="img"></p><h3 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h3><ul><li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li><li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li></ul><h3 id="IP-首部（暂略）"><a href="#IP-首部（暂略）" class="headerlink" title="IP 首部（暂略）"></a>IP 首部（暂略）</h3><h2 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h2><p>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li><li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul><li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li><li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li><li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li></ul><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul><li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li><li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li></ul><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><ul><li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li><li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li><li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li></ul><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><ul><li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li><li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li><li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li></ul><h3 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lqkzre9j30ht04caaa.jpg" alt="img"></p><ul><li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li><li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li><li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP&quot;&gt;&lt;a href=&quot;#IP&quot; class=&quot;headerlink&quot; title=&quot;IP&quot;&gt;&lt;/a&gt;IP&lt;/h1&gt;&lt;p&gt;IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“&lt;strong&gt;实现终端节点之间的通信&lt;/s
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Http/1.0的Keep-Alive和Http/2.0的多路复用对比</title>
    <link href="http://yoursite.com/2019/10/04/Http1.0%E7%9A%84Keep-Alive%E5%92%8CHttp2.0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AF%B9%E6%AF%94%20copy/"/>
    <id>http://yoursite.com/2019/10/04/Http1.0的Keep-Alive和Http2.0的多路复用对比 copy/</id>
    <published>2019-10-04T08:14:38.000Z</published>
    <updated>2019-11-10T14:37:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比"><a href="#Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比" class="headerlink" title="Http/1.0 的 Keep-Alive 和 Http/2.0 的多路复用对比"></a>Http/1.0 的 Keep-Alive 和 Http/2.0 的多路复用对比</h1><h2 id="Http-1-0-的-Keep-Alive"><a href="#Http-1-0-的-Keep-Alive" class="headerlink" title="Http/1.0 的 Keep-Alive"></a>Http/1.0 的 Keep-Alive</h2><p>在没有<code>Keep-Alive</code>前，我们与服务器请求数据的流程是这样：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nsz9l0hxj30ac0caq3x.jpg" alt="clipboard.png"></p><ul><li>浏览器请求<code>//static.mtime.cn/a.js</code>–&gt;解析域名–&gt;HTTP 连接–&gt;服务器处理文件–&gt;返回数据–&gt;浏览器解析、渲染文件</li><li>浏览器请求<code>//static.mtime.cn/b.js</code>–&gt;解析域名–&gt;HTTP 连接–&gt;服务器处理文件–&gt;返回数据–&gt;浏览器解析、渲染文件</li><li>…</li><li>这样循环下去，直至全部文件下载完成。</li></ul><p>这个流程最大的问题就是：<strong>每次请求都会建立一次 HTTP 连接</strong>，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次建立连接是正常的，以后就占用这个通道，下载其他文件，这样效率多高啊！你猜对了，这就是<code>Keep-Alive</code>。</p><h3 id="Keep-Alive解决的问题"><a href="#Keep-Alive解决的问题" class="headerlink" title="Keep-Alive解决的问题"></a><code>Keep-Alive</code>解决的问题</h3><p><code>Keep-Alive</code>解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的<strong>一定时间</strong>是可以配置的，不管你用的是<code>Apache</code>还是<code>nginx</code>。</p><h3 id="HTTP1-1还是存在效率问题"><a href="#HTTP1-1还是存在效率问题" class="headerlink" title="HTTP1.1还是存在效率问题"></a><code>HTTP1.1</code>还是存在效率问题</h3><p>如上面所说，在<code>HTTP1.1</code>中是默认开启了<code>Keep-Alive</code>，他解决了多次连接的问题，但是依然有两个效率上的问题：</p><ul><li>第一个：<strong>串行的文件传输</strong>。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</li><li>第二个：<strong>连接数过多</strong>。我们假设<code>Apache</code>设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。</li></ul><h2 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h2><p>HTTP/2 的多路复用就是为了解决上述的两个性能问题，我们来看一下，他是如何解决的。</p><ul><li>解决第一个：在<code>HTTP1.1</code>的协议中，我们传输的<code>request</code>和<code>response</code>都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：<code>hello world</code>，只能从<code>h</code>到<code>d</code>一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在<code>HTTP1.1</code>是不能实现的。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nszfhktpj30kp05lmxt.jpg" alt="clipboard.png"></p><p><code>HTTP/2</code>引入<code>二进制数据帧</code>和<code>流</code>的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是<code>流</code>所做的事情。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nszichcoj30fm0aft9y.jpg" alt="clipboard.png"></p><ul><li>解决第二个问题：<code>HTTP/2</code>对同一域名下所有请求都是基于<code>流</code>，也就是说同一域名不管访问多少文件，也只<strong>建立一路连接</strong>。同样<code>Apache</code>的最大连接数为 300，因为有了这个新特性，最大的并发就可以提升到 300，比原来提升了 6 倍！</li></ul><h2 id="多路复用和-keep-alive-区别？"><a href="#多路复用和-keep-alive-区别？" class="headerlink" title="多路复用和 keep alive 区别？"></a><strong>多路复用和 keep alive 区别？</strong></h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nt1pb7xkj30ln0l940f.jpg" alt="img"></p><p>1）线头阻塞（Head-of-Line Blocking），HTTP1.X 虽然可以采用 keep alive 来解决复用 TCP 的问题，但是还是无法解决请求阻塞问题。</p><p>2）所谓请求阻塞意思就是一条 TCP 的 connection 在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。</p><p>3）之所以有这个问题就是因为 HTTP1.x 需要每条请求都是可是识别，按顺序发送，否则 server 就无法判断该相应哪个具体的请求。</p><p>4）HTTP2 采用多路复用是指，在同一个域名下，开启一个 TCP 的 connection，每个请求以 stream 的方式传输，每个 stream 有唯一标识，connection 一旦建立，后续的请求都可以复用这个 connection 并且可以同时发送，server 端可以根据 stream 的唯一标识来相应对应的请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比&quot;&gt;&lt;a href=&quot;#Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比&quot; class=&quot;headerlink&quot; title=&quot;Http/1.0 的 K
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS 清除浮动</title>
    <link href="http://yoursite.com/2019/09/29/CSS%20%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/09/29/CSS 清除浮动/</id>
    <published>2019-09-29T07:26:33.000Z</published>
    <updated>2019-11-10T14:37:39.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-清除浮动"><a href="#CSS-清除浮动" class="headerlink" title="CSS 清除浮动"></a>CSS 清除浮动</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tbm9sca0j30op0fh0tp.jpg" alt="img"></p><h2 id="浮动是什么？"><a href="#浮动是什么？" class="headerlink" title="浮动是什么？"></a>浮动是什么？</h2><p>W3school 中给出的浮动定义为<strong>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</strong>由于浮动框脱离文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p><h2 id="浮动的特点"><a href="#浮动的特点" class="headerlink" title="浮动的特点"></a>浮动的特点</h2><p>浮动的特点，可以用八个字总结：<strong>脱标、贴边、字围和收缩。</strong></p><p>为了更好说明，请看下图：<br>当框 1 向左浮动时，它脱离文档流（<strong>脱标</strong>）并且向左移动（<strong>贴边</strong>），直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果框 2 中有文字，就会围着框 1 排开（<strong>字围</strong>）。</p><p>如果把所有三个框都向左浮动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tc3n56n2j30em06haa4.jpg" alt="img"><br>下面着重讲解下第四个特点–<strong>收缩</strong></p><p>一个浮动的内联元素（比如 span img 标签）不需要设置 display：block 就可以设置宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      background-color: greenyellow;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    这是一段文字</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到以下的效果：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tc6sc8yzj30qo01ft8h.jpg" alt="img"><br>我们都知道 div 标签是块级元素，会独占一行，然而上面的例子中将 div 设置为左浮后，其宽度不再是占满一行，而是收紧为内部元素的宽度，这就是浮动第四个特征的含义。</p><h2 id="浮动的缺点"><a href="#浮动的缺点" class="headerlink" title="浮动的缺点"></a>浮动的缺点</h2><p>先看下面这段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">      border: solid 5px;</span><br><span class="line">      width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background-color: red;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background-color: greenyellow;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想让父容器包裹着三个浮动元素，然而事与愿违，得到却是这样的结果：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tcc3apdwj30920393yb.jpg" alt="img"><br><strong>这就是浮动带来副作用—-父容器高度塌陷，于是清理浮动就显着至关重要。</strong></p><h2 id="清理浮动"><a href="#清理浮动" class="headerlink" title="清理浮动"></a>清理浮动</h2><p><strong>清除浮动不是不用浮动，是清除浮动产生的父容器高度塌陷</strong>。</p><h3 id="套路-1：给浮动元素的父元素添加高度（扩展性不好）"><a href="#套路-1：给浮动元素的父元素添加高度（扩展性不好）" class="headerlink" title="套路 1：给浮动元素的父元素添加高度（扩展性不好）"></a>套路 1：给浮动元素的父元素添加高度（扩展性不好）</h3><p>如果一个元素要浮动，那么它的父元素一定要有高度。高度的盒子，才能关住浮动。可以通过直接给父元素设置 height，实际应用中我们不大可能给所有的盒子加高度，不仅麻烦，并且不能适应页面的快速变化；另外一种，父容器的高度可以通过内容撑开（比如 img 图片），实际当中此方法用的比较多。</p><h3 id="套路-2：clear-both"><a href="#套路-2：clear-both" class="headerlink" title="套路 2：clear:both;"></a>套路 2：clear:both;</h3><p>在最后一个子元素后新添加一个冗余元素，然后将其设置 clear:both,这样就可以清除浮动。这里强调一点，即<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear: both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="套路-3：伪元素清除浮动"><a href="#套路-3：伪元素清除浮动" class="headerlink" title="套路 3：伪元素清除浮动"></a>套路 3：伪元素清除浮动</h3><p>上面那种办法固然可以清除浮动，但是我们不想在页面中添加这些没有意义的冗余元素，此时如何清除浮动吗？<br><strong>结合 :after 伪元素和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*开启haslayout*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ie6 7不支持伪元素*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">  visibility: hidden; //允许浏览器渲染它，但是不显示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给浮动元素的父容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素，实现元素末尾添加一个看不见的块元素来清理浮动。这是通用的清理浮动方案，推荐使用</p><h3 id="套路-4：给父元素使用-overflow-hidden"><a href="#套路-4：给父元素使用-overflow-hidden" class="headerlink" title="套路 4：给父元素使用 overflow:hidden;"></a>套路 4：给父元素使用 overflow:hidden;</h3><p>这种方案让父容器形成了 BFC（块级格式上下文），而 BFC 可以包含浮动，通常用来解决浮动父元素高度坍塌的问题。</p><p><strong>BFC 的触发方式</strong></p><p>我们可以给父元素添加以下属性来触发 BFC：</p><ul><li>float 为 left | right</li><li>overflow 为 hidden | auto | scorll</li><li>display 为 table-cell | table-caption | inline-block</li><li>position 为 absolute | fixed</li></ul><p>这里可以给父元素设置 overflow:auto，但是为了兼容 IE 最好使用 overflow:hidden。</p><p><strong>但这种办法有个缺陷：如果有内容出了盒子，用这种方法就会把多的部分裁切掉，所以这时候不能使用。</strong></p><p><strong>BFC 的主要特征:</strong></p><ul><li>BFC 容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的 BFC 来解决垂直边距折叠问题。</li><li>BFC 不会重叠浮动元素</li><li>BFC 可以包含浮动,这可以清除浮动。</li></ul><h3 id="套路-5：br-标签清浮动"><a href="#套路-5：br-标签清浮动" class="headerlink" title="套路 5：br 标签清浮动"></a>套路 5：br 标签清浮动</h3><p><strong>br 标签存在一个属性：clear。这个属性就是能够清除浮动的利器，在 br 标签中设置属性 clear，并赋值 all。即能清除掉浮动</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> <span class="attr">clear</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-清除浮动&quot;&gt;&lt;a href=&quot;#CSS-清除浮动&quot; class=&quot;headerlink&quot; title=&quot;CSS 清除浮动&quot;&gt;&lt;/a&gt;CSS 清除浮动&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8m
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="清除浮动" scheme="http://yoursite.com/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>git merge和git rebase的区别</title>
    <link href="http://yoursite.com/2019/09/21/git%20merge%E5%92%8Cgit%20rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/09/21/git merge和git rebase的区别/</id>
    <published>2019-09-21T14:53:17.000Z</published>
    <updated>2019-09-21T14:54:12.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h1><p>git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wkw4uh2dj30xc0qtjsl.jpg" alt="img"></p><p>为了将master 上新的提交合并到你的feature分支上，你有两种选择：<code>merging</code> or <code>rebase</code></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master feature</span><br></pre></td></tr></table></figure><p>那么此时在feature上git 自动会产生一个新的commit(merge commit)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wky69tunj30w90850te.jpg" alt="img"></p><h3 id="git-merge-有如下特点："><a href="#git-merge-有如下特点：" class="headerlink" title="git merge 有如下特点："></a><code>git merge</code> 有如下特点：</h3><ul><li>只处理一次冲突，如果合并的时候遇到冲突，仅需要修改后重新commit</li><li>引入了一次合并的历史记录，合并后的所有 <code>commit</code> 会按照提交时间从旧到新排列</li><li>所有的过程信息更多，可能会提高之后查找问题的难度</li></ul><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>记录了真实的commit情况，包括每个分支的详情</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>与 <code>git merge</code> 一致，<code>git rebase</code> 的目的也是将一个分支的更改并入到另外一个分支中去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>本质是<strong>变基 变基 变基</strong></p><p>变基是什么? <code>找公共祖先</code></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wl0azimrj30wx0823zd.jpg" alt="img"></p><h3 id="rebase-特点："><a href="#rebase-特点：" class="headerlink" title="rebase 特点："></a>rebase 特点：</h3><ul><li>改变当前分支从 <code>master</code>上拉出分支的位置</li><li>没有多余的合并历史的记录，会合并之前的commit历史，且合并后的 <code>commit</code>顺序不一定按照 <code>commit</code>的提交时间排列</li><li>可能会多次解决同一个地方的冲突（有 <code>squash</code>来解决）</li><li>更清爽一些，<code>master</code>分支上每个 <code>commit</code>点都是相对独立完整的功能单元</li></ul><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>得到更简洁的项目历史，去掉了merge commit</p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>如果合并出现代码问题不容易定位，因为rewrite了history</p><h3 id="合并时遇到冲突："><a href="#合并时遇到冲突：" class="headerlink" title="合并时遇到冲突："></a>合并时遇到冲突：</h3><p>合并时如果出现冲突需要按照如下步骤解决</p><ul><li>修改冲突部分</li><li>git add</li><li><code>git rebase --continue</code></li><li>（如果第三步无效可以执行 <code>git rebase --skip</code>）</li></ul><p>不要在git add 之后习惯性的执行 git commit命令</p><h3 id="git-rebase-的交互模式"><a href="#git-rebase-的交互模式" class="headerlink" title="git rebase 的交互模式"></a>git rebase 的交互模式</h3><p>打开变基的交互模式只需要传入一个参数 <code>-i</code> 即可，同时还需要指定对哪些提交进行处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p>上述命令指定了对当前分支的最近四次提交进行操作。下面我们使用上面这行命令将 <code>feature</code> 分支的提交合并。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wl7ji36xj30wi0gpq67.jpg" alt="img"></p><p>中间红框内有一些命令，可以用来处理某次提交的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果你想要一个干净的，没有merge commit的线性历史树，或者当发现自己修改某个功能时，频繁进行了<code>git commit</code>提交时，发现其实过多的提交信息没有必要时，那么你应该选择git rebase</li><li>当需要保留详细的合并信息的时候建议使用<code>git merge</code>，特别是需要将分支合并进入<code>master</code>分支时，并且想要避免重写commit history的风险，你应该选择使用git merge</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-merge和git-rebase的区别&quot;&gt;&lt;a href=&quot;#git-merge和git-rebase的区别&quot; class=&quot;headerlink&quot; title=&quot;git merge和git rebase的区别&quot;&gt;&lt;/a&gt;git merge和git reb
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浏览器同域名请求的最大并发数限制</title>
    <link href="http://yoursite.com/2019/09/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E5%9F%9F%E5%90%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%95%B0%E9%99%90%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/14/浏览器同域名请求的最大并发数限制/</id>
    <published>2019-09-14T15:14:44.000Z</published>
    <updated>2019-11-10T14:37:39.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器同域名请求的最大并发数限制"><a href="#浏览器同域名请求的最大并发数限制" class="headerlink" title="浏览器同域名请求的最大并发数限制"></a>浏览器同域名请求的最大并发数限制</h1><p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p><p>如果同时只有 2 个并发连接数数量，那网页打开的时候只能依赖于这 2 条线程，前面如果有打开慢的内容，就会直接影响到后面的内容打开。但是如果同时有更多的并发连接数，这样就会大大的提高网页加载速度。但是浏览器的并发连接数也并非越大越好。</p><p>HTTP 客户端一般对同一个服务器的并发连接个数都是有限制的。实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p><h2 id="主流浏览器最大并发连接数"><a href="#主流浏览器最大并发连接数" class="headerlink" title="主流浏览器最大并发连接数"></a>主流浏览器最大并发连接数</h2><p>一些主流浏览器对 HTTP 1.1 和 HTTP 1.0 的最大并发连接数目，可以参考如下表格：</p><table><thead><tr><th>浏览器</th><th>HTTP / 1.1</th><th>HTTP / 1.0</th></tr></thead><tbody><tr><td>IE 11</td><td>6</td><td>6</td></tr><tr><td>IE 10</td><td>6</td><td>6</td></tr><tr><td>IE 9</td><td>10</td><td>10</td></tr><tr><td>IE 8</td><td>6</td><td>6</td></tr><tr><td>IE 6,7</td><td>2</td><td>4</td></tr><tr><td>火狐</td><td>6</td><td>6</td></tr><tr><td>Safari 3,4</td><td>4</td><td>4</td></tr><tr><td>Chrome 4+</td><td>6</td><td>6</td></tr><tr><td>歌剧 9.63,10.00alpha</td><td>4</td><td>4</td></tr><tr><td>Opera 10.51+</td><td>8</td><td>？</td></tr><tr><td>iPhone 2</td><td>4</td><td>？</td></tr><tr><td>iPhone 3</td><td>6</td><td>？</td></tr><tr><td>iPhone 4</td><td>4</td><td>？</td></tr><tr><td>iphone 5</td><td>6</td><td>？</td></tr><tr><td>Android2-4</td><td>4</td><td>？</td></tr></tbody></table><h3 id="Firefox-浏览器的最大并发连接数"><a href="#Firefox-浏览器的最大并发连接数" class="headerlink" title="Firefox 浏览器的最大并发连接数"></a>Firefox 浏览器的最大并发连接数</h3><p>在 Firefox 中的地址栏输入“about：config 中”，然后搜索并修改如下两个配置项目即可：</p><ul><li><code>network.http.max-persistent-connections-per-server:6</code>连接同一个服务器允许的最大持久连接数，默认为 6，可以不用更改。</li><li><code>network.http.max-persistent-connections-per-proxy:8</code>每个代理服务器允许的最大持久连接数,公司用户使用代理服务器，但是外面的客户一般不使用代理，火狐推荐的每台代理服务器设置为：&lt;= 10。</li></ul><h4 id="Firefox3-6"><a href="#Firefox3-6" class="headerlink" title="Firefox3.6"></a>Firefox3.6</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbxx2j6tj30fq06faa1.jpg" alt="img"></p><p>和 IE8 的几乎完全一样：</p><ul><li>最大并发 HTTP 连接数为 6 个（可在 about:config 中修改）。</li><li>javascript 文件不会阻塞其他资源的加载，多个 javascript 文件可以一起加载。</li><li>会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。</li></ul><h4 id="Firefox4-beta12"><a href="#Firefox4-beta12" class="headerlink" title="Firefox4 beta12"></a>Firefox4 beta12</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jby0whawj30fv07n3yj.jpg" alt="img"></p><p>不知是因为设计理念上的不同，还是因为 beta 版未照顾到这一块，Firefox4 反而退化了，和 Firefox3.6 的区别主要体现在对资源类型的处理上，Firefox4 不再严格地优先下载 script 和 link 标签定义的外部资源，而是按照 HTML 结构中出现的顺序来进行加载。</p><h3 id="IE-浏览器的最大并发连接数"><a href="#IE-浏览器的最大并发连接数" class="headerlink" title="IE 浏览器的最大并发连接数"></a>IE 浏览器的最大并发连接数</h3><p>用“注册表编辑器”命令打开注册表编辑器，找到：</p><p>[HKEY_CURRRENT_USER \ Software \ Microsoft \ Windows \ CurrentVersion \ Internet Settings]，可以看到<strong>MaxConnectionsPerServer</strong>和<strong>MaxConnectionsPer1_0Server</strong>这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置）</p><p><strong>对于 IE 9</strong></p><p>[HKEY_CURRRENT_USER \ Software \ Policies \ Microsoft \ Internet Exploer \ Main \ FeatureControl，可以看到<strong>FEATURE_MAXCONNECTIONSPER1_0SERVER</strong>和<strong>FEATURE_MAXCONNECTIONSPERSERVER</strong>这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置）</p><h4 id="IE8"><a href="#IE8" class="headerlink" title="IE8"></a>IE8</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbx8rdwaj30g407pweh.jpg" alt="img"></p><p>和 IE6 完全不同的瀑布图，其特点有：</p><ul><li>最大并发 HTTP 连接数为 6 个。</li><li>javascript 文件已经不会阻塞其他资源的加载，甚至多个 javascript 文件可以一起加载，并且会保证执行的顺序。</li><li>会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。</li></ul><h3 id="chrome-浏览器的最大并发连接数"><a href="#chrome-浏览器的最大并发连接数" class="headerlink" title="chrome 浏览器的最大并发连接数"></a>chrome 浏览器的最大并发连接数</h3><h4 id="Chrome8"><a href="#Chrome8" class="headerlink" title="Chrome8"></a>Chrome8</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbzcty9xj30fw07zwef.jpg" alt="img"></p><p>Chrome 自带的工具不能很清楚地表示各请求的开始时间，所以使用了 Fiddler 的瀑布图，从图上可以看出，Chrome 也是比较特立独行的一位，其特点有：</p><ul><li>最大并发 HTTP 连接数为 6。</li><li>head 部分的资源会单独下载，且阻塞 body 中的其他资源的加载。</li><li>会优先加载 script 和 link 标签定义的资源。</li></ul><h3 id="opera-浏览器的最大并发连接数"><a href="#opera-浏览器的最大并发连接数" class="headerlink" title="opera 浏览器的最大并发连接数"></a>opera 浏览器的最大并发连接数</h3><h4 id="Opera11"><a href="#Opera11" class="headerlink" title="Opera11"></a>Opera11</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbzixw3tj30fj0813yh.jpg" alt="img"></p><p>先报怨一下，Dragonfly 不怎么好用来着……Opera 的资源加载也比较有特色，而且很难看出规律，只能大致总结一下：</p><ul><li>Opera 的最大并发 HTTP 连接数默认为 16，可在 opera:config - Performance - Max Connections Server 查看和修改。</li><li>javascript 文件的加载会阻塞其他 script 和 link 标签定义的外部资源的加载，如图中的 2.js。但不会阻塞图片等其他资源的加载，如图中的 3.js。</li><li>会一定程度上对资源的优先级进行优化，但由于 javascript 文件要阻止后续部分资源的加载，又为了充分利用最大 HTTP 连接数，因此不能严格先加载所有的 script 和 link 标签定义的资源，导致瀑布图上各类型资源有相互穿插，难寻规律。</li></ul><h2 id="HTTP-连接请求与线程"><a href="#HTTP-连接请求与线程" class="headerlink" title="HTTP 连接请求与线程"></a>HTTP 连接请求与线程</h2><p>HTTP 连接是复杂，有状态的对象，所以它必须被妥善管理。<strong>一个 HTTP 连接请求在同一时间只能被一个线程访问。</strong></p><p>HttpClient 使用一个叫做的 Http 连接管理器的特殊实体类来管理的 Http 连接。Http 连接管理器在新建的 HTTP 连接时，作为工厂类；管理持久的 http 连接的生命周期；同步持久连接（确保线程安全，即一个 HTTP 连接同一时间只能被一个线程访问）。</p><p>如果一个的 Http 连接被释放或者被它的消费者明确表示要关闭，那么底层的连接就会和它的代理进行分离，并且该连接会被交还给连接管理器。这是，即使服务消费者仍然持有代理的引用，它也不能再执行 I / O 操作，或者更改的 Http 连接的状态。</p><h3 id="连接池管理器"><a href="#连接池管理器" class="headerlink" title="连接池管理器"></a>连接池管理器</h3><p>连接池管理器是个复杂的类，它管理着连接池，可以同时为很多线程提供 HTTP 连接请求。当请求一个新的连接时，如果连接池有有可用的持久连接，连接管理器就会使用其中的一个，而不是再创建一个新的连接。</p><p>当使用了请求连接池管理器后，HttpClient 的就可以同时执行多个线程的请求了。</p><p>连接池管理器会根据它的配置来分配请求连接。如果连接池中的所有连接都被占用了，那么后续的请求就会被阻塞，直到有连接被释放回连接池中。</p><h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p>线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：</p><p>线程池在还没有任务到来之前，创建一定数量的线程，放入空闲队列中。这些线程都是处于睡眠状态，即均为启动，不消耗 CPU，而只是占用较小的内存空间。当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。</p><p>线程池能节约大量的的系统资源，使得更多的 CPU 时间和内存用来处理实际的商业应用，而不是频繁的线程创建与销毁</p><p>每个线程需要大约 1MB 内存，线程开的越多，消耗的内存也就越大。</p><p>在什么情况下使用线程池：</p><ol><li>单个任务处理的时间比较短</li><li>将需处理的任务的数量大</li></ol><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池（简单说：在一个“池”里放了好多半成品的数据库联接对象），由应用程序动态地对池中的连接进行申请，使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。<br>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量，使用情况等。</p><p>1）最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费;<br>2）最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p><p><strong>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。</strong>一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。</p><h3 id="WebSphere-Application-Server-性能"><a href="#WebSphere-Application-Server-性能" class="headerlink" title="WebSphere Application Server 性能"></a>WebSphere Application Server 性能</h3><p><a href="http://websphere.sys-con.com/node/46514/print" target="_blank" rel="noopener">http://websphere.sys-con.com/node/46514/print</a></p><p>构建服务器应用程序的一个过于简单的模型是：每当一个请求到达就创建一个新的服务对象，然后在新的服务对象中为服务请求，但当有大量请求并发访问时，服务器不断的创建和销毁对象的开销很大。</p><p>在面向对象的编程中，创建和销毁对象是很浪费资源的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 的中更是如此，虚拟机试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以，提高程序效率的一个手段就是尽可能减少创建和销毁对象的次数。利用已有的对象来服务就是“池化资源”技术产生的原因。</p><p><strong>HTTP 侦听器</strong><br>HTTP 侦听器负责在 HTTP 服务器级别创建线程。这里发生的大多数处理是静态页面服务，或 HTTP post / GET 传递命令到后端。这是必须考虑的第一级线程配置。</p><p><strong>Web 容器</strong><br>Web 容器负责在应用程序服务器级别创建线程池。此级别的大多数处理包括 servlet，JSP，EJB，动态页面创建和后端传递处理。Web 容器是必须配置的第二级线程池配置。</p><p><strong>ORB 容器</strong> ORB 容器负责在对象级创建线程池。这里发生的大部分处理包括处理基于非 Web 的客户端。ORB 容器是必须配置的线程池配置的第三级。</p><p><strong>数据源</strong><br>数据源级负责创建从数据库或“传统”系统访问的连接线程。这些线程是必须解决的第四级配置</p><h3 id="WAS-线程池数与-IHS-server"><a href="#WAS-线程池数与-IHS-server" class="headerlink" title="WAS 线程池数与 IHS server"></a>WAS 线程池数与 IHS server</h3><p>假定一个浏览器的并发连接请求数为 10，通常同一时间内会有多个用户并发访问网站。又考虑到，一个 Http 连接请求在同一时间只能被一个线程访问。所以，IHS 服务器的 httpd.conf 里的 maxclients（允许建立的总线程数）要能够处理峰值时刻的浏览器连接请求才行。同时，考虑不是所有的连接请求都会到 was server，有的连接只是为了在 web 服务器上取静态资源，所以，was 上的线程池数目（Thread pools ：50 ）会远小于 IHS server 上的 maxclients 值譬如 400）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浏览器同域名请求的最大并发数限制&quot;&gt;&lt;a href=&quot;#浏览器同域名请求的最大并发数限制&quot; class=&quot;headerlink&quot; title=&quot;浏览器同域名请求的最大并发数限制&quot;&gt;&lt;/a&gt;浏览器同域名请求的最大并发数限制&lt;/h1&gt;&lt;p&gt;当我们在浏览网页的时候，对浏
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端优化</title>
    <link href="http://yoursite.com/2019/09/08/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/08/前端优化/</id>
    <published>2019-09-08T15:48:15.000Z</published>
    <updated>2019-11-10T14:37:39.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h1><h2 id="前端性能衡量指标"><a href="#前端性能衡量指标" class="headerlink" title="前端性能衡量指标"></a>前端性能衡量指标</h2><ul><li><strong>白屏时间</strong> 该时间点表示浏览器开始绘制页面，在此之前页面都是白屏，也称为开始渲染时间</li><li><strong>首屏时间</strong> 该时间点表示用户看到第一屏页面的时间</li><li><strong>用户可交互时间</strong> 也叫 DOM Ready,该时间点表示 DOM 解析完成，资源还没有完成，这个时候用户与页面可以交互了</li><li><strong>完全加载时间</strong> 该时间点是 window.onload 时间触发的时间，表示原始文档和所用引用的内容已经加载完成，用户最明显的感觉就是浏览器 tab 上 loading 状态结束</li><li><strong>首字节时间（TTFB）</strong> 第一字节响应时间（TTFB）=发送请求到 WEB 服务器的时间+WEB 服务器处理请求并生成响应花费的时间+WEB 服务器生成响应到浏览器花费的时间</li><li><strong>DNS 解析时间</strong></li><li><strong>TCP 连接时间</strong></li><li><strong>HTTP 请求时间</strong></li><li><strong>HTTP 响应时间</strong></li></ul><h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><p>雅虎 14 条优化原则：</p><ol><li><p>尽可能的减少 HTTP 的请求数 content</p></li><li><p>使用 CDN（Content Delivery Network） server</p></li><li><p>添加 Expires 头(或者 Cache-control ) server</p></li><li><p>Gzip 组件 server</p></li><li><p>将 CSS 样式放在页面的上方 css</p></li><li><p>将脚本移动到底部（包括内联的） javascript</p></li><li><p>避免使用 CSS 中的 Expressions css</p></li><li><p>将 JavaScript 和 CSS 独立成外部文件 javascript css</p></li><li><p>减少 DNS 查询 content</p></li><li><p>压缩 JavaScript 和 CSS (包括内联的) javascript css</p></li><li><p>避免重定向 server</p></li><li><p>移除重复的脚本 javascript</p></li><li><p>配置实体标签（ETags） css</p></li><li><p>使 AJAX 缓存</p></li></ol><table><thead><tr><th>优化方向</th><th>优化手段</th></tr></thead><tbody><tr><td>请求数量</td><td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域，字体图标，雪碧图片等</td></tr><tr><td>请求带宽</td><td>开启服务器 GZip，精简 JavaScript，移除重复脚本，图像优化（包括图片大小 kb）</td></tr><tr><td>缓存利用</td><td>使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AjaX 可缓存</td></tr><tr><td>页面结构</td><td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td></tr><tr><td>代码校验</td><td>避免 CSS 表达式，避免重定向</td></tr></tbody></table><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//yuchengkai.cn"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用缓存"><a href="#利用缓存" class="headerlink" title="利用缓存"></a>利用缓存</h3><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p><p>通常浏览器缓存策略分为两种：强缓存和协商缓存</p><h4 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h4><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul><h3 id="使用-HTTP-2-0"><a href="#使用-HTTP-2-0" class="headerlink" title="使用 HTTP / 2.0"></a>使用 HTTP / 2.0</h3><p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p><p>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p><h3 id="预加载-amp-懒加载"><a href="#预加载-amp-懒加载" class="headerlink" title="预加载&amp;懒加载"></a>预加载&amp;懒加载</h3><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p><p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><h4 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h4><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染。</p><h4 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h4><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载就是将不关键的资源延后加载。</p><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p><h2 id="文件优化"><a href="#文件优化" class="headerlink" title="文件优化"></a>文件优化</h2><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><h4 id="图片大小计算"><a href="#图片大小计算" class="headerlink" title="图片大小计算"></a>图片大小计算</h4><p>在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p><p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p><ul><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ul><h4 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h4><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h3 id="其他文件优化"><a href="#其他文件优化" class="headerlink" title="其他文件优化"></a>其他文件优化</h3><ul><li>CSS 文件放在 <code>head</code> 中</li><li>服务端开启文件压缩功能</li><li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。</li><li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。—— 科学百科</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6p436ax42j30ia09l74f.jpg" alt="img"></p><h4 id="CDN-存在的意义"><a href="#CDN-存在的意义" class="headerlink" title="CDN 存在的意义"></a>CDN 存在的意义</h4><p>为了不让网络拥塞成为互联网发展的障碍。</p><h4 id="CDN-的优势"><a href="#CDN-的优势" class="headerlink" title="CDN 的优势"></a>CDN 的优势</h4><ol><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li><li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载；</li><li>降低“广播风暴”的影响，提高网络访问的稳定性；节省骨干网带宽，减少带宽需求量。</li></ol><h4 id="CDN-的核心点"><a href="#CDN-的核心点" class="headerlink" title="CDN 的核心点"></a>CDN 的核心点</h4><ul><li><p>缓存：将从根服务器请求来的资源按要求缓存。</p></li><li><p>回源：当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</p></li></ul><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><ol><li>内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；</li><li>内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应；</li><li>内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在 POP 的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；</li><li>性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</li></ol><h4 id="CDN-amp-静态资源"><a href="#CDN-amp-静态资源" class="headerlink" title="CDN &amp; 静态资源"></a>CDN &amp; 静态资源</h4><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段。</p><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="使用-Webpack-优化项目"><a href="#使用-Webpack-优化项目" class="headerlink" title="使用 Webpack 优化项目"></a>使用 Webpack 优化项目</h3><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</p><ul><li>对于跨域的代码运行错误会显示 <code>Script error.</code> 对于这种情况我们需要给 <code>script</code> 标签添加 <code>crossorigin</code> 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li></ul><p>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promise</code> 可以直接使用 <code>catch</code> 函数，<code>async await</code> 可以使用 <code>try catch</code></p><p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。</p><p>对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</p><h2 id="如何优化第二次加载速度？（增量加载）"><a href="#如何优化第二次加载速度？（增量加载）" class="headerlink" title="如何优化第二次加载速度？（增量加载）"></a>如何优化第二次加载速度？（增量加载）</h2><p><a href="https://juejin.im/post/5d00820b5188255ee806a1c7" target="_blank" rel="noopener">前端性能优化三部曲(加载篇)</a></p><p><a href="https://juejin.im/entry/599403656fb9a0247f4f2ee3" target="_blank" rel="noopener">移动 H5 首屏秒开优化方案探讨</a></p><ol><li><strong>降低请求量：</strong>合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li><li><strong>加快请求速度：</strong>预解析 DNS，减少域名数，并行加载，CDN 分发。</li><li><strong>缓存：</strong>HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</li><li><strong>渲染：</strong>JS/CSS 优化，加载顺序，服务端渲染，pipeline。</li></ol><p>其中对首屏启动速度影响最大的就是网络请求，所以优化的重点就是缓存</p><p><strong>增量式更新”</strong>的解决方案，简单地说就是在版本更新的时候不需要重新加载资源，只需要加载一段很小的 diff 信息，然后合并到当前资源上，类似 git merge 的效果。</p><p>增量加载的一种思路：</p><p>1、用户端使用 LocalStorage 或者其它储存方案，存储一份原始代码+时间戳：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    timeStamp: &quot;20161026xxxxxx&quot;,</span><br><span class="line">    data: &quot;aaabbbccc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、每次加载资源的时候向服务器发送这个时间戳；</p><p>3、服务器从接受到时间戳中识别出客户端的版本，和最新的版本做一次 diff，返回两者的 diff 信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff(<span class="string">"aaabbbccc"</span>, <span class="string">"aaagggccc"</span>);</span><br><span class="line"><span class="comment">// 假设我们的diff信息这样表示：</span></span><br><span class="line"><span class="comment">// [3, "-3", "+ggg", 3]</span></span><br></pre></td></tr></table></figure><p>4、客户端接收到这个 diff 信息之后，把本地资源和时间戳更新到最新，实现一次增量更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mergeDiff(<span class="string">"aaabbbccc"</span>, [<span class="number">3</span>, <span class="string">"-3"</span>, <span class="string">"+ggg"</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">//=&gt; "aaagggccc"</span></span><br></pre></td></tr></table></figure><h2 id="面试题（如何渲染几万条数据并不卡住界）"><a href="#面试题（如何渲染几万条数据并不卡住界）" class="headerlink" title="面试题（如何渲染几万条数据并不卡住界）"></a>面试题（如何渲染几万条数据并不卡住界）</h2><p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 <code>requestAnimationFrame</code> 来每 16 ms 刷新一次。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      控件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> total = <span class="number">100000</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 一次插入 20 条，如果觉得性能不好就减少</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> once = <span class="number">20</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 渲染数据总共需要几次</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> loopCount = total / once;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> countOfRender = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 优化性能，插入不会造成回流</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">            li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span></span><br><span class="line">            fragment.appendChild(li);</span><br><span class="line">          &#125;</span><br><span class="line">          ul.appendChild(fragment);</span><br><span class="line">          countOfRender += 1;</span><br><span class="line"><span class="vbscript">          <span class="keyword">loop</span>();</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.requestAnimationFrame(add);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="vbscript">        <span class="keyword">loop</span>();</span></span><br><span class="line">      &#125;, 0);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="拓展知识之-Gzip"><a href="#拓展知识之-Gzip" class="headerlink" title="拓展知识之 Gzip"></a>拓展知识之 Gzip</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome,firefox,IE 等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持 gzip。</p><p>gzip 压缩比率在 3 到 10 倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。</p><h3 id="gzip-工作原理："><a href="#gzip-工作原理：" class="headerlink" title="gzip 工作原理："></a>gzip 工作原理：</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjepqxiaj30go0bcaa9.jpg" alt="img"></p><ol><li>浏览器请求 url，并在 request header 中设置属性 accept-encoding:gzip。表明浏览器支持 gzip。</li><li>服务器收到浏览器发送的请求之后，判断浏览器是否支持 gzip，如果支持 gzip，则向浏览器传送压缩过的内容，不支持则向浏览器发送未经压缩的内容。一般情况下，浏览器和服务器都支持 gzip，response headers 返回包含 content-encoding:gzip。</li><li>浏览器接收到服务器的响应之后判断内容是否被压缩，如果被压缩则解压缩显示页面内容。</li></ol><h3 id="Nginx-中开启-gzip"><a href="#Nginx-中开启-gzip" class="headerlink" title="Nginx 中开启 gzip"></a>Nginx 中开启 gzip</h3><p>如果服务端接口使用 nodejs 和 express，那么开启 nginx 非常简单。启用 compress() 中间件即可并在 nginx.conf 中添加 gzip 配置项即可，express.compress() gzip 压缩中间件，通过 filter 函数设置需要压缩的文件类型。压缩算法为 gzip/deflate。这个中间件应该放置在所有的中间件最前面以保证所有的返回都是被压缩的。如果使用 java 开发，需要配置 filter。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjg93f23j30go03eq2v.jpg" alt="img"></p><p>添加完参数后，运行 nginx –t 检查一下语法，若语法检测通过，则开始访问 url 检测 gzip 是否添加成功。</p><ol><li>gzip on：开启 gzip。</li><li>gzip_comp_level：gzip 压缩比。</li><li>gzip_min_length：允许被压缩的页面最小字节数。</li><li>gzip_types：匹配 MIME 类型进行压缩，text/html 默认被压缩。</li></ol><h3 id="检测-gzip-是否开启"><a href="#检测-gzip-是否开启" class="headerlink" title="检测 gzip 是否开启"></a>检测 gzip 是否开启</h3><p>如果没有现成的项目代码，这里提供一个比较简单的检测方式。首先在本地安装 nginx，在 nginx 默认目录下面添加了两个静态文件 bootstrap.css、bootstrap.js。</p><p>OS X 系统的默认路径为：/usr/local/Cellar/nginx/1.10.2_1/html，Windows 系统直接复制文件到文件夹下面。</p><p>拷贝文件指令可参考：cp -r bootstrap.js /usr/local/Cellar/nginx/1.10.2_1/html，在 nginx 的默认成功跳转页面 index.html 引入这两个静态文件。index.html 页面内容如图所示。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjhnk9acj30go0c90tb.jpg" alt="img"></p><p>做好这一切的准备工作之后，浏览器输入<a href="https://link.juejin.im/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flocalhost%3A8080%2F" target="_blank" rel="noopener">http://localhost:8080/</a>。出现如图所示页面表明 nginx 启动成功。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjii979gj30go048wei.jpg" alt="img"></p><p>nginx 启动成功界面。</p><p>此时打开 Chrome 控制台，可以看到 network 信息，response headers 中返回了 content-encoding:gzip，表明 gzip 开启成功。</p><p>gzip 未开启前 network 信息如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjjd5bavj30go02ogll.jpg" alt="img"></p><p>开启后返回 network 信息如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjjxm19cj30go02m0sp.jpg" alt="img"></p><p>url 请求的 headers 报文如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjk4yn88j30go0a4jrt.jpg" alt="img"></p><p>对比以上三图可以看出 gzip 压缩效率非常高，且经过压缩后静态文件大小不到原来的五分之一。这里值得一提的是静态资源文件越大，gzip 的压缩效率越高。所以对于静态资源量非常大的网站，开启 gzip 可节省大量流量，而同时 gzip 的应用远不止提高 web 性能,Android，IOS 底层网络请求同样可用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端优化&quot;&gt;&lt;a href=&quot;#前端优化&quot; class=&quot;headerlink&quot; title=&quot;前端优化&quot;&gt;&lt;/a&gt;前端优化&lt;/h1&gt;&lt;h2 id=&quot;前端性能衡量指标&quot;&gt;&lt;a href=&quot;#前端性能衡量指标&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CSS的position属性</title>
    <link href="http://yoursite.com/2019/08/31/CSS%E7%9A%84position%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/08/31/CSS的position属性/</id>
    <published>2019-08-31T13:48:53.000Z</published>
    <updated>2019-11-10T14:37:39.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-的-position-属性"><a href="#CSS-的-position-属性" class="headerlink" title="CSS 的 position 属性"></a>CSS 的 position 属性</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>默认值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code>属性无效。</p><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h3 id="定位类型"><a href="#定位类型" class="headerlink" title="定位类型"></a>定位类型</h3><p>相对定位元素，相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。</p><h3 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成相对定位的元素，相对于其正常位置进行定位。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白，”left:20” 会向元素的 LEFT 位置添加 20 像素。）。<code>position:relative</code> 对 <code>table-group</code>, <code>table-row</code>,<code>table-column</code>,<code>table-cell</code>,<code>table-caption</code> 元素无效。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"three"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"four"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#two</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyqx5px1j312q0b40t2.jpg" alt="img"></p><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h3 id="定位类型-1"><a href="#定位类型-1" class="headerlink" title="定位类型"></a>定位类型</h3><p>绝对定位元素，相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于<em>最近的非 static 祖先元素</em>定位。当这样的祖先元素不存在时，则相对于 ICB（inital container block, 初始包含块）。</p><h3 id="定位方式-1"><a href="#定位方式-1" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成绝对定位的元素，不为元素预留空间，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"three"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"four"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#three</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyrszydtj310809e0sz.jpg" alt="image-20190823001646550"></p><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><h3 id="定位类型-2"><a href="#定位类型-2" class="headerlink" title="定位类型"></a>定位类型</h3><p>绝对定位元素，固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。</p><h3 id="定位方式-2"><a href="#定位方式-2" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成绝对定位的元素，不为元素预留空间，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。</p><p><strong>当元素祖先的 <code>transform</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</strong></p><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><h3 id="定位类型-3"><a href="#定位类型-3" class="headerlink" title="定位类型"></a>定位类型</h3><p>粘性定位元素，粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p><h3 id="定位方式-3"><a href="#定位方式-3" class="headerlink" title="定位方式"></a>定位方式</h3><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table 时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code>对 <code>table</code> 元素的效果与 <code>position: relative</code>相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。</p><p>粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>A<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Andrew W.K.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Apparat<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Arcade Fire<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>At The Drive-In<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Aziz Ansari<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>C<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Chromeo<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Common<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Converge<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Crystal Castles<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Cursive<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>E<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Explosions In The Sky<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>T<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Ted Leo &amp; The Pharmacists<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>T-Pain<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Thrice<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>TV On The Radio<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Two Gallants<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">24px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dt</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b8c1c8</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#989ea4</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#717d85</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">18px</span>/<span class="number">21px</span> Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">position</span>: -webkit-sticky;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">20px</span>/<span class="number">45px</span> Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生效规则"><a href="#生效规则" class="headerlink" title="生效规则"></a>生效规则</h3><p><code>position:sticky</code> 的生效是有一定的限制的，总结如下：</p><ol><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。<ul><li>并且 <code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高。</li></ul></li><li>设定为 <code>position:sticky</code> 元素的任意父节点的 overflow 属性必须是 visible，否则 <code>position:sticky</code> 不会生效。这里需要解释一下：<ul><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>overflow:hidden</code>，则父容器无法进行滚动，所以 <code>position:sticky</code> 元素也不会有滚动然后固定的情况。</li><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>position:relative | absolute | fixed</code>，则元素相对父元素进行定位，而不会相对 viewprot 定位。</li></ul></li><li>达到设定的阀值。这个还算好理解，也就是设定了 <code>position:sticky</code> 的元素表现为 <code>relative</code> 还是 <code>fixed</code> 是根据元素是否达到设定了的阈值决定的。</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>同一个父容器中的 sticky 元素，如果定位值相等，则会重叠；如果属于不同父元素，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li></ol><h2 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h2><p><code>initial</code> 关键字用于设置 CSS 属性为它的默认值，可作用于任何 CSS 样式。（IE 不支持该关键字）</p><h2 id="inherit："><a href="#inherit：" class="headerlink" title="inherit："></a>inherit：</h2><p>规定应该从父元素继承 position 属性的值。</p><p>每一个 CSS 属性都有一个特性就是，这个属性必然是默认继承的 (<code>inherited: Yes</code>) 或者是默认不继承的 (<code>inherited: no</code>)其中之一，我们可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference" target="_blank" rel="noopener">MDN</a> 上通过这个索引查找，判断一个属性的是否继承特性。</p><h3 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h3><ul><li>所有元素可继承：visibility 和 cursor</li><li>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction</li><li>块状元素可继承：text-indent 和 text-align</li><li>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image</li><li>表格元素可继承：border-collapse</li></ul><h2 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h2><p><code>unset</code> 关键字我们可以简单理解为不设置。其实，它是关键字 <code>initial</code> 和 <code>inherit</code> 的组合。</p><p>什么意思呢？也就是当我们给一个 CSS 属性设置了 <code>unset</code> 的话：</p><ol><li>如果该属性是默认继承属性，该值等同于 <code>inherit</code></li><li>如果该属性是非继承属性，该值等同于 <code>initial</code></li></ol><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children"</span>&gt;</span>子级元素一<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children unset"</span>&gt;</span>子级元素二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.father &#123; color: red; border: 1px solid black; &#125; .children &#123; color: green;</span><br><span class="line">border: 1px solid blue; &#125; .unset &#123; color: unset; border: unset; &#125;</span><br></pre></td></tr></table></figure><ol><li>由于 <code>color</code> 是可继承样式，设置了 <code>color: unset</code> 的元素，最终表现为了父级的颜色 <code>red</code>。</li><li>由于 <code>border</code> 是不可继承样式，设置了 <code>border: unset</code> 的元素，最终表现为 <code>border: initial</code> ，也就是默认 border 样式，无边框。</li></ol><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>revert 未列入规范</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-的-position-属性&quot;&gt;&lt;a href=&quot;#CSS-的-position-属性&quot; class=&quot;headerlink&quot; title=&quot;CSS 的 position 属性&quot;&gt;&lt;/a&gt;CSS 的 position 属性&lt;/h1&gt;&lt;h2 id=&quot;stati
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="position" scheme="http://yoursite.com/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>ES6 装饰器</title>
    <link href="http://yoursite.com/2019/08/18/ES6%20%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2019/08/18/ES6 装饰器/</id>
    <published>2019-08-18T14:47:55.000Z</published>
    <updated>2019-11-10T14:37:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-装饰器"><a href="#ES6-装饰器" class="headerlink" title="ES6 装饰器"></a>ES6 装饰器</h1><p>装饰器（Decorator）是一种与类（class）相关的语法，<strong>用来注释或修改类和类方法</strong>。装饰器是一种函数，写成<code>@ + 函数名</code>。它可以放在类和类方法的定义前面。</p>  <a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@frozen</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  @configurable(<span class="literal">false</span>)</span><br><span class="line">  @enumerable(<span class="literal">true</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @throttle(<span class="number">500</span>)</span><br><span class="line">  expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。</p><p><strong>Proxy 的核心作用是控制外界对被代理者内部的访问，Decorator 的核心作用是增强被装饰者的功能。著作权归作者所有。</strong></p><h2 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h2><p>装饰器可以用来装饰整个类。</p><h3 id="为类添加静态属性"><a href="#为类添加静态属性" class="headerlink" title="为类添加静态属性"></a>为类添加静态属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>@testable</code>就是一个装饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p><p>基本上，装饰器的行为就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，<strong>装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</strong></p><p>如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，装饰器<code>testable</code>可以接受参数，这就等于可以修改装饰器的行为。</p><p><strong>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</strong></p><h3 id="为类添加实例属性"><a href="#为类添加实例属性" class="headerlink" title="为类添加实例属性"></a>为类添加实例属性</h3><p>如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，装饰器函数<code>testable</code>是在目标类的<code>prototype</code>对象上添加属性，因此就可以在实例上调用。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">"./mixins"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码通过装饰器<code>mixins</code>，把<code>Foo</code>对象的方法添加到了<code>MyClass</code>的实例上面。可以用<code>Object.assign()</code>模拟这个功能。</p><h2 id="方法的装饰"><a href="#方法的装饰" class="headerlink" title="方法的装饰"></a>方法的装饰</h2><h3 id="装饰器修改属性的描述对象"><a href="#装饰器修改属性的描述对象" class="headerlink" title="装饰器修改属性的描述对象"></a>装饰器修改属性的描述对象</h3><p>装饰器不仅可以装饰类，还可以装饰类的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，装饰器<code>readonly</code>用来装饰“类”的<code>name</code>方法。</p><p>装饰器函数<code>readonly</code>一共可以接受三个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// descriptor对象原来的值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//   enumerable: false,</span></span><br><span class="line">  <span class="comment">//   configurable: true,</span></span><br><span class="line">  <span class="comment">//   writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">"name"</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, descriptor);</span><br></pre></td></tr></table></figure><p>装饰器第一个参数是类的原型对象，上例是<code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但是<strong>这个时候实例还没生成，所以只能去装饰原型</strong>（这不同于类的装饰，那种情况时<code>target</code>参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。</p><p>另外，上面代码说明，<strong>装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</strong></p><p>下面是另一个例子，修改属性描述对象的<code>enumerable</code>属性，使得该属性不可遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="keyword">get</span> kidCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.children.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的<code>@log</code>装饰器，可以起到输出日志的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with`</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// passed parameters should get logged now</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>@log</code>装饰器的作用就是在执行原始的操作之前，执行一次<code>console.log</code>，从而达到输出日志的目的。</p><h3 id="装饰器的注释作用"><a href="#装饰器的注释作用" class="headerlink" title="装饰器的注释作用"></a>装饰器的注释作用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中，我们一眼就能看出，<code>Person</code>类是可测试的，而<code>name</code>方法是只读和不可枚举的。</p><p>下面是使用 Decorator 写法的<a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener">组件</a>，看上去一目了然。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  tag: <span class="string">"my-component"</span>,</span><br><span class="line">  styleUrl: <span class="string">"my-component.scss"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  @Prop() first: string;</span><br><span class="line">  @Prop() last: string;</span><br><span class="line">  @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Hello, my name is &#123;<span class="keyword">this</span>.first&#125; &#123;<span class="keyword">this</span>.last&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h3><p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"evaluated"</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"executed"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  @dec(<span class="number">1</span>)</span><br><span class="line">  @dec(<span class="number">2</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行。</p><h3 id="装饰器可用作类型检查"><a href="#装饰器可用作类型检查" class="headerlink" title="装饰器可用作类型检查"></a>装饰器可用作类型检查</h3><p>除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</p><h2 id="为什么装饰器不能用于函数"><a href="#为什么装饰器不能用于函数" class="headerlink" title="为什么装饰器不能用于函数"></a>为什么装饰器不能用于函数</h2><h3 id="函数提升，类没有提升"><a href="#函数提升，类没有提升" class="headerlink" title="函数提升，类没有提升"></a>函数提升，类没有提升</h3><p>装饰器只能用于类和类的方法，不能用于函数，<strong>因为存在函数提升</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0。因为函数提升，使得实际执行的代码是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter;</span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly = <span class="built_in">require</span>(<span class="string">"some-decorator"</span>);</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也有问题，因为实际执行是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly;</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readOnly = <span class="built_in">require</span>(<span class="string">"some-decorator"</span>);</span><br></pre></td></tr></table></figure><p>总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><h3 id="函数一定要用装饰器"><a href="#函数一定要用装饰器" class="headerlink" title="函数一定要用装饰器"></a>函数一定要用装饰器</h3><p>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingDecorator</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Starting"</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure><h2 id="常见装饰器"><a href="#常见装饰器" class="headerlink" title="常见装饰器"></a>常见装饰器</h2><p><a href="https://github.com/jayphelps/core-decorators.js" target="_blank" rel="noopener">core-decorators.js</a>是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。</p><h3 id="1-autobind"><a href="#1-autobind" class="headerlink" title="1. @autobind"></a>1. @autobind</h3><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; autobind &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @autobind</span><br><span class="line">  getPerson() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.getPerson;</span><br><span class="line"></span><br><span class="line">getPerson() === person;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2-readonly"><a href="#2-readonly" class="headerlink" title="2. @readonly"></a>2. @readonly</h3><p><code>readonly</code>装饰器使得属性或方法不可写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  entree = <span class="string">"steak"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dinner = <span class="keyword">new</span> Meal();</span><br><span class="line">dinner.entree = <span class="string">"salmon"</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property 'entree' of [object Object]</span></span><br></pre></td></tr></table></figure><h3 id="3-override"><a href="#3-override" class="headerlink" title="3. @override"></a>3. @override</h3><p><code>override</code>装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; override &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  speak(first, second) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  @override</span><br><span class="line">  speak() &#123;&#125;</span><br><span class="line">  <span class="comment">// SyntaxError: Child#speak() does not properly override Parent#speak(first, second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  @override</span><br><span class="line">  speaks() &#123;&#125;</span><br><span class="line">  <span class="comment">// SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   Did you mean "speak"?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-deprecate-别名-deprecated"><a href="#4-deprecate-别名-deprecated" class="headerlink" title="4. @deprecate (别名@deprecated)"></a>4. @deprecate (别名@deprecated)</h3><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; deprecate &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @deprecate</span><br><span class="line">  facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">"We stopped facepalming"</span>)</span><br><span class="line">  facepalmHard() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">"We stopped facepalming"</span>, &#123;</span><br><span class="line">    url: <span class="string">"http://knowyourmeme.com/memes/facepalm"</span></span><br><span class="line">  &#125;)</span><br><span class="line">  facepalmHarder() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalm();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalm: This function will be removed in future versions.</span></span><br><span class="line"></span><br><span class="line">person.facepalmHard();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHard: We stopped facepalming</span></span><br><span class="line"></span><br><span class="line">person.facepalmHarder();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHarder: We stopped facepalming</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     See http://knowyourmeme.com/memes/facepalm for more details.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="5-suppressWarnings"><a href="#5-suppressWarnings" class="headerlink" title="5. @suppressWarnings"></a>5. @suppressWarnings</h3><p><code>suppressWarnings</code>装饰器抑制<code>deprecated</code>装饰器导致的<code>console.warn()</code>调用。但是，异步代码发出的调用除外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; suppressWarnings &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @deprecated</span><br><span class="line">  facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @suppressWarnings</span><br><span class="line">  facepalmWithoutWarning() &#123;</span><br><span class="line">    <span class="keyword">this</span>.facepalm();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalmWithoutWarning();</span><br><span class="line"><span class="comment">// no warning is logged</span></span><br></pre></td></tr></table></figure><h2 id="使用装饰器实现自动发布事件"><a href="#使用装饰器实现自动发布事件" class="headerlink" title="使用装饰器实现自动发布事件"></a>使用装饰器实现自动发布事件</h2><p>我们可以使用装饰器，使得对象的方法被调用时，自动发出一个事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postal = <span class="built_in">require</span>(<span class="string">"postal/lib/postal.lodash"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">topic, channel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> channelName = channel || <span class="string">"/"</span>;</span><br><span class="line">  <span class="keyword">const</span> msgChannel = postal.channel(channelName);</span><br><span class="line">  msgChannel.subscribe(topic, v =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"频道: "</span>, channelName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"事件: "</span>, topic);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数据: "</span>, v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> value = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      msgChannel.publish(topic, value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个名为<code>publish</code>的装饰器，它通过改写<code>descriptor.value</code>，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是<a href="https://github.com/postaljs/postal.js" target="_blank" rel="noopener">Postal.js</a>。</p><p>它的用法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> publish <span class="keyword">from</span> <span class="string">"./publish"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooComponent</span> </span>&#123;</span><br><span class="line">  @publish(<span class="string">"foo.some.message"</span>, <span class="string">"component"</span>)</span><br><span class="line">  someMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">my</span>: <span class="string">"data"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @publish(<span class="string">"foo.some.other"</span>)</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> FooComponent();</span><br><span class="line"></span><br><span class="line">foo.someMethod();</span><br><span class="line">foo.anotherMethod();</span><br></pre></td></tr></table></figure><p>以后，只要调用<code>someMethod</code>或者<code>anotherMethod</code>，就会自动发出一个事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bash-node index.js</span><br><span class="line">频道:  component</span><br><span class="line">事件:  foo.some.message</span><br><span class="line">数据:  &#123; my: <span class="string">'data'</span> &#125;</span><br><span class="line"></span><br><span class="line">频道:  /</span><br><span class="line">事件:  foo.some.other</span><br><span class="line">数据:  undefined</span><br></pre></td></tr></table></figure><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><p>在装饰器的基础上，可以实现<code>Mixin</code>模式。所谓<code>Mixin</code>模式，就是<strong>对象继承的一种替代方案</strong>，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p><p>请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码之中，对象<code>Foo</code>有一个<code>foo</code>方法，通过<code>Object.assign</code>方法，可以将<code>foo</code>方法“混入”<code>MyClass</code>类，导致<code>MyClass</code>的实例<code>obj</code>对象都具有<code>foo</code>方法。这就是“混入”模式的一个简单实现。</p><p>下面，我们部署一个通用脚本<code>mixins.js</code>，将 Mixin 写成一个装饰器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以使用上面这个装饰器，为类“混入”各种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">"./mixins"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure><p>通过<code>mixins</code>这个装饰器，实现了在<code>MyClass</code>类上面“混入”<code>Foo</code>对象的<code>foo</code>方法。</p><p>不过，上面的方法会改写<code>MyClass</code>类的<code>prototype</code>对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyBaseClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>继承了<code>MyBaseClass</code>。如果我们想在<code>MyClass</code>里面“混入”一个<code>foo</code>方法，一个办法是在<code>MyClass</code>和<code>MyBaseClass</code>之间插入一个混入类，这个类具有<code>foo</code>方法，并且继承了<code>MyBaseClass</code>的所有方法，然后<code>MyClass</code>再继承这个类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyMixin = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from MyMixin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyMixin</code>是一个混入类生成器，接受<code>superclass</code>作为参数，然后返回一个继承<code>superclass</code>的子类，该子类包含一个<code>foo</code>方法。</p><p>接着，目标类再去继承这个混入类，就达到了“混入”<code>foo</code>方法的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyMixin</span>(<span class="title">MyBaseClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line">c.foo(); <span class="comment">// "foo from MyMixin"</span></span><br></pre></td></tr></table></figure><p>如果需要“混入”多个方法，就生成多个混入类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">MyBaseClass</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的一个好处，是可以调用<code>super</code>，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Mixin1 = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from Mixin1"</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Mixin2 = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from Mixin2"</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo from S"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">S</span>)) </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo from C"</span>);</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，每一次<code>混入</code>发生时，都调用了父类的<code>super.foo</code>方法，导致父类的同名方法没有被覆盖，行为被保留了下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> C().foo();</span><br><span class="line"><span class="comment">// foo from C</span></span><br><span class="line"><span class="comment">// foo from Mixin1</span></span><br><span class="line"><span class="comment">// foo from Mixin2</span></span><br><span class="line"><span class="comment">// foo from S</span></span><br></pre></td></tr></table></figure><h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>Trait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。</p><p>下面采用<a href="https://github.com/CocktailJS/traits-decorator" target="_blank" rel="noopener">traits-decorator</a>这个第三方模块作为例子。这个模块提供的<code>traits</code>装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码中，通过<code>traits</code>装饰器，在<code>MyClass</code>类上面“混入”了<code>TFoo</code>类的<code>foo</code>方法和<code>TBar</code>对象的<code>bar</code>方法。</p><p>Trait 不允许“混入”同名方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// throw new Error('Method named: ' + methodName + ' is defined twice.');</span></span><br><span class="line"><span class="comment">//        ^</span></span><br><span class="line"><span class="comment">// Error: Method named: foo is defined twice.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>TFoo</code>和<code>TBar</code>都有<code>foo</code>方法，结果<code>traits</code>装饰器报错。</p><p>一种解决方法是排除<code>TBar</code>的<code>foo</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits, excludes &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::excludes(<span class="string">"foo"</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码使用绑定运算符（::）在<code>TBar</code>上排除<code>foo</code>方法，混入时就不会报错了。</p><p>另一种方法是为<code>TBar</code>的<code>foo</code>方法起一个别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits, alias &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::alias(&#123; <span class="attr">foo</span>: <span class="string">"aliasFoo"</span> &#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.aliasFoo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码为<code>TBar</code>的<code>foo</code>方法起了别名<code>aliasFoo</code>，于是<code>MyClass</code>也可以混入<code>TBar</code>的<code>foo</code>方法了。</p><p><code>alias</code>和<code>excludes</code>方法，可以结合起来使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@traits(TExample::excludes(<span class="string">"foo"</span>, <span class="string">"bar"</span>)::alias(&#123; <span class="attr">baz</span>: <span class="string">"exampleBaz"</span> &#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码排除了<code>TExample</code>的<code>foo</code>方法和<code>bar</code>方法，为<code>baz</code>方法起了别名<code>exampleBaz</code>。</p><p><code>as</code>方法则为上面的代码提供了另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@traits(</span><br><span class="line">  TExample::<span class="keyword">as</span>(&#123; <span class="attr">excludes</span>: [<span class="string">"foo"</span>, <span class="string">"bar"</span>], <span class="attr">alias</span>: &#123; <span class="attr">baz</span>: <span class="string">"exampleBaz"</span> &#125; &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-装饰器&quot;&gt;&lt;a href=&quot;#ES6-装饰器&quot; class=&quot;headerlink&quot; title=&quot;ES6 装饰器&quot;&gt;&lt;/a&gt;ES6 装饰器&lt;/h1&gt;&lt;p&gt;装饰器（Decorator）是一种与类（class）相关的语法，&lt;strong&gt;用来注释或修改类和类方法&lt;/strong&gt;。装饰器是一种函数，写成&lt;code&gt;@ + 函数名&lt;/code&gt;。它可以放在类和类方法的定义前面。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>QUIC</title>
    <link href="http://yoursite.com/2019/08/16/QUIC/"/>
    <id>http://yoursite.com/2019/08/16/QUIC/</id>
    <published>2019-08-15T17:52:20.000Z</published>
    <updated>2019-11-10T14:37:39.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h1><h2 id="QUIC-概述"><a href="#QUIC-概述" class="headerlink" title="QUIC 概述"></a>QUIC 概述</h2><p>Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。</p><p>QUIC 协议内置了 TLS 栈，实现了自己的<a href="https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit" target="_blank" rel="noopener">传输加密层</a>，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izr9eluaj315w0k0aaa.jpg" alt="img"></p><p>从图上可以看出，QUIC 底层通过 UDP 协议替代了 TCP，上层只需要一层用于和远程服务器交互的 HTTP/2 API。这是因为 QUIC 协议已经包含了多路复用和连接管理，HTTP API 只需要完成 HTTP 协议的解析即可。</p><h2 id="QUIC-优势"><a href="#QUIC-优势" class="headerlink" title="QUIC 优势"></a>QUIC 优势</h2><ol><li>减少了 TCP 三次握手及 TLS 握手时间。</li><li>改进的拥塞控制。</li><li>避免队头阻塞的多路复用。</li><li>连接迁移。</li><li>前向冗余纠错。（目前默认的冗余量是 10%，既每发送 10 个数据包，其冗余数据就可以重新构建一个丢失的数据包）</li></ol><h2 id="为什么需要-QUIC"><a href="#为什么需要-QUIC" class="headerlink" title="为什么需要 QUIC"></a>为什么需要 QUIC</h2><ol><li><p>协议历史悠久导致中间设备僵化。</p><p>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口（80、443）及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p></li><li><p>依赖于操作系统的实现导致协议本身僵化。</p><p>TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。</p></li><li><p>建立连接的握手延迟大。</p><p>不管是 HTTP1.0/1.1 还是 HTTPS，HTTP2，都使用了 TCP 进行传输。HTTPS 和 HTTP2 还需要使用 TLS 协议来进行安全传输。这就出现了两个握手延迟：</p><ul><li>TCP 三次握手导致的 TCP 连接建立的延迟。</li><li>TLS 完全握手需要至少 2 个 RTT 才能建立，简化握手需要 1 个 RTT 的握手延迟。</li></ul><p>对于很多短连接场景，这样的握手延迟影响很大，且无法消除。</p></li><li><p>队头阻塞。</p><p>队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。</p><p>另外 TLS 协议层面也有一个队头阻塞，因为 TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。</p></li></ol><p><strong>QUIC 协议选择了 UDP，因为 UDP 本身没有连接的概念，不需要三次握手，优化了连接建立的握手延迟，同时在应用程序层面实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性，只需要用户端和服务端的应用程序支持 QUIC 协议，完全避开了操作系统和中间设备的限制。</strong></p><h2 id="QUIC-详解"><a href="#QUIC-详解" class="headerlink" title="QUIC 详解"></a>QUIC 详解</h2><h3 id="1-QUIC-核心特性连接建立延时低"><a href="#1-QUIC-核心特性连接建立延时低" class="headerlink" title="1. QUIC 核心特性连接建立延时低"></a>1. QUIC 核心特性连接建立延时低</h3><p><strong>0RTT 建连</strong>可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</p><ol><li>传输层 0RTT 就能建立连接。</li><li>加密层 0RTT 就能建立加密连接。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izr8c4vjj314a0n0gpa.jpg" alt="img"></p><p>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption[14]，也需要至少 2 个 RTT。</p><p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket[13] 要高很多。</p><h3 id="2-改进的拥塞控制"><a href="#2-改进的拥塞控制" class="headerlink" title="2. 改进的拥塞控制"></a>2. 改进的拥塞控制</h3><p>TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。</p><p>QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。</p><p>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</p><ul><li><strong>可插拔</strong></li></ul><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：</p><ol><li>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</li><li>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</li><li>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。</li></ol><p>STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</p><ul><li><strong>单调递增的 Packet Number</strong></li></ul><p>TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。</p><p>QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrp5123j30k008rjro.jpg" alt="img"></p><p>​ 图 2 Tcp 重传歧义性</p><p>如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。</p><p>如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。</p><p>由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrs95mpj30k007xjrn.jpg" alt="img"></p><p>​ 图 3 Quic 重传没有歧义性</p><p>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。</p><p>但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 Stream Offset 的概念。</p><p>即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。但是 Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。如错误! 未找到引用源。所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。</p><p>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrw4o31j30k005smxc.jpg" alt="img"></p><p>​ 图 4 Stream Offset 保证有序性</p><ul><li><strong>不允许 Reneging</strong></li></ul><p>什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。</p><p>Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据。</p><p>QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰。</p><ul><li><strong>更多的 Ack 块</strong></li></ul><p>TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</p><p>由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 [25]，所以留给 Sack 选项的只有 30 个字节。</p><p>每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。</p><p>但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。</p><ul><li><strong>Ack Delay 时间</strong></li></ul><p>Tcp 的 Timestamp 选项存在一个问题，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。</p><p>这样就会导致 RTT 计算误差。如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrzqtwlj30k00f4wf5.jpg" alt="img"></p><p>可以认为 TCP 的 RTT 计算：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs42dncj308d015743.jpg" alt="img"></p><p>而 Quic 计算如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs6x1lbj30a70153yc.jpg" alt="img"></p><p>当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式 [9]。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs9tffbj308d01vwed.jpg" alt="img"></p><h3 id="3-基于-stream-和-connecton-级别的流量控制"><a href="#3-基于-stream-和-connecton-级别的流量控制" class="headerlink" title="3.基于 stream 和 connecton 级别的流量控制"></a>3.基于 stream 和 connecton 级别的流量控制</h3><p>QUIC 的流量控制类似 HTTP2，即在 Connection 和 Stream 级别提供了两种流量控制。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。</p><ol><li>Stream 可以认为就是一条 HTTP 请求。</li><li>Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</li></ol><p>QUIC 实现流量控制的原理比较简单：</p><p>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</p><p>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</p><p>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。</p><p>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsddv9lj30k0087q3a.jpg" alt="img"></p><p>​ 图 5 Quic Flow Control</p><p>针对 Stream：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsh7d39j30bz011glh.jpg" alt="img"></p><p>针对 Connection：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsk0cpyj30gy011a9z.jpg" alt="img"></p><p>同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。</p><p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p><h3 id="4-没有队头阻塞的多路复用"><a href="#4-没有队头阻塞的多路复用" class="headerlink" title="4.没有队头阻塞的多路复用"></a>4.没有队头阻塞的多路复用</h3><p>QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。</p><p>QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。</p><p>这也就在很大程度上缓解甚至消除了队头阻塞的影响。</p><p>多路复用是 HTTP2 最强大的特性，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞，如下图示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsn9t0ej30k007gq3a.jpg" alt="img"></p><p>​ 图 6 HTTP2 队头阻塞</p><p>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。</p><p>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞 [12]。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsr1djhj30k00ctaac.jpg" alt="img"></p><p>​ 图 7 TLS 队头阻塞</p><p>Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。</p><p>那 QUIC 多路复用为什么能避免上述问题呢？</p><ol><li>QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。</li><li>Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。（QUIC 协议直接通过底层使用 UDP 协议天然的避免了该问题。由于 UDP 协议没有严格的顺序，当一个数据包遇到问题需要重传时，只会影响该数据包对应的资源，其他独立的资源（如其他 css、js 文件）不会受到影响）</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsvoeyqj30k007gdg7.jpg" alt="img"></p><p>​ 图 8 QUIC 多路复用时没有队头阻塞的问题</p><p>当然，并不是所有的 QUIC 数据都不会受到队头阻塞的影响，比如 QUIC 当前也是使用 Hpack 压缩算法 [10]，由于算法的限制，丢失一个头部数据时，可能遇到队头阻塞。</p><p>总体来说，QUIC 在传输大量数据时，比如视频，受到队头阻塞的影响很小。</p><h3 id="5-加密认证的报文"><a href="#5-加密认证的报文" class="headerlink" title="5.加密认证的报文"></a>5.加密认证的报文</h3><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><p>如下图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsyv3ovj30i3091dgf.jpg" alt="img"></p><h3 id="6-连接迁移"><a href="#6-连接迁移" class="headerlink" title="6.连接迁移"></a>6.连接迁移</h3><p>一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。</p><p>比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。</p><p>又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。</p><p>针对 TCP 的连接变化，MPTCP 其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。</p><p>所以从 TCP 连接的角度来讲，这个问题是无解的。</p><p>那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。</p><p>由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。</p><h3 id="7-其他亮点"><a href="#7-其他亮点" class="headerlink" title="7.其他亮点"></a>7.其他亮点</h3><p>此外，QUIC 还能实现前向冗余纠错，在重要的包比如握手消息发生丢失时，能够根据冗余信息还原出握手消息。</p><p>QUIC 还能实现证书压缩，减少证书传输量，针对包头进行验证等。</p><h2 id="QUIC-协议实践"><a href="#QUIC-协议实践" class="headerlink" title="QUIC 协议实践"></a>QUIC 协议实践</h2><p>Chrome 浏览器从 2014 年开始已经实验性的支持了 QUIC 协议。可以通过在 Chrome 浏览器中输入<code>chrome://net-internals/#quic</code>查看是否已经支持 QUIC 协议。如果还未支持，可以在<code>chrome://flags/#enable-quic</code>中进行开启。</p><p>开始 Chrome 浏览器对 QUIC 协议的支持之后，可以在<code>chrome://net-internals/#quic</code>中查看到当前浏览器的 QUIC 一些连接。当然目前只有 Google 服务才支持 QUIC 协议（如 YouTube、 Google.com）。</p><h3 id="1-关于防火墙"><a href="#1-关于防火墙" class="headerlink" title="1. 关于防火墙"></a>1. 关于防火墙</h3><p>通常系统管理员会关注防火墙的 TCP 规则，而忽略 UDP 规则。如果要在防火墙之后使用 QUIC 协议，除了传统 web 服务需要开放的<code>80/TCP</code>、<code>443/TCP</code>之外，针对 QUIC 还需要开放<code>443/UDP</code>的访问。</p><h3 id="2-服务端使用-QUIC-协议"><a href="#2-服务端使用-QUIC-协议" class="headerlink" title="2.服务端使用 QUIC 协议"></a>2.服务端使用 QUIC 协议</h3><p>目前支持 QUIC 协议的 web 服务只有 0.9 版本以后的<a href="https://github.com/mholt/caddy/wiki/QUIC" target="_blank" rel="noopener">Caddy</a>。其他常用 web 服务如 nginx、apache 等都未开始支持。curl 表达了对 QUIC 协议<a href="https://daniel.haxx.se/blog/2016/07/20/curl-wants-to-quic/" target="_blank" rel="noopener">支持的兴趣</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;QUIC&quot;&gt;&lt;a href=&quot;#QUIC&quot; class=&quot;headerlink&quot; title=&quot;QUIC&quot;&gt;&lt;/a&gt;QUIC&lt;/h1&gt;&lt;h2 id=&quot;QUIC-概述&quot;&gt;&lt;a href=&quot;#QUIC-概述&quot; class=&quot;headerlink&quot; title=&quot;QUIC 概述&quot;&gt;&lt;/a&gt;QUIC 概述&lt;/h2&gt;&lt;p&gt;Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。&lt;/p&gt;
&lt;p&gt;QUIC 协议内置了 TLS 栈，实现了自己的&lt;a href=&quot;https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传输加密层&lt;/a&gt;，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
</feed>
