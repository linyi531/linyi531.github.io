<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>01不是包子脸</title>
  
  <subtitle>小01的程序猿成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-26T05:32:56.169Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Linyi Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>循环中的异步操作问题小结</title>
    <link href="http://yoursite.com/2019/11/26/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6%20copy/"/>
    <id>http://yoursite.com/2019/11/26/JS事件机制 copy/</id>
    <published>2019-11-26T05:29:24.000Z</published>
    <updated>2019-11-26T05:32:56.169Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环中的异步操作问题小结"><a href="#循环中的异步操作问题小结" class="headerlink" title="循环中的异步操作问题小结"></a>循环中的异步操作问题小结</h1><p>循环的异步操作主要有两个问题：</p><ul><li>如何确保循环的所有异步操作完成之后执行某个其他操作</li><li>循环中的下一步操作依赖于前一步的操作，如何解决</li></ul><h2 id="不需等待结果"><a href="#不需等待结果" class="headerlink" title="不需等待结果"></a>不需等待结果</h2><p>要处理这个问题，我们可以把这个匿名函数定义为异步的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  array.forEach(<span class="keyword">async</span> (item)=&gt;&#123;</span><br><span class="line">    <span class="keyword">await</span> delayedLog(item)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样的话 forEach 方法就相当于异步的了，不会等待遍历完所有的 item 将会输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Done!</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>如果你不需要等待这个循环完成，这样就已经可以了。但是大部分情况我们还是需要等待这个循环完成才进行之后的操作。</p><h2 id="如何确保循环的所有异步操作完成之后执行某个其他操作"><a href="#如何确保循环的所有异步操作完成之后执行某个其他操作" class="headerlink" title="如何确保循环的所有异步操作完成之后执行某个其他操作"></a>如何确保循环的所有异步操作完成之后执行某个其他操作</h2><h3 id="方法一：设置一个flag，在每个异步操作中对flag进行检测"><a href="#方法一：设置一个flag，在每个异步操作中对flag进行检测" class="headerlink" title="方法一：设置一个flag，在每个异步操作中对flag进行检测"></a>方法一：设置一个flag，在每个异步操作中对flag进行检测</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">  flag++;</span><br><span class="line">  Database.save_method().exec().then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span>(flag === len) &#123;</span><br><span class="line">            <span class="comment">// your code</span></span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：将所有的循环放在一个promise中，使用then处理"><a href="#方法二：将所有的循环放在一个promise中，使用then处理" class="headerlink" title="方法二：将所有的循环放在一个promise中，使用then处理"></a>方法二：将所有的循环放在一个promise中，使用then处理</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</span><br><span class="line">      resolve()</span><br><span class="line"> &#125;).then(<span class="function"><span class="params">()</span>=&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">           Database.save_method().exec()</span><br><span class="line">     &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// your code</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法三：串行遍历"><a href="#方法三：串行遍历" class="headerlink" title="方法三：串行遍历"></a>方法三：串行遍历</h3><p>要等待所有的结果返回，我们还是要回到老式的 for 循环写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> array)&#123;</span><br><span class="line">    <span class="keyword">await</span> delayedLog(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果符合我们的预期：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure><h3 id="方法四：并行遍历"><a href="#方法四：并行遍历" class="headerlink" title="方法四：并行遍历"></a>方法四：并行遍历</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c606vfgvj30tg081mxe.jpg" alt="img"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processArray</span>(<span class="params">array</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//map array to promise</span></span><br><span class="line">  <span class="keyword">const</span> promises=array.map(delayedLog)</span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Done!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（注意：对于特别大的数组不建议使用这种写法，太多的并行任务会加重 CPU 和内存的负荷）</p><h2 id="循环中的下一步操作依赖于前一步的操作，如何解决"><a href="#循环中的下一步操作依赖于前一步的操作，如何解决" class="headerlink" title="循环中的下一步操作依赖于前一步的操作，如何解决"></a>循环中的下一步操作依赖于前一步的操作，如何解决</h2><h3 id="方法一：使用递归，在异步操作完成之后调用下一次异步操作"><a href="#方法一：使用递归，在异步操作完成之后调用下一次异步操作" class="headerlink" title="方法一：使用递归，在异步操作完成之后调用下一次异步操作"></a>方法一：使用递归，在异步操作完成之后调用下一次异步操作</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params">i</span>)</span>&#123;</span><br><span class="line">  i++;</span><br><span class="line">  Database.save_method().exec().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      loop(i)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法二：使用async和await（串行遍历）"><a href="#方法二：使用async和await（串行遍历）" class="headerlink" title="方法二：使用async和await（串行遍历）"></a>方法二：使用async和await（串行遍历）</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">loop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">         <span class="keyword">await</span> Database.save_method().exec();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="如何优雅地写js异步循环"><a href="#如何优雅地写js异步循环" class="headerlink" title="如何优雅地写js异步循环"></a>如何优雅地写js异步循环</h1><h2 id="循环的方式"><a href="#循环的方式" class="headerlink" title="循环的方式"></a>循环的方式</h2><p>假设我们有个数组，包含 5 个数字：<code>let times = [100, 150, 200, 250, 300]</code>；<br>还有一个异步的睡觉方法：<code>sleep(time, cb)</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当没有 cb 时，返回一个 Promise 对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">time, cb</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        setTimeout(cb, time);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">            setTimeout(resolve, time);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在要去循环睡这几个数字，问你有哪些睡法？🤔</p><p>为了方便交流，我就给这几个睡法起个名字：</p><ol><li>All in：你如果赶时间又不担心消耗过度，你可以一次性都睡了；</li><li>One by one：你想细水长流，你可以一个一个睡；</li><li>With concurrency：你害羞地低下头，说一次能不能睡两个。</li></ol><blockquote><p>作为一段有节操的代码，肯定要告诉其他人你睡完了，也就是必须有全部完成的回调，否则我们接下来的交流会毫无意义。</p></blockquote><p>本文目的是和大家探讨如何写出优雅的异步循环代码，并不是去实现这些循环控制的逻辑；而保持代码优雅，个人以为最好的办法是使用较新的语言特性，其次是使用优秀的开源项目，最后才是自己撸。下面会使用 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fcaolan%2Fasync" target="_blank" rel="noopener">Async</a>、<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fpetkaantonov%2Fbluebird" target="_blank" rel="noopener">Promise(bluebird)</a> 和 ES7 中的 <code>async/await</code> 对比下实现这几种循环的区别。</p><h3 id="All-in"><a href="#All-in" class="headerlink" title="All in"></a>All in</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c606vfgvj30tg081mxe.jpg" alt="All in"></p><p>这种方式效率是最高的，耗时取决于循环中最慢的那个异步方法。对资源的消耗也是最大的，如果大量循环请求后端服务，很有可能造成瞬时拥堵的情况。</p><p>如果自己实现，这也是最简单的场景，加一个完成计数器，每个异步方法完就给这个完成计数器加 1，然后检查完成数是不是等于数组长度，一旦相等就表示所有的异步方法执行完毕，通知全部完成的回调。</p><h4 id="使用-async-each："><a href="#使用-async-each：" class="headerlink" title="使用 async.each："></a>使用 async.each：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; each &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async all in'</span>);  </span><br><span class="line">each(times, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async all in: 304.627ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-all："><a href="#使用-Promise-all：" class="headerlink" title="使用 Promise.all："></a>使用 Promise.all：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise all in'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.all(times.map(<span class="function"><span class="params">time</span> =&gt;</span> sleep(time))).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise all in: 305.509ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await："><a href="#使用ES7-async-await：" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 all in'</span>);</span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> i <span class="keyword">of</span> times.map(<span class="function"><span class="params">time</span> =&gt;</span> sleep(time))) &#123;&#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 all in'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 all in: 305.986ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h3 id="One-by-one"><a href="#One-by-one" class="headerlink" title="One by one"></a>One by one</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c65nlncwj30tg04374g.jpg" alt="One by one"></p><p>这种方式效率最低，有点类似于同步语言中的循环，一个接着一个执行，耗时自然也就是所有异步方法耗时的总和。对资源的消耗最小。</p><p>这个实现起来也比较简单，把数组看做一个队列，每次从队列<code>shift</code>出一个代入异步方法执行，执行完成就开始递归调用这个过程，当队列长度为空就表示所有的异步方法执行完毕，结束递归，通知全部完成的回调。</p><h4 id="使用-async-eachSeries："><a href="#使用-async-eachSeries：" class="headerlink" title="使用 async.eachSeries："></a>使用 async.eachSeries：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eachSeries &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async one by one'</span>);  </span><br><span class="line">eachSeries(times, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async one by one: 1020.078ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-reduce："><a href="#使用-Promise-reduce：" class="headerlink" title="使用 Promise.reduce："></a>使用 Promise.reduce：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise one by one'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.reduce(times, (last, curr) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">return</span> sleep(curr);</span><br><span class="line">&#125;, <span class="number">0</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise one by one: 1023.014ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await：-1"><a href="#使用ES7-async-await：-1" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 one by one'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> time <span class="keyword">of</span> times) &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(time);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 one by one: 1025.513ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h3 id="With-concurrency"><a href="#With-concurrency" class="headerlink" title="With concurrency"></a>With concurrency</h3><p>这种方式稍微复杂些，但也是最灵活的方式，可以随心控制并发数。效率和耗时取决于魔法数字 <code>concurrency</code>，当 <code>concurrency</code> 大于或等于数组长度时，它就等同于 <strong>All in</strong> 方式；当 <code>concurrency</code> 为 1 时，它就等同于 <strong>One by one</strong> 方式。所以耗时和对资源的消耗都会介于以上两种方式之间。</p><p><strong>With concurrency</strong> 本身在实现上也会有不同的方式，分别是预分组和任务池。</p><h4 id="预分组"><a href="#预分组" class="headerlink" title="预分组"></a>预分组</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c66v9wx3j30tg05074j.jpg" alt="Pre Group"></p><p>顾名思义，就是提前将数组内容按 <code>concurrency</code> 分好组，组内是以 <strong>All in</strong> 方式执行，组之间则是以 <strong>One by one</strong> 的方式执行。</p><p>就以上文的例子，假如 <code>concurrency</code> 为 2，<code>times</code> 预先分组成：<code>[[100, 150], [200, 250], [300]]</code>，这样耗时会是 700（150 + 250 + 300）。</p><p>这个实现方式可以有效地控制并发数，优点就是简单，缺点是并不能达到效率最大化。</p><h4 id="任务池"><a href="#任务池" class="headerlink" title="任务池"></a>任务池</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g7c67an02oj30tg066q38.jpg" alt="Task Pool"></p><p>任务池的方式就是设置一个容量为 <code>concurrency</code> 的池子，比如容量为 2，初始化放入两个任务，每当有任务完成，就继续往池子添加新的任务，直到所有任务都完成。上文的例子执行过程大致如下：</p><ol><li><code>time = 0; pool = [100, 150]</code>：放入 <code>100</code> 和 <code>150</code></li><li><code>time = 100; pool = [150, 200]</code>：<code>100</code> 结束，放入 <code>200</code></li><li><code>time = 150; pool = [200, 250]</code>：<code>150</code> 结束，放入 <code>250</code></li><li><code>time = 300; pool = [250, 300]</code>：<code>200</code> 结束，放入 <code>300</code></li><li><code>time = 400; pool = [300]</code>：<code>250</code> 结束，没有更多任务</li><li><code>time = 600; pool = []</code>：<code>300</code> 结束，循环完毕</li></ol><p>得出来的耗时是 600，比预分组的方式效率更高，而且同样能有效控制并发个数。async 和 bluebird 也有相关的方法供直接使用。</p><h4 id="使用-async-eachLimit："><a href="#使用-async-eachLimit：" class="headerlink" title="使用 async.eachLimit："></a>使用 async.eachLimit：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; eachLimit &#125; <span class="keyword">from</span> <span class="string">'async'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'async with concurrency'</span>);  </span><br><span class="line">eachLimit(times, <span class="number">2</span>, sleep, (err) =&gt; &#123;  </span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'async with concurrency'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// async with concurrency: 611.498ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用-Promise-map（bluebird-特有-api）："><a href="#使用-Promise-map（bluebird-特有-api）：" class="headerlink" title="使用 Promise.map（bluebird 特有 api）："></a>使用 Promise.map（bluebird 特有 api）：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">Promise</span> <span class="keyword">from</span> <span class="string">'bluebird'</span>;  </span><br><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);  </span><br><span class="line"><span class="built_in">console</span>.time(<span class="string">'promise one by one'</span>);  </span><br><span class="line"><span class="built_in">Promise</span>.map(times, (time) =&gt; &#123;  </span><br><span class="line">    <span class="keyword">return</span> sleep(time);</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    concurrency: <span class="number">2</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'promise one by one'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// promise with concurrency: 616.601ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h4 id="使用ES7-async-await：-2"><a href="#使用ES7-async-await：-2" class="headerlink" title="使用ES7 async/await："></a>使用ES7 async/await：</h4><blockquote><p><code>pool</code> 方法来自<a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fdavetemplin%2Fasync-parallel%2Fblob%2Fmaster%2Findex.ts%23L153" target="_blank" rel="noopener">davetemplin/async-parallel</a></p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sleep <span class="keyword">from</span> <span class="string">'./sleep'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> times = [<span class="number">100</span>, <span class="number">150</span>, <span class="number">200</span>, <span class="number">250</span>, <span class="number">300</span>];</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep start'</span>);</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">'es7 with concurrency'</span>);</span><br><span class="line">    <span class="keyword">await</span> pool(<span class="number">2</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">        <span class="keyword">await</span> sleep(times.shift());</span><br><span class="line">        <span class="keyword">return</span> times.length &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">'es7 with concurrency'</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'sleep complete'</span>);</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">pool</span>(<span class="params">size, task</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> active = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> done = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">var</span> errors = [];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">        next();</span><br><span class="line">        <span class="function"><span class="keyword">function</span> <span class="title">next</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (active &lt; size &amp;&amp; !done) &#123;</span><br><span class="line">                active += <span class="number">1</span>;</span><br><span class="line">                task()</span><br><span class="line">                    .then(<span class="function"><span class="params">more</span> =&gt;</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (--active === <span class="number">0</span> &amp;&amp; (done || !more))</span><br><span class="line">                            errors.length === <span class="number">0</span> ? resolve() : reject(errors);</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (more)</span><br><span class="line">                            next();</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            done = <span class="literal">true</span>;</span><br><span class="line">                    &#125;)</span><br><span class="line">                    .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">                        errors.push(err);</span><br><span class="line">                        done = <span class="literal">true</span>;</span><br><span class="line">                        <span class="keyword">if</span> (--active === <span class="number">0</span>)</span><br><span class="line">                            reject(errors);</span><br><span class="line">                    &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// sleep start</span></span><br><span class="line"><span class="comment">// es7 with concurrency: 612.197ms</span></span><br><span class="line"><span class="comment">// sleep complete</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，到这应该可以给这三种循环方式打下分了：</p><table><thead><tr><th><strong>循环方式</strong></th><th>效率</th><th>消耗</th><th>灵活度</th><th>复杂度</th></tr></thead><tbody><tr><td><strong>All in</strong></td><td>高</td><td>高</td><td>低</td><td>低</td></tr><tr><td><strong>One by one</strong></td><td>低</td><td>低</td><td>低</td><td>低</td></tr><tr><td><strong>With concurrency</strong></td><td>中</td><td>中</td><td>高</td><td>高</td></tr></tbody></table><p>乍一看 <strong>With concurrency</strong> 是完胜，其实并没有。<strong>All in</strong> 和 <strong>One by one</strong> 虽然灵活度低，但是应用的场景还是非常广泛的。要求效率优先就使用 <strong>All in</strong>；如果有下一次循环依赖上一次循环结果的场景，就必须使用 <strong>One by One</strong>。</p><p>再说下上面 async、bluebird、ES7 对这三种循环方式的实现。需求一直在变，async 需要修改的代码非常少，甚至只要改下方法名就可以，方法定义简单优雅，这可能也是 async 易上手的原因；bluebird 在 <code>Promise</code> 标准基础上添加的方法非常实用，如：map、join…，以至于我几乎是没有使用过原生 <code>Promise</code> 😂；ES7 新增的 <code>async/await</code> 语法特性确实减轻了编写异步代码的痛苦，同时还增强了代码的可读性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;循环中的异步操作问题小结&quot;&gt;&lt;a href=&quot;#循环中的异步操作问题小结&quot; class=&quot;headerlink&quot; title=&quot;循环中的异步操作问题小结&quot;&gt;&lt;/a&gt;循环中的异步操作问题小结&lt;/h1&gt;&lt;p&gt;循环的异步操作主要有两个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>伪类和伪元素</title>
    <link href="http://yoursite.com/2019/11/16/%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    <id>http://yoursite.com/2019/11/16/伪类和伪元素/</id>
    <published>2019-11-16T11:40:32.000Z</published>
    <updated>2019-11-16T11:49:57.412Z</updated>
    
    <content type="html"><![CDATA[<h1 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h1><p><code>css</code>引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分。</p><ul><li>伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过<code>:hover</code>来描述这个元素的状态。虽然它和普通的<code>css</code>类相似，可以为已有的元素添加样式，但是它只有处于<code>dom</code>树无法描述的状态下才能为元素添加样式，所以将其称为伪类。</li><li>伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过<code>:before</code>来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。</li></ul><p>伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。</p><p>伪类和伪元素的根本区别在于：它们是否创造了<strong>新</strong>的元素,,   这个新创造的元素就叫  “伪无素” 。</p><p>##伪类</p><p>伪类前面是一个冒号，<code>E:first-child</code>会对现有的元素进行筛选</p><ul><li><p><code>:link</code>:选择未访问的链接</p></li><li><p><code>:visited</code>:选择已访问的链接</p></li><li><p><code>:hover</code>:选择鼠标指针浮动在其上的元素</p></li><li><p><code>:active</code>:选择活动的链接</p></li><li><p><code>:focus</code>:选择获取焦点的输入字段</p></li><li><p><code>:not()</code>:一个否定伪类，用于匹配不符合参数选择器的元素。</p></li><li><p><code>:first-child</code>:匹配元素的第一个子元素。</p></li><li><p><code>:last-child</code>:匹配元素的最后一个子元素。</p></li><li><p><code>:first-of-type</code>:匹配属于其父元素的首个特定类型的子元素的每个元素。</p></li><li><p><code>:last-of-type</code>:匹配属于其父元素的最后一个特定类型的子元素的每个元素。</p></li><li><p><code>:nth-child</code>:<code>:nth-child</code>根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素</p></li><li><p><code>:nth-last-child</code>:<code>:nth-last-child</code> 与<code>:nth-child</code>相似，不同之处在于它是从最后一个子元素开始计数的。</p></li><li><p><code>:nth-of-type</code>:<code>:nth-of-type</code> 与 <code>nth-child</code>相似，不同之处在于它是只匹配特定类型的元素。</p></li><li><p><code>:nth-last-type</code>:<code>:nth-last-of-type</code> 与 <code>nth-of-type</code>相似，不同之处在于它是从最后一个子元素开始计数的。</p></li><li><p><code>:only-child</code> :当元素是其父元素中唯一一个特定类型的子元素时，<code>:only-child</code>匹配该元素。</p></li><li><p><code>:target</code> :当URL带有锚名称，指向文档内某个具体的元素时，<code>:target</code>匹配该元素。</p></li><li><p><code>:checked</code>:<code>:checked</code>匹配被选中的 input 元素，这个 input 元素包括 radio 和 checkbox。</p></li><li><p><code>:default</code>: 匹配默认选中的元素</p></li><li><p><code>:disabled</code>: 匹配禁用的表单元素。</p></li><li><p><code>:empty</code> :匹配没有子元素的元素</p></li><li><p><code>:enabled</code>: 匹配没有设置 disabled 属性的表单元素。</p></li><li><p><code>:in-range</code>: 匹配在指定区域内元素。</p></li><li><p><code>:out-of-range</code>: 与<code>:in-range</code>相反，它匹配不在指定区域内的元素。</p></li><li><p><code>:indeterminate</code>:indeterminate 的英文意思是“ 不确定的”。当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。</p></li><li><p><code>:valid</code> :匹配条件验证正确的表单元素。</p></li><li><p><code>:invalid</code>: 与<code>:valid</code> 相反，匹配条件验证错误的表单元素。</p></li><li><p><code>:optional</code>:匹配是具有 optional 属性的表单元素。当表单元素没有设置为 required 时，即为 optional 属性。</p></li><li><p><code>:required</code>: 与<code>:optional</code>相反匹配设置了 required 属性的表单元素。</p></li><li><p><code>:read-only</code>: 匹配设置了只读属性的元素，表单元素可以通过设置“readonly” 属性来定义元素只读。</p></li><li><p><code>:read-write</code>: 匹配处于编辑状态的元素。input，textarea 和设置了 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。</p></li><li><p><code>:scope</code>: 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。</p></li><li><p><code>:dir</code>:匹配指定阅读方向的元素，当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持:dir 伪类，并在火狐浏览器中使用时需要添加前缀 ( -moz-dir() )。</p></li><li><p><code>:lang</code>:匹配设置了特定语言的元素，设置特定语言可以通过为了 HTML 元素设置 lang=”” 属性，设置 meta 元素的 charset=”” 属性，或者是在 http 头部上设置语言属性。</p><p>实际上，lang=”” 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。</p></li></ul><ul><li><code>:root</code>:匹配文档的根元素。一般的 html 文件的根元素是 html 元素，而 SVG 或 XML 文件的根元素则可能是其他元素。</li><li><code>:fullscreen</code>: 匹配处于全屏模式下的元素。全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79wl6d5ouj30gi0exq4h.jpg" alt="img"></p><p>##伪元素</p><p>伪元素前面是两个冒号，<code>E::first-line</code>会创造出不存在的新元素，由于css对单冒号的伪元素也支持，所以这样很容易让新学者混淆。但实际上现在css3已经明确规定了伪类单冒号，伪元素双冒号的规则。</p><ul><li><p><code>::before/:before</code>在被选元素前插入内容。需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。</p></li><li><p><code>::after/:after</code> 在被元素后插入内容，其用法和特性与<code>:before</code>相似。</p><p>对于伪元素 <code>:before</code> 和 <code>:after</code> 而言，属性 <code>content</code> 是必须设置的，我们知道属性的值可以为字符串，也可以有其它形式，比如指向一张图片的 <code>URL:</code></p><p><code>content: url(&#39;img/icon.png&#39;)</code></p></li><li><p><code>::first-letter/:first-letter</code> 匹配元素中文本的首字母。被修饰的首字母不在文档树中</p></li><li><p><code>::first-line/:first-line</code> 匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。</p></li><li><p><code>::selection</code> 匹配用户被用户选中或者处于高亮状态的部分。在火狐浏览器使用时需要添加<code>-moz</code>前缀。该伪元素只支持双冒号的形式。</p></li><li><p><code>::placeholder</code> 匹配占位符的文本，只有元素设置了<code>placeholder</code>属性时，该伪元素才能生效。</p><p>伪元素不是<code>CSS</code>的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（<code>IE10</code>和<code>Firefox18</code>及其以下版本）会使用单冒号的形式。</p></li></ul><ul><li><code>::backdrop</code> 用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式</li></ul><p>注意：</p><ul><li>配合伪类使用<ul><li>伪元素 <code>:before</code> 还可以配合伪类使用，这里举经常与 <code>:before</code> 配合使用的伪类 <code>:hover</code> 为例：</li></ul></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.before</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:before</span>&#123;<span class="attribute">content</span>:<span class="string">'you before'</span>; <span class="attribute">color</span>:red;&#125;</span><br><span class="line">&lt;div class="before"&gt; me&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>配合取值函数 <code>attr()</code> 使用</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">::before</span>&#123;<span class="attribute">content</span>: <span class="built_in">attr</span>(title)&#125;</span><br><span class="line">&lt;a href="https://blog.ihoey.com" title="梦魇小栈"&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">效果</span><br><span class="line">&lt;a href="https://blog.ihoey.com" title="梦魇小栈"&gt;梦魇小栈&lt;/a&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g79wlwrg6aj30dn05w3yy.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;伪类和伪元素&quot;&gt;&lt;a href=&quot;#伪类和伪元素&quot; class=&quot;headerlink&quot; title=&quot;伪类和伪元素&quot;&gt;&lt;/a&gt;伪类和伪元素&lt;/h1&gt;&lt;p&gt;&lt;code&gt;css&lt;/code&gt;引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="伪元素" scheme="http://yoursite.com/tags/%E4%BC%AA%E5%85%83%E7%B4%A0/"/>
    
      <category term="伪类" scheme="http://yoursite.com/tags/%E4%BC%AA%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>sass&amp;less对比</title>
    <link href="http://yoursite.com/2019/11/11/sass&amp;less%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2019/11/11/sass&amp;less对比/</id>
    <published>2019-11-11T06:09:00.000Z</published>
    <updated>2019-11-10T15:36:08.788Z</updated>
    
    <content type="html"><![CDATA[<h1 id="sass-amp-less"><a href="#sass-amp-less" class="headerlink" title="sass&amp;less"></a>sass&amp;less</h1><p>##为什么要使用 CSS 预处理器？</p><p>作为前端开发人员，大家都知道，Js 中可以自定义变量，而 CSS 仅仅是一个标记语言，不是编程语言，因此不可以自定义变量，不可以引用等等。</p><p><strong>CSS 有具体以下几个缺点：</strong></p><p>语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器；</p><p>没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。</p><p>这就导致了我们在工作中无端增加了许多工作量。而使用 CSS 预处理器，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了我们的开发效率。</p><p>但是，CSS 预处理器也不是万金油，CSS 的好处在于简便、随时随地被使用和调试。预编译 CSS 步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。</p><p>所以我们在实际项目中衡量预编译方案时，还是得想想，比起带来的额外维护开销，CSS 预处理器有没有解决更大的麻烦。</p><h2 id="主要区别："><a href="#主要区别：" class="headerlink" title="主要区别："></a>主要区别：</h2><p>首先 sass 和 less 都是 css 的预编译处理语言，他们引入了 mixins，参数，嵌套规则，运算，颜色，名字空间，作用域，JavaScript 赋值等 加快了 css 开发效率,当然这两者都可以配合 gulp 和 grunt 等前端构建工具使用</p><p>sass 和 less<strong>主要区别:在于实现方式 less 是基于 JavaScript 的在客户端处理 所以安装的时候用 npm，sass 是基于 ruby 所以在服务器处理。</strong></p><h2 id="SASS-介绍"><a href="#SASS-介绍" class="headerlink" title="SASS 介绍"></a>SASS 介绍</h2><p>Sass 是 Ruby 开发者为前端开发提供的处理 CSS 的工具。它为 CSS 提供更动态的设定方式，允许编译、变量、函数……总之，使 CSS 更动态，也更像一门真正的可编程语言。</p><ol><li>Sass 是基于 Ruby 开发的，所以开发环境首先需要安装 Ruby。</li><li>浏览器中无法编译 Sass，所以要先编译好 css 文件，再交给浏览器。Sass<strong>不能</strong>在浏览器环境中直接运行。</li></ol><p>##Less 介绍</p><p>Less 是晚些产生的语言，基于 JS 进行开发，在 Node 中进行编译。所以使用时不需要安装其他语言，不过要记得<strong>先导入 less 文件，然后导入 less.js</strong>。提供 CDN 地址在这里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/less.js/3.0.4/less.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/less.js/3.0.4/less.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然 Less 也提供服务器端的编译功能。</p><h2 id="Stylus-介绍"><a href="#Stylus-介绍" class="headerlink" title="Stylus 介绍"></a>Stylus 介绍</h2><p><a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2F" target="_blank" rel="noopener">Stylus</a>相对前两者较新，可以看官方文档介绍的功能。</p><p>1.来自 NodeJS 社区，所以和 NodeJS 走得很近，与 JavaScript 联系非常紧密。还有专门 JavaScript API：<a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2Fdocs%2Fjs.html" target="_blank" rel="noopener">learnboost.github.io/stylus/docs…</a></p><p>2.支持 Ruby 之类等等框架</p><p>3.更多更强大的支持和功能</p><p>以 stylus 的角度来说,stylus 更加注重对 javascript( <a href="https://link.juejin.im?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flearnboost.github.io%2Fstylus%2Fdocs%2Fjs.html" target="_blank" rel="noopener">learnboost.github.io/stylus/docs…</a> ) 的利用。 当用户觉得写 stylus 函数遇到了过于复杂或者无法测试，stylus 语法不支持等需求时， 也可以直接用 js 来实现这个函数并且在 stylus 中调用。</p><p>其次从编译器源码上来看：stylus 应该比 less.js 更有条理， 感觉如果未来社区添加功能的话，stylus 的源码添加起功能来会更简单，同样，目前 stylus 的功能也更复杂。</p><p>stylus 和 sass 另一个区别在于 sass 本身会建议，以下划线(_) 打头的文件在静态资源打包的时候不会被编译成 .css 文件【只是作为一种 import 存在】。而 stylus 没有这方面的规范。</p><p>同时写过 stylus 和 sass， 就语法简洁来看， stylus 在这方面占了很大的便宜。</p><h2 id="三者对比"><a href="#三者对比" class="headerlink" title="三者对比"></a><a href="https://cloud.tencent.com/developer/article/1092653" target="_blank" rel="noopener">三者对比</a></h2><ul><li><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3></li></ul><p>Sass: $var<br>Less: @var<br>两种语言都会有作用域的问题。一个变量只能在它被定义的代码块中使用。重复定义的变量会报错。</p><p>Stylus 对变量名没有任何限定，你可以是 $ 开始，也可以是任意的字符，而且与变量值之间可以用冒号、空格隔开，需要注意的是 Stylus (0.22.4) 将会编译 @ 开始的变量，但其对应的值并不会赋予该变量，换句话说，在 Stylus 的变量名不要用 @ 开头。</p><ul><li><h3 id="运算赋值："><a href="#运算赋值：" class="headerlink" title="运算赋值："></a>运算赋值：</h3></li></ul><p>只要保持单位统一或可相互转换，就可以进行运算，包括颜色在内：<br>Sass:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: e + -resize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="comment">// p &#123;</span></span><br><span class="line"><span class="comment">//   cursor: e-resize;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: (<span class="number">14px</span>/<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50px</span> + <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="variable">$var</span> * <span class="number">10%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Less:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base:</span> <span class="number">5%</span>;</span><br><span class="line"><span class="variable">@filler:</span> <span class="variable">@base</span> * <span class="number">2</span>;</span><br><span class="line"><span class="variable">@other:</span> <span class="variable">@base</span> + <span class="variable">@filler</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">color</span>: <span class="number">#888</span> / <span class="number">4</span>;</span><br><span class="line"><span class="attribute">background-color</span>: <span class="variable">@base-color</span> + <span class="number">#111</span>;</span><br><span class="line"><span class="attribute">height</span>: <span class="number">100%</span> / <span class="number">2</span> + <span class="variable">@filler</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">@var:</span> <span class="number">1px</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">width</span>: (<span class="variable">@var</span> + <span class="number">5</span>) * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">border</span>: (<span class="variable">@width</span> * <span class="number">2</span>) solid black;</span><br></pre></td></tr></table></figure><ul><li><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3></li></ul><p>Sass 和 Less 均允许元素嵌套。如果父子选择器均用逗号分开，那么编译时会按结合律拆开编译。<br>Sass 和 Less 指代上层元素均使用<code>&amp;</code>符号。</p><ul><li><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3></li></ul><p>Sass 中，写好的选择器进行集成，需要<code>@extend</code>关键字。（sytlus 与 sass 相同）<br>Less 中，直接写入即可：<code>.be-extend-class;</code></p><ul><li><h3 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h3></li></ul><p>Sass 中，需要进行 Mixin 操作的选择器需要<code>@mixin</code>关键字，选择器后可以传入变量和默认值。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">mixin</span> left(<span class="variable">$value</span>: 10px) padding: <span class="variable">$value</span>;</span><br></pre></td></tr></table></figure><p>使用时使用<code>@include</code>关键字，并可以更新变量：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">include</span> left @<span class="keyword">include</span> left(<span class="number">20px</span>);</span><br></pre></td></tr></table></figure><p>Less 中 Mixin 和继承感觉更相似，选择器在书写时就留好了变量，直接继承或更新变量即可：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.be-extend-class</span>(<span class="variable">@width</span>: <span class="number">10px</span>) &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="variable">@width</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="selector-class">.be-extend-class</span>;</span><br><span class="line"><span class="selector-class">.be-extend-class</span>(<span class="number">20px</span>);</span><br></pre></td></tr></table></figure><p>sass：在 sass 定义 Mixins 和 less、stylus 有所不同，在声明 Mixins 时需要使用“@mixin”,然后后面紧跟 Mixins 的名，他也可以定义参数，同时可以给这个参数设置一个默认值，但参数名是使用“$”符号开始，而且和参数值之间需要使用冒号（：）分开。另外在 sass 中调用 Mixins 需要使用“@include”，然后在其后紧跟你要调用的 Mixins 名。</p><p>less：less 中声明 Mixins 和 CSS 定义样式非常类似，可以将 Mixins 看成是一个选择器，当然 Mixins 也可以设置参数，并给参数设置默认值。不过设置参数的变量名是使用“@”开始，同样参数和默认参数值之间需要使用冒号（：）分开。</p><p>stylus：stylus 和前两者也略有不同，他可以不使用任何符号，就是直接定义 Mixins 名，然后在定义参数和默认值之间用等号（=）来连接。</p><ul><li><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3></li></ul><p>两种语言相同：多行注释格式可保留，单行注释格式会在编译时被删除。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 会被保留的注释格式 */</span></span><br><span class="line"><span class="comment">// 不保存的注释格式</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="颜色运算："><a href="#颜色运算：" class="headerlink" title="颜色运算："></a>颜色运算：</h3></li></ul><p>CSS 预处理器提供一系列<strong>颜色函数</strong>帮助生成主题系列颜色：<br>Sass：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lighten(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #d6d65c</span></span><br><span class="line">darken(<span class="selector-id">#cc3</span>, 10%) <span class="comment">// #a3a329</span></span><br><span class="line">grayscale(<span class="selector-id">#cc3</span>) <span class="comment">// #808080 灰度</span></span><br><span class="line">complement(<span class="selector-id">#cc3</span>) <span class="comment">// #33c</span></span><br></pre></td></tr></table></figure><p>Less：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">lighten</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color which is 10% *lighter* than @color</span></span><br><span class="line"><span class="selector-tag">darken</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color which is 10% *darker* than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">saturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);    <span class="comment">// return a color 10% *more* saturated than @color</span></span><br><span class="line"><span class="selector-tag">desaturate</span>(<span class="variable">@color</span>, <span class="number">10%</span>);  <span class="comment">// return a color 10% *less* saturated than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">fadein</span>(<span class="variable">@color</span>, <span class="number">10%</span>);      <span class="comment">// return a color 10% *less* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fadeout</span>(<span class="variable">@color</span>, <span class="number">10%</span>);     <span class="comment">// return a color 10% *more* transparent than @color</span></span><br><span class="line"><span class="selector-tag">fade</span>(<span class="variable">@color</span>, <span class="number">50%</span>);        <span class="comment">// return @color with 50% transparency</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, <span class="number">10</span>);         <span class="comment">// return a color with a 10 degree larger in hue than @color</span></span><br><span class="line"><span class="selector-tag">spin</span>(<span class="variable">@color</span>, -<span class="number">10</span>);        <span class="comment">// return a color with a 10 degree smaller hue than @color</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">mix</span>(<span class="variable">@color1</span>, <span class="variable">@color2</span>);    <span class="comment">// return a mix of @color1 and @color2</span></span><br></pre></td></tr></table></figure><p>stylus：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lighten(color, 10%); /* 返回的颜色在'color'基础上变亮10% */</span><br><span class="line">darken(color, 10%);  /* 返回的颜色在'color'基础上变暗10% */</span><br><span class="line">saturate(color, 10%);   /* 返回的颜色在'color'基础上饱和度增加10% */</span><br><span class="line">desaturate(color, 10%); /* 返回的颜色在'color'基础上饱和度降低10% */</span><br></pre></td></tr></table></figure><ul><li><h3 id="插入文件"><a href="#插入文件" class="headerlink" title="插入文件"></a>插入文件</h3></li></ul><p>两种语言相同，使用@import 关键字引入。注意后缀名，可以直接导入 css 文件。后缀名为 css 的文件不会被预处理器处理。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">import</span> <span class="string">"path/filename.scss"</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">"lib.less"</span>;</span><br><span class="line">@<span class="keyword">import</span> <span class="string">"lib.css"</span>;</span><br></pre></td></tr></table></figure><ul><li><h3 id="高级语法："><a href="#高级语法：" class="headerlink" title="==高级语法：=="></a>==高级语法：==</h3></li></ul><h4 id="SASS"><a href="#SASS" class="headerlink" title="SASS"></a>SASS</h4><p>在 Sass 中，需要用 Sass 自己的一套语言编程：</p><ol><li>条件 if-else</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">if</span> lightness(<span class="variable">$color</span>) &gt; 30% &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125; @<span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>循环</li></ol><p>for:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">for</span> <span class="variable">$i</span> from 1 to 10 &#123;</span><br><span class="line">  <span class="selector-class">.border-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">border</span>: #&#123;<span class="variable">$i</span>&#125;px solid blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line">@<span class="keyword">while</span> <span class="variable">$i</span> &gt; 0 &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>each:</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">each</span> <span class="variable">$member</span> in a, b, c, d &#123;</span><br><span class="line">  .#&#123;<span class="variable">$member</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">"/image/#&#123;$member&#125;.jpg"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>自定义函数</li></ol><p>需要<code>@function</code>、<code>@return</code>关键字。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@function double(<span class="variable">$n</span>) &#123;</span><br><span class="line">  @return <span class="variable">$n</span> * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: double(<span class="number">5px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h4><p>Less 是使用 JS 作为编译环境的，所以它支持 JS 语法。</p><ol><li>字符串插值</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@base-url:</span> <span class="string">"http://assets.fnord.com"</span>;</span><br><span class="line"><span class="attribute">background-image</span>: url(<span class="string">"@&#123;base-url&#125;/images/bg.png"</span>);</span><br></pre></td></tr></table></figure><ol start="2"><li>用反引号使用 JS 语法：</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@var:</span> <span class="built_in">` "hello" .toUpperCase() + "!" `</span>;</span><br></pre></td></tr></table></figure><ol start="3"><li>直接访问 JS 环境</li></ol><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@height:</span> <span class="built_in">`document.body.clientHeight`</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;sass-amp-less&quot;&gt;&lt;a href=&quot;#sass-amp-less&quot; class=&quot;headerlink&quot; title=&quot;sass&amp;amp;less&quot;&gt;&lt;/a&gt;sass&amp;amp;less&lt;/h1&gt;&lt;p&gt;##为什么要使用 CSS 预处理器？&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="SASS" scheme="http://yoursite.com/tags/SASS/"/>
    
      <category term="LESS" scheme="http://yoursite.com/tags/LESS/"/>
    
  </entry>
  
  <entry>
    <title>oh-my-zsh git 命令缩写</title>
    <link href="http://yoursite.com/2019/11/05/oh-my-zsh%20git%20%E5%91%BD%E4%BB%A4%E7%BC%A9%E5%86%99/"/>
    <id>http://yoursite.com/2019/11/05/oh-my-zsh git 命令缩写/</id>
    <published>2019-11-05T13:08:23.000Z</published>
    <updated>2019-11-10T14:37:39.026Z</updated>
    
    <content type="html"><![CDATA[<p>#oh-my-zsh git 命令缩写</p><p>喜欢用 git 命令行，平时能少打几个字还是会节省不少时间的。</p><h2 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">alias ga=<span class="string">'git add'</span></span><br><span class="line">alias gb=<span class="string">'git branch'</span></span><br><span class="line">alias gba=<span class="string">'git branch -a'</span></span><br><span class="line">alias gbd=<span class="string">'git branch -d'</span></span><br><span class="line">alias gcam=<span class="string">'git commit -a -m'</span></span><br><span class="line">alias gcb=<span class="string">'git checkout -b'</span></span><br><span class="line">alias gco=<span class="string">'git checkout'</span></span><br><span class="line">alias gcp=<span class="string">'git cherry-pick'</span></span><br><span class="line">alias gd=<span class="string">'git diff'</span></span><br><span class="line">alias gfo=<span class="string">'git fetch origin'</span></span><br><span class="line">alias ggpush=<span class="string">'git push origin $(git_current_branch)'</span></span><br><span class="line">alias ggsup=<span class="string">'git branch --set-upstream-to=origin/$(git_current_branch)'</span></span><br><span class="line">alias glgp=<span class="string">'git log --stat -p'</span></span><br><span class="line">alias gm=<span class="string">'git merge'</span></span><br><span class="line">alias gp=<span class="string">'git push'</span></span><br><span class="line">alias gst=<span class="string">'git status'</span></span><br><span class="line">alias gsta=<span class="string">'git stash save'</span></span><br><span class="line">alias gstp=<span class="string">'git stash pop'</span></span><br></pre></td></tr></table></figure><h2 id="全部"><a href="#全部" class="headerlink" title="全部"></a>全部</h2><p>参考：<a href="https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh" target="_blank" rel="noopener">https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><span class="line">alias g=<span class="string">'git'</span></span><br><span class="line"></span><br><span class="line">alias ga=<span class="string">'git add'</span></span><br><span class="line">alias gaa=<span class="string">'git add --all'</span></span><br><span class="line">alias gapa=<span class="string">'git add --patch'</span></span><br><span class="line">alias gau=<span class="string">'git add --update'</span></span><br><span class="line"></span><br><span class="line">alias gb=<span class="string">'git branch'</span></span><br><span class="line">alias gba=<span class="string">'git branch -a'</span></span><br><span class="line">alias gbd=<span class="string">'git branch -d'</span></span><br><span class="line">alias gbda=<span class="string">'git branch --no-color --merged | command grep -vE "^(\*|\s*(master|develop|dev)\s*$)" | command xargs -n 1 git branch -d'</span></span><br><span class="line">alias gbl=<span class="string">'git blame -b -w'</span></span><br><span class="line">alias gbnm=<span class="string">'git branch --no-merged'</span></span><br><span class="line">alias gbr=<span class="string">'git branch --remote'</span></span><br><span class="line">alias gbs=<span class="string">'git bisect'</span></span><br><span class="line">alias gbsb=<span class="string">'git bisect bad'</span></span><br><span class="line">alias gbsg=<span class="string">'git bisect good'</span></span><br><span class="line">alias gbsr=<span class="string">'git bisect reset'</span></span><br><span class="line">alias gbss=<span class="string">'git bisect start'</span></span><br><span class="line"></span><br><span class="line">alias gc=<span class="string">'git commit -v'</span></span><br><span class="line">alias gc!=<span class="string">'git commit -v --amend'</span></span><br><span class="line">alias gcn!=<span class="string">'git commit -v --no-edit --amend'</span></span><br><span class="line">alias gca=<span class="string">'git commit -v -a'</span></span><br><span class="line">alias gca!=<span class="string">'git commit -v -a --amend'</span></span><br><span class="line">alias gcan!=<span class="string">'git commit -v -a --no-edit --amend'</span></span><br><span class="line">alias gcans!=<span class="string">'git commit -v -a -s --no-edit --amend'</span></span><br><span class="line">alias gcam=<span class="string">'git commit -a -m'</span></span><br><span class="line">alias gcsm=<span class="string">'git commit -s -m'</span></span><br><span class="line">alias gcb=<span class="string">'git checkout -b'</span></span><br><span class="line">alias gcf=<span class="string">'git config --list'</span></span><br><span class="line">alias gcl=<span class="string">'git clone --recursive'</span></span><br><span class="line">alias gclean=<span class="string">'git clean -fd'</span></span><br><span class="line">alias gpristine=<span class="string">'git reset --hard &amp;&amp; git clean -dfx'</span></span><br><span class="line">alias gcm=<span class="string">'git checkout master'</span></span><br><span class="line">alias gcd=<span class="string">'git checkout develop'</span></span><br><span class="line">alias gcmsg=<span class="string">'git commit -m'</span></span><br><span class="line">alias gco=<span class="string">'git checkout'</span></span><br><span class="line">alias gcount=<span class="string">'git shortlog -sn'</span></span><br><span class="line">compdef _git gcount</span><br><span class="line">alias gcp=<span class="string">'git cherry-pick'</span></span><br><span class="line">alias gcpa=<span class="string">'git cherry-pick --abort'</span></span><br><span class="line">alias gcpc=<span class="string">'git cherry-pick --continue'</span></span><br><span class="line">alias gcs=<span class="string">'git commit -S'</span></span><br><span class="line"></span><br><span class="line">alias gd=<span class="string">'git diff'</span></span><br><span class="line">alias gdca=<span class="string">'git diff --cached'</span></span><br><span class="line">alias gdct=<span class="string">'git describe --tags `git rev-list --tags --max-count=1`'</span></span><br><span class="line">alias gdt=<span class="string">'git diff-tree --no-commit-id --name-only -r'</span></span><br><span class="line">alias gdw=<span class="string">'git diff --word-diff'</span></span><br><span class="line"></span><br><span class="line">gdv() &#123; git diff -w <span class="string">"$@"</span> | view - &#125;</span><br><span class="line">compdef _git gdv=git-diff</span><br><span class="line"></span><br><span class="line">alias gf=<span class="string">'git fetch'</span></span><br><span class="line">alias gfa=<span class="string">'git fetch --all --prune'</span></span><br><span class="line">alias gfo=<span class="string">'git fetch origin'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gfg</span>(<span class="params"></span>) </span>&#123; git ls-files | grep $@ &#125;</span><br><span class="line">compdef _grep gfg</span><br><span class="line"></span><br><span class="line">alias gg=<span class="string">'git gui citool'</span></span><br><span class="line">alias gga=<span class="string">'git gui citool --amend'</span></span><br><span class="line"></span><br><span class="line">ggf() &#123;</span><br><span class="line">  [[ <span class="string">"$#"</span> != <span class="number">1</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">  git push --force origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggf=git-checkout</span><br><span class="line"></span><br><span class="line">ggl() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> != <span class="number">0</span> ]] &amp;&amp; [[ <span class="string">"$#"</span> != <span class="number">1</span> ]]; then</span><br><span class="line">    git pull origin <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    [[ <span class="string">"$#"</span> == <span class="number">0</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">    git pull origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggl=git-checkout</span><br><span class="line"></span><br><span class="line">ggp() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> != <span class="number">0</span> ]] &amp;&amp; [[ <span class="string">"$#"</span> != <span class="number">1</span> ]]; then</span><br><span class="line">    git push origin <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    [[ <span class="string">"$#"</span> == <span class="number">0</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">    git push origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggp=git-checkout</span><br><span class="line"></span><br><span class="line">ggpnp() &#123;</span><br><span class="line">  <span class="keyword">if</span> [[ <span class="string">"$#"</span> == <span class="number">0</span> ]]; then</span><br><span class="line">    ggl &amp;&amp; ggp</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    ggl <span class="string">"$&#123;*&#125;"</span> &amp;&amp; ggp <span class="string">"$&#123;*&#125;"</span></span><br><span class="line">  fi</span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggpnp=git-checkout</span><br><span class="line"></span><br><span class="line">ggu() &#123;</span><br><span class="line">  [[ <span class="string">"$#"</span> != <span class="number">1</span> ]] &amp;&amp; local b=<span class="string">"$(git_current_branch)"</span></span><br><span class="line">  git pull --rebase origin <span class="string">"$&#123;b:=$1&#125;"</span></span><br><span class="line">&#125;</span><br><span class="line">compdef _git ggu=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpur=<span class="string">'ggu'</span></span><br><span class="line">compdef _git ggpur=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpull=<span class="string">'git pull origin $(git_current_branch)'</span></span><br><span class="line">compdef _git ggpull=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggpush=<span class="string">'git push origin $(git_current_branch)'</span></span><br><span class="line">compdef _git ggpush=git-checkout</span><br><span class="line"></span><br><span class="line">alias ggsup=<span class="string">'git branch --set-upstream-to=origin/$(git_current_branch)'</span></span><br><span class="line">alias gpsup=<span class="string">'git push --set-upstream origin $(git_current_branch)'</span></span><br><span class="line"></span><br><span class="line">alias ghh=<span class="string">'git help'</span></span><br><span class="line"></span><br><span class="line">alias gignore=<span class="string">'git update-index --assume-unchanged'</span></span><br><span class="line">alias gignored=<span class="string">'git ls-files -v | grep "^[[:lower:]]"'</span></span><br><span class="line">alias git-svn-dcommit-push=<span class="string">'git svn dcommit &amp;&amp; git push github master:svntrunk'</span></span><br><span class="line">compdef _git git-svn-dcommit-push=git</span><br><span class="line"></span><br><span class="line">alias gk=<span class="string">'\gitk --all --branches'</span></span><br><span class="line">compdef _git gk=<span class="string">'gitk'</span></span><br><span class="line">alias gke=<span class="string">'\gitk --all $(git log -g --pretty=%h)'</span></span><br><span class="line">compdef _git gke=<span class="string">'gitk'</span></span><br><span class="line"></span><br><span class="line">alias gl=<span class="string">'git pull'</span></span><br><span class="line">alias glg=<span class="string">'git log --stat'</span></span><br><span class="line">alias glgp=<span class="string">'git log --stat -p'</span></span><br><span class="line">alias glgg=<span class="string">'git log --graph'</span></span><br><span class="line">alias glgga=<span class="string">'git log --graph --decorate --all'</span></span><br><span class="line">alias glgm=<span class="string">'git log --graph --max-count=10'</span></span><br><span class="line">alias glo=<span class="string">'git log --oneline --decorate'</span></span><br><span class="line">alias glol=<span class="string">"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit"</span></span><br><span class="line">alias glola=<span class="string">"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --all"</span></span><br><span class="line">alias glog=<span class="string">'git log --oneline --decorate --graph'</span></span><br><span class="line">alias gloga=<span class="string">'git log --oneline --decorate --graph --all'</span></span><br><span class="line">alias glp=<span class="string">"_git_log_prettily"</span></span><br><span class="line">compdef _git glp=git-log</span><br><span class="line"></span><br><span class="line">alias gm=<span class="string">'git merge'</span></span><br><span class="line">alias gmom=<span class="string">'git merge origin/master'</span></span><br><span class="line">alias gmt=<span class="string">'git mergetool --no-prompt'</span></span><br><span class="line">alias gmtvim=<span class="string">'git mergetool --no-prompt --tool=vimdiff'</span></span><br><span class="line">alias gmum=<span class="string">'git merge upstream/master'</span></span><br><span class="line"></span><br><span class="line">alias gp=<span class="string">'git push'</span></span><br><span class="line">alias gpd=<span class="string">'git push --dry-run'</span></span><br><span class="line">alias gpoat=<span class="string">'git push origin --all &amp;&amp; git push origin --tags'</span></span><br><span class="line">compdef _git gpoat=git-push</span><br><span class="line">alias gpu=<span class="string">'git push upstream'</span></span><br><span class="line">alias gpv=<span class="string">'git push -v'</span></span><br><span class="line"></span><br><span class="line">alias gr=<span class="string">'git remote'</span></span><br><span class="line">alias gra=<span class="string">'git remote add'</span></span><br><span class="line">alias grb=<span class="string">'git rebase'</span></span><br><span class="line">alias grba=<span class="string">'git rebase --abort'</span></span><br><span class="line">alias grbc=<span class="string">'git rebase --continue'</span></span><br><span class="line">alias grbi=<span class="string">'git rebase -i'</span></span><br><span class="line">alias grbm=<span class="string">'git rebase master'</span></span><br><span class="line">alias grbs=<span class="string">'git rebase --skip'</span></span><br><span class="line">alias grh=<span class="string">'git reset HEAD'</span></span><br><span class="line">alias grhh=<span class="string">'git reset HEAD --hard'</span></span><br><span class="line">alias grmv=<span class="string">'git remote rename'</span></span><br><span class="line">alias grrm=<span class="string">'git remote remove'</span></span><br><span class="line">alias grset=<span class="string">'git remote set-url'</span></span><br><span class="line">alias grt=<span class="string">'cd $(git rev-parse --show-toplevel || echo ".")'</span></span><br><span class="line">alias gru=<span class="string">'git reset --'</span></span><br><span class="line">alias grup=<span class="string">'git remote update'</span></span><br><span class="line">alias grv=<span class="string">'git remote -v'</span></span><br><span class="line"></span><br><span class="line">alias gsb=<span class="string">'git status -sb'</span></span><br><span class="line">alias gsd=<span class="string">'git svn dcommit'</span></span><br><span class="line">alias gsi=<span class="string">'git submodule init'</span></span><br><span class="line">alias gsps=<span class="string">'git show --pretty=short --show-signature'</span></span><br><span class="line">alias gsr=<span class="string">'git svn rebase'</span></span><br><span class="line">alias gss=<span class="string">'git status -s'</span></span><br><span class="line">alias gst=<span class="string">'git status'</span></span><br><span class="line">alias gsta=<span class="string">'git stash save'</span></span><br><span class="line">alias gstaa=<span class="string">'git stash apply'</span></span><br><span class="line">alias gstc=<span class="string">'git stash clear'</span></span><br><span class="line">alias gstd=<span class="string">'git stash drop'</span></span><br><span class="line">alias gstl=<span class="string">'git stash list'</span></span><br><span class="line">alias gstp=<span class="string">'git stash pop'</span></span><br><span class="line">alias gsts=<span class="string">'git stash show --text'</span></span><br><span class="line">alias gsu=<span class="string">'git submodule update'</span></span><br><span class="line"></span><br><span class="line">alias gts=<span class="string">'git tag -s'</span></span><br><span class="line">alias gtv=<span class="string">'git tag | sort -V'</span></span><br><span class="line"></span><br><span class="line">alias gunignore=<span class="string">'git update-index --no-assume-unchanged'</span></span><br><span class="line">alias gunwip=<span class="string">'git log -n 1 | grep -q -c "\-\-wip\-\-" &amp;&amp; git reset HEAD~1'</span></span><br><span class="line">alias gup=<span class="string">'git pull --rebase'</span></span><br><span class="line">alias gupv=<span class="string">'git pull --rebase -v'</span></span><br><span class="line">alias glum=<span class="string">'git pull upstream master'</span></span><br><span class="line"></span><br><span class="line">alias gwch=<span class="string">'git whatchanged -p --abbrev-commit --pretty=medium'</span></span><br><span class="line">alias gwip=<span class="string">'git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m "--wip-- [skip ci]"'</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#oh-my-zsh git 命令缩写&lt;/p&gt;
&lt;p&gt;喜欢用 git 命令行，平时能少打几个字还是会节省不少时间的。&lt;/p&gt;
&lt;h2 id=&quot;常用&quot;&gt;&lt;a href=&quot;#常用&quot; class=&quot;headerlink&quot; title=&quot;常用&quot;&gt;&lt;/a&gt;常用&lt;/h2&gt;&lt;figure
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Object.prototype.toString方法的原理</title>
    <link href="http://yoursite.com/2019/10/28/Object.prototype.toString%E6%96%B9%E6%B3%95%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/10/28/Object.prototype.toString方法的原理/</id>
    <published>2019-10-28T04:33:37.000Z</published>
    <updated>2019-11-10T14:37:39.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Object-prototype-toString-方法的原理"><a href="#Object-prototype-toString-方法的原理" class="headerlink" title="Object.prototype.toString 方法的原理"></a>Object.prototype.toString 方法的原理</h1><h2 id="ECMAScript-3"><a href="#ECMAScript-3" class="headerlink" title="ECMAScript 3"></a>ECMAScript 3</h2><h3 id="Object-prototype-toString-方法的规范"><a href="#Object-prototype-toString-方法的规范" class="headerlink" title="Object.prototype.toString 方法的规范"></a>Object.prototype.toString 方法的规范</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>获取 this 对象的[[Class]]属性的值.</li><li>计算出三个字符串<strong>“[object “,</strong>第一步的操作结果 Result(1), 以及 <strong>“]”</strong>连接后的新字符串.</li><li>返回第二步的操作结果 Result(2).</li></ol><h3 id="Class"><a href="#Class" class="headerlink" title="[[Class]]"></a>[[Class]]</h3><p>[[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的</p><table><thead><tr><th>内部属性</th><th>描述</th></tr></thead><tbody><tr><td>[[Class]]</td><td>一个字符串值,表明了该对象的类型.</td></tr></tbody></table><p>然后给了一段解释:</p><blockquote><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过<strong>Object.prototype.toString</strong>方法之外,本规范没有提供任何其他方式来让程序访问该属性的值</p></blockquote><p>也就是说,把 Object.prototype.toString 方法返回的字符串,去掉前面固定的<strong>“[object “</strong>和后面固定的<strong>“]”,</strong>就是内部属性[[class]]的值,也就达到了判断对象类型的目的。</p><h3 id="Class-的值"><a href="#Class-的值" class="headerlink" title="[[Class]]的值"></a>[[Class]]的值</h3><p>在 ES3 中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有 10 种.分别是:<code>&quot;Array&quot;</code>, <code>&quot;Boolean&quot;</code>, <code>&quot;Date&quot;</code>, <code>&quot;Error&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;Math&quot;</code>, <code>&quot;Number&quot;</code>, <code>&quot;Object&quot;</code>, <code>&quot;RegExp&quot;</code>, <code>&quot;String&quot;.</code></p><h2 id="ECMAScript-5"><a href="#ECMAScript-5" class="headerlink" title="ECMAScript 5"></a>ECMAScript 5</h2><h3 id="Object-prototype-toString-方法的规范-1"><a href="#Object-prototype-toString-方法的规范-1" class="headerlink" title="Object.prototype.toString 方法的规范"></a>Object.prototype.toString 方法的规范</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用 ToObject(<strong>this)</strong>的结果.</li><li>让<em>class</em>成为<em>O</em>的内部属性[[Class]]的值.</li><li>返回三个字符串<strong>“[object “,</strong> <em>class</em>, 以及 <strong>“]”</strong>连接后的新字符串.</li></ol><p>可以看出,ES5 比 ES3 多了 1,2,3 步.第 1,2 步属于新规则,比较特殊,因为”<code>Undefined&quot;</code>和”<code>Null&quot;</code>并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this 的值才会保持 undefined 或 null,非严格模式下会自动成为全局对象).第 3 步并不算是新规则,因为在 ES3 的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来.</p><h3 id="Class-1"><a href="#Class-1" class="headerlink" title="[[Class]]"></a>[[Class]]</h3><p>ES5 中,[[Class]]属性的解释更加详细:</p><blockquote><p>所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过<strong>Object.prototype.toString</strong>方法之外,本规范没有提供任何其他方式来让程序访问该属性的值</p></blockquote><h3 id="对比-ES3"><a href="#对比-ES3" class="headerlink" title="对比 ES3"></a>对比 ES3</h3><ul><li>第一个差别就是[[class]]内部属性的值多了两种,成了 12 种<ul><li>一种是 arguments 对象的[[class]]成了”Arguments”,而不是以前的”Object”</li><li>多个了全局对象 JSON,它的[[class]]值为”JSON”.</li></ul></li><li>第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这 12 种值冲突（不过在支持 ES3 的浏览器中,貌似也没有发现哪些宿主对象故意使用那 10 个值）</li></ul><h2 id="ECMAScript-6"><a href="#ECMAScript-6" class="headerlink" title="ECMAScript 6"></a>ECMAScript 6</h2><p><strong>[[class]]内部属性没有了</strong>,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的:</p><table><thead><tr><th>内部属性</th><th>属性值</th><th>描述</th></tr></thead><tbody><tr><td>[[NativeBrand]]</td><td>枚举 NativeBrand 的一个成员.</td><td>该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型.</td></tr></tbody></table><h3 id="NativeBrand-属性（internal-slot）"><a href="#NativeBrand-属性（internal-slot）" class="headerlink" title="[[NativeBrand]]属性（internal slot）"></a>[[NativeBrand]]属性（<code>internal slot</code>）</h3><p>[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的 ECMAScript 原生对象.只有在表 10 中明确指出的对象类型才有[[NativeBrand]]内部属性.</p><table><thead><tr><th>属性值</th><th>对应类型</th></tr></thead><tbody><tr><td>NativeFunction</td><td>Function objects</td></tr><tr><td>NativeArray</td><td>Array objects</td></tr><tr><td>StringWrapper</td><td>String objects</td></tr><tr><td>BooleanWrapper</td><td>Boolean objects</td></tr><tr><td>NumberWrapper</td><td>Number objects</td></tr><tr><td>NativeMath</td><td>The Math object</td></tr><tr><td>NativeDate</td><td>Date objects</td></tr><tr><td>NativeRegExp</td><td>RegExp objects</td></tr><tr><td>NativeError</td><td>Error objects</td></tr><tr><td>NativeJSON</td><td>The JSON object</td></tr><tr><td>NativeArguments</td><td>Arguments objects</td></tr><tr><td>NativePrivateName</td><td>Private Name objects</td></tr></tbody></table><p>可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]].</p><h3 id="Object-prototype-toString-方法的规范-2"><a href="#Object-prototype-toString-方法的规范-2" class="headerlink" title="Object.prototype.toString 方法的规范:"></a>Object.prototype.toString 方法的规范:</h3><p>在<strong>toString</strong>方法被调用时,会执行下面的操作步骤:</p><ol><li>如果<strong>this</strong>的值为<strong>undefined</strong>,则返回<code>&quot;[object Undefined]&quot;</code>.</li><li>如果<strong>this</strong>的值为<strong>null</strong>,则返回<code>&quot;[object Null]&quot;</code>.</li><li>让<em>O</em>成为调用 ToObject(<strong>this)</strong>的结果.</li><li>如果<em>O</em>有[[NativeBrand]]内部属性,让<em>tag</em>成为表 29 中对应的值.</li><li>否则<ol><li>让<em>hasTag</em>成为调用<em>O</em>的[[HasProperty]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>hasTag</em>为<strong>false</strong>,则让<em>tag</em>为<code>&quot;Object&quot;</code>.</li><li>否则,<ol><li>让<em>tag</em>成为调用<em>O</em>的[[Get]]内部方法后的结果,参数为@@toStringTag.</li><li>如果<em>tag</em>是一个 abrupt completion,则让<em>tag</em>成为 NormalCompletion(<code>&quot;???&quot;</code>).</li><li>让<em>tag<em>成为</em>tag</em>.[[value]].</li><li>如果 Type(<em>tag</em>)不是字符串,则让<em>tag 成为</em><code>&quot;???&quot;</code>.</li><li>如果<em>tag</em>的值为<code>&quot;Arguments&quot;</code>, <code>&quot;Array&quot;</code>, <code>&quot;Boolean&quot;</code>, <code>&quot;Date&quot;</code>, <code>&quot;Error&quot;</code>, <code>&quot;Function&quot;</code>, <code>&quot;JSON&quot;</code>, <code>&quot;Math&quot;</code>, <code>&quot;Number&quot;</code>, <code>&quot;Object&quot;</code>, <code>&quot;RegExp&quot;</code>,<code>或者&quot;String&quot;中的任一个,则让</code><em>tag</em>成为字符串<code>&quot;~&quot;和</code><em>tag</em>当前的值连接后的结果.</li></ol></li></ol></li><li>返回三个字符串”[object “, tag, and “]”连接后的新字符串.</li></ol><h3 id="ES6-里的新类型-Map-Set"><a href="#ES6-里的新类型-Map-Set" class="headerlink" title="ES6 里的新类型 Map,Set"></a>ES6 里的新类型 Map,Set</h3><p>ES6 里的新类型 Map,Set 等,都没有在表 29 中.它们在执行 toString 方法的时候返回的是什么?</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Map</span>())); <span class="comment">//"[object Map]"</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Set</span>())); <span class="comment">//"[object Set]"</span></span><br></pre></td></tr></table></figure><p>Map.prototype.@@toStringTag</p><p>@@toStringTag 属性的初始值为字符串<strong>“Map”</strong>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Object-prototype-toString-方法的原理&quot;&gt;&lt;a href=&quot;#Object-prototype-toString-方法的原理&quot; class=&quot;headerlink&quot; title=&quot;Object.prototype.toString 方法的原
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>函数式编程</title>
    <link href="http://yoursite.com/2019/10/21/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/10/21/函数式编程/</id>
    <published>2019-10-21T03:15:12.000Z</published>
    <updated>2019-11-10T14:37:39.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="什么是函数式编程"><a href="#什么是函数式编程" class="headerlink" title="什么是函数式编程"></a>什么是函数式编程</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>函数式编程是一种编程范式，主要是利用函数把运算过程封装起来，通过组合各种函数来计算结果。函数式编程意味着你可以在更短的时间内编写具有更少错误的代码。</p><p>举个简单的例子，假设我们要把字符串 <code>functional programming is great</code> 变成每个单词首字母大写，我们可以这样实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string = <span class="string">"functional programming is great"</span>;</span><br><span class="line"><span class="keyword">var</span> result = string</span><br><span class="line">  .split(<span class="string">" "</span>)</span><br><span class="line">  .map(<span class="function"><span class="params">v</span> =&gt;</span> v.slice(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + v.slice(<span class="number">1</span>))</span><br><span class="line">  .join(<span class="string">" "</span>);</span><br></pre></td></tr></table></figure><p>上面的例子先用 split 把字符串转换数组，然后再通过 map 把各元素的首字母转换成大写，最后通过 join 把数组转换成字符串。 整个过程就是 <code>join(map(split(str)))</code>,体现了函数式编程的核心思想： <strong>通过函数对数据进行转换</strong>。</p><h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>由此我们可以得到，函数式编程有两个基本特点：</p><ul><li>通过函数来对数据进行转换</li><li>通过串联多个函数来求结果</li></ul><h2 id="对比声明式与命令式"><a href="#对比声明式与命令式" class="headerlink" title="对比声明式与命令式"></a>对比声明式与命令式</h2><ul><li>命令式：我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。命令式代码中频繁使用语句,来完成某个行为。比如 for、if、switch、throw 等这些语句。</li><li>声明式：我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//命令式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; companies.length; i++) &#123;</span><br><span class="line">  CEOs.push(companies[i].CEO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明式</span></span><br><span class="line"><span class="keyword">var</span> CEOs = companies.map(<span class="function"><span class="params">c</span> =&gt;</span> c.CEO);</span><br></pre></td></tr></table></figure><p>从上面的例子中，我们可以看到声明式的写法是一个表达式，无需关心如何进行计数器迭代，返回的数组如何收集，它指明的是做什么，而不是怎么做。<strong>函数式编程的一个明显的好处就是这种声明式的代码</strong>，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。</p><h2 id="常见特性"><a href="#常见特性" class="headerlink" title="常见特性"></a>常见特性</h2><h3 id="无副作用"><a href="#无副作用" class="headerlink" title="无副作用"></a>无副作用</h3><p>指调用函数时不会修改外部状态，即一个函数调用 n 次后依然返回同样的结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 含有副作用，它修改了外部变量 a</span></span><br><span class="line"><span class="comment">// 多次调用结果不一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a++;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 无副作用，没有修改外部状态</span></span><br><span class="line"><span class="comment">// 多次调用结果一样</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="透明引用"><a href="#透明引用" class="headerlink" title="透明引用"></a>透明引用</h3><p>指一个函数只会用到传递给它的变量以及自己内部创建的变量，不会使用到其他变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 函数内部使用的变量并不属于它的作用域</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 函数内部使用的变量是显式传递进去的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test2</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h3><p>指的是一个变量一旦创建后，就不能再进行修改，任何修改都会生成一个新的变量。使用不可变变量最大的好处是线程安全。多个线程可以同时访问同一个不可变变量，让并行变得更容易实现。 由于 JavaScript 原生不支持不可变变量，需要通过第三方库来实现。 (如 Immutable.js，Mori 等等)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = Immutable(&#123; <span class="attr">a</span>: <span class="number">1</span> &#125;);</span><br><span class="line"><span class="keyword">var</span> obj2 = obj.set(<span class="string">"a"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Immutable(&#123; a: 1 &#125;)</span></span><br><span class="line"><span class="built_in">console</span>.log(obj2); <span class="comment">// Immutable(&#123; a: 2 &#125;)</span></span><br></pre></td></tr></table></figure><h3 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h3><p>我们常说函数是 JavaScript 的”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。下文将要介绍的闭包、高阶函数、函数柯里化和函数组合都是围绕这一特性的应用</p><h2 id="常见的函数式编程模型"><a href="#常见的函数式编程模型" class="headerlink" title="常见的函数式编程模型"></a>常见的函数式编程模型</h2><h3 id="1-闭包（Closure）"><a href="#1-闭包（Closure）" class="headerlink" title="1.闭包（Closure）"></a>1.闭包（Closure）</h3><p>如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。</p><p>闭包的形成条件：</p><ul><li>存在内、外两层函数</li><li>内层函数对外层函数的局部变量进行了引用</li></ul><p>闭包的用途:<br><strong>可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的缓存工具</span></span><br><span class="line"><span class="comment">// 匿名函数创造了一个闭包</span></span><br><span class="line"><span class="keyword">const</span> cache = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> store = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">get</span>(key) &#123;</span><br><span class="line">      <span class="keyword">return</span> store[key];</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>(key, val) &#123;</span><br><span class="line">      store[key] = val;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(cache); <span class="comment">//&#123;get: ƒ, set: ƒ&#125;</span></span><br><span class="line">cache.set(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line">cache.get(<span class="string">"a"</span>); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。</p><p>闭包的弊端:<strong>持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费</strong>，所以一般需要一些额外手动的清理机制。</p><h3 id="2-高阶函数"><a href="#2-高阶函数" class="headerlink" title="2.高阶函数"></a>2.高阶函数</h3><p>函数式编程倾向于复用一组通用的函数功能来处理数据，它通过使用高阶函数来实现。<strong>高阶函数指的是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值</strong>。</p><p>高阶函数经常用于：</p><ul><li>抽象或隔离行为、作用，异步控制流程作为回调函数，promises，monads 等</li><li>创建可以泛用于各种数据类型的功能</li><li>部分应用于函数参数（偏函数应用）或创建一个柯里化的函数，用于复用或函数复合。</li><li>接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。</li></ul><p>JavaScript 语言是原生支持高阶函数的, 例如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce 是 JavaScript 中内置的一些高阶函数，使用高阶函数会让我们的代码更清晰简洁。</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>map() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。map 不会改变原数组。</p><p>假设我们有一个包含名称和种类属性的对象数组，我们想要这个数组中所有名称属性放在一个新数组中，如何实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  names.push(animals[i].name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(names); <span class="comment">//["Fluffykins", "Caro", "Hamilton", "Harold", "Ursula", "Jimmy"]</span></span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> names = animals.map(<span class="function"><span class="params">x</span> =&gt;</span> x.name);</span><br><span class="line"><span class="built_in">console</span>.log(names); <span class="comment">//["Fluffykins", "Caro", "Hamilton", "Harold", "Ursula", "Jimmy"]</span></span><br></pre></td></tr></table></figure><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>filter() 方法会创建一个新数组，其中包含所有通过回调函数测试的元素。filter 为数组中的每个元素调用一次 callback 函数， callback 函数返回 true 表示该元素通过测试，保留该元素，false 则不保留。filter 不会改变原数组，它返回过滤后的新数组。</p><p>假设我们有一个包含名称和种类属性的对象数组。 我们想要创建一个只包含狗（species: “dog”）的数组。如何实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> dogs = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; animals.length; i++) &#123;</span><br><span class="line">  <span class="keyword">if</span> (animals[i].species === <span class="string">"dog"</span>) dogs.push(animals[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(dogs);</span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">var</span> animals = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Fluffykins"</span>, <span class="attr">species</span>: <span class="string">"rabbit"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Caro"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Hamilton"</span>, <span class="attr">species</span>: <span class="string">"dog"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Harold"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Ursula"</span>, <span class="attr">species</span>: <span class="string">"cat"</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">"Jimmy"</span>, <span class="attr">species</span>: <span class="string">"fish"</span> &#125;</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> dogs = animals.filter(<span class="function"><span class="params">x</span> =&gt;</span> x.species === <span class="string">"dog"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(dogs); <span class="comment">// &#123;name: "Caro", species: "dog"&#125;</span></span><br><span class="line"><span class="comment">// &#123; name: "Hamilton", species: "dog" &#125;</span></span><br></pre></td></tr></table></figure><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p>reduce 方法对调用数组的每个元素执行回调函数，最后生成一个单一的值并返回。 reduce 方法接受两个参数：1）reducer 函数（回调），2）一个可选的 initialValue。</p><p>假设我们要对一个数组的求和：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用高阶函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  sum = sum + arr[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br><span class="line"><span class="comment">// 使用高阶函数</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">const</span> sum = arr.reduce(</span><br><span class="line">  (accumulator, currentValue) =&gt; accumulator + currentValue,</span><br><span class="line">  <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(sum); <span class="comment">//25</span></span><br></pre></td></tr></table></figure><p>我们可以通过下图，形象生动展示三者的区别：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6ixh3e6euj30ml0bnwf2.jpg" alt="img"></p><h3 id="3-函数柯里化"><a href="#3-函数柯里化" class="headerlink" title="3.函数柯里化"></a>3.函数柯里化</h3><p>柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候，再一次性把所有传入的参数进行求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 函数柯里化</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> increment = add(<span class="number">1</span>);</span><br><span class="line">increment(<span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。那么，我们如何来实现一个简易的柯里化函数呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryIt</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 参数fn函数的参数个数</span></span><br><span class="line">  <span class="keyword">var</span> n = fn.length;</span><br><span class="line">  <span class="keyword">var</span> args = [];</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">    args.push(arg);</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; n) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">arguments</span>.callee; <span class="comment">// 返回这个函数的引用</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [a, b, c];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = curryIt(add);</span><br><span class="line"><span class="keyword">var</span> c1 = c(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> c2 = c1(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> c3 = c2(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">console</span>.log(c3); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>由此我们可以看出，柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法！</p><h3 id="4-函数组合-Composition"><a href="#4-函数组合-Composition" class="headerlink" title="4.函数组合 (Composition)"></a>4.函数组合 (Composition)</h3><p>前面提到过，函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。<br>假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个函数的组合</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function"><span class="keyword">function</span>(<span class="params">f, g</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> f(g(x));</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line"><span class="keyword">var</span> compose = <span class="function">(<span class="params">f, g</span>) =&gt;</span> <span class="function"><span class="params">x</span> =&gt;</span> f(g(x));</span><br><span class="line"><span class="keyword">var</span> add1 = <span class="function"><span class="params">x</span> =&gt;</span> x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> mul5 = <span class="function"><span class="params">x</span> =&gt;</span> x * <span class="number">5</span>;</span><br><span class="line">compose(</span><br><span class="line">  mul5,</span><br><span class="line">  add1</span><br><span class="line">)(<span class="number">2</span>); <span class="comment">// =&gt;15</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;函数式编程&quot;&gt;&lt;a href=&quot;#函数式编程&quot; class=&quot;headerlink&quot; title=&quot;函数式编程&quot;&gt;&lt;/a&gt;函数式编程&lt;/h1&gt;&lt;h2 id=&quot;什么是函数式编程&quot;&gt;&lt;a href=&quot;#什么是函数式编程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>IP</title>
    <link href="http://yoursite.com/2019/10/13/IP/"/>
    <id>http://yoursite.com/2019/10/13/IP/</id>
    <published>2019-10-13T07:41:22.000Z</published>
    <updated>2019-11-10T14:37:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h1><p>IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“<strong>实现终端节点之间的通信</strong>”。这种终端节点之间的通信也叫“点对点通信”。</p><p>网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。</p><p><strong>IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。</strong></p><h2 id="TCP-IP-基础"><a href="#TCP-IP-基础" class="headerlink" title="TCP/IP 基础"></a>TCP/IP 基础</h2><p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhns2grvj30lc0eojse.jpg" alt="img"></p><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhmr7ldbj30fk0dz751.jpg" alt="img"></p><p>网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。<strong>包首部就像协议的脸。</strong></p><h3 id="数据处理流程"><a href="#数据处理流程" class="headerlink" title="数据处理流程"></a>数据处理流程</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6zhpvepe5j30lg0lkdis.jpg" alt="img"></p><ol><li>应用程序处理<br>首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；<br>编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。</li><li>TCP 模块的处理<br>TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。</li><li>IP 模块的处理<br>IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。</li><li>网络接口（以太网驱动）的处理<br>从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。</li><li>网络接口（以太网驱动）的处理<br>主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。<br>如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。</li><li>IP 模块的处理<br>IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。<br>另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。</li><li>TCP 模块的处理<br>在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。</li><li>应用程序的处理<br>接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。</li></ol><h2 id="IP-服务的主要特点"><a href="#IP-服务的主要特点" class="headerlink" title="IP 服务的主要特点"></a>IP 服务的主要特点</h2><p>IP 协议为上层协议提供无状态、无连接、不可靠的服务。</p><ul><li><h6 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h6></li></ul><p>无状态是指 IP 通信双方不同步传输数据的状态信息，所有 IP 数据报的发送、传输、接受都是相互独立、没有上下文关系的。这种服务优点在于简单、高效。最大的缺点是无法处理乱序和重复的 IP 数据报，确保 IP 数据报完整的工作只能交给上层协议来完成。</p><ul><li><h6 id="无连接"><a href="#无连接" class="headerlink" title="无连接"></a>无连接</h6></li></ul><p>无连接是指 IP 通信双方都不长久地维持对方的任何信息。上层协议每次发送数据的时候，都需要明确指出对方的 IP 地址。</p><ul><li><h6 id="不可靠"><a href="#不可靠" class="headerlink" title="不可靠"></a>不可靠</h6></li></ul><p>不可靠是指 IP 协议不能保证 IP 数据报准确到达接收端，它指承诺尽最大努力交付。IP 模块一旦检测到数据报发送失败，就通知上层协议，而不会试图重传。</p><h2 id="IP-地址"><a href="#IP-地址" class="headerlink" title="IP 地址"></a>IP 地址</h2><h3 id="IP-地址概述"><a href="#IP-地址概述" class="headerlink" title="IP 地址概述"></a>IP 地址概述</h3><ul><li>在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。</li><li>作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“<strong>连接到网络中的所有主机中识别出进行通信的目标地址</strong>”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。</li><li>不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。</li><li>IP 地址（IPv4 地址）由 32 位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将 32 位的 IP 地址以每 8 位为一组，分成 4 组，每组以 “.” 隔开，再将每组数转换成十进制数。如下：</li></ul><table><thead><tr><th>2^8</th><th>2^8</th><th>2^8</th><th>2^8</th><th></th></tr></thead><tbody><tr><td>10101100</td><td>00010100</td><td>00000001</td><td>00000001</td><td>（2 进制）</td></tr><tr><td>172.</td><td>20.</td><td>1.</td><td>1</td><td>（10 进制）</td></tr></tbody></table><h3 id="IP-地址由网络和主机两部分标识组成"><a href="#IP-地址由网络和主机两部分标识组成" class="headerlink" title="IP 地址由网络和主机两部分标识组成"></a>IP 地址由网络和主机两部分标识组成</h3><ul><li>如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 <strong>IP 地址具有了唯一性</strong>。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l2qlpa6j30k80hiwhe.jpg" alt="img"></p><ul><li>如下图，IP 包被转发到途中某个路由器时，正是<strong>利用目标 IP 地址的网络标识进行路由</strong>。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l4my99cj30k40auabx.jpg" alt="img"></p><h3 id="IP-地址的分类"><a href="#IP-地址的分类" class="headerlink" title="IP 地址的分类"></a>IP 地址的分类</h3><p><strong>IP 地址分为四个级别，分别为 A 类、B 类、C 类、D 类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。</strong></p><ul><li><strong>A 类 IP 地址是首位以 “0” 开头的地址。</strong>从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 16,777,214 个。</li><li><strong>B 类 IP 地址是前两位 “10” 的地址。</strong>从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 65,534 个。</li><li><strong>C 类 IP 地址是前三位为 “110” 的地址。</strong>从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 254 个。</li><li><strong>D 类 IP 地址是前四位为 “1110” 的地址。</strong>从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。</li><li>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</li></ul><h3 id="广播地址"><a href="#广播地址" class="headerlink" title="广播地址"></a>广播地址</h3><ul><li>广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。</li><li>广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。</li></ul><h3 id="IP-多播"><a href="#IP-多播" class="headerlink" title="IP 多播"></a>IP 多播</h3><ul><li><p>多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。</p></li><li><p>相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70l8g7veoj30f70jjn02.jpg" alt="img"></p></li><li><p>多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。</p></li><li><p>此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。</p></li></ul><h3 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h3><ul><li>现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。</li><li>子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。</li><li>对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th></tr></thead><tbody><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr><tr><td></td><td></td><td></td><td></td><td></td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td></tr><tr><td>子网掩码</td><td>255.</td><td>255.</td><td>255.</td><td>192</td></tr></tbody></table><ul><li>第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下：</li></ul><table><thead><tr><th>IP 地址</th><th>172.</th><th>20.</th><th>100.</th><th>52</th><th>/ 26</th></tr></thead><tbody><tr><td>网络地址</td><td>172.</td><td>20.</td><td>100.</td><td>0</td><td>/ 26</td></tr><tr><td>广播地址</td><td>172.</td><td>20.</td><td>100.</td><td>63</td><td>/ 26</td></tr></tbody></table><ul><li>另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。</li></ul><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><ul><li>发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。</li><li>该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。</li><li>IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。</li></ul><h3 id="IP-地址与路由控制"><a href="#IP-地址与路由控制" class="headerlink" title="IP 地址与路由控制"></a>IP 地址与路由控制</h3><ul><li>IP 地址的网络地址部分用于进行路由控制。</li><li>路由控制表中记录着网络地址与下一步应该发送至路由器的地址。</li><li>在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70ldgjh6gj30ka0gen0n.jpg" alt="img"></p><h3 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h3><p>路由匹配顺序：<br>1） 直接匹配，查找路由表中是否由与目标 IP 地址完全匹配的主机 IP 地址，找到则匹配成功，没有的话转 2；<br>2）查找是否有与目标 IP 地址具有相同网络 ID 的 IP 地址，找到则匹配成功，没有的话转 3；<br>3）查看是否有默认网关，有则转发给它，没有的话，路由查找失败，由 ICMP 返回错误信息。</p><h3 id="路由更新"><a href="#路由更新" class="headerlink" title="路由更新"></a>路由更新</h3><p>通过 route 命令或其他工具可以手工修改路由表，是静态路由更新方式。对于大型路由器，它们通常通过 BGP、RIP、OSPF 等协议进行动态路由更新。</p><h2 id="IP-分包与组包"><a href="#IP-分包与组包" class="headerlink" title="IP 分包与组包"></a>IP 分包与组包</h2><ul><li>每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。</li><li>任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。</li><li>经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。</li></ul><h3 id="路径-MTU-发现"><a href="#路径-MTU-发现" class="headerlink" title="路径 MTU 发现"></a>路径 MTU 发现</h3><ul><li>分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。</li><li>为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。</li><li>进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。</li></ul><h2 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h2><h3 id="IPv4-头部"><a href="#IPv4-头部" class="headerlink" title="IPv4 头部"></a>IPv4 头部</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lsqccjaj30eh064dge.jpg" alt="img"></p><ul><li><h6 id="头部长度"><a href="#头部长度" class="headerlink" title="头部长度"></a>头部长度</h6></li></ul><p>标识该 IP 头部有多少个 32 位 bit 字（4 字节），由于 4 位最大描述 15，所以 IP 头部最大长度为 60 字节。</p><ul><li><h6 id="8-为服务位"><a href="#8-为服务位" class="headerlink" title="8 为服务位"></a>8 为服务位</h6></li></ul><p>包括 3 位优先权位，4 为 TOS 字段和 1 位保留字段。<br>4 为 TOS 字段分别表示：最小延时，最大吞吐量、最高可靠性和最小费用。其中最多能选择一位置 1，应用程序根据实际需要来设置服务类型。</p><ul><li><h6 id="16-位标识"><a href="#16-位标识" class="headerlink" title="16 位标识"></a>16 位标识</h6></li></ul><p>唯一标识主机发送的每一个数据报。其初始值由系统随机生成；每发一个数据报就加 1。每个分片中具有相同的标识值。</p><ul><li><h6 id="分片偏移"><a href="#分片偏移" class="headerlink" title="分片偏移"></a>分片偏移</h6></li></ul><p>有 3 位用于标识偏移，第一位保留，第二位 DF 字段（禁止分片标识），第三位 MF 字段（更多分片标识，最后一个分片为 0，其他分片置 1）。13 位偏移是勇敢将实际值左移三位得到的，因此要求数据部分的长度是 8 的倍数。</p><ul><li><h6 id="8-位协议"><a href="#8-位协议" class="headerlink" title="8 位协议"></a>8 位协议</h6></li></ul><p>标识上层协议，1 是 ICMP，6 是 TCP，17 是 UDP。</p><ul><li><h6 id="16-位头部校验和"><a href="#16-位头部校验和" class="headerlink" title="16 位头部校验和"></a>16 位头部校验和</h6></li></ul><p>IP 模块接受数据后，首先对数据报头部做 CRC 校验，确保 IP 头部在传输过程中无损坏后，再分析其头部具体信息。</p><h2 id="IPv6"><a href="#IPv6" class="headerlink" title="IPv6"></a>IPv6</h2><p>IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。</p><p>IPv6 协议并不是 IPv4 的简单扩展，而是完全独立的协议。从以太网帧封装的数据类型来看，前者类型是 0X86dd，后者是 0x8600，是完全不同的类型。</p><p>IPv6 解决了网络地址不足的问题，其头部增加了多播和流的功能，引入了自动配置功能，还增加了网络安全的功能。</p><h3 id="IPv6-头部固定部分"><a href="#IPv6-头部固定部分" class="headerlink" title="IPv6 头部固定部分"></a>IPv6 头部固定部分</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lv0wgqij30em05ydg6.jpg" alt="img"></p><ul><li><h6 id="流标签"><a href="#流标签" class="headerlink" title="流标签"></a>流标签</h6></li></ul><p>是 IPv6 新增加的字段，用于对某些连接的服务质量有特殊要求的通信，比如音频或者视频等实时数据传递。</p><ul><li><h6 id="下一个包头"><a href="#下一个包头" class="headerlink" title="下一个包头"></a>下一个包头</h6></li></ul><p>指出紧跟 IPv6 固定头部后的包头类型，如拓展头，或者某个上层协议头（ICMP，TCP，UDP），它类似 IPv4 中的协议字段，且相同的取值具有相同的含义。</p><h3 id="IPv6-的特点"><a href="#IPv6-的特点" class="headerlink" title="IPv6 的特点"></a>IPv6 的特点</h3><ul><li>IP 得知的扩大与路由控制表的聚合。</li><li>性能提升。包首部长度采用固定的值（40 字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。</li><li>支持即插即用功能。即使没有 DHCP 服务器也可以实现自动分配 IP 地址。</li><li>采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。</li><li>多播、Mobile IP 成为扩展功能。</li></ul><h3 id="IPv6-中-IP-地址的标记方法"><a href="#IPv6-中-IP-地址的标记方法" class="headerlink" title="IPv6 中 IP 地址的标记方法"></a>IPv6 中 IP 地址的标记方法</h3><ul><li>一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。</li><li>而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。</li></ul><h3 id="IPv6-地址的结构"><a href="#IPv6-地址的结构" class="headerlink" title="IPv6 地址的结构"></a>IPv6 地址的结构</h3><ul><li>IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。</li><li>在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。</li></ul><table><thead><tr><th>未定义</th><th>0000 … 0000（128 比特）</th><th>：：/ 128</th></tr></thead><tbody><tr><td>环回地址</td><td>0000 … 0001（128 比特）</td><td>：：1 / 128</td></tr><tr><td>唯一本地地址</td><td>1111 110</td><td>FC00：/ 7</td></tr><tr><td>链路本地单播地址</td><td>1111 1110 10</td><td>FE80：：/ 10</td></tr><tr><td>多播地址</td><td>1111 1111</td><td>FF00：：/ 8</td></tr><tr><td>全局单播地址</td><td>（其他）</td><td></td></tr></tbody></table><h3 id="全局单播地址"><a href="#全局单播地址" class="headerlink" title="全局单播地址"></a>全局单播地址</h3><ul><li>全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。</li><li>格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lktamkvj30lt08qmxq.jpg" alt="img"></p><h3 id="链路本地单播地址"><a href="#链路本地单播地址" class="headerlink" title="链路本地单播地址"></a>链路本地单播地址</h3><p>链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70llnrbecj30lg052weo.jpg" alt="img"></p><h3 id="唯一本地地址"><a href="#唯一本地地址" class="headerlink" title="唯一本地地址"></a>唯一本地地址</h3><ul><li>唯一本地地址是不进行互联网通信时所用的地址。</li><li>唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。</li><li>L 通常被置为 1</li><li>全局 ID 的值随机决定</li><li>子网 ID 是指该域子网地址</li><li>接口 ID 即为接口的 ID</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lmkuopyj30ms053mxf.jpg" alt="img"></p><h3 id="IPv6-分段处理"><a href="#IPv6-分段处理" class="headerlink" title="IPv6 分段处理"></a>IPv6 分段处理</h3><ul><li>IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。</li><li>IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。</li></ul><h3 id="IP-首部（暂略）"><a href="#IP-首部（暂略）" class="headerlink" title="IP 首部（暂略）"></a>IP 首部（暂略）</h3><h2 id="IP-协议相关技术"><a href="#IP-协议相关技术" class="headerlink" title="IP 协议相关技术"></a>IP 协议相关技术</h2><p>IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。</p><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。</li><li>这种 DNS 不仅适用于 IPv4，还适用于 IPv6。</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><ul><li>只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。</li><li>ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。</li><li>RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。</li></ul><h3 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h3><ul><li>ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。</li><li>IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。</li></ul><h3 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h3><ul><li>如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。</li><li>于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。</li><li>DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。</li></ul><h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><ul><li>NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。</li><li>除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。</li><li>NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。</li></ul><h3 id="IP-隧道"><a href="#IP-隧道" class="headerlink" title="IP 隧道"></a>IP 隧道</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g70lqkzre9j30ht04caaa.jpg" alt="img"></p><ul><li>如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。</li><li>IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。</li><li>一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IP&quot;&gt;&lt;a href=&quot;#IP&quot; class=&quot;headerlink&quot; title=&quot;IP&quot;&gt;&lt;/a&gt;IP&lt;/h1&gt;&lt;p&gt;IP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“&lt;strong&gt;实现终端节点之间的通信&lt;/s
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Http/1.0的Keep-Alive和Http/2.0的多路复用对比</title>
    <link href="http://yoursite.com/2019/10/04/Http1.0%E7%9A%84Keep-Alive%E5%92%8CHttp2.0%E7%9A%84%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E5%AF%B9%E6%AF%94%20copy/"/>
    <id>http://yoursite.com/2019/10/04/Http1.0的Keep-Alive和Http2.0的多路复用对比 copy/</id>
    <published>2019-10-04T08:14:38.000Z</published>
    <updated>2019-11-10T14:37:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比"><a href="#Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比" class="headerlink" title="Http/1.0 的 Keep-Alive 和 Http/2.0 的多路复用对比"></a>Http/1.0 的 Keep-Alive 和 Http/2.0 的多路复用对比</h1><h2 id="Http-1-0-的-Keep-Alive"><a href="#Http-1-0-的-Keep-Alive" class="headerlink" title="Http/1.0 的 Keep-Alive"></a>Http/1.0 的 Keep-Alive</h2><p>在没有<code>Keep-Alive</code>前，我们与服务器请求数据的流程是这样：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nsz9l0hxj30ac0caq3x.jpg" alt="clipboard.png"></p><ul><li>浏览器请求<code>//static.mtime.cn/a.js</code>–&gt;解析域名–&gt;HTTP 连接–&gt;服务器处理文件–&gt;返回数据–&gt;浏览器解析、渲染文件</li><li>浏览器请求<code>//static.mtime.cn/b.js</code>–&gt;解析域名–&gt;HTTP 连接–&gt;服务器处理文件–&gt;返回数据–&gt;浏览器解析、渲染文件</li><li>…</li><li>这样循环下去，直至全部文件下载完成。</li></ul><p>这个流程最大的问题就是：<strong>每次请求都会建立一次 HTTP 连接</strong>，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次建立连接是正常的，以后就占用这个通道，下载其他文件，这样效率多高啊！你猜对了，这就是<code>Keep-Alive</code>。</p><h3 id="Keep-Alive解决的问题"><a href="#Keep-Alive解决的问题" class="headerlink" title="Keep-Alive解决的问题"></a><code>Keep-Alive</code>解决的问题</h3><p><code>Keep-Alive</code>解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的<strong>一定时间</strong>是可以配置的，不管你用的是<code>Apache</code>还是<code>nginx</code>。</p><h3 id="HTTP1-1还是存在效率问题"><a href="#HTTP1-1还是存在效率问题" class="headerlink" title="HTTP1.1还是存在效率问题"></a><code>HTTP1.1</code>还是存在效率问题</h3><p>如上面所说，在<code>HTTP1.1</code>中是默认开启了<code>Keep-Alive</code>，他解决了多次连接的问题，但是依然有两个效率上的问题：</p><ul><li>第一个：<strong>串行的文件传输</strong>。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输）</li><li>第二个：<strong>连接数过多</strong>。我们假设<code>Apache</code>设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。</li></ul><h2 id="HTTP-2-的多路复用"><a href="#HTTP-2-的多路复用" class="headerlink" title="HTTP/2 的多路复用"></a>HTTP/2 的多路复用</h2><p>HTTP/2 的多路复用就是为了解决上述的两个性能问题，我们来看一下，他是如何解决的。</p><ul><li>解决第一个：在<code>HTTP1.1</code>的协议中，我们传输的<code>request</code>和<code>response</code>都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：<code>hello world</code>，只能从<code>h</code>到<code>d</code>一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在<code>HTTP1.1</code>是不能实现的。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nszfhktpj30kp05lmxt.jpg" alt="clipboard.png"></p><p><code>HTTP/2</code>引入<code>二进制数据帧</code>和<code>流</code>的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是<code>流</code>所做的事情。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nszichcoj30fm0aft9y.jpg" alt="clipboard.png"></p><ul><li>解决第二个问题：<code>HTTP/2</code>对同一域名下所有请求都是基于<code>流</code>，也就是说同一域名不管访问多少文件，也只<strong>建立一路连接</strong>。同样<code>Apache</code>的最大连接数为 300，因为有了这个新特性，最大的并发就可以提升到 300，比原来提升了 6 倍！</li></ul><h2 id="多路复用和-keep-alive-区别？"><a href="#多路复用和-keep-alive-区别？" class="headerlink" title="多路复用和 keep alive 区别？"></a><strong>多路复用和 keep alive 区别？</strong></h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6nt1pb7xkj30ln0l940f.jpg" alt="img"></p><p>1）线头阻塞（Head-of-Line Blocking），HTTP1.X 虽然可以采用 keep alive 来解决复用 TCP 的问题，但是还是无法解决请求阻塞问题。</p><p>2）所谓请求阻塞意思就是一条 TCP 的 connection 在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。</p><p>3）之所以有这个问题就是因为 HTTP1.x 需要每条请求都是可是识别，按顺序发送，否则 server 就无法判断该相应哪个具体的请求。</p><p>4）HTTP2 采用多路复用是指，在同一个域名下，开启一个 TCP 的 connection，每个请求以 stream 的方式传输，每个 stream 有唯一标识，connection 一旦建立，后续的请求都可以复用这个 connection 并且可以同时发送，server 端可以根据 stream 的唯一标识来相应对应的请求。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比&quot;&gt;&lt;a href=&quot;#Http-1-0-的-Keep-Alive-和-Http-2-0-的多路复用对比&quot; class=&quot;headerlink&quot; title=&quot;Http/1.0 的 K
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>CSS 清除浮动</title>
    <link href="http://yoursite.com/2019/09/29/CSS%20%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    <id>http://yoursite.com/2019/09/29/CSS 清除浮动/</id>
    <published>2019-09-29T07:26:33.000Z</published>
    <updated>2019-11-10T14:37:39.013Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-清除浮动"><a href="#CSS-清除浮动" class="headerlink" title="CSS 清除浮动"></a>CSS 清除浮动</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tbm9sca0j30op0fh0tp.jpg" alt="img"></p><h2 id="浮动是什么？"><a href="#浮动是什么？" class="headerlink" title="浮动是什么？"></a>浮动是什么？</h2><p>W3school 中给出的浮动定义为<strong>浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。</strong>由于浮动框脱离文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p><h2 id="浮动的特点"><a href="#浮动的特点" class="headerlink" title="浮动的特点"></a>浮动的特点</h2><p>浮动的特点，可以用八个字总结：<strong>脱标、贴边、字围和收缩。</strong></p><p>为了更好说明，请看下图：<br>当框 1 向左浮动时，它脱离文档流（<strong>脱标</strong>）并且向左移动（<strong>贴边</strong>），直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果框 2 中有文字，就会围着框 1 排开（<strong>字围</strong>）。</p><p>如果把所有三个框都向左浮动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tc3n56n2j30em06haa4.jpg" alt="img"><br>下面着重讲解下第四个特点–<strong>收缩</strong></p><p>一个浮动的内联元素（比如 span img 标签）不需要设置 display：block 就可以设置宽度。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    div &#123;</span><br><span class="line">      float: left;</span><br><span class="line">      background-color: greenyellow;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    这是一段文字</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>得到以下的效果：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tc6sc8yzj30qo01ft8h.jpg" alt="img"><br>我们都知道 div 标签是块级元素，会独占一行，然而上面的例子中将 div 设置为左浮后，其宽度不再是占满一行，而是收紧为内部元素的宽度，这就是浮动第四个特征的含义。</p><h2 id="浮动的缺点"><a href="#浮动的缺点" class="headerlink" title="浮动的缺点"></a>浮动的缺点</h2><p>先看下面这段代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.parent</span> &#123;</span></span><br><span class="line">      border: solid 5px;</span><br><span class="line">      width: 300px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child(1)</span> &#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child(2)</span> &#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background-color: red;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.child</span><span class="selector-pseudo">:nth-child(3)</span> &#123;</span></span><br><span class="line">      height: 100px;</span><br><span class="line">      width: 100px;</span><br><span class="line">      background-color: greenyellow;</span><br><span class="line">      float: left;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们想让父容器包裹着三个浮动元素，然而事与愿违，得到却是这样的结果：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tcc3apdwj30920393yb.jpg" alt="img"><br><strong>这就是浮动带来副作用—-父容器高度塌陷，于是清理浮动就显着至关重要。</strong></p><h2 id="清理浮动"><a href="#清理浮动" class="headerlink" title="清理浮动"></a>清理浮动</h2><p><strong>清除浮动不是不用浮动，是清除浮动产生的父容器高度塌陷</strong>。</p><h3 id="套路-1：给浮动元素的父元素添加高度（扩展性不好）"><a href="#套路-1：给浮动元素的父元素添加高度（扩展性不好）" class="headerlink" title="套路 1：给浮动元素的父元素添加高度（扩展性不好）"></a>套路 1：给浮动元素的父元素添加高度（扩展性不好）</h3><p>如果一个元素要浮动，那么它的父元素一定要有高度。高度的盒子，才能关住浮动。可以通过直接给父元素设置 height，实际应用中我们不大可能给所有的盒子加高度，不仅麻烦，并且不能适应页面的快速变化；另外一种，父容器的高度可以通过内容撑开（比如 img 图片），实际当中此方法用的比较多。</p><h3 id="套路-2：clear-both"><a href="#套路-2：clear-both" class="headerlink" title="套路 2：clear:both;"></a>套路 2：clear:both;</h3><p>在最后一个子元素后新添加一个冗余元素，然后将其设置 clear:both,这样就可以清除浮动。这里强调一点，即<strong>在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"clear: both;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="套路-3：伪元素清除浮动"><a href="#套路-3：伪元素清除浮动" class="headerlink" title="套路 3：伪元素清除浮动"></a>套路 3：伪元素清除浮动</h3><p>上面那种办法固然可以清除浮动，但是我们不想在页面中添加这些没有意义的冗余元素，此时如何清除浮动吗？<br><strong>结合 :after 伪元素和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span> <span class="attr">class</span>=<span class="string">"clearfix"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*开启haslayout*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;</span><br><span class="line">  *zoom: 1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*ie6 7不支持伪元素*/</span></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">  visibility: hidden; //允许浏览器渲染它，但是不显示出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>给浮动元素的父容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素，实现元素末尾添加一个看不见的块元素来清理浮动。这是通用的清理浮动方案，推荐使用</p><h3 id="套路-4：给父元素使用-overflow-hidden"><a href="#套路-4：给父元素使用-overflow-hidden" class="headerlink" title="套路 4：给父元素使用 overflow:hidden;"></a>套路 4：给父元素使用 overflow:hidden;</h3><p>这种方案让父容器形成了 BFC（块级格式上下文），而 BFC 可以包含浮动，通常用来解决浮动父元素高度坍塌的问题。</p><p><strong>BFC 的触发方式</strong></p><p>我们可以给父元素添加以下属性来触发 BFC：</p><ul><li>float 为 left | right</li><li>overflow 为 hidden | auto | scorll</li><li>display 为 table-cell | table-caption | inline-block</li><li>position 为 absolute | fixed</li></ul><p>这里可以给父元素设置 overflow:auto，但是为了兼容 IE 最好使用 overflow:hidden。</p><p><strong>但这种办法有个缺陷：如果有内容出了盒子，用这种方法就会把多的部分裁切掉，所以这时候不能使用。</strong></p><p><strong>BFC 的主要特征:</strong></p><ul><li>BFC 容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的 BFC 来解决垂直边距折叠问题。</li><li>BFC 不会重叠浮动元素</li><li>BFC 可以包含浮动,这可以清除浮动。</li></ul><h3 id="套路-5：br-标签清浮动"><a href="#套路-5：br-标签清浮动" class="headerlink" title="套路 5：br 标签清浮动"></a>套路 5：br 标签清浮动</h3><p><strong>br 标签存在一个属性：clear。这个属性就是能够清除浮动的利器，在 br 标签中设置属性 clear，并赋值 all。即能清除掉浮动</strong>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> <span class="attr">clear</span>=<span class="string">"all"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#wrap</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#inner</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-清除浮动&quot;&gt;&lt;a href=&quot;#CSS-清除浮动&quot; class=&quot;headerlink&quot; title=&quot;CSS 清除浮动&quot;&gt;&lt;/a&gt;CSS 清除浮动&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/006y8m
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="清除浮动" scheme="http://yoursite.com/tags/%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8/"/>
    
  </entry>
  
  <entry>
    <title>git merge和git rebase的区别</title>
    <link href="http://yoursite.com/2019/09/21/git%20merge%E5%92%8Cgit%20rebase%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2019/09/21/git merge和git rebase的区别/</id>
    <published>2019-09-21T14:53:17.000Z</published>
    <updated>2019-09-21T14:54:12.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h1><p>git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wkw4uh2dj30xc0qtjsl.jpg" alt="img"></p><p>为了将master 上新的提交合并到你的feature分支上，你有两种选择：<code>merging</code> or <code>rebase</code></p><h2 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h2><p>执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git merge master</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge master feature</span><br></pre></td></tr></table></figure><p>那么此时在feature上git 自动会产生一个新的commit(merge commit)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wky69tunj30w90850te.jpg" alt="img"></p><h3 id="git-merge-有如下特点："><a href="#git-merge-有如下特点：" class="headerlink" title="git merge 有如下特点："></a><code>git merge</code> 有如下特点：</h3><ul><li>只处理一次冲突，如果合并的时候遇到冲突，仅需要修改后重新commit</li><li>引入了一次合并的历史记录，合并后的所有 <code>commit</code> 会按照提交时间从旧到新排列</li><li>所有的过程信息更多，可能会提高之后查找问题的难度</li></ul><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><p>记录了真实的commit情况，包括每个分支的详情</p><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><p>因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。</p><h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p>与 <code>git merge</code> 一致，<code>git rebase</code> 的目的也是将一个分支的更改并入到另外一个分支中去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase master</span><br></pre></td></tr></table></figure><p>本质是<strong>变基 变基 变基</strong></p><p>变基是什么? <code>找公共祖先</code></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wl0azimrj30wx0823zd.jpg" alt="img"></p><h3 id="rebase-特点："><a href="#rebase-特点：" class="headerlink" title="rebase 特点："></a>rebase 特点：</h3><ul><li>改变当前分支从 <code>master</code>上拉出分支的位置</li><li>没有多余的合并历史的记录，会合并之前的commit历史，且合并后的 <code>commit</code>顺序不一定按照 <code>commit</code>的提交时间排列</li><li>可能会多次解决同一个地方的冲突（有 <code>squash</code>来解决）</li><li>更清爽一些，<code>master</code>分支上每个 <code>commit</code>点都是相对独立完整的功能单元</li></ul><h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>得到更简洁的项目历史，去掉了merge commit</p><h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>如果合并出现代码问题不容易定位，因为rewrite了history</p><h3 id="合并时遇到冲突："><a href="#合并时遇到冲突：" class="headerlink" title="合并时遇到冲突："></a>合并时遇到冲突：</h3><p>合并时如果出现冲突需要按照如下步骤解决</p><ul><li>修改冲突部分</li><li>git add</li><li><code>git rebase --continue</code></li><li>（如果第三步无效可以执行 <code>git rebase --skip</code>）</li></ul><p>不要在git add 之后习惯性的执行 git commit命令</p><h3 id="git-rebase-的交互模式"><a href="#git-rebase-的交互模式" class="headerlink" title="git rebase 的交互模式"></a>git rebase 的交互模式</h3><p>打开变基的交互模式只需要传入一个参数 <code>-i</code> 即可，同时还需要指定对哪些提交进行处理</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rebase -i HEAD~4</span><br></pre></td></tr></table></figure><p>上述命令指定了对当前分支的最近四次提交进行操作。下面我们使用上面这行命令将 <code>feature</code> 分支的提交合并。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6wl7ji36xj30wi0gpq67.jpg" alt="img"></p><p>中间红框内有一些命令，可以用来处理某次提交的</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果你想要一个干净的，没有merge commit的线性历史树，或者当发现自己修改某个功能时，频繁进行了<code>git commit</code>提交时，发现其实过多的提交信息没有必要时，那么你应该选择git rebase</li><li>当需要保留详细的合并信息的时候建议使用<code>git merge</code>，特别是需要将分支合并进入<code>master</code>分支时，并且想要避免重写commit history的风险，你应该选择使用git merge</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;git-merge和git-rebase的区别&quot;&gt;&lt;a href=&quot;#git-merge和git-rebase的区别&quot; class=&quot;headerlink&quot; title=&quot;git merge和git rebase的区别&quot;&gt;&lt;/a&gt;git merge和git reb
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>浏览器同域名请求的最大并发数限制</title>
    <link href="http://yoursite.com/2019/09/14/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%90%8C%E5%9F%9F%E5%90%8D%E8%AF%B7%E6%B1%82%E7%9A%84%E6%9C%80%E5%A4%A7%E5%B9%B6%E5%8F%91%E6%95%B0%E9%99%90%E5%88%B6/"/>
    <id>http://yoursite.com/2019/09/14/浏览器同域名请求的最大并发数限制/</id>
    <published>2019-09-14T15:14:44.000Z</published>
    <updated>2019-11-10T14:37:39.038Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器同域名请求的最大并发数限制"><a href="#浏览器同域名请求的最大并发数限制" class="headerlink" title="浏览器同域名请求的最大并发数限制"></a>浏览器同域名请求的最大并发数限制</h1><p>当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。</p><p>如果同时只有 2 个并发连接数数量，那网页打开的时候只能依赖于这 2 条线程，前面如果有打开慢的内容，就会直接影响到后面的内容打开。但是如果同时有更多的并发连接数，这样就会大大的提高网页加载速度。但是浏览器的并发连接数也并非越大越好。</p><p>HTTP 客户端一般对同一个服务器的并发连接个数都是有限制的。实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（<strong>通常为四个</strong>）。服务器可以自由地关闭来自特定客户端的过多连接。</p><h2 id="主流浏览器最大并发连接数"><a href="#主流浏览器最大并发连接数" class="headerlink" title="主流浏览器最大并发连接数"></a>主流浏览器最大并发连接数</h2><p>一些主流浏览器对 HTTP 1.1 和 HTTP 1.0 的最大并发连接数目，可以参考如下表格：</p><table><thead><tr><th>浏览器</th><th>HTTP / 1.1</th><th>HTTP / 1.0</th></tr></thead><tbody><tr><td>IE 11</td><td>6</td><td>6</td></tr><tr><td>IE 10</td><td>6</td><td>6</td></tr><tr><td>IE 9</td><td>10</td><td>10</td></tr><tr><td>IE 8</td><td>6</td><td>6</td></tr><tr><td>IE 6,7</td><td>2</td><td>4</td></tr><tr><td>火狐</td><td>6</td><td>6</td></tr><tr><td>Safari 3,4</td><td>4</td><td>4</td></tr><tr><td>Chrome 4+</td><td>6</td><td>6</td></tr><tr><td>歌剧 9.63,10.00alpha</td><td>4</td><td>4</td></tr><tr><td>Opera 10.51+</td><td>8</td><td>？</td></tr><tr><td>iPhone 2</td><td>4</td><td>？</td></tr><tr><td>iPhone 3</td><td>6</td><td>？</td></tr><tr><td>iPhone 4</td><td>4</td><td>？</td></tr><tr><td>iphone 5</td><td>6</td><td>？</td></tr><tr><td>Android2-4</td><td>4</td><td>？</td></tr></tbody></table><h3 id="Firefox-浏览器的最大并发连接数"><a href="#Firefox-浏览器的最大并发连接数" class="headerlink" title="Firefox 浏览器的最大并发连接数"></a>Firefox 浏览器的最大并发连接数</h3><p>在 Firefox 中的地址栏输入“about：config 中”，然后搜索并修改如下两个配置项目即可：</p><ul><li><code>network.http.max-persistent-connections-per-server:6</code>连接同一个服务器允许的最大持久连接数，默认为 6，可以不用更改。</li><li><code>network.http.max-persistent-connections-per-proxy:8</code>每个代理服务器允许的最大持久连接数,公司用户使用代理服务器，但是外面的客户一般不使用代理，火狐推荐的每台代理服务器设置为：&lt;= 10。</li></ul><h4 id="Firefox3-6"><a href="#Firefox3-6" class="headerlink" title="Firefox3.6"></a>Firefox3.6</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbxx2j6tj30fq06faa1.jpg" alt="img"></p><p>和 IE8 的几乎完全一样：</p><ul><li>最大并发 HTTP 连接数为 6 个（可在 about:config 中修改）。</li><li>javascript 文件不会阻塞其他资源的加载，多个 javascript 文件可以一起加载。</li><li>会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。</li></ul><h4 id="Firefox4-beta12"><a href="#Firefox4-beta12" class="headerlink" title="Firefox4 beta12"></a>Firefox4 beta12</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jby0whawj30fv07n3yj.jpg" alt="img"></p><p>不知是因为设计理念上的不同，还是因为 beta 版未照顾到这一块，Firefox4 反而退化了，和 Firefox3.6 的区别主要体现在对资源类型的处理上，Firefox4 不再严格地优先下载 script 和 link 标签定义的外部资源，而是按照 HTML 结构中出现的顺序来进行加载。</p><h3 id="IE-浏览器的最大并发连接数"><a href="#IE-浏览器的最大并发连接数" class="headerlink" title="IE 浏览器的最大并发连接数"></a>IE 浏览器的最大并发连接数</h3><p>用“注册表编辑器”命令打开注册表编辑器，找到：</p><p>[HKEY_CURRRENT_USER \ Software \ Microsoft \ Windows \ CurrentVersion \ Internet Settings]，可以看到<strong>MaxConnectionsPerServer</strong>和<strong>MaxConnectionsPer1_0Server</strong>这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置）</p><p><strong>对于 IE 9</strong></p><p>[HKEY_CURRRENT_USER \ Software \ Policies \ Microsoft \ Internet Exploer \ Main \ FeatureControl，可以看到<strong>FEATURE_MAXCONNECTIONSPER1_0SERVER</strong>和<strong>FEATURE_MAXCONNECTIONSPERSERVER</strong>这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置）</p><h4 id="IE8"><a href="#IE8" class="headerlink" title="IE8"></a>IE8</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbx8rdwaj30g407pweh.jpg" alt="img"></p><p>和 IE6 完全不同的瀑布图，其特点有：</p><ul><li>最大并发 HTTP 连接数为 6 个。</li><li>javascript 文件已经不会阻塞其他资源的加载，甚至多个 javascript 文件可以一起加载，并且会保证执行的顺序。</li><li>会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。</li></ul><h3 id="chrome-浏览器的最大并发连接数"><a href="#chrome-浏览器的最大并发连接数" class="headerlink" title="chrome 浏览器的最大并发连接数"></a>chrome 浏览器的最大并发连接数</h3><h4 id="Chrome8"><a href="#Chrome8" class="headerlink" title="Chrome8"></a>Chrome8</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbzcty9xj30fw07zwef.jpg" alt="img"></p><p>Chrome 自带的工具不能很清楚地表示各请求的开始时间，所以使用了 Fiddler 的瀑布图，从图上可以看出，Chrome 也是比较特立独行的一位，其特点有：</p><ul><li>最大并发 HTTP 连接数为 6。</li><li>head 部分的资源会单独下载，且阻塞 body 中的其他资源的加载。</li><li>会优先加载 script 和 link 标签定义的资源。</li></ul><h3 id="opera-浏览器的最大并发连接数"><a href="#opera-浏览器的最大并发连接数" class="headerlink" title="opera 浏览器的最大并发连接数"></a>opera 浏览器的最大并发连接数</h3><h4 id="Opera11"><a href="#Opera11" class="headerlink" title="Opera11"></a>Opera11</h4><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6jbzixw3tj30fj0813yh.jpg" alt="img"></p><p>先报怨一下，Dragonfly 不怎么好用来着……Opera 的资源加载也比较有特色，而且很难看出规律，只能大致总结一下：</p><ul><li>Opera 的最大并发 HTTP 连接数默认为 16，可在 opera:config - Performance - Max Connections Server 查看和修改。</li><li>javascript 文件的加载会阻塞其他 script 和 link 标签定义的外部资源的加载，如图中的 2.js。但不会阻塞图片等其他资源的加载，如图中的 3.js。</li><li>会一定程度上对资源的优先级进行优化，但由于 javascript 文件要阻止后续部分资源的加载，又为了充分利用最大 HTTP 连接数，因此不能严格先加载所有的 script 和 link 标签定义的资源，导致瀑布图上各类型资源有相互穿插，难寻规律。</li></ul><h2 id="HTTP-连接请求与线程"><a href="#HTTP-连接请求与线程" class="headerlink" title="HTTP 连接请求与线程"></a>HTTP 连接请求与线程</h2><p>HTTP 连接是复杂，有状态的对象，所以它必须被妥善管理。<strong>一个 HTTP 连接请求在同一时间只能被一个线程访问。</strong></p><p>HttpClient 使用一个叫做的 Http 连接管理器的特殊实体类来管理的 Http 连接。Http 连接管理器在新建的 HTTP 连接时，作为工厂类；管理持久的 http 连接的生命周期；同步持久连接（确保线程安全，即一个 HTTP 连接同一时间只能被一个线程访问）。</p><p>如果一个的 Http 连接被释放或者被它的消费者明确表示要关闭，那么底层的连接就会和它的代理进行分离，并且该连接会被交还给连接管理器。这是，即使服务消费者仍然持有代理的引用，它也不能再执行 I / O 操作，或者更改的 Http 连接的状态。</p><h3 id="连接池管理器"><a href="#连接池管理器" class="headerlink" title="连接池管理器"></a>连接池管理器</h3><p>连接池管理器是个复杂的类，它管理着连接池，可以同时为很多线程提供 HTTP 连接请求。当请求一个新的连接时，如果连接池有有可用的持久连接，连接管理器就会使用其中的一个，而不是再创建一个新的连接。</p><p>当使用了请求连接池管理器后，HttpClient 的就可以同时执行多个线程的请求了。</p><p>连接池管理器会根据它的配置来分配请求连接。如果连接池中的所有连接都被占用了，那么后续的请求就会被阻塞，直到有连接被释放回连接池中。</p><h3 id="线程池的原理"><a href="#线程池的原理" class="headerlink" title="线程池的原理"></a>线程池的原理</h3><p>线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下：</p><p>线程池在还没有任务到来之前，创建一定数量的线程，放入空闲队列中。这些线程都是处于睡眠状态，即均为启动，不消耗 CPU，而只是占用较小的内存空间。当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。</p><p>线程池能节约大量的的系统资源，使得更多的 CPU 时间和内存用来处理实际的商业应用，而不是频繁的线程创建与销毁</p><p>每个线程需要大约 1MB 内存，线程开的越多，消耗的内存也就越大。</p><p>在什么情况下使用线程池：</p><ol><li>单个任务处理的时间比较短</li><li>将需处理的任务的数量大</li></ol><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><p>数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池（简单说：在一个“池”里放了好多半成品的数据库联接对象），由应用程序动态地对池中的连接进行申请，使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。<br>连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量，使用情况等。</p><p>1）最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费;<br>2）最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。</p><p><strong>数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。</strong>一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。</p><h3 id="WebSphere-Application-Server-性能"><a href="#WebSphere-Application-Server-性能" class="headerlink" title="WebSphere Application Server 性能"></a>WebSphere Application Server 性能</h3><p><a href="http://websphere.sys-con.com/node/46514/print" target="_blank" rel="noopener">http://websphere.sys-con.com/node/46514/print</a></p><p>构建服务器应用程序的一个过于简单的模型是：每当一个请求到达就创建一个新的服务对象，然后在新的服务对象中为服务请求，但当有大量请求并发访问时，服务器不断的创建和销毁对象的开销很大。</p><p>在面向对象的编程中，创建和销毁对象是很浪费资源的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 的中更是如此，虚拟机试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以，提高程序效率的一个手段就是尽可能减少创建和销毁对象的次数。利用已有的对象来服务就是“池化资源”技术产生的原因。</p><p><strong>HTTP 侦听器</strong><br>HTTP 侦听器负责在 HTTP 服务器级别创建线程。这里发生的大多数处理是静态页面服务，或 HTTP post / GET 传递命令到后端。这是必须考虑的第一级线程配置。</p><p><strong>Web 容器</strong><br>Web 容器负责在应用程序服务器级别创建线程池。此级别的大多数处理包括 servlet，JSP，EJB，动态页面创建和后端传递处理。Web 容器是必须配置的第二级线程池配置。</p><p><strong>ORB 容器</strong> ORB 容器负责在对象级创建线程池。这里发生的大部分处理包括处理基于非 Web 的客户端。ORB 容器是必须配置的线程池配置的第三级。</p><p><strong>数据源</strong><br>数据源级负责创建从数据库或“传统”系统访问的连接线程。这些线程是必须解决的第四级配置</p><h3 id="WAS-线程池数与-IHS-server"><a href="#WAS-线程池数与-IHS-server" class="headerlink" title="WAS 线程池数与 IHS server"></a>WAS 线程池数与 IHS server</h3><p>假定一个浏览器的并发连接请求数为 10，通常同一时间内会有多个用户并发访问网站。又考虑到，一个 Http 连接请求在同一时间只能被一个线程访问。所以，IHS 服务器的 httpd.conf 里的 maxclients（允许建立的总线程数）要能够处理峰值时刻的浏览器连接请求才行。同时，考虑不是所有的连接请求都会到 was server，有的连接只是为了在 web 服务器上取静态资源，所以，was 上的线程池数目（Thread pools ：50 ）会远小于 IHS server 上的 maxclients 值譬如 400）。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;浏览器同域名请求的最大并发数限制&quot;&gt;&lt;a href=&quot;#浏览器同域名请求的最大并发数限制&quot; class=&quot;headerlink&quot; title=&quot;浏览器同域名请求的最大并发数限制&quot;&gt;&lt;/a&gt;浏览器同域名请求的最大并发数限制&lt;/h1&gt;&lt;p&gt;当我们在浏览网页的时候，对浏
      
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>前端优化</title>
    <link href="http://yoursite.com/2019/09/08/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96/"/>
    <id>http://yoursite.com/2019/09/08/前端优化/</id>
    <published>2019-09-08T15:48:15.000Z</published>
    <updated>2019-11-10T14:37:39.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前端优化"><a href="#前端优化" class="headerlink" title="前端优化"></a>前端优化</h1><h2 id="前端性能衡量指标"><a href="#前端性能衡量指标" class="headerlink" title="前端性能衡量指标"></a>前端性能衡量指标</h2><ul><li><strong>白屏时间</strong> 该时间点表示浏览器开始绘制页面，在此之前页面都是白屏，也称为开始渲染时间</li><li><strong>首屏时间</strong> 该时间点表示用户看到第一屏页面的时间</li><li><strong>用户可交互时间</strong> 也叫 DOM Ready,该时间点表示 DOM 解析完成，资源还没有完成，这个时候用户与页面可以交互了</li><li><strong>完全加载时间</strong> 该时间点是 window.onload 时间触发的时间，表示原始文档和所用引用的内容已经加载完成，用户最明显的感觉就是浏览器 tab 上 loading 状态结束</li><li><strong>首字节时间（TTFB）</strong> 第一字节响应时间（TTFB）=发送请求到 WEB 服务器的时间+WEB 服务器处理请求并生成响应花费的时间+WEB 服务器生成响应到浏览器花费的时间</li><li><strong>DNS 解析时间</strong></li><li><strong>TCP 连接时间</strong></li><li><strong>HTTP 请求时间</strong></li><li><strong>HTTP 响应时间</strong></li></ul><h2 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h2><p>雅虎 14 条优化原则：</p><ol><li><p>尽可能的减少 HTTP 的请求数 content</p></li><li><p>使用 CDN（Content Delivery Network） server</p></li><li><p>添加 Expires 头(或者 Cache-control ) server</p></li><li><p>Gzip 组件 server</p></li><li><p>将 CSS 样式放在页面的上方 css</p></li><li><p>将脚本移动到底部（包括内联的） javascript</p></li><li><p>避免使用 CSS 中的 Expressions css</p></li><li><p>将 JavaScript 和 CSS 独立成外部文件 javascript css</p></li><li><p>减少 DNS 查询 content</p></li><li><p>压缩 JavaScript 和 CSS (包括内联的) javascript css</p></li><li><p>避免重定向 server</p></li><li><p>移除重复的脚本 javascript</p></li><li><p>配置实体标签（ETags） css</p></li><li><p>使 AJAX 缓存</p></li></ol><table><thead><tr><th>优化方向</th><th>优化手段</th></tr></thead><tbody><tr><td>请求数量</td><td>合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域，字体图标，雪碧图片等</td></tr><tr><td>请求带宽</td><td>开启服务器 GZip，精简 JavaScript，移除重复脚本，图像优化（包括图片大小 kb）</td></tr><tr><td>缓存利用</td><td>使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AjaX 可缓存</td></tr><tr><td>页面结构</td><td>将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出</td></tr><tr><td>代码校验</td><td>避免 CSS 表达式，避免重定向</td></tr></tbody></table><h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><h3 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h3><p>DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"dns-prefetch"</span> <span class="attr">href</span>=<span class="string">"//yuchengkai.cn"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="利用缓存"><a href="#利用缓存" class="headerlink" title="利用缓存"></a>利用缓存</h3><p>缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。</p><p>通常浏览器缓存策略分为两种：强缓存和协商缓存</p><h4 id="选择合适的缓存策略"><a href="#选择合适的缓存策略" class="headerlink" title="选择合适的缓存策略"></a>选择合适的缓存策略</h4><p>对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略</p><ul><li>对于某些不需要缓存的资源，可以使用 <code>Cache-control: no-store</code> ，表示该资源不需要缓存</li><li>对于频繁变动的资源，可以使用 <code>Cache-Control: no-cache</code> 并配合 <code>ETag</code> 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。</li><li>对于代码文件来说，通常使用 <code>Cache-Control: max-age=31536000</code> 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。</li></ul><h3 id="使用-HTTP-2-0"><a href="#使用-HTTP-2-0" class="headerlink" title="使用 HTTP / 2.0"></a>使用 HTTP / 2.0</h3><p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。</p><p>在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。</p><h3 id="预加载-amp-懒加载"><a href="#预加载-amp-懒加载" class="headerlink" title="预加载&amp;懒加载"></a>预加载&amp;懒加载</h3><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。</p><p>预加载其实是声明式的 <code>fetch</code> ，强制浏览器请求资源，并且不会阻塞 <code>onload</code> 事件，可以使用以下代码开启预加载</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"preload"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。</p><h4 id="预渲染"><a href="#预渲染" class="headerlink" title="预渲染"></a>预渲染</h4><p>可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"prerender"</span> <span class="attr">href</span>=<span class="string">"http://example.com"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染。</p><h4 id="懒执行"><a href="#懒执行" class="headerlink" title="懒执行"></a>懒执行</h4><p>懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。</p><h4 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h4><p>懒加载就是将不关键的资源延后加载。</p><p>懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 <code>src</code> 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 <code>src</code> 属性，这样图片就会去下载资源，实现了图片懒加载。</p><p>懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。</p><h2 id="文件优化"><a href="#文件优化" class="headerlink" title="文件优化"></a>文件优化</h2><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><h4 id="图片大小计算"><a href="#图片大小计算" class="headerlink" title="图片大小计算"></a>图片大小计算</h4><p>在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。</p><p>了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了：</p><ul><li>减少像素点</li><li>减少每个像素点能够显示的颜色</li></ul><h4 id="图片加载优化"><a href="#图片加载优化" class="headerlink" title="图片加载优化"></a>图片加载优化</h4><ol><li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li><li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li><li>小图使用 base64 格式</li><li>将多个图标文件整合到一张图片中（雪碧图）</li><li>选择正确的图片格式：<ul><li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li><li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li><li>照片使用 JPEG</li></ul></li></ol><h3 id="其他文件优化"><a href="#其他文件优化" class="headerlink" title="其他文件优化"></a>其他文件优化</h3><ul><li>CSS 文件放在 <code>head</code> 中</li><li>服务端开启文件压缩功能</li><li>将 <code>script</code> 标签放在 <code>body</code> 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 <code>script</code> 标签放在任意位置然后加上 <code>defer</code> ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 <code>async</code> ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。</li><li>执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 <code>Webworker</code>。<code>Webworker</code> 可以让我们另开一个线程执行脚本而不影响渲染。</li></ul><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><blockquote><p>CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。—— 科学百科</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6p436ax42j30ia09l74f.jpg" alt="img"></p><h4 id="CDN-存在的意义"><a href="#CDN-存在的意义" class="headerlink" title="CDN 存在的意义"></a>CDN 存在的意义</h4><p>为了不让网络拥塞成为互联网发展的障碍。</p><h4 id="CDN-的优势"><a href="#CDN-的优势" class="headerlink" title="CDN 的优势"></a>CDN 的优势</h4><ol><li>CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低；</li><li>大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载；</li><li>降低“广播风暴”的影响，提高网络访问的稳定性；节省骨干网带宽，减少带宽需求量。</li></ol><h4 id="CDN-的核心点"><a href="#CDN-的核心点" class="headerlink" title="CDN 的核心点"></a>CDN 的核心点</h4><ul><li><p>缓存：将从根服务器请求来的资源按要求缓存。</p></li><li><p>回源：当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。</p></li></ul><h4 id="关键技术"><a href="#关键技术" class="headerlink" title="关键技术"></a>关键技术</h4><ol><li>内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处；</li><li>内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应；</li><li>内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在 POP 的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量；</li><li>性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。</li></ol><h4 id="CDN-amp-静态资源"><a href="#CDN-amp-静态资源" class="headerlink" title="CDN &amp; 静态资源"></a>CDN &amp; 静态资源</h4><p>静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段。</p><p>静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。</p><h2 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h2><h3 id="使用-Webpack-优化项目"><a href="#使用-Webpack-优化项目" class="headerlink" title="使用 Webpack 优化项目"></a>使用 Webpack 优化项目</h3><ul><li>对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩</li><li>使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码</li><li>优化图片，对于小图可以使用 base64 的方式写入文件中</li><li>按照路由拆分代码，实现按需加载</li><li>给打包出来的文件名添加哈希，实现浏览器缓存文件</li></ul><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>对于代码运行错误，通常的办法是使用 <code>window.onerror</code> 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外</p><ul><li>对于跨域的代码运行错误会显示 <code>Script error.</code> 对于这种情况我们需要给 <code>script</code> 标签添加 <code>crossorigin</code> 属性</li><li>对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 <code>arguments.callee.caller</code> 来做栈递归</li></ul><p>对于异步代码来说，可以使用 <code>catch</code> 的方式捕获错误。比如 <code>Promise</code> 可以直接使用 <code>catch</code> 函数，<code>async await</code> 可以使用 <code>try catch</code></p><p>但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。</p><p>对于捕获的错误需要上传给服务器，通常可以通过 <code>img</code> 标签的 <code>src</code> 发起一个请求。</p><h2 id="如何优化第二次加载速度？（增量加载）"><a href="#如何优化第二次加载速度？（增量加载）" class="headerlink" title="如何优化第二次加载速度？（增量加载）"></a>如何优化第二次加载速度？（增量加载）</h2><p><a href="https://juejin.im/post/5d00820b5188255ee806a1c7" target="_blank" rel="noopener">前端性能优化三部曲(加载篇)</a></p><p><a href="https://juejin.im/entry/599403656fb9a0247f4f2ee3" target="_blank" rel="noopener">移动 H5 首屏秒开优化方案探讨</a></p><ol><li><strong>降低请求量：</strong>合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。</li><li><strong>加快请求速度：</strong>预解析 DNS，减少域名数，并行加载，CDN 分发。</li><li><strong>缓存：</strong>HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。</li><li><strong>渲染：</strong>JS/CSS 优化，加载顺序，服务端渲染，pipeline。</li></ol><p>其中对首屏启动速度影响最大的就是网络请求，所以优化的重点就是缓存</p><p><strong>增量式更新”</strong>的解决方案，简单地说就是在版本更新的时候不需要重新加载资源，只需要加载一段很小的 diff 信息，然后合并到当前资源上，类似 git merge 的效果。</p><p>增量加载的一种思路：</p><p>1、用户端使用 LocalStorage 或者其它储存方案，存储一份原始代码+时间戳：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    timeStamp: &quot;20161026xxxxxx&quot;,</span><br><span class="line">    data: &quot;aaabbbccc&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、每次加载资源的时候向服务器发送这个时间戳；</p><p>3、服务器从接受到时间戳中识别出客户端的版本，和最新的版本做一次 diff，返回两者的 diff 信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff(<span class="string">"aaabbbccc"</span>, <span class="string">"aaagggccc"</span>);</span><br><span class="line"><span class="comment">// 假设我们的diff信息这样表示：</span></span><br><span class="line"><span class="comment">// [3, "-3", "+ggg", 3]</span></span><br></pre></td></tr></table></figure><p>4、客户端接收到这个 diff 信息之后，把本地资源和时间戳更新到最新，实现一次增量更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mergeDiff(<span class="string">"aaabbbccc"</span>, [<span class="number">3</span>, <span class="string">"-3"</span>, <span class="string">"+ggg"</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">//=&gt; "aaagggccc"</span></span><br></pre></td></tr></table></figure><h2 id="面试题（如何渲染几万条数据并不卡住界）"><a href="#面试题（如何渲染几万条数据并不卡住界）" class="headerlink" title="面试题（如何渲染几万条数据并不卡住界）"></a>面试题（如何渲染几万条数据并不卡住界）</h2><p>这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 <code>requestAnimationFrame</code> 来每 16 ms 刷新一次。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      控件</span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 插入十万条数据</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> total = <span class="number">100000</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 一次插入 20 条，如果觉得性能不好就减少</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> once = <span class="number">20</span>;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 渲染数据总共需要几次</span></span></span><br><span class="line"><span class="actionscript">        <span class="keyword">const</span> loopCount = total / once;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> countOfRender = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">"ul"</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="comment">// 优化性能，插入不会造成回流</span></span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span></span><br><span class="line"><span class="javascript">          <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; once; i++) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span></span><br><span class="line"><span class="javascript">            li.innerText = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random() * total);</span></span><br><span class="line">            fragment.appendChild(li);</span><br><span class="line">          &#125;</span><br><span class="line">          ul.appendChild(fragment);</span><br><span class="line">          countOfRender += 1;</span><br><span class="line"><span class="vbscript">          <span class="keyword">loop</span>();</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="actionscript">        <span class="function"><span class="keyword">function</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">          <span class="keyword">if</span> (countOfRender &lt; loopCount) &#123;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.requestAnimationFrame(add);</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="vbscript">        <span class="keyword">loop</span>();</span></span><br><span class="line">      &#125;, 0);</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="拓展知识之-Gzip"><a href="#拓展知识之-Gzip" class="headerlink" title="拓展知识之 Gzip"></a>拓展知识之 Gzip</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome,firefox,IE 等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持 gzip。</p><p>gzip 压缩比率在 3 到 10 倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。</p><h3 id="gzip-工作原理："><a href="#gzip-工作原理：" class="headerlink" title="gzip 工作原理："></a>gzip 工作原理：</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjepqxiaj30go0bcaa9.jpg" alt="img"></p><ol><li>浏览器请求 url，并在 request header 中设置属性 accept-encoding:gzip。表明浏览器支持 gzip。</li><li>服务器收到浏览器发送的请求之后，判断浏览器是否支持 gzip，如果支持 gzip，则向浏览器传送压缩过的内容，不支持则向浏览器发送未经压缩的内容。一般情况下，浏览器和服务器都支持 gzip，response headers 返回包含 content-encoding:gzip。</li><li>浏览器接收到服务器的响应之后判断内容是否被压缩，如果被压缩则解压缩显示页面内容。</li></ol><h3 id="Nginx-中开启-gzip"><a href="#Nginx-中开启-gzip" class="headerlink" title="Nginx 中开启 gzip"></a>Nginx 中开启 gzip</h3><p>如果服务端接口使用 nodejs 和 express，那么开启 nginx 非常简单。启用 compress() 中间件即可并在 nginx.conf 中添加 gzip 配置项即可，express.compress() gzip 压缩中间件，通过 filter 函数设置需要压缩的文件类型。压缩算法为 gzip/deflate。这个中间件应该放置在所有的中间件最前面以保证所有的返回都是被压缩的。如果使用 java 开发，需要配置 filter。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjg93f23j30go03eq2v.jpg" alt="img"></p><p>添加完参数后，运行 nginx –t 检查一下语法，若语法检测通过，则开始访问 url 检测 gzip 是否添加成功。</p><ol><li>gzip on：开启 gzip。</li><li>gzip_comp_level：gzip 压缩比。</li><li>gzip_min_length：允许被压缩的页面最小字节数。</li><li>gzip_types：匹配 MIME 类型进行压缩，text/html 默认被压缩。</li></ol><h3 id="检测-gzip-是否开启"><a href="#检测-gzip-是否开启" class="headerlink" title="检测 gzip 是否开启"></a>检测 gzip 是否开启</h3><p>如果没有现成的项目代码，这里提供一个比较简单的检测方式。首先在本地安装 nginx，在 nginx 默认目录下面添加了两个静态文件 bootstrap.css、bootstrap.js。</p><p>OS X 系统的默认路径为：/usr/local/Cellar/nginx/1.10.2_1/html，Windows 系统直接复制文件到文件夹下面。</p><p>拷贝文件指令可参考：cp -r bootstrap.js /usr/local/Cellar/nginx/1.10.2_1/html，在 nginx 的默认成功跳转页面 index.html 引入这两个静态文件。index.html 页面内容如图所示。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjhnk9acj30go0c90tb.jpg" alt="img"></p><p>做好这一切的准备工作之后，浏览器输入<a href="https://link.juejin.im/?target=https%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttp%3A%2F%2Flocalhost%3A8080%2F" target="_blank" rel="noopener">http://localhost:8080/</a>。出现如图所示页面表明 nginx 启动成功。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjii979gj30go048wei.jpg" alt="img"></p><p>nginx 启动成功界面。</p><p>此时打开 Chrome 控制台，可以看到 network 信息，response headers 中返回了 content-encoding:gzip，表明 gzip 开启成功。</p><p>gzip 未开启前 network 信息如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjjd5bavj30go02ogll.jpg" alt="img"></p><p>开启后返回 network 信息如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjjxm19cj30go02m0sp.jpg" alt="img"></p><p>url 请求的 headers 报文如图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6sjk4yn88j30go0a4jrt.jpg" alt="img"></p><p>对比以上三图可以看出 gzip 压缩效率非常高，且经过压缩后静态文件大小不到原来的五分之一。这里值得一提的是静态资源文件越大，gzip 的压缩效率越高。所以对于静态资源量非常大的网站，开启 gzip 可节省大量流量，而同时 gzip 的应用远不止提高 web 性能,Android，IOS 底层网络请求同样可用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前端优化&quot;&gt;&lt;a href=&quot;#前端优化&quot; class=&quot;headerlink&quot; title=&quot;前端优化&quot;&gt;&lt;/a&gt;前端优化&lt;/h1&gt;&lt;h2 id=&quot;前端性能衡量指标&quot;&gt;&lt;a href=&quot;#前端性能衡量指标&quot; class=&quot;headerlink&quot; title=&quot;前
      
    
    </summary>
    
      <category term="前端" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="性能优化" scheme="http://yoursite.com/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CSS的position属性</title>
    <link href="http://yoursite.com/2019/08/31/CSS%E7%9A%84position%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2019/08/31/CSS的position属性/</id>
    <published>2019-08-31T13:48:53.000Z</published>
    <updated>2019-11-10T14:37:39.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CSS-的-position-属性"><a href="#CSS-的-position-属性" class="headerlink" title="CSS 的 position 属性"></a>CSS 的 position 属性</h1><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p>默认值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 <code>top</code>, <code>right</code>, <code>bottom</code>, <code>left</code> 和 <code>z-index</code>属性无效。</p><h2 id="relative"><a href="#relative" class="headerlink" title="relative"></a>relative</h2><h3 id="定位类型"><a href="#定位类型" class="headerlink" title="定位类型"></a>定位类型</h3><p>相对定位元素，相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。</p><h3 id="定位方式"><a href="#定位方式" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成相对定位的元素，相对于其正常位置进行定位。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白，”left:20” 会向元素的 LEFT 位置添加 20 像素。）。<code>position:relative</code> 对 <code>table-group</code>, <code>table-row</code>,<code>table-column</code>,<code>table-cell</code>,<code>table-caption</code> 元素无效。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"three"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"four"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#two</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyqx5px1j312q0b40t2.jpg" alt="img"></p><h2 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h2><h3 id="定位类型-1"><a href="#定位类型-1" class="headerlink" title="定位类型"></a>定位类型</h3><p>绝对定位元素，相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于<em>最近的非 static 祖先元素</em>定位。当这样的祖先元素不存在时，则相对于 ICB（inital container block, 初始包含块）。</p><h3 id="定位方式-1"><a href="#定位方式-1" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成绝对定位的元素，不为元素预留空间，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"one"</span>&gt;</span>One<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span>Two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"three"</span>&gt;</span>Three<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span> <span class="attr">id</span>=<span class="string">"four"</span>&gt;</span>Four<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: inline-block;</span><br><span class="line">  <span class="attribute">background</span>: red;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#three</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iyrszydtj310809e0sz.jpg" alt="image-20190823001646550"></p><h2 id="fixed"><a href="#fixed" class="headerlink" title="fixed"></a>fixed</h2><h3 id="定位类型-2"><a href="#定位类型-2" class="headerlink" title="定位类型"></a>定位类型</h3><p>绝对定位元素，固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。</p><h3 id="定位方式-2"><a href="#定位方式-2" class="headerlink" title="定位方式"></a>定位方式</h3><p>生成绝对定位的元素，不为元素预留空间，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。<code>fixed</code> 属性会创建新的层叠上下文。</p><p><strong>当元素祖先的 <code>transform</code> 属性非 <code>none</code> 时，容器由视口改为该祖先。</strong></p><h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><h3 id="定位类型-3"><a href="#定位类型-3" class="headerlink" title="定位类型"></a>定位类型</h3><p>粘性定位元素，粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。</p><h3 id="定位方式-3"><a href="#定位方式-3" class="headerlink" title="定位方式"></a>定位方式</h3><p>盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 <code>table 时</code>），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。<code>position: sticky</code>对 <code>table</code> 元素的效果与 <code>position: relative</code>相同。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#one</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。</p><p>粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>A<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Andrew W.K.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Apparat<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Arcade Fire<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>At The Drive-In<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Aziz Ansari<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>C<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Chromeo<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Common<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Converge<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Crystal Castles<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Cursive<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>E<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Explosions In The Sky<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>T<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Ted Leo &amp; The Pharmacists<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>T-Pain<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Thrice<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>TV On The Radio<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>Two Gallants<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dl</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">24px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dt</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#b8c1c8</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">1px</span> solid <span class="number">#989ea4</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#717d85</span>;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">18px</span>/<span class="number">21px</span> Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">2px</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">position</span>: -webkit-sticky;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">1px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: bold <span class="number">20px</span>/<span class="number">45px</span> Helvetica, Arial, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">12px</span>;</span><br><span class="line">  <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">dd</span> + <span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="生效规则"><a href="#生效规则" class="headerlink" title="生效规则"></a>生效规则</h3><p><code>position:sticky</code> 的生效是有一定的限制的，总结如下：</p><ol><li>须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。<ul><li>并且 <code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高。</li></ul></li><li>设定为 <code>position:sticky</code> 元素的任意父节点的 overflow 属性必须是 visible，否则 <code>position:sticky</code> 不会生效。这里需要解释一下：<ul><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>overflow:hidden</code>，则父容器无法进行滚动，所以 <code>position:sticky</code> 元素也不会有滚动然后固定的情况。</li><li>如果 <code>position:sticky</code> 元素的任意父节点定位设置为 <code>position:relative | absolute | fixed</code>，则元素相对父元素进行定位，而不会相对 viewprot 定位。</li></ul></li><li>达到设定的阀值。这个还算好理解，也就是设定了 <code>position:sticky</code> 的元素表现为 <code>relative</code> 还是 <code>fixed</code> 是根据元素是否达到设定了的阈值决定的。</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ol><li>同一个父容器中的 sticky 元素，如果定位值相等，则会重叠；如果属于不同父元素，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。</li></ol><h2 id="initial"><a href="#initial" class="headerlink" title="initial"></a>initial</h2><p><code>initial</code> 关键字用于设置 CSS 属性为它的默认值，可作用于任何 CSS 样式。（IE 不支持该关键字）</p><h2 id="inherit："><a href="#inherit：" class="headerlink" title="inherit："></a>inherit：</h2><p>规定应该从父元素继承 position 属性的值。</p><p>每一个 CSS 属性都有一个特性就是，这个属性必然是默认继承的 (<code>inherited: Yes</code>) 或者是默认不继承的 (<code>inherited: no</code>)其中之一，我们可以在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/Reference" target="_blank" rel="noopener">MDN</a> 上通过这个索引查找，判断一个属性的是否继承特性。</p><h3 id="可继承属性"><a href="#可继承属性" class="headerlink" title="可继承属性"></a>可继承属性</h3><ul><li>所有元素可继承：visibility 和 cursor</li><li>内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction</li><li>块状元素可继承：text-indent 和 text-align</li><li>列表元素可继承：list-style、list-style-type、list-style-position、list-style-image</li><li>表格元素可继承：border-collapse</li></ul><h2 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h2><p><code>unset</code> 关键字我们可以简单理解为不设置。其实，它是关键字 <code>initial</code> 和 <code>inherit</code> 的组合。</p><p>什么意思呢？也就是当我们给一个 CSS 属性设置了 <code>unset</code> 的话：</p><ol><li>如果该属性是默认继承属性，该值等同于 <code>inherit</code></li><li>如果该属性是非继承属性，该值等同于 <code>initial</code></li></ol><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"father"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children"</span>&gt;</span>子级元素一<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"children unset"</span>&gt;</span>子级元素二<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">.father &#123; color: red; border: 1px solid black; &#125; .children &#123; color: green;</span><br><span class="line">border: 1px solid blue; &#125; .unset &#123; color: unset; border: unset; &#125;</span><br></pre></td></tr></table></figure><ol><li>由于 <code>color</code> 是可继承样式，设置了 <code>color: unset</code> 的元素，最终表现为了父级的颜色 <code>red</code>。</li><li>由于 <code>border</code> 是不可继承样式，设置了 <code>border: unset</code> 的元素，最终表现为 <code>border: initial</code> ，也就是默认 border 样式，无边框。</li></ol><h2 id="revert"><a href="#revert" class="headerlink" title="revert"></a>revert</h2><p>revert 未列入规范</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CSS-的-position-属性&quot;&gt;&lt;a href=&quot;#CSS-的-position-属性&quot; class=&quot;headerlink&quot; title=&quot;CSS 的 position 属性&quot;&gt;&lt;/a&gt;CSS 的 position 属性&lt;/h1&gt;&lt;h2 id=&quot;stati
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="position" scheme="http://yoursite.com/tags/position/"/>
    
  </entry>
  
  <entry>
    <title>ES6 装饰器</title>
    <link href="http://yoursite.com/2019/08/18/ES6%20%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2019/08/18/ES6 装饰器/</id>
    <published>2019-08-18T14:47:55.000Z</published>
    <updated>2019-11-10T14:37:39.018Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-装饰器"><a href="#ES6-装饰器" class="headerlink" title="ES6 装饰器"></a>ES6 装饰器</h1><p>装饰器（Decorator）是一种与类（class）相关的语法，<strong>用来注释或修改类和类方法</strong>。装饰器是一种函数，写成<code>@ + 函数名</code>。它可以放在类和类方法的定义前面。</p>  <a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@frozen</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  @configurable(<span class="literal">false</span>)</span><br><span class="line">  @enumerable(<span class="literal">true</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @throttle(<span class="number">500</span>)</span><br><span class="line">  expensiveMethod() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。</p><p><strong>Proxy 的核心作用是控制外界对被代理者内部的访问，Decorator 的核心作用是增强被装饰者的功能。著作权归作者所有。</strong></p><h2 id="类的装饰"><a href="#类的装饰" class="headerlink" title="类的装饰"></a>类的装饰</h2><p>装饰器可以用来装饰整个类。</p><h3 id="为类添加静态属性"><a href="#为类添加静态属性" class="headerlink" title="为类添加静态属性"></a>为类添加静态属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>@testable</code>就是一个装饰器。它修改了<code>MyTestableClass</code>这个类的行为，为它加上了静态属性<code>isTestable</code>。<code>testable</code>函数的参数<code>target</code>是<code>MyTestableClass</code>类本身。</p><p>基本上，装饰器的行为就是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@decorator</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br><span class="line">A = decorator(A) || A;</span><br></pre></td></tr></table></figure><p>也就是说，<strong>装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。</strong></p><p>如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">isTestable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    target.isTestable = isTestable;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">true</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line">MyTestableClass.isTestable; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">@testable(<span class="literal">false</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line">MyClass.isTestable; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>上面代码中，装饰器<code>testable</code>可以接受参数，这就等于可以修改装饰器的行为。</p><p><strong>注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。</strong></p><h3 id="为类添加实例属性"><a href="#为类添加实例属性" class="headerlink" title="为类添加实例属性"></a>为类添加实例属性</h3><p>如果想添加实例属性，可以通过目标类的<code>prototype</code>对象操作。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testable</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  target.prototype.isTestable = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTestableClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyTestableClass();</span><br><span class="line">obj.isTestable; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>上面代码中，装饰器函数<code>testable</code>是在目标类的<code>prototype</code>对象上添加属性，因此就可以在实例上调用。</p><p>下面是另外一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mixins.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">"./mixins"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码通过装饰器<code>mixins</code>，把<code>Foo</code>对象的方法添加到了<code>MyClass</code>的实例上面。可以用<code>Object.assign()</code>模拟这个功能。</p><h2 id="方法的装饰"><a href="#方法的装饰" class="headerlink" title="方法的装饰"></a>方法的装饰</h2><h3 id="装饰器修改属性的描述对象"><a href="#装饰器修改属性的描述对象" class="headerlink" title="装饰器修改属性的描述对象"></a>装饰器修改属性的描述对象</h3><p>装饰器不仅可以装饰类，还可以装饰类的属性。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，装饰器<code>readonly</code>用来装饰“类”的<code>name</code>方法。</p><p>装饰器函数<code>readonly</code>一共可以接受三个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readonly</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// descriptor对象原来的值如下</span></span><br><span class="line">  <span class="comment">// &#123;</span></span><br><span class="line">  <span class="comment">//   value: specifiedFunction,</span></span><br><span class="line">  <span class="comment">//   enumerable: false,</span></span><br><span class="line">  <span class="comment">//   configurable: true,</span></span><br><span class="line">  <span class="comment">//   writable: true</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  descriptor.writable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readonly(Person.prototype, <span class="string">"name"</span>, descriptor);</span><br><span class="line"><span class="comment">// 类似于</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Person.prototype, <span class="string">"name"</span>, descriptor);</span><br></pre></td></tr></table></figure><p>装饰器第一个参数是类的原型对象，上例是<code>Person.prototype</code>，装饰器的本意是要“装饰”类的实例，但是<strong>这个时候实例还没生成，所以只能去装饰原型</strong>（这不同于类的装饰，那种情况时<code>target</code>参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。</p><p>另外，上面代码说明，<strong>装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。</strong></p><p>下面是另一个例子，修改属性描述对象的<code>enumerable</code>属性，使得该属性不可遍历。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @nonenumerable</span><br><span class="line">  <span class="keyword">get</span> kidCount() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.children.length;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonenumerable</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  descriptor.enumerable = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的<code>@log</code>装饰器，可以起到输出日志的作用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Math</span> </span>&#123;</span><br><span class="line">  @log</span><br><span class="line">  add(a, b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oldValue = descriptor.value;</span><br><span class="line"></span><br><span class="line">  descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Calling <span class="subst">$&#123;name&#125;</span> with`</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> oldValue.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> descriptor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> math = <span class="keyword">new</span> <span class="built_in">Math</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// passed parameters should get logged now</span></span><br><span class="line">math.add(<span class="number">2</span>, <span class="number">4</span>);</span><br></pre></td></tr></table></figure><p>上面代码中，<code>@log</code>装饰器的作用就是在执行原始的操作之前，执行一次<code>console.log</code>，从而达到输出日志的目的。</p><h3 id="装饰器的注释作用"><a href="#装饰器的注释作用" class="headerlink" title="装饰器的注释作用"></a>装饰器的注释作用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@testable</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  @nonenumerable</span><br><span class="line">  name() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.first&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.last&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面代码中，我们一眼就能看出，<code>Person</code>类是可测试的，而<code>name</code>方法是只读和不可枚举的。</p><p>下面是使用 Decorator 写法的<a href="https://github.com/ionic-team/stencil" target="_blank" rel="noopener">组件</a>，看上去一目了然。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Component(&#123;</span><br><span class="line">  tag: <span class="string">"my-component"</span>,</span><br><span class="line">  styleUrl: <span class="string">"my-component.scss"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> </span>&#123;</span><br><span class="line">  @Prop() first: string;</span><br><span class="line">  @Prop() last: string;</span><br><span class="line">  @State() isVisible: boolean = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        Hello, my name is &#123;<span class="keyword">this</span>.first&#125; &#123;<span class="keyword">this</span>.last&#125;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="多个装饰器"><a href="#多个装饰器" class="headerlink" title="多个装饰器"></a>多个装饰器</h3><p>如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dec</span>(<span class="params">id</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"evaluated"</span>, id);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">target, property, descriptor</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">"executed"</span>, id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">  @dec(<span class="number">1</span>)</span><br><span class="line">  @dec(<span class="number">2</span>)</span><br><span class="line">  method() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// evaluated 1</span></span><br><span class="line"><span class="comment">// evaluated 2</span></span><br><span class="line"><span class="comment">// executed 2</span></span><br><span class="line"><span class="comment">// executed 1</span></span><br></pre></td></tr></table></figure><p>上面代码中，外层装饰器<code>@dec(1)</code>先进入，但是内层装饰器<code>@dec(2)</code>先执行。</p><h3 id="装饰器可用作类型检查"><a href="#装饰器可用作类型检查" class="headerlink" title="装饰器可用作类型检查"></a>装饰器可用作类型检查</h3><p>除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。</p><h2 id="为什么装饰器不能用于函数"><a href="#为什么装饰器不能用于函数" class="headerlink" title="为什么装饰器不能用于函数"></a>为什么装饰器不能用于函数</h2><h3 id="函数提升，类没有提升"><a href="#函数提升，类没有提升" class="headerlink" title="函数提升，类没有提升"></a>函数提升，类没有提升</h3><p>装饰器只能用于类和类的方法，不能用于函数，<strong>因为存在函数提升</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，意图是执行后<code>counter</code>等于 1，但是实际上结果是<code>counter</code>等于 0。因为函数提升，使得实际执行的代码是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@add</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> counter;</span><br><span class="line"><span class="keyword">var</span> add;</span><br><span class="line"></span><br><span class="line">counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是另一个例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly = <span class="built_in">require</span>(<span class="string">"some-decorator"</span>);</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码也有问题，因为实际执行是下面这样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readOnly;</span><br><span class="line"></span><br><span class="line">@readOnly</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readOnly = <span class="built_in">require</span>(<span class="string">"some-decorator"</span>);</span><br></pre></td></tr></table></figure><p>总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。</p><h3 id="函数一定要用装饰器"><a href="#函数一定要用装饰器" class="headerlink" title="函数一定要用装饰器"></a>函数一定要用装饰器</h3><p>另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello, "</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loggingDecorator</span>(<span class="params">wrapped</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Starting"</span>);</span><br><span class="line">    <span class="keyword">const</span> result = wrapped.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wrapped = loggingDecorator(doSomething);</span><br></pre></td></tr></table></figure><h2 id="常见装饰器"><a href="#常见装饰器" class="headerlink" title="常见装饰器"></a>常见装饰器</h2><p><a href="https://github.com/jayphelps/core-decorators.js" target="_blank" rel="noopener">core-decorators.js</a>是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。</p><h3 id="1-autobind"><a href="#1-autobind" class="headerlink" title="1. @autobind"></a>1. @autobind</h3><p><code>autobind</code>装饰器使得方法中的<code>this</code>对象，绑定原始对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; autobind &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @autobind</span><br><span class="line">  getPerson() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">let</span> getPerson = person.getPerson;</span><br><span class="line"></span><br><span class="line">getPerson() === person;</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="2-readonly"><a href="#2-readonly" class="headerlink" title="2. @readonly"></a>2. @readonly</h3><p><code>readonly</code>装饰器使得属性或方法不可写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; readonly &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Meal</span> </span>&#123;</span><br><span class="line">  @readonly</span><br><span class="line">  entree = <span class="string">"steak"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dinner = <span class="keyword">new</span> Meal();</span><br><span class="line">dinner.entree = <span class="string">"salmon"</span>;</span><br><span class="line"><span class="comment">// Cannot assign to read only property 'entree' of [object Object]</span></span><br></pre></td></tr></table></figure><h3 id="3-override"><a href="#3-override" class="headerlink" title="3. @override"></a>3. @override</h3><p><code>override</code>装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; override &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  speak(first, second) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  @override</span><br><span class="line">  speak() &#123;&#125;</span><br><span class="line">  <span class="comment">// SyntaxError: Child#speak() does not properly override Parent#speak(first, second)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// or</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  @override</span><br><span class="line">  speaks() &#123;&#125;</span><br><span class="line">  <span class="comment">// SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">//   Did you mean "speak"?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-deprecate-别名-deprecated"><a href="#4-deprecate-别名-deprecated" class="headerlink" title="4. @deprecate (别名@deprecated)"></a>4. @deprecate (别名@deprecated)</h3><p><code>deprecate</code>或<code>deprecated</code>装饰器在控制台显示一条警告，表示该方法将废除。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; deprecate &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @deprecate</span><br><span class="line">  facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">"We stopped facepalming"</span>)</span><br><span class="line">  facepalmHard() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @deprecate(<span class="string">"We stopped facepalming"</span>, &#123;</span><br><span class="line">    url: <span class="string">"http://knowyourmeme.com/memes/facepalm"</span></span><br><span class="line">  &#125;)</span><br><span class="line">  facepalmHarder() &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalm();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalm: This function will be removed in future versions.</span></span><br><span class="line"></span><br><span class="line">person.facepalmHard();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHard: We stopped facepalming</span></span><br><span class="line"></span><br><span class="line">person.facepalmHarder();</span><br><span class="line"><span class="comment">// DEPRECATION Person#facepalmHarder: We stopped facepalming</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//     See http://knowyourmeme.com/memes/facepalm for more details.</span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><h3 id="5-suppressWarnings"><a href="#5-suppressWarnings" class="headerlink" title="5. @suppressWarnings"></a>5. @suppressWarnings</h3><p><code>suppressWarnings</code>装饰器抑制<code>deprecated</code>装饰器导致的<code>console.warn()</code>调用。但是，异步代码发出的调用除外。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; suppressWarnings &#125; <span class="keyword">from</span> <span class="string">"core-decorators"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  @deprecated</span><br><span class="line">  facepalm() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @suppressWarnings</span><br><span class="line">  facepalmWithoutWarning() &#123;</span><br><span class="line">    <span class="keyword">this</span>.facepalm();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">person.facepalmWithoutWarning();</span><br><span class="line"><span class="comment">// no warning is logged</span></span><br></pre></td></tr></table></figure><h2 id="使用装饰器实现自动发布事件"><a href="#使用装饰器实现自动发布事件" class="headerlink" title="使用装饰器实现自动发布事件"></a>使用装饰器实现自动发布事件</h2><p>我们可以使用装饰器，使得对象的方法被调用时，自动发出一个事件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> postal = <span class="built_in">require</span>(<span class="string">"postal/lib/postal.lodash"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">publish</span>(<span class="params">topic, channel</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> channelName = channel || <span class="string">"/"</span>;</span><br><span class="line">  <span class="keyword">const</span> msgChannel = postal.channel(channelName);</span><br><span class="line">  msgChannel.subscribe(topic, v =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"频道: "</span>, channelName);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"事件: "</span>, topic);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"数据: "</span>, v);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target, name, descriptor</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = descriptor.value;</span><br><span class="line"></span><br><span class="line">    descriptor.value = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> value = fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">      msgChannel.publish(topic, value);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码定义了一个名为<code>publish</code>的装饰器，它通过改写<code>descriptor.value</code>，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是<a href="https://github.com/postaljs/postal.js" target="_blank" rel="noopener">Postal.js</a>。</p><p>它的用法如下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">import</span> publish <span class="keyword">from</span> <span class="string">"./publish"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FooComponent</span> </span>&#123;</span><br><span class="line">  @publish(<span class="string">"foo.some.message"</span>, <span class="string">"component"</span>)</span><br><span class="line">  someMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">my</span>: <span class="string">"data"</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  @publish(<span class="string">"foo.some.other"</span>)</span><br><span class="line">  anotherMethod() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="keyword">new</span> FooComponent();</span><br><span class="line"></span><br><span class="line">foo.someMethod();</span><br><span class="line">foo.anotherMethod();</span><br></pre></td></tr></table></figure><p>以后，只要调用<code>someMethod</code>或者<code>anotherMethod</code>，就会自动发出一个事件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ bash-node index.js</span><br><span class="line">频道:  component</span><br><span class="line">事件:  foo.some.message</span><br><span class="line">数据:  &#123; my: <span class="string">'data'</span> &#125;</span><br><span class="line"></span><br><span class="line">频道:  /</span><br><span class="line">事件:  foo.some.other</span><br><span class="line">数据:  undefined</span><br></pre></td></tr></table></figure><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><p>在装饰器的基础上，可以实现<code>Mixin</code>模式。所谓<code>Mixin</code>模式，就是<strong>对象继承的一种替代方案</strong>，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。</p><p>请看下面的例子。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(MyClass.prototype, Foo);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure><p>上面代码之中，对象<code>Foo</code>有一个<code>foo</code>方法，通过<code>Object.assign</code>方法，可以将<code>foo</code>方法“混入”<code>MyClass</code>类，导致<code>MyClass</code>的实例<code>obj</code>对象都具有<code>foo</code>方法。这就是“混入”模式的一个简单实现。</p><p>下面，我们部署一个通用脚本<code>mixins.js</code>，将 Mixin 写成一个装饰器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mixins</span>(<span class="params">...list</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(target.prototype, ...list);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，就可以使用上面这个装饰器，为类“混入”各种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mixins &#125; <span class="keyword">from</span> <span class="string">"./mixins"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Foo = &#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@mixins(Foo)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure><p>通过<code>mixins</code>这个装饰器，实现了在<code>MyClass</code>类上面“混入”<code>Foo</code>对象的<code>foo</code>方法。</p><p>不过，上面的方法会改写<code>MyClass</code>类的<code>prototype</code>对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyBaseClass</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyClass</code>继承了<code>MyBaseClass</code>。如果我们想在<code>MyClass</code>里面“混入”一个<code>foo</code>方法，一个办法是在<code>MyClass</code>和<code>MyBaseClass</code>之间插入一个混入类，这个类具有<code>foo</code>方法，并且继承了<code>MyBaseClass</code>的所有方法，然后<code>MyClass</code>再继承这个类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> MyMixin = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from MyMixin"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>上面代码中，<code>MyMixin</code>是一个混入类生成器，接受<code>superclass</code>作为参数，然后返回一个继承<code>superclass</code>的子类，该子类包含一个<code>foo</code>方法。</p><p>接着，目标类再去继承这个混入类，就达到了“混入”<code>foo</code>方法的目的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">MyMixin</span>(<span class="title">MyBaseClass</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> MyClass();</span><br><span class="line">c.foo(); <span class="comment">// "foo from MyMixin"</span></span><br></pre></td></tr></table></figure><p>如果需要“混入”多个方法，就生成多个混入类。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">MyBaseClass</span>)) </span>&#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法的一个好处，是可以调用<code>super</code>，因此可以避免在“混入”过程中覆盖父类的同名方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> Mixin1 = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from Mixin1"</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Mixin2 = <span class="function"><span class="params">superclass</span> =&gt;</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">superclass</span> </span>&#123;</span><br><span class="line">    foo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"foo from Mixin2"</span>);</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">super</span>.foo) <span class="keyword">super</span>.foo();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo from S"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">Mixin1</span>(<span class="title">Mixin2</span>(<span class="title">S</span>)) </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo from C"</span>);</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中，每一次<code>混入</code>发生时，都调用了父类的<code>super.foo</code>方法，导致父类的同名方法没有被覆盖，行为被保留了下来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> C().foo();</span><br><span class="line"><span class="comment">// foo from C</span></span><br><span class="line"><span class="comment">// foo from Mixin1</span></span><br><span class="line"><span class="comment">// foo from Mixin2</span></span><br><span class="line"><span class="comment">// foo from S</span></span><br></pre></td></tr></table></figure><h2 id="Trait"><a href="#Trait" class="headerlink" title="Trait"></a>Trait</h2><p>Trait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。</p><p>下面采用<a href="https://github.com/CocktailJS/traits-decorator" target="_blank" rel="noopener">traits-decorator</a>这个第三方模块作为例子。这个模块提供的<code>traits</code>装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码中，通过<code>traits</code>装饰器，在<code>MyClass</code>类上面“混入”了<code>TFoo</code>类的<code>foo</code>方法和<code>TBar</code>对象的<code>bar</code>方法。</p><p>Trait 不允许“混入”同名方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, TBar)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="comment">// throw new Error('Method named: ' + methodName + ' is defined twice.');</span></span><br><span class="line"><span class="comment">//        ^</span></span><br><span class="line"><span class="comment">// Error: Method named: foo is defined twice.</span></span><br></pre></td></tr></table></figure><p>上面代码中，<code>TFoo</code>和<code>TBar</code>都有<code>foo</code>方法，结果<code>traits</code>装饰器报错。</p><p>一种解决方法是排除<code>TBar</code>的<code>foo</code>方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits, excludes &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::excludes(<span class="string">"foo"</span>))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码使用绑定运算符（::）在<code>TBar</code>上排除<code>foo</code>方法，混入时就不会报错了。</p><p>另一种方法是为<code>TBar</code>的<code>foo</code>方法起一个别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; traits, alias &#125; <span class="keyword">from</span> <span class="string">"traits-decorator"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TFoo</span> </span>&#123;</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> TBar = &#123;</span><br><span class="line">  bar() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"bar"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"foo"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">@traits(TFoo, <span class="attr">TBar</span>::alias(&#123; <span class="attr">foo</span>: <span class="string">"aliasFoo"</span> &#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> MyClass();</span><br><span class="line">obj.foo(); <span class="comment">// foo</span></span><br><span class="line">obj.aliasFoo(); <span class="comment">// foo</span></span><br><span class="line">obj.bar(); <span class="comment">// bar</span></span><br></pre></td></tr></table></figure><p>上面代码为<code>TBar</code>的<code>foo</code>方法起了别名<code>aliasFoo</code>，于是<code>MyClass</code>也可以混入<code>TBar</code>的<code>foo</code>方法了。</p><p><code>alias</code>和<code>excludes</code>方法，可以结合起来使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@traits(TExample::excludes(<span class="string">"foo"</span>, <span class="string">"bar"</span>)::alias(&#123; <span class="attr">baz</span>: <span class="string">"exampleBaz"</span> &#125;))</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>上面代码排除了<code>TExample</code>的<code>foo</code>方法和<code>bar</code>方法，为<code>baz</code>方法起了别名<code>exampleBaz</code>。</p><p><code>as</code>方法则为上面的代码提供了另一种写法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@traits(</span><br><span class="line">  TExample::<span class="keyword">as</span>(&#123; <span class="attr">excludes</span>: [<span class="string">"foo"</span>, <span class="string">"bar"</span>], <span class="attr">alias</span>: &#123; <span class="attr">baz</span>: <span class="string">"exampleBaz"</span> &#125; &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;ES6-装饰器&quot;&gt;&lt;a href=&quot;#ES6-装饰器&quot; class=&quot;headerlink&quot; title=&quot;ES6 装饰器&quot;&gt;&lt;/a&gt;ES6 装饰器&lt;/h1&gt;&lt;p&gt;装饰器（Decorator）是一种与类（class）相关的语法，&lt;strong&gt;用来注释或修改类和类方法&lt;/strong&gt;。装饰器是一种函数，写成&lt;code&gt;@ + 函数名&lt;/code&gt;。它可以放在类和类方法的定义前面。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>QUIC</title>
    <link href="http://yoursite.com/2019/08/16/QUIC/"/>
    <id>http://yoursite.com/2019/08/16/QUIC/</id>
    <published>2019-08-15T17:52:20.000Z</published>
    <updated>2019-11-10T14:37:39.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h1><h2 id="QUIC-概述"><a href="#QUIC-概述" class="headerlink" title="QUIC 概述"></a>QUIC 概述</h2><p>Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。</p><p>QUIC 协议内置了 TLS 栈，实现了自己的<a href="https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit" target="_blank" rel="noopener">传输加密层</a>，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：</p><a id="more"></a><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izr9eluaj315w0k0aaa.jpg" alt="img"></p><p>从图上可以看出，QUIC 底层通过 UDP 协议替代了 TCP，上层只需要一层用于和远程服务器交互的 HTTP/2 API。这是因为 QUIC 协议已经包含了多路复用和连接管理，HTTP API 只需要完成 HTTP 协议的解析即可。</p><h2 id="QUIC-优势"><a href="#QUIC-优势" class="headerlink" title="QUIC 优势"></a>QUIC 优势</h2><ol><li>减少了 TCP 三次握手及 TLS 握手时间。</li><li>改进的拥塞控制。</li><li>避免队头阻塞的多路复用。</li><li>连接迁移。</li><li>前向冗余纠错。（目前默认的冗余量是 10%，既每发送 10 个数据包，其冗余数据就可以重新构建一个丢失的数据包）</li></ol><h2 id="为什么需要-QUIC"><a href="#为什么需要-QUIC" class="headerlink" title="为什么需要 QUIC"></a>为什么需要 QUIC</h2><ol><li><p>协议历史悠久导致中间设备僵化。</p><p>TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口（80、443）及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。</p></li><li><p>依赖于操作系统的实现导致协议本身僵化。</p><p>TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。</p></li><li><p>建立连接的握手延迟大。</p><p>不管是 HTTP1.0/1.1 还是 HTTPS，HTTP2，都使用了 TCP 进行传输。HTTPS 和 HTTP2 还需要使用 TLS 协议来进行安全传输。这就出现了两个握手延迟：</p><ul><li>TCP 三次握手导致的 TCP 连接建立的延迟。</li><li>TLS 完全握手需要至少 2 个 RTT 才能建立，简化握手需要 1 个 RTT 的握手延迟。</li></ul><p>对于很多短连接场景，这样的握手延迟影响很大，且无法消除。</p></li><li><p>队头阻塞。</p><p>队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。</p><p>另外 TLS 协议层面也有一个队头阻塞，因为 TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。</p></li></ol><p><strong>QUIC 协议选择了 UDP，因为 UDP 本身没有连接的概念，不需要三次握手，优化了连接建立的握手延迟，同时在应用程序层面实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性，只需要用户端和服务端的应用程序支持 QUIC 协议，完全避开了操作系统和中间设备的限制。</strong></p><h2 id="QUIC-详解"><a href="#QUIC-详解" class="headerlink" title="QUIC 详解"></a>QUIC 详解</h2><h3 id="1-QUIC-核心特性连接建立延时低"><a href="#1-QUIC-核心特性连接建立延时低" class="headerlink" title="1. QUIC 核心特性连接建立延时低"></a>1. QUIC 核心特性连接建立延时低</h3><p><strong>0RTT 建连</strong>可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。</p><ol><li>传输层 0RTT 就能建立连接。</li><li>加密层 0RTT 就能建立加密连接。</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izr8c4vjj314a0n0gpa.jpg" alt="img"></p><p>比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption[14]，也需要至少 2 个 RTT。</p><p>而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket[13] 要高很多。</p><h3 id="2-改进的拥塞控制"><a href="#2-改进的拥塞控制" class="headerlink" title="2. 改进的拥塞控制"></a>2. 改进的拥塞控制</h3><p>TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。</p><p>QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。</p><p>从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点：</p><ul><li><strong>可插拔</strong></li></ul><p>什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面：</p><ol><li>应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。</li><li>即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。</li><li>应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。</li></ol><p>STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。</p><ul><li><strong>单调递增的 Packet Number</strong></li></ul><p>TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。</p><p>QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrp5123j30k008rjro.jpg" alt="img"></p><p>​ 图 2 Tcp 重传歧义性</p><p>如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。</p><p>如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。</p><p>由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrs95mpj30k007xjrn.jpg" alt="img"></p><p>​ 图 3 Quic 重传没有歧义性</p><p>如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。</p><p>但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 Stream Offset 的概念。</p><p>即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。但是 Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。如错误! 未找到引用源。所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。</p><p>假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrw4o31j30k005smxc.jpg" alt="img"></p><p>​ 图 4 Stream Offset 保证有序性</p><ul><li><strong>不允许 Reneging</strong></li></ul><p>什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。</p><p>Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据。</p><p>QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰。</p><ul><li><strong>更多的 Ack 块</strong></li></ul><p>TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。</p><p>由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 [25]，所以留给 Sack 选项的只有 30 个字节。</p><p>每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。</p><p>但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。</p><ul><li><strong>Ack Delay 时间</strong></li></ul><p>Tcp 的 Timestamp 选项存在一个问题，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。</p><p>这样就会导致 RTT 计算误差。如下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izrzqtwlj30k00f4wf5.jpg" alt="img"></p><p>可以认为 TCP 的 RTT 计算：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs42dncj308d015743.jpg" alt="img"></p><p>而 Quic 计算如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs6x1lbj30a70153yc.jpg" alt="img"></p><p>当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式 [9]。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izs9tffbj308d01vwed.jpg" alt="img"></p><h3 id="3-基于-stream-和-connecton-级别的流量控制"><a href="#3-基于-stream-和-connecton-级别的流量控制" class="headerlink" title="3.基于 stream 和 connecton 级别的流量控制"></a>3.基于 stream 和 connecton 级别的流量控制</h3><p>QUIC 的流量控制类似 HTTP2，即在 Connection 和 Stream 级别提供了两种流量控制。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。</p><ol><li>Stream 可以认为就是一条 HTTP 请求。</li><li>Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。</li></ol><p>QUIC 实现流量控制的原理比较简单：</p><p>通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。</p><p>通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。</p><p>QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。</p><p>但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsddv9lj30k0087q3a.jpg" alt="img"></p><p>​ 图 5 Quic Flow Control</p><p>针对 Stream：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsh7d39j30bz011glh.jpg" alt="img"></p><p>针对 Connection：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsk0cpyj30gy011a9z.jpg" alt="img"></p><p>同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。</p><p>最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。</p><h3 id="4-没有队头阻塞的多路复用"><a href="#4-没有队头阻塞的多路复用" class="headerlink" title="4.没有队头阻塞的多路复用"></a>4.没有队头阻塞的多路复用</h3><p>QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。</p><p>QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。</p><p>这也就在很大程度上缓解甚至消除了队头阻塞的影响。</p><p>多路复用是 HTTP2 最强大的特性，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞，如下图示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsn9t0ej30k007gq3a.jpg" alt="img"></p><p>​ 图 6 HTTP2 队头阻塞</p><p>HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。</p><p>不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞 [12]。<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsr1djhj30k00ctaac.jpg" alt="img"></p><p>​ 图 7 TLS 队头阻塞</p><p>Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。</p><p>那 QUIC 多路复用为什么能避免上述问题呢？</p><ol><li>QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。</li><li>Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。（QUIC 协议直接通过底层使用 UDP 协议天然的避免了该问题。由于 UDP 协议没有严格的顺序，当一个数据包遇到问题需要重传时，只会影响该数据包对应的资源，其他独立的资源（如其他 css、js 文件）不会受到影响）</li></ol><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsvoeyqj30k007gdg7.jpg" alt="img"></p><p>​ 图 8 QUIC 多路复用时没有队头阻塞的问题</p><p>当然，并不是所有的 QUIC 数据都不会受到队头阻塞的影响，比如 QUIC 当前也是使用 Hpack 压缩算法 [10]，由于算法的限制，丢失一个头部数据时，可能遇到队头阻塞。</p><p>总体来说，QUIC 在传输大量数据时，比如视频，受到队头阻塞的影响很小。</p><h3 id="5-加密认证的报文"><a href="#5-加密认证的报文" class="headerlink" title="5.加密认证的报文"></a>5.加密认证的报文</h3><p>TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。</p><p>但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。</p><p>这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。</p><p>如下图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izsyv3ovj30i3091dgf.jpg" alt="img"></p><h3 id="6-连接迁移"><a href="#6-连接迁移" class="headerlink" title="6.连接迁移"></a>6.连接迁移</h3><p>一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。</p><p>比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。</p><p>又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。</p><p>针对 TCP 的连接变化，MPTCP 其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。</p><p>所以从 TCP 连接的角度来讲，这个问题是无解的。</p><p>那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。</p><p>由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。</p><h3 id="7-其他亮点"><a href="#7-其他亮点" class="headerlink" title="7.其他亮点"></a>7.其他亮点</h3><p>此外，QUIC 还能实现前向冗余纠错，在重要的包比如握手消息发生丢失时，能够根据冗余信息还原出握手消息。</p><p>QUIC 还能实现证书压缩，减少证书传输量，针对包头进行验证等。</p><h2 id="QUIC-协议实践"><a href="#QUIC-协议实践" class="headerlink" title="QUIC 协议实践"></a>QUIC 协议实践</h2><p>Chrome 浏览器从 2014 年开始已经实验性的支持了 QUIC 协议。可以通过在 Chrome 浏览器中输入<code>chrome://net-internals/#quic</code>查看是否已经支持 QUIC 协议。如果还未支持，可以在<code>chrome://flags/#enable-quic</code>中进行开启。</p><p>开始 Chrome 浏览器对 QUIC 协议的支持之后，可以在<code>chrome://net-internals/#quic</code>中查看到当前浏览器的 QUIC 一些连接。当然目前只有 Google 服务才支持 QUIC 协议（如 YouTube、 Google.com）。</p><h3 id="1-关于防火墙"><a href="#1-关于防火墙" class="headerlink" title="1. 关于防火墙"></a>1. 关于防火墙</h3><p>通常系统管理员会关注防火墙的 TCP 规则，而忽略 UDP 规则。如果要在防火墙之后使用 QUIC 协议，除了传统 web 服务需要开放的<code>80/TCP</code>、<code>443/TCP</code>之外，针对 QUIC 还需要开放<code>443/UDP</code>的访问。</p><h3 id="2-服务端使用-QUIC-协议"><a href="#2-服务端使用-QUIC-协议" class="headerlink" title="2.服务端使用 QUIC 协议"></a>2.服务端使用 QUIC 协议</h3><p>目前支持 QUIC 协议的 web 服务只有 0.9 版本以后的<a href="https://github.com/mholt/caddy/wiki/QUIC" target="_blank" rel="noopener">Caddy</a>。其他常用 web 服务如 nginx、apache 等都未开始支持。curl 表达了对 QUIC 协议<a href="https://daniel.haxx.se/blog/2016/07/20/curl-wants-to-quic/" target="_blank" rel="noopener">支持的兴趣</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;QUIC&quot;&gt;&lt;a href=&quot;#QUIC&quot; class=&quot;headerlink&quot; title=&quot;QUIC&quot;&gt;&lt;/a&gt;QUIC&lt;/h1&gt;&lt;h2 id=&quot;QUIC-概述&quot;&gt;&lt;a href=&quot;#QUIC-概述&quot; class=&quot;headerlink&quot; title=&quot;QUIC 概述&quot;&gt;&lt;/a&gt;QUIC 概述&lt;/h2&gt;&lt;p&gt;Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。&lt;/p&gt;
&lt;p&gt;QUIC 协议内置了 TLS 栈，实现了自己的&lt;a href=&quot;https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;传输加密层&lt;/a&gt;，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>TCP</title>
    <link href="http://yoursite.com/2019/08/11/TCP/"/>
    <id>http://yoursite.com/2019/08/11/TCP/</id>
    <published>2019-08-11T13:15:33.000Z</published>
    <updated>2019-11-10T14:37:39.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><ul><li>TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment）</li><li>IP 在第三层——Network 层（在第三层上的数据叫 Packet）</li><li>ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame）</li></ul><p>我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p><a id="more"></a><h2 id="TCP-头格式"><a href="#TCP-头格式" class="headerlink" title="TCP 头格式"></a>TCP 头格式</h2><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izttyfinj30m8090jsz.jpg" alt="img"></p><p>你需要注意这么几点：</p><ul><li>TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。</li><li>一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。</li><li>注意上图中的四个非常重要的东西：<ul><li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li><li><strong>Acknowledgement Number</strong>就是 ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li><li><strong>Window 又叫 Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li><li><strong>TCP Flag</strong> ，也就是包的类型，<strong>主要是用于操控 TCP 的状态机的</strong>。</li></ul></li></ul><h2 id="TCP-状态机"><a href="#TCP-状态机" class="headerlink" title="TCP 状态机"></a>TCP 状态机</h2><p>其实，<strong>网络上的传输是没有连接的，包括 TCP 也是一样的</strong>。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。</p><p>“<strong>TCP 协议的状态机</strong>”和 “<strong>TCP 建链接</strong>”、“<strong>TCP 断链接</strong>”、“<strong>传数据</strong>” 的对照图</p><p><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcpfsm.png" style="zoom:70%;display:inline"><img src="https://coolshell.cn/wp-content/uploads/2014/05/tcp_open_close.jpg" style="zoom:40%;display:inline"></p><p>很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？</p><ul><li><strong>对于建链接的 3 次握手，</strong>主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number）——所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。</li><li><strong>对于 4 次挥手，</strong>其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）：</li></ul><h2 id="数据传输中的-Sequence-Number"><a href="#数据传输中的-Sequence-Number" class="headerlink" title="数据传输中的 Sequence Number"></a>数据传输中的 Sequence Number</h2><p>下图是从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 Statistics -&gt;Flow Graph… ）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5nx0rq0j30al0a1jsq.jpg" alt="img"></p><p>你可以看到，<strong>SeqNum 的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。</p><p><strong>注意</strong>：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为 0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum——相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p><h2 id="TCP-重传机制"><a href="#TCP-重传机制" class="headerlink" title="TCP 重传机制"></a>TCP 重传机制</h2><p>TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。</p><p>注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p><h3 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h3><p>一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4——意味着 3 和 4 都收到了。</p><p>但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。</p><p>对此有两种选择：</p><ul><li>一种是仅重传 timeout 的包。也就是第 3 份数据。</li><li>另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。</li></ul><p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的）</p><h3 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h3><p>于是，TCP 引入了一种叫<strong>Fast Retransmit</strong> 的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。Fast Retransmit 的好处是不用等 timeout 了再重传。</p><p>比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack=2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5o1shzuj30ci0833yx.jpg" alt="img"></p><p>Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2 呢还是重传#2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2)是谁传回来的？也许发送端发了 20 份数据，是#6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。</p><h3 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h3><p>另外一种更好的方式叫：<strong>Selective Acknowledgment (SACK)</strong>（参看<a href="http://tools.ietf.org/html/rfc2018" target="_blank" rel="noopener">RFC 2018</a>），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5o7gj8sj30sg0g1ta5.jpg" alt="img"></p><p>这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过<strong>tcp_sack</strong>参数打开这个功能（Linux 2.4 后默认打开）。</p><p>这里还需要注意一个问题——<strong>接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了</strong>。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。<strong>所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。</strong></p><p>注意：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。</p><h3 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h3><p>Duplicate SACK 又称 D-SACK，<strong>其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了</strong>。<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="noopener">RFC-2883 </a>里有详细描述和示例。下面举几个例子（来源于<a href="http://www.ietf.org/rfc/rfc2883.txt" target="_blank" rel="noopener">RFC-2883</a>）</p><p>D-SACK 使用了 SACK 的第一个段来做标志，</p><ul><li>如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK</li><li>如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK</li></ul><h4 id="示例一：ACK-丢包"><a href="#示例一：ACK-丢包" class="headerlink" title="示例一：ACK 丢包"></a>示例一：ACK 丢包</h4><p>下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个 SACK=3000-3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Transmitted  Received    ACK Sent</span><br><span class="line">Segment      Segment     (Including SACK Blocks)</span><br><span class="line">3000-3499    3000-3499   3500 (ACK dropped)</span><br><span class="line">3500-3999    3500-3999   4000 (ACK dropped)</span><br><span class="line">3000-3499    3000-3499   4000, SACK=3000-3500</span><br><span class="line">                                    ---------</span><br></pre></td></tr></table></figure><h4 id="示例二，网络延误"><a href="#示例二，网络延误" class="headerlink" title="示例二，网络延误"></a>示例二，网络延误</h4><p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK=1000-1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK——标识收到了重复的包。</p><p>这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transmitted    Received    ACK Sent</span><br><span class="line">Segment        Segment     (Including SACK Blocks)</span><br><span class="line"><span class="number">500</span><span class="number">-999</span>        <span class="number">500</span><span class="number">-999</span>     <span class="number">1000</span></span><br><span class="line">1000-1499      (delayed)</span><br><span class="line">1500-1999      1500-1999   1000, SACK=1500-2000</span><br><span class="line">2000-2499      2000-2499   1000, SACK=1500-2500</span><br><span class="line">2500-2999      2500-2999   1000, SACK=1500-3000</span><br><span class="line"><span class="number">1000</span><span class="number">-1499</span>      <span class="number">1000</span><span class="number">-1499</span>   <span class="number">3000</span></span><br><span class="line">               1000-1499   3000, SACK=1000-1500</span><br><span class="line">                                      ---------</span><br></pre></td></tr></table></figure><p>可见，引入了 D-SACK，有这么几个好处：</p><p>1）可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。</p><p>2）是不是自己的 timeout 太小了，导致重传。</p><p>3）网络上出现了先发的包后到的情况（又称 reordering）</p><p>4）网络上是不是把我的数据包给复制了。</p><p><strong>知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控</strong>。</p><p>Linux 下的 tcp_dsack 参数用于开启这个功能（Linux 2.4 后默认打开）</p><h2 id="TCP-的-RTT-算法"><a href="#TCP-的-RTT-算法" class="headerlink" title="TCP 的 RTT 算法"></a>TCP 的 RTT 算法</h2><p>从前面的 TCP 重传机制我们知道 Timeout 的设置对于重传非常重要。</p><ul><li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li><li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li></ul><p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP 引入了 RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置 Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下 t0，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p><h3 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h3><p><a href="http://tools.ietf.org/html/rfc793" target="_blank" rel="noopener">RFC793</a> 中定义的经典算法是这样的：</p><p>1）首先，先采样 RTT，记下最近好几次的 RTT 值。</p><p>2）然后做平滑计算 SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 Exponential weighted moving average，中文叫：加权移动平均）</p><p><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p><p>3）开始计算 RTO。公式如下：</p><p><strong>RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ]</strong></p><p>其中：</p><ul><li>UBOUND 是最大的 timeout 时间，上限值</li><li>LBOUND 是最小的 timeout 时间，下限值</li><li>β 值一般在 1.3 到 2.0 之间。</li></ul><h3 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h3><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和 ack 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？</p><p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p><ul><li>情况（a）是 ack 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。</li><li>情况（b）是 ack 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5odttngj30kp098mxm.jpg" alt="img"></p><p>所以 1987 年的时候，搞了一个叫<a href="http://en.wikipedia.org/wiki/Karn's_Algorithm" target="_blank" rel="noopener">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的 RTT 做采样</strong>（你看，你不需要去解决不存在的问题）。</p><p>但是，这样一来，又会引发一个大 BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的 RTO 很小），于是，因为重转的不算，所以，RTO 就不会被更新，这是一个灾难</strong>。 于是 Karn 算法用了一个取巧的方式——只要一发生重传，就对现有的 RTO 值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的 RTT 也不靠谱。</p><h3 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h3><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果 RTT 有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988 年，又有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看<a href="http://tools.ietf.org/html/rfc6298" target="_blank" rel="noopener">RFC6289</a>）。这个算法引入了最新的 RTT 的采样和平滑过的 SRTT 的差距做因子来计算。 公式如下：（其中的 DevRTT 是 Deviation RTT 的意思）</p><p><strong>SRTT</strong> <strong>= S**</strong>RTT** <strong>+ α</strong> <strong>(**</strong>RTT** <strong>– S**</strong>RTT*<strong>*)</strong> —— 计算平滑 RTT</p><p><strong>DevRTT</strong> <strong>= (1-β**</strong>)**<strong>*DevRTT</strong> <strong>+ β***</strong>(|*<strong>*RTT-SRTT**</strong>|)** ——计算平滑 RTT 和真实的差距（加权移动平均）</p><p><strong>RTO= µ * SRTT + ∂ *DevRTT</strong> —— 神一样的公式</p><p>（其中：在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的 TCP 协议中（Linux 的源代码在：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609" target="_blank" rel="noopener">tcp_rtt_estimator</a>）。</p><h2 id="TCP-滑动窗口"><a href="#TCP-滑动窗口" class="headerlink" title="TCP 滑动窗口"></a>TCP 滑动窗口</h2><p>需要说明一下，如果你不了解 TCP 的滑动窗口这个事，你等于不了解 TCP 协议。我们都知道，<strong>TCP 必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p><p>所以，TCP 引入了一些技术和设计来做网络流控，Sliding Window 是其中一个技术。 前面我们说过，<strong>TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下 TCP 缓冲区的一些数据结构：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5oinwowj30p60a13z5.jpg" alt="img"></p><p>上图中，我们可以看到：</p><ul><li>接收端 LastByteRead 指向了 TCP 缓冲区中读到的位置，NextByteExpected 指向的地方是收到的连续包的最后一个位置，LastByteRcved 指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li><li>发送端的 LastByteAcked 指向了被接收端 Ack 过的位置（表示成功发送确认），LastByteSent 表示发出去了，但还没有收到成功确认的 Ack，LastByteWritten 指向的是上层应用正在写的地方。</li></ul><p>于是：</p><ul><li>接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li><li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li></ul><p>下面我们来看一下发送方的滑动窗口示意图：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5omcs7ej30ic07i750.jpg" alt="img"></p><p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p><ul><li>#1 已收到 ack 确认的数据。</li><li>#2 发还没收到 ack 的。</li><li>#3 在窗口中还没有发出的（接收方还有空间）。</li><li>#4 窗口以外的数据（接收方没空间）</li></ul><p>下面是个滑动后的示意图（收到 36 的 ack，并发出了 46-51 的字节）：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5oq49tuj30ic05uwev.jpg" alt="img"></p><p>下面我们来看一个接受端控制发送端的图示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5ot8lvsj30ii0n8wfy.jpg" alt="img"></p><h3 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h3><p>上图，我们可以看到一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的 TCP Sliding Window 给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？</p><p>解决这个问题，TCP 使用了 Zero Window Probe 技术，缩写为 ZWP，也就是说，发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。</p><p><strong>注意</strong>：只要有等待的地方都可能出现 DDoS 攻击，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a href="http://en.wikipedia.org/wiki/Sockstress" target="_blank" rel="noopener">Wikipedia 的 SockStress 词条</a>）</p><p>另外，Wireshark 中，你可以使用 tcp.analysis.zero_window 来过滤包，然后使用右键菜单里的 follow TCP stream，你可以看到 ZeroWindowProbe 及 ZeroWindowProbeAck 的包。</p><h3 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h3><p>Silly Window Syndrome 翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。</p><p>要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p><p>另外，你需要知道网络上有个 MTU，对于以太网来说，MTU 是 1500 字节，除去 TCP+IP 头的 40 个字节，真正的数据传输可以有 1460，这就是所谓的 MSS（Max Segment Size）注意，TCP 的 RFC 定义这个 MSS 的默认值是 536，这是因为 <a href="http://tools.ietf.org/html/rfc791" target="_blank" rel="noopener">RFC 791</a>里说了任何一个 IP 设备都得最少接收 576 尺寸的大小（实际上来说 576 是拨号的网络的 MTU，而 576 减去 IP 头的 20 个字节就是 536）。</p><p><strong>如果你的网络包可以塞满 MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于 MTU 的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个 MTU 就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p><p>所以，<strong>Silly Windows Syndrome 这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。</p><ul><li>如果这个问题是由 Receiver 端引起的，那么就会使用 David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。</li><li>如果这个问题是由 Sender 端引起的，那么就会使用著名的 <a href="http://en.wikipedia.org/wiki/Nagle's_algorithm" target="_blank" rel="noopener">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。</li></ul><p>另外，Nagle 算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像 telnet 或 ssh 这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char*)&amp;value,sizeof(int));</span><br></pre></td></tr></table></figure><p>另外，网上有些文章说 TCP_CORK 的 socket option 是也关闭 Nagle 算法，这不对。<strong>TCP_CORK 其实是更新激进的 Nagle 算汉，完全禁止小包发送，而 Nagle 算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p><h2 id="TCP-的拥塞处理-–-Congestion-Handling"><a href="#TCP-的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP 的拥塞处理 – Congestion Handling"></a>TCP 的拥塞处理 – Congestion Handling</h2><p>上面我们知道了，TCP 通过 Sliding Window 来做流控（Flow Control），但是 TCP 觉得这还不够，因为 Sliding Window 需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP 的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型 4 层以上的事，TCP 的还应该更聪明地知道整个网络上的事。</p><p>具体一点，我们知道 TCP 通过一个 timer 采样了 RTT 并计算 RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP 对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的 TCP 连接都这么行事，那么马上就会形成“网络风暴”，TCP 这个协议就会拖垮整个网络。</strong>这是一个灾难。</p><p>所以，TCP 不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此 TCP 的设计理念是：<strong>TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong></p><p>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p><ul><li>1988 年，TCP-Tahoe 提出了 1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li><li>1990 年，TCP Reno 在 Tahoe 的基础上增加了 4）快速恢复</li></ul><h3 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h3><p>首先，我们来看一下 TCP 的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p><p>慢启动的算法如下(cwnd 全称 Congestion Window)：</p><p>1）连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。</p><p>2）每当收到一个 ACK，cwnd++; 呈线性上升</p><p>3）每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升</p><p>4）还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”（后面会说这个算法）</p><p>所以，我们可以看到，如果网速很快的话，ACK 也会返回得快，RTT 也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5oz81ffj30ie0asjsi.jpg" alt="img"></p><p>一篇 Google 的论文《<a href="http://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf" target="_blank" rel="noopener">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0 后采用了这篇论文的建议——把 cwnd 初始化成了 10 个 MSS。而 Linux 3.0 以前，比如 2.6，Linux 采用了<a href="http://www.rfc-editor.org/rfc/rfc3390.txt" target="_blank" rel="noopener">RFC3390</a>，cwnd 是跟 MSS 的值来变的，如果 MSS&lt; 1095，则 cwnd = 4；如果 MSS&gt;2190，则 cwnd=2；其它情况下，则是 3。</p><h3 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h3><p>前面说过，还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”。一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下：</p><p>1）收到一个 ACK 时，cwnd = cwnd + 1/cwnd</p><p>2）当每过一个 RTT 时，cwnd = cwnd + 1</p><p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p><h3 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h3><p>前面我们说过，当丢包的时候，会有两种情况：</p><p>1）等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。</p><ul><li><ul><li>sshthresh = cwnd /2</li><li>cwnd 重置为 1</li><li>进入慢启动过程</li></ul></li></ul><p>2）Fast Retransmit 算法，也就是在收到 3 个 duplicate ACK 时就开启重传，而不用等到 RTO 超时。</p><ul><li><ul><li>TCP Tahoe 的实现和 RTO 超时一样。</li></ul></li><li><ul><li>TCP Reno 的实现是：<ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li><li>进入快速恢复算法——Fast Recovery</li></ul></li></ul></li></ul><p>上面我们可以看到 RTO 超时后，sshthresh 会变成 cwnd 的一半，这意味着，如果 cwnd&lt;=sshthresh 时出现的丢包，那么 TCP 的 sshthresh 就会减了一半，然后等 cwnd 又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP 是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p><h3 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h3><h4 id="TCP-Reno"><a href="#TCP-Reno" class="headerlink" title="TCP Reno"></a>TCP Reno</h4><p>这个算法定义在<a href="http://tools.ietf.org/html/rfc5681" target="_blank" rel="noopener">RFC5681</a>。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有 3 个 Duplicated Acks 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。 注意，正如前面所说，进入 Fast Recovery 之前，cwnd 和 sshthresh 已被更新：</p><ul><li>cwnd = cwnd /2</li><li>sshthresh = cwnd</li></ul><p>然后，真正的 Fast Recovery 算法如下：</p><ul><li>cwnd = sshthresh + 3 * MSS （3 的意思是确认有 3 个数据包被收到了）</li><li>重传 Duplicated ACKs 指定的数据包</li><li>如果再收到 duplicated Acks，那么 cwnd = cwnd +1</li><li>如果收到了新的 Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li></ul><p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于 3 个重复的 Acks</strong>。注意，3 个重复的 Acks 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成 TCP 的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。</p><p>通常来说，正如我们前面所说的，SACK 或 D-SACK 的方法可以让 Fast Recovery 或 Sender 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持 SACK（SACK 需要两端都支持），所以，需要一个没有 SACK 的解决方案。而通过 SACK 进行拥塞控制的算法是 FACK（后面会讲）</p><h4 id="TCP-New-Reno"><a href="#TCP-New-Reno" class="headerlink" title="TCP New Reno"></a>TCP New Reno</h4><p>于是，1995 年，TCP New Reno（参见 <a href="http://tools.ietf.org/html/rfc6582" target="_blank" rel="noopener">RFC 6582</a> ）算法提出来，主要就是在没有 SACK 的支持下改进 Fast Recovery 算法的——</p><ul><li>当 sender 这边收到了 3 个 Duplicated Acks，进入 Fast Retransimit 模式，开发重传重复 Acks 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 Ack 会把整个已经被 sender 传输出去的数据 ack 回来。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。</li><li>一旦 Sender 这边发现了 Partial ACK 出现，那么，sender 就可以推理出来有多个包被丢了，于是乎继续重传 sliding window 里未被 ack 的第一个包。直到再也收不到了 Partial Ack，才真正结束 Fast Recovery 这个过程</li></ul><p>我们可以看到，这个“Fast Recovery 的变更”是一个非常激进的玩法，他同时延长了 Fast Retransmit 和 Fast Recovery 的过程。</p><h5 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h5><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5p47j65j30sg09zgmc.jpg" alt="img"></p><h4 id="FACK-算法"><a href="#FACK-算法" class="headerlink" title="FACK 算法"></a>FACK 算法</h4><p>FACK 全称 Forward Acknowledgment 算法，论文地址在这里（PDF）<a href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf" target="_blank" rel="noopener">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于 SACK 的，前面我们说过 SACK 是使用了 TCP 扩展字段 Ack 了有哪些数据收到，哪些数据没有收到，他比 Fast Retransmit 的 3 个 duplicated acks 好处在于，前者只知道有包丢了，不知道是一个还是多个，而 SACK 可以准确的知道有哪些包丢了。 所以，SACK 可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK 用来做重传过程中的拥塞流控。</p><ul><li>这个算法会把 SACK 中最大的 Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack 的更新由 ack 带秋，如果网络一切安好则和 snd.una 一样（snd.una 就是还没有收到 ack 的地方，也就是前面 sliding window 里的 category #2 的第一个地方）</li><li>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt 指向发送端 sliding window 中正在要被发送的地方——前面 sliding windows 图示的 category#3 第一个位置），这样 awnd 的意思就是在网络上的数据。（所谓 awnd 意为：actual quantity of data outstanding in the network）</li><li>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd 是传出去的数据 + 重传的数据。</li><li>然后触发 Fast Recovery 的条件是： ( <strong>( snd.fack – snd.una ) &gt; (3*MSS)</strong> ) || (dupacks == 3) ) 。这样一来，就不需要等到 3 个 duplicated acks 才重传，而是只要 sack 中的最大的一个数据和 ack 的数据比较长了（3 个 MSS），那就触发重传。在整个重传过程中 cwnd 不变。直到当第一次丢包的 snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd 线性上涨。</li></ul><p>我们可以看到如果没有 FACK 在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的 window 的大小，而需要几个 RTT 的时间才会完成恢复，而 FACK 会比较激进地来干这事。 但是，FACK 如果在一个网络包会被 reordering 的网络里会有很大的问题。</p><h2 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h2><h3 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a><strong>TCP Vegas 拥塞控制算法</strong></h3><p>这个算法 1994 年被提出，它主要对 TCP Reno 做了些修改。这个算法通过对 RTT 的非常重的监控来计算一个基准 RTT。然后通过这个基准 RTT 来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加 cwnd 的大小。如果这个计算出来的 RTT 大于了 Timeout 后，那么，不等 ack 超时就直接重传。（Vegas 的核心思想是用 RTT 的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a href="http://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf" target="_blank" rel="noopener">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了 Vegas 和 New Reno 的对比：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5p96am2j30sg0fftd3.jpg" alt="img"></p><p>关于这个算法实现，你可以参看 Linux 源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h" target="_blank" rel="noopener">/net/ipv4/tcp_vegas.h</a>， <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c" target="_blank" rel="noopener">/net/ipv4/tcp_vegas.c</a></p><h3 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h3><p>这个算法来自<a href="http://tools.ietf.org/html/rfc3649" target="_blank" rel="noopener">RFC 3649</a>（<a href="http://en.wikipedia.org/wiki/HSTCP" target="_blank" rel="noopener">Wikipedia 词条</a>）。其对最基础的算法进行了更改，他使得 Congestion Window 涨得快，减得慢。其中：</p><ul><li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li><li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li></ul><p>注：α(cwnd)和 β(cwnd)都是函数，如果你要让他们和标准的 TCP 一样，那么让 α(cwnd)=1，β(cwnd)=0.5 就可以了。 对于 α(cwnd)和 β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看 Linux 源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c" target="_blank" rel="noopener">/net/ipv4/tcp_highspeed.c</a></p><h3 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h3><p>2004 年，产内出 BIC 算法。现在你还可以查得到相关的新闻《Google：<a href="https://www.google.com/search?lr=lang_zh-CN|lang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr%3Alang_1zh-CN|lang_1zh-TW&q=美科学家研发BIC-TCP协议+速度是DSL六千倍&oq=美科学家研发BIC-TCP协议+速度是DSL六千倍" target="_blank" rel="noopener">美科学家研发 BIC-TCP 协议 速度是 DSL 六千倍</a>》 BIC 全称<a href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic" target="_blank" rel="noopener">Binary Increase Congestion control</a>，在 Linux 2.6.8 中是默认拥塞控制算法。BIC 的发明者发这么多的拥塞控制算法都在努力找一个合适的 cwnd – Congestion Window，而且 BIC-TCP 的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以 BIC 这个算法主要用的是 Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看 Linux 源码：<a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c" target="_blank" rel="noopener">/net/ipv4/tcp_bic.c</a></p><h3 id="TCP-WestWood-算法"><a href="#TCP-WestWood-算法" class="headerlink" title="TCP WestWood 算法"></a>TCP WestWood 算法</h3><p>westwood 采用和 Reno 相同的慢启动算法、拥塞避免算法。westwood 的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个 RTT 时间，会测量一次带宽，测量带宽的公式很简单，就是这段 RTT 内成功被 ack 了多少字节。因为，这个带宽和用 RTT 计算 RTO 一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送 X 个字节，而 RTT 是一个数据发出去后确认需要的时候，所以，X _ RTT 应该是我们缓冲区大小。所以，在这个算法中，ssthresh 的值就是 est_BD _ min-RTT(最小的 RTT 值)，如果丢包是 Duplicated ACKs 引起的，那么如果 cwnd &gt; ssthresh，则 cwin = ssthresh。如果是 RTO 引起的，cwnd = 1，进入慢启动。 关于这个算法实现，你可以参看 Linux 源码： <a href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c" target="_blank" rel="noopener">/net/ipv4/tcp_westwood.c</a></p><h2 id="四次挥手优化——三次挥手"><a href="#四次挥手优化——三次挥手" class="headerlink" title="四次挥手优化——三次挥手"></a>四次挥手优化——三次挥手</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#三次挥手 -- 客户端发起断开连接请求    客户端序列号为 3495051432</span><br><span class="line">#fin  seq = 3495051432</span><br><span class="line">00:05:30.157325 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [F.], seq 3495051432, ack 485492629, win 115, options [nop,nop,TS val 1695781058 ecr 629900122], length 0</span><br><span class="line">#三次挥手 -- 服务器端发起断开连接请求</span><br><span class="line">#ack = 3495051432 + 1 = 3495051433  注意 因为服务器端也没有东西要发送了，所以也要关闭连接，因此同时发送了fin信号，seq = 485492629</span><br><span class="line">00:05:30.157562 IP VM_0_6_centos.webcache &gt; 221.122.42.100.58706: Flags [F.], seq 485492629, ack 3495051433, win 235, options [nop,nop,TS val 629900162 ecr 1695781058], length 0</span><br><span class="line">#三次挥手 -- 客户端应答</span><br><span class="line">#ack = 485492629 + 1 = 485492630</span><br><span class="line">00:05:30.196710 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [.], ack 485492630, win 115, options [nop,nop,TS val 1695781097 ecr 629900162], length 0</span><br></pre></td></tr></table></figure><p>这是因为关闭连接有两种方式，当一方关闭连接，另外一方没有数据发送时，马上关闭连接，也就将第二步的 ack 与第三步的 fin 合并为一步了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;TCP&quot;&gt;&lt;a href=&quot;#TCP&quot; class=&quot;headerlink&quot; title=&quot;TCP&quot;&gt;&lt;/a&gt;TCP&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment）&lt;/li&gt;
&lt;li&gt;IP 在第三层——Network 层（在第三层上的数据叫 Packet）&lt;/li&gt;
&lt;li&gt;ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。&lt;/p&gt;
    
    </summary>
    
      <category term="浏览器" scheme="http://yoursite.com/categories/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
    
      <category term="浏览器" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="TCP/IP" scheme="http://yoursite.com/tags/TCP-IP/"/>
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="http://yoursite.com/2019/08/05/promise/"/>
    <id>http://yoursite.com/2019/08/05/promise/</id>
    <published>2019-08-05T11:44:02.000Z</published>
    <updated>2019-11-10T14:37:39.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h1><h2 id="创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）"><a href="#创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）" class="headerlink" title="创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）"></a>创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）</h2><p>方法一：</p><p>创建一个用 Promise 把 XHR 处理包装起来的名为 <code>getURL</code> 的函数。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line"><span class="keyword">var</span> URL = <span class="string">"http://httpbin.org/get"</span>;</span><br><span class="line">getURL(URL)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajaxPromise</span>(<span class="params">url, data, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">      url: url,</span><br><span class="line">      type: data == <span class="literal">null</span> ? <span class="string">"GET"</span> : <span class="string">"POST"</span>,</span><br><span class="line">      dataType: <span class="string">"json"</span>,</span><br><span class="line">      data: data == <span class="literal">null</span> ? <span class="string">""</span> : <span class="built_in">JSON</span>.stringify(data),</span><br><span class="line">      <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">      contentType: <span class="string">"application/json"</span>,</span><br><span class="line">      success: <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">        callback(res);</span><br><span class="line">        resolve();</span><br><span class="line">      &#125;,</span><br><span class="line">      error: <span class="function"><span class="keyword">function</span>(<span class="params">XMLHttpRequest, textStatus, errorThrown</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (XMLHttpRequest.status == <span class="string">"401"</span>) &#123;</span><br><span class="line">          <span class="built_in">window</span>.parent.location = <span class="string">"/enterprise/enterprise_login.html"</span>;</span><br><span class="line">          self.location = <span class="string">"/enterprise/enterprise_login.html"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          alert(XMLHttpRequest.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        reject();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ajaxPromise(<span class="string">'/prefix/entity1/action1'</span>,<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">     <span class="comment">//do something on response</span></span><br><span class="line">&#125;).then(</span><br><span class="line">     ajaxPromise(<span class="string">'/prefix/entity2/action2'</span>, someData, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">          <span class="comment">//do something on response</span></span><br><span class="line">     &#125;</span><br><span class="line">).then(</span><br><span class="line">     initVue() ;</span><br><span class="line">).then(</span><br><span class="line">     <span class="comment">//do  something else</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="promise-的实现和原理（用-js）"><a href="#promise-的实现和原理（用-js）" class="headerlink" title="promise 的实现和原理（用 js）"></a>promise 的实现和原理（用 js）</h2><p><a href="https://juejin.im/post/5b83cb5ae51d4538cc3ec354" target="_blank" rel="noopener">promise 实现原理</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断变量否为function</span></span><br><span class="line"><span class="keyword">const</span> isFunction = <span class="function"><span class="params">variable</span> =&gt;</span> <span class="keyword">typeof</span> variable === <span class="string">"function"</span>;</span><br><span class="line"><span class="comment">// 定义Promise的三种状态常量</span></span><br><span class="line"><span class="keyword">const</span> PENDING = <span class="string">"PENDING"</span>;</span><br><span class="line"><span class="keyword">const</span> FULFILLED = <span class="string">"FULFILLED"</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">"REJECTED"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(handle) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(handle)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"MyPromise must accept a function as a parameter"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._status = PENDING;</span><br><span class="line">    <span class="comment">// 添加状态</span></span><br><span class="line">    <span class="keyword">this</span>._value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">// 添加成功回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._fulfilledQueues = [];</span><br><span class="line">    <span class="comment">// 添加失败回调函数队列</span></span><br><span class="line">    <span class="keyword">this</span>._rejectedQueues = [];</span><br><span class="line">    <span class="comment">// 执行handle</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      handle(<span class="keyword">this</span>._resolve.bind(<span class="keyword">this</span>), <span class="keyword">this</span>._reject.bind(<span class="keyword">this</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="keyword">this</span>._reject(err);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加resovle时执行的函数</span></span><br><span class="line">  _resolve(val) &#123;</span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">      <span class="comment">// 依次执行成功队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runFulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._fulfilledQueues.shift())) &#123;</span><br><span class="line">          cb(value);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">      <span class="keyword">const</span> runRejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> cb;</span><br><span class="line">        <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">          cb(error);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">/* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后,</span></span><br><span class="line"><span class="comment">          当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */</span></span><br><span class="line">      <span class="keyword">if</span> (val <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">        val.then(</span><br><span class="line">          value =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = value;</span><br><span class="line">            <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">            runFulfilled(value);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="keyword">this</span>._value = err;</span><br><span class="line">            <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">            runRejected(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._value = val;</span><br><span class="line">        <span class="keyword">this</span>._status = FULFILLED;</span><br><span class="line">        runFulfilled(val);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加reject时执行的函数</span></span><br><span class="line">  _reject(err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._status !== PENDING) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 依次执行失败队列中的函数，并清空队列</span></span><br><span class="line">    <span class="keyword">const</span> run = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>._status = REJECTED;</span><br><span class="line">      <span class="keyword">this</span>._value = err;</span><br><span class="line">      <span class="keyword">let</span> cb;</span><br><span class="line">      <span class="keyword">while</span> ((cb = <span class="keyword">this</span>._rejectedQueues.shift())) &#123;</span><br><span class="line">        cb(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 为了支持同步的Promise，这里采用异步调用</span></span><br><span class="line">    setTimeout(run, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加then方法</span></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; _value, _status &#125; = <span class="keyword">this</span>;</span><br><span class="line">    <span class="comment">// 返回一个新的Promise对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">onFulfilledNext, onRejectedNext</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 封装一个成功时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> fulfilled = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onFulfilled)) &#123;</span><br><span class="line">            onFulfilledNext(value);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onFulfilled(value);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="comment">// 封装一个失败时执行的函数</span></span><br><span class="line">      <span class="keyword">let</span> rejected = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (!isFunction(onRejected)) &#123;</span><br><span class="line">            onRejectedNext(error);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> res = onRejected(error);</span><br><span class="line">            <span class="keyword">if</span> (res <span class="keyword">instanceof</span> MyPromise) &#123;</span><br><span class="line">              <span class="comment">// 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调</span></span><br><span class="line">              res.then(onFulfilledNext, onRejectedNext);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数</span></span><br><span class="line">              onFulfilledNext(res);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">          <span class="comment">// 如果函数执行出错，新的Promise对象的状态为失败</span></span><br><span class="line">          onRejectedNext(err);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      <span class="keyword">switch</span> (_status) &#123;</span><br><span class="line">        <span class="comment">// 当状态为pending时，将then方法回调函数加入执行队列等待执行</span></span><br><span class="line">        <span class="keyword">case</span> PENDING:</span><br><span class="line">          <span class="keyword">this</span>._fulfilledQueues.push(fulfilled);</span><br><span class="line">          <span class="keyword">this</span>._rejectedQueues.push(rejected);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 当状态已经改变时，立即执行对应的回调函数</span></span><br><span class="line">        <span class="keyword">case</span> FULFILLED:</span><br><span class="line">          fulfilled(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> REJECTED:</span><br><span class="line">          rejected(_value);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加catch方法</span></span><br><span class="line">  <span class="keyword">catch</span>(onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(<span class="literal">undefined</span>, onRejected);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态resolve方法</span></span><br><span class="line">  <span class="keyword">static</span> resolve(value) &#123;</span><br><span class="line">    <span class="comment">// 如果参数是MyPromise实例，直接返回这个实例</span></span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> MyPromise) <span class="keyword">return</span> value;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态reject方法</span></span><br><span class="line">  <span class="keyword">static</span> reject(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(value));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态all方法</span></span><br><span class="line">  <span class="keyword">static</span> all(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 返回值的集合</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">let</span> values = [];</span><br><span class="line">      <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> [i, p] <span class="keyword">of</span> list.entries()) &#123;</span><br><span class="line">        <span class="comment">// 数组参数如果不是MyPromise实例，先调用MyPromise.resolve</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            values[i] = res;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="comment">// 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled</span></span><br><span class="line">            <span class="keyword">if</span> (count === list.length) resolve(values);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            <span class="comment">// 有一个被rejected时返回的MyPromise状态就变成rejected</span></span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加静态race方法</span></span><br><span class="line">  <span class="keyword">static</span> race(list) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MyPromise(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> p <span class="keyword">of</span> list) &#123;</span><br><span class="line">        <span class="comment">// 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变</span></span><br><span class="line">        <span class="keyword">this</span>.resolve(p).then(</span><br><span class="line">          res =&gt; &#123;</span><br><span class="line">            resolve(res);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">finally</span>(cb) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">      value =&gt; MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> value),</span><br><span class="line">      reason =&gt;</span><br><span class="line">        MyPromise.resolve(cb()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> reason;</span><br><span class="line">        &#125;)</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="promise-race-和超时处理"><a href="#promise-race-和超时处理" class="headerlink" title="promise.race 和超时处理"></a>promise.race 和超时处理</h2><p>函数 <code>timeoutPromise(比较对象promise, ms)</code> 接收两个参数，第一个是需要使用超时机制的 promise 对象，第二个参数是超时时间，它返回一个由 <code>Promise.race</code> 创建的相互竞争的 promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Operation timed out after "</span> + ms + <span class="string">" ms"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Operation timed out after "</span> + ms + <span class="string">" ms"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line"><span class="keyword">var</span> taskPromise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 随便一些什么处理</span></span><br><span class="line">  <span class="keyword">var</span> delay = <span class="built_in">Math</span>.random() * <span class="number">2000</span>;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    resolve(delay + <span class="string">"ms"</span>);</span><br><span class="line">  &#125;, delay);</span><br><span class="line">&#125;);</span><br><span class="line">timeoutPromise(taskPromise, <span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"taskPromise在规定时间内结束 : "</span> + value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"发生超时"</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>虽然在发生超时的时候抛出了异常，但是这样的话我们就不能区分这个异常到底是<em>普通的错误</em>还是<em>超时错误</em>了。</p><p>为了能区分这个 <code>Error</code> 对象的类型，我们再来定义一个<code>Error</code> 对象的子类 <code>TimeoutError</code>。</p><ul><li><h4 id="定制-Error-对象"><a href="#定制-Error-对象" class="headerlink" title="定制 Error 对象"></a>定制 Error 对象</h4></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TimeoutError.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(source).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">      target,</span><br><span class="line">      propName,</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propName)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> superInstance = <span class="built_in">Error</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  copyOwnFrom(<span class="keyword">this</span>, superInstance);</span><br><span class="line">&#125;</span><br><span class="line">TimeoutError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line">TimeoutError.prototype.constructor = TimeoutError;</span><br></pre></td></tr></table></figure><p>我们定义了 <code>TimeoutError</code> 类和构造函数，这个类继承了 Error 的 prototype。</p><p>它的使用方法和普通的 <code>Error</code> 对象一样，使用 <code>throw</code> 语句即可，如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> TimeoutError(<span class="string">"timeout"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(error <span class="keyword">instanceof</span> TimeoutError); <span class="comment">// true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4></li></ul><p>取消 XHR 操作本身的话并不难，只需要调用 <code>XMLHttpRequest</code> 对象的 <code>abort()</code> 方法就可以了。</p><p>为了能在外部调用 <code>abort()</code> 方法，我们先对之前本节出现的 <a href="http://liubin.org/promises-book/#xhr-promise.js" target="_blank" rel="noopener"><code>getURL</code></a> 进行简单的扩展，<code>cancelableXHR</code> 方法除了返回一个包装了 XHR 的 promise 对象之外，还返回了一个用于取消该 XHR 请求的<code>abort</code>方法。</p><p>大体的流程就像下面这样。</p><ol><li>通过 <code>cancelableXHR</code> 方法取得包装了 XHR 的 promise 对象和取消该 XHR 请求的方法</li><li>在 <code>timeoutPromise</code> 方法中通过 <code>Promise.race</code> 让 XHR 的包装 promise 和超时用 promise 进行竞争。<ul><li>XHR 在超时前返回结果的话<ol><li>和正常的 promise 一样，通过 <code>then</code> 返回请求结果</li></ol></li><li>发生超时的时候<ol><li>抛出 <code>throw TimeoutError</code> 异常并被 <code>catch</code></li><li>catch 的错误对象如果是 <code>TimeoutError</code> 类型的话，则调用 <code>abort</code> 方法取消 XHR 请求</li></ol></li></ul></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyOwnFrom</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyNames(source).forEach(<span class="function"><span class="keyword">function</span>(<span class="params">propName</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.defineProperty(</span><br><span class="line">      target,</span><br><span class="line">      propName,</span><br><span class="line">      <span class="built_in">Object</span>.getOwnPropertyDescriptor(source, propName)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TimeoutError</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> superInstance = <span class="built_in">Error</span>.apply(<span class="literal">null</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  copyOwnFrom(<span class="keyword">this</span>, superInstance);</span><br><span class="line">&#125;</span><br><span class="line">TimeoutError.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Error</span>.prototype);</span><br><span class="line">TimeoutError.prototype.constructor = TimeoutError;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayPromise</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeoutPromise</span>(<span class="params">promise, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timeout = delayPromise(ms).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(</span><br><span class="line">      <span class="keyword">new</span> TimeoutError(<span class="string">"Operation timed out after "</span> + ms + <span class="string">" ms"</span>)</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.race([promise, timeout]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelableXHR</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onabort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"abort this request"</span>));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> abort = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果request还没有结束的话就执行abort</span></span><br><span class="line">    <span class="comment">// https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest</span></span><br><span class="line">    <span class="keyword">if</span> (req.readyState !== XMLHttpRequest.UNSENT) &#123;</span><br><span class="line">      req.abort();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    promise: promise,</span><br><span class="line">    abort: abort</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> object = cancelableXHR(<span class="string">"http://httpbin.org/get"</span>);</span><br><span class="line"><span class="comment">// main</span></span><br><span class="line">timeoutPromise(object.promise, <span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Contents"</span>, contents);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (error <span class="keyword">instanceof</span> TimeoutError) &#123;</span><br><span class="line">      object.abort();</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(error);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"XHR Error :"</span>, error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="promise-all-和顺序处理"><a href="#promise-all-和顺序处理" class="headerlink" title="promise.all 和顺序处理"></a>promise.all 和顺序处理</h2><ul><li>在 <a href="http://liubin.org/promises-book/#multiple-xhr.js" target="_blank" rel="noopener">重复使用多个 then 的方法</a> 中的实现方法如下。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [] 用来保存初始化的值</span></span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">return</span> request</span><br><span class="line">    .comment()</span><br><span class="line">    .then(pushValue)</span><br><span class="line">    .then(request.people)</span><br><span class="line">    .then(pushValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>使用这种写法的话那么随着 <code>request</code> 中元素数量的增加，我们也需要不断增加对 <code>then</code> 方法的调用</p><ul><li>将处理内容统一放到数组里，再配合 for 循环进行处理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [] 用来保存初始化值</span></span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="comment">// 返回promise对象的函数的数组</span></span><br><span class="line">  <span class="keyword">var</span> tasks = [request.comment, request.people];</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="built_in">Promise</span>.resolve();</span><br><span class="line">  <span class="comment">// 开始的地方</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tasks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> task = tasks[i];</span><br><span class="line">    promise = promise.then(task).then(pushValue);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>promise = promise.then(task).then(pushValue);</code> 的代码就是通过不断对 promise 进行处理，不断的覆盖 <code>promise</code> 变量的值，以达到对 promise 对象的累积处理效果。</p><p>但是这种方法需要 <code>promise</code> 这个临时变量，从代码质量上来说显得不那么简洁。</p><ul><li>Promise chain 和 reduce</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">var</span> tasks = [request.comment, request.people];</span><br><span class="line">  <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(task).then(pushValue);</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p><code>Array.prototype.reduce</code> 的第二个参数用来设置盛放计算结果的初始值。在这个例子中， <code>Promise.resolve()</code> 会赋值给 <code>promise</code>，此时的 <code>task</code> 为 <code>request.comment</code> 。</p><p>在 reduce 中第一个参数中被 <code>return</code> 的值，则会被赋值为下次循环时的 <code>promise</code> 。也就是说，通过返回由 <code>then</code> 创建的新的 promise 对象，就实现了和 for 循环类似的 <a href="http://liubin.org/promises-book/#promise-chain" target="_blank" rel="noopener">Promise chain</a> 了。</p><p>使用 reduce 和 for 循环不同的地方是 reduce 不再需要临时变量 <code>promise</code> 了，因此也不用编写 <code>promise = promise.then(task).then(pushValue);</code> 这样冗长的代码了，这是非常大的进步。</p><ul><li>定义进行顺序处理的函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(task).then(pushValue);</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，和 <code>Promise.all</code> 等不同，这个函数接收的参数是一个函数的数组。为什么传给这个函数的不是一个 promise 对象的数组呢？这是因为 promise 对象创建的时候，XHR 已经开始执行了，因此再对这些 promise 对象进行顺序处理的话就不能正常工作了。</p><p>重写上例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequenceTasks</span>(<span class="params">tasks</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">recordValue</span>(<span class="params">results, value</span>) </span>&#123;</span><br><span class="line">    results.push(value);</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> pushValue = recordValue.bind(<span class="literal">null</span>, []);</span><br><span class="line">  <span class="keyword">return</span> tasks.reduce(<span class="function"><span class="keyword">function</span>(<span class="params">promise, task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> promise.then(task).then(pushValue);</span><br><span class="line">  &#125;, <span class="built_in">Promise</span>.resolve());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getURL</span>(<span class="params">URL</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">"GET"</span>, URL, <span class="literal">true</span>);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(req.responseText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.onerror = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req.statusText));</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> request = &#123;</span><br><span class="line">  comment: <span class="function"><span class="keyword">function</span> <span class="title">getComment</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/comment.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;,</span><br><span class="line">  people: <span class="function"><span class="keyword">function</span> <span class="title">getPeople</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getURL(<span class="string">"http://azu.github.io/promises-book/json/people.json"</span>).then(</span><br><span class="line">      <span class="built_in">JSON</span>.parse</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sequenceTasks([request.comment, request.people]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行示例</span></span><br><span class="line">main()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="如何实现-Promise-all"><a href="#如何实现-Promise-all" class="headerlink" title="如何实现 Promise.all ?"></a>如何实现 Promise.all ?</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> result = [];</span><br><span class="line">    <span class="keyword">if</span> (promises.length === <span class="number">0</span>) &#123;</span><br><span class="line">      resolve(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processValue</span>(<span class="params">i, data</span>) </span>&#123;</span><br><span class="line">        result[i] = data;</span><br><span class="line">        <span class="keyword">if</span> (++index === promises.length) &#123;</span><br><span class="line">          resolve(result);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">        <span class="comment">//promises[i] 可能是普通值</span></span><br><span class="line">        <span class="built_in">Promise</span>.resolve(promises[i]).then(</span><br><span class="line">          data =&gt; &#123;</span><br><span class="line">            processValue(i, data);</span><br><span class="line">          &#125;,</span><br><span class="line">          err =&gt; &#123;</span><br><span class="line">            reject(err);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="如何实现-Promise-finally"><a href="#如何实现-Promise-finally" class="headerlink" title="如何实现 Promise.finally ?"></a>如何实现 Promise.finally ?</h2><p>不管成功还是失败，都会走到 finally 中,并且 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.prototype.finally = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(callback()).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> err;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li><p>输出结果：success</p><p>解题思路：Promise 状态一旦改变，无法在发生变更。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">"success"</span>);</span><br><span class="line">    reject(<span class="string">"error"</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(</span><br><span class="line">  res =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;,</span><br><span class="line">  err =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="2"><li><p>输出结果：1</p><p>解题思路：Promise 的 then 方法的参数期望是函数，传入非函数则会发生值穿透。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="number">2</span>)</span><br><span class="line">  .then(<span class="built_in">Promise</span>.resolve(<span class="number">3</span>))</span><br><span class="line">  .then(<span class="built_in">console</span>.log);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>结果是：3 4 6 8 7 5 2 1</p><p>优先级关系如下：<code>process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate</code></p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">setImmediate(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">  resolve();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">7</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>V8 实现中，两个队列各包含不同的任务：</p><p><code>macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI rendering</code><br><code>microtasks: process.nextTick, Promises, Object.observe, MutationObserver</code></p><ol start="4"><li><p>实现一个简单的 Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> status = <span class="string">"pending"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">successNotify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status = <span class="string">"fulfilled"</span>; <span class="comment">//状态变为fulfilled</span></span><br><span class="line">    toDoThen.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">failNotify</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    status = <span class="string">"rejected"</span>; <span class="comment">//状态变为rejected</span></span><br><span class="line">    toDoThen.apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行回调</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">toDoThen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 保证回调是异步执行的</span></span><br><span class="line">      <span class="keyword">if</span> (status === <span class="string">"fulfilled"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; successArray.length; i++) &#123;</span><br><span class="line">          successArray[i].apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行then里面的回掉函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status === <span class="string">"rejected"</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; failArray.length; i++) &#123;</span><br><span class="line">          failArray[i].apply(<span class="literal">undefined</span>, <span class="built_in">arguments</span>); <span class="comment">//执行then里面的回掉函数</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> successArray = [];</span><br><span class="line">  <span class="keyword">var</span> failArray = [];</span><br><span class="line">  fn.call(<span class="literal">undefined</span>, successNotify, failNotify);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    then: <span class="function"><span class="keyword">function</span>(<span class="params">successFn, failFn</span>) </span>&#123;</span><br><span class="line">      successArray.push(successFn);</span><br><span class="line">      failArray.push(failFn);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>; <span class="comment">// 此处应该返回一个Promise</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>解题思路：Promise 中的 resolve 和 reject 用于改变 Promise 的状态和传参，then 中的参数必须是作为回调执行的函数。因此，当 Promise 改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;promise&quot;&gt;&lt;a href=&quot;#promise&quot; class=&quot;headerlink&quot; title=&quot;promise&quot;&gt;&lt;/a&gt;promise&lt;/h1&gt;&lt;h2 id=&quot;创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）&quot;&gt;&lt;a href=&quot;#创建-XHR-的-promise-对象（Promise-包装-XHR-ajax-处理）&quot; class=&quot;headerlink&quot; title=&quot;创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）&quot;&gt;&lt;/a&gt;创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）&lt;/h2&gt;&lt;p&gt;方法一：&lt;/p&gt;
&lt;p&gt;创建一个用 Promise 把 XHR 处理包装起来的名为 &lt;code&gt;getURL&lt;/code&gt; 的函数。&lt;/p&gt;
    
    </summary>
    
      <category term="ES6" scheme="http://yoursite.com/categories/ES6/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>JS引擎执行机制</title>
    <link href="http://yoursite.com/2019/07/30/JS%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/30/JS引擎执行机制/</id>
    <published>2019-07-30T05:13:29.000Z</published>
    <updated>2019-11-10T14:37:39.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-引擎执行机制"><a href="#JS-引擎执行机制" class="headerlink" title="JS 引擎执行机制"></a>JS 引擎执行机制</h1><p><strong>(1) JS 是单线程语言</strong></p><p><strong>(2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop</strong></p><a id="more"></a><h2 id="JS-为什么是单线程的-为什么需要异步-单线程又是如何实现异步的呢"><a href="#JS-为什么是单线程的-为什么需要异步-单线程又是如何实现异步的呢" class="headerlink" title="JS 为什么是单线程的? 为什么需要异步? 单线程又是如何实现异步的呢?"></a>JS 为什么是单线程的? 为什么需要异步? 单线程又是如何实现异步的呢?</h2><ul><li><p>JS 最初被设计用在浏览器中,那么想象一下,如果浏览器中的 JS 是多线程的。</p><p>场景描述:</p><p>那么现在有 2 个线程,process1 process2,由于是多线程的 JS,所以他们对同一个 dom,同时进行操作。process1 删除了该 dom,而 process2 编辑了该 dom,同时下达 2 个矛盾的命令,浏览器究竟该如何执行呢?</p></li><li><p>JS 为什么需要异步?</p><p>如果 JS 中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。<br>对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验</p></li><li><p>JS 单线程又是如何实现异步的呢?</p><p><strong>是通过的事件循环(event loop),理解了 event loop 机制,就理解了 JS 的执行机制</strong></p></li></ul><h2 id="JS-中的-event-loop"><a href="#JS-中的-event-loop" class="headerlink" title="JS 中的 event loop"></a>JS 中的 event loop</h2><h3 id="event-loop（1）"><a href="#event-loop（1）" class="headerlink" title="event loop（1）"></a>event loop（1）</h3><p>JS 里的一种分类方式,就是将任务分为: 同步任务和异步任务</p><p>JS 的执行机制是：</p><ul><li>首先判断 JS 是同步还是异步,同步就进入主线程,异步就进入 event table</li><li>异步任务在 event table 中注册函数,当满足触发条件后,被推入 event queue</li><li>同步任务进入主线程后一直执行,直到主线程空闲时,才会去 event queue 中查看是否有可执行的异步任务,如果有就推入主线程中</li></ul><h3 id="event-loop（2）"><a href="#event-loop（2）" class="headerlink" title="event loop（2）"></a>event loop（2）</h3><p>准确的划分方式是:</p><ul><li>macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval</li><li>micro-task(微任务)：Promise.then，process.nextTick</li></ul><p>JS 的执行机制是：</p><ul><li>执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里</li><li>当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完</li></ul><p><strong>重复以上 2 步骤,结合 event loop(1) event loop(2) ,就是更为准确的 JS 执行机制了。</strong></p><h2 id="理解-JavaScript-的-async-await"><a href="#理解-JavaScript-的-async-await" class="headerlink" title="理解 JavaScript 的 async/await"></a>理解 JavaScript 的 async/await</h2><h3 id="async-和-await-在干什么"><a href="#async-和-await-在干什么" class="headerlink" title="async 和 await 在干什么"></a>async 和 await 在干什么</h3><p>先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p><ul><li>async 函数返回的是一个 <strong>Promise</strong> 对象。<ul><li>如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</li><li>如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</li><li>Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</li></ul></li><li>await 等待的是一个表达式。<ul><li>这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</li><li>await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。</li></ul></li><li>await 等到了要等的，然后呢？<ul><li><code>await</code> 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。</li><li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li><li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li></ul></li></ul><p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p><h3 id="await-等待的表达式详解"><a href="#await-等待的表达式详解" class="headerlink" title="await 等待的表达式详解"></a>await 等待的表达式详解</h3><p><strong>await 等的是右侧「表达式」的结果</strong></p><p>await 是从<strong>右向左执行的</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line">async1();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br></pre></td></tr></table></figure><p>先执行 async2 后，发现有 await 关键字，于是让出线程，阻塞代码</p><p>右侧表达式的结果:</p><ul><li>如果不是 promise , await 会阻塞后面的代码，先执行 async 外面的同步代码，同步代码执行完，再回到 async 内部，把这个非 promise 的东西，作为 await 表达式的结果</li><li>如果它等到的是一个 promise 对象，await 也会暂停 async 后面的代码，先执行 async 外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。</li></ul><h3 id="async-await-的优势在于处理-then-链"><a href="#async-await-的优势在于处理-then-链" class="headerlink" title="async/await 的优势在于处理 then 链"></a>async/await 的优势在于处理 then 链</h3><p>单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。</p><ul><li>Async/await 代码清晰很多，几乎跟同步代码一样。</li><li>Promise 方案的死穴—— 链式调用参数传递太麻烦</li></ul><h2 id="async-await-和-promise-的执行顺序"><a href="#async-await-和-promise-的执行顺序" class="headerlink" title="async/await 和 promise 的执行顺序"></a>async/await 和 promise 的执行顺序</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 start"</span>);</span><br><span class="line">  <span class="keyword">await</span> async2();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async1 end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"async2"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"setTimeout"</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line">async1();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script end"</span>);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">script start</span><br><span class="line">async1 start</span><br><span class="line">async2</span><br><span class="line">promise1</span><br><span class="line">script end</span><br><span class="line">promise2</span><br><span class="line">async1 end</span><br><span class="line">setTimeout</span><br></pre></td></tr></table></figure><p>宏任务和微任务的慨念，在我脑海中宏任务和为微任务如图所示</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izm5nu3ij30f204qq2z.jpg" alt="img"></p><p>也就是「宏任务」、「微任务」都是队列。</p><p>一段代码执行时，会先执行宏任务中的同步代码，</p><ul><li>如果执行中遇到 setTimeout 之类宏任务，那么就把这个 setTimeout 内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。</li><li>如果执行中遇到 promise.then()之类的微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行所有的微任务 1、2、3</li></ul><h3 id="例子分析执行顺序"><a href="#例子分析执行顺序" class="headerlink" title="例子分析执行顺序"></a>例子分析执行顺序</h3><h4 id="直接打印同步代码-console-log-‘script-start’"><a href="#直接打印同步代码-console-log-‘script-start’" class="headerlink" title="直接打印同步代码 console.log(‘script start’)"></a>直接打印同步代码 console.log(‘script start’)</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先是2个函数声明，虽然有async关键字，但不是调用我们就不看。然后首先是打印同步代码</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"script start"</span>);</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izmivm1ij30m801x745.jpg" alt="img"></p><h4 id="将-setTimeout-放入宏任务队列"><a href="#将-setTimeout-放入宏任务队列" class="headerlink" title="将 setTimeout 放入宏任务队列"></a>将 setTimeout 放入宏任务队列</h4><p>默认所包裹的代码，其实可以理解为是第一个宏任务，所以这里是宏任务 2</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izmvovzjj30m8034dft.jpg" alt="img"></p><h4 id="调用-async1，打印-同步代码-console-log-‘async1-start’"><a href="#调用-async1，打印-同步代码-console-log-‘async1-start’" class="headerlink" title="调用 async1，打印 同步代码 console.log( ‘async1 start’ )"></a>调用 async1，打印 同步代码 console.log( ‘async1 start’ )</h4><p>我们说过看到带有 async 关键字的函数，不用害怕，它的仅仅是把 return 值包装成了 promise，其他并没有什么不同的地方。所以就很普通的打印 console.log( ‘async1 start’ )</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izn7f29dj30m803dt8o.jpg" alt="img"></p><h4 id="分析一下-await-async2"><a href="#分析一下-await-async2" class="headerlink" title="分析一下 await async2()"></a>分析一下 await async2()</h4><p>前文提过 await，1.它先计算出右侧的结果，2.然后看到 await 后，中断 async 函数</p><ul><li>先得到 await 右侧表达式的结果。执行 async2()，打印同步代码 console.log(‘async2’), 并且 return Promise.resolve(undefined)</li><li>await 后，中断 async 函数，先执行 async 外的同步代码</li></ul><p>目前就直接打印 console.log(‘async2’)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iznit5adj30m803edfu.jpg" alt="img"></p><h4 id="被阻塞后，要执行-async-之外的代码"><a href="#被阻塞后，要执行-async-之外的代码" class="headerlink" title="被阻塞后，要执行 async 之外的代码"></a>被阻塞后，要执行 async 之外的代码</h4><p>执行 new Promise()，Promise 构造函数是直接调用的同步代码，所以 console.log( ‘promise1’ )</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6iznu7o6jj30m803l74a.jpg" alt="img"></p><h4 id="代码运行到-promise-then"><a href="#代码运行到-promise-then" class="headerlink" title="代码运行到 promise.then()"></a>代码运行到 promise.then()</h4><p>代码运行到 promise.then()，发现这个是微任务，所以暂时不打印，只是推入当前宏任务的微任务队列中。</p><p><strong>注意：这里只是把 promise2 推入微任务队列，并没有执行。微任务会在当前宏任务的同步代码执行完毕，才会依次执行</strong></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izo8rmlkj30m803c0sp.jpg" alt="img"></p><h4 id="打印同步代码-console-log-‘script-end’"><a href="#打印同步代码-console-log-‘script-end’" class="headerlink" title="打印同步代码 console.log(‘script end’)"></a>打印同步代码 console.log(‘script end’)</h4><p>执行完这个同步代码后，「async 外的代码」终于走了一遍</p><p>下面该回到 await 表达式那里，执行 await Promise.resolve(undefined)了<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izoj1zjkj30m803c749.jpg" alt="img"></p><h4 id="回到-async-内部，执行-await-Promise-resolve-undefined"><a href="#回到-async-内部，执行-await-Promise-resolve-undefined" class="headerlink" title="回到 async 内部，执行 await Promise.resolve(undefined)"></a>回到 async 内部，执行 await Promise.resolve(undefined)</h4><p>这部分可能不太好理解，我尽量表达我的想法。</p><p>对于 await Promise.resolve(undefined) 如何理解呢？</p><p>根据 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">MDN</a> 原话我们知道</p><p><strong>如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</strong></p><p>在我们这个例子中，就是 Promise.resolve(undefined)正常处理完成，并返回其处理结果。那么 await async2()就算是执行结束了。</p><p>目前这个 promise 的状态是 fulfilled，等其处理结果返回就可以执行 await 下面的代码了。</p><p>那何时能拿到处理结果呢？</p><p>回忆平时我们用 promise，调用 resolve 后，何时能拿到处理结果？是不是需要在 then 的第一个参数里，才能拿到结果。</p><p>（调用 resolve 时，会把 then 的参数推入微任务队列，等主线程空闲时，再调用它）</p><p>所以这里的 await Promise.resolve() 就类似于</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="literal">undefined</span>).then(<span class="function"><span class="params">undefined</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>把 then 的第一个回调参数 (undefined) =&gt; {} 推入微任务队列。</p><p>then 执行完，才是 await async2()执行结束。</p><p>await async2()执行结束，才能继续执行后面的代码</p><p>如图</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6izovbp1aj30m8037q2y.jpg" alt="img"></p><h4 id="此时当前宏任务-1-都执行完了，要处理微任务队列里的代码。"><a href="#此时当前宏任务-1-都执行完了，要处理微任务队列里的代码。" class="headerlink" title="此时当前宏任务 1 都执行完了，要处理微任务队列里的代码。"></a>此时当前宏任务 1 都执行完了，要处理微任务队列里的代码。</h4><p>微任务队列，先进选出的原则，</p><ol><li>执行微任务 1，打印 promise2</li><li>执行微任务 2，没什么内容..</li></ol><p>但是微任务 2 执行后，await async2()语句结束，后面的代码不再被阻塞，所以打印</p><p>console.log(‘async1 end’)</p><h4 id="宏任务-1-执行完成后-执行宏任务-2"><a href="#宏任务-1-执行完成后-执行宏任务-2" class="headerlink" title="宏任务 1 执行完成后,执行宏任务 2"></a>宏任务 1 执行完成后,执行宏任务 2</h4><p>宏任务 2 的执行比较简单，就是打印</p><p>console.log(‘setTimeout’)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS-引擎执行机制&quot;&gt;&lt;a href=&quot;#JS-引擎执行机制&quot; class=&quot;headerlink&quot; title=&quot;JS 引擎执行机制&quot;&gt;&lt;/a&gt;JS 引擎执行机制&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;(1) JS 是单线程语言&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;(2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS事件机制</title>
    <link href="http://yoursite.com/2019/07/24/JS%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2019/07/24/JS事件机制/</id>
    <published>2019-07-24T07:22:00.000Z</published>
    <updated>2019-11-10T14:37:39.019Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-事件机制"><a href="#JS-事件机制" class="headerlink" title="JS 事件机制"></a>JS 事件机制</h1><h2 id="js-里一般的阻止事件默认行为怎么做？"><a href="#js-里一般的阻止事件默认行为怎么做？" class="headerlink" title="js 里一般的阻止事件默认行为怎么做？"></a>js 里一般的阻止事件默认行为怎么做？</h2><p>event.preventDefault()可以取消默认事件</p><p>event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。</p><a id="more"></a><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> event = event || <span class="built_in">window</span>.event; <span class="comment">//兼容IE</span></span><br><span class="line">  <span class="comment">//取消事件相关的默认行为</span></span><br><span class="line">  <span class="keyword">if</span> (event.preventDefault)</span><br><span class="line">    <span class="comment">//标准技术</span></span><br><span class="line">    event.preventDefault();</span><br><span class="line">  <span class="keyword">if</span> (event.returnValue)</span><br><span class="line">    <span class="comment">//兼容IE9之前的IE</span></span><br><span class="line">    event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//用于处理使用对象属性注册的处理程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡的机制是什么？下面代码输出顺序是什么？（2-gt-button-gt-1）"><a href="#冒泡的机制是什么？下面代码输出顺序是什么？（2-gt-button-gt-1）" class="headerlink" title="冒泡的机制是什么？下面代码输出顺序是什么？（2-&gt;button-&gt;1）"></a>冒泡的机制是什么？下面代码输出顺序是什么？（2-&gt;button-&gt;1）</h2><ul><li>触发顺序：button-&gt;1-&gt;2</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"button"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>触发顺序：2-&gt;button-&gt;1</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"button"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>触发顺序：2-&gt;button-&gt;1</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>aaa<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"1"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">false</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"div"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"2"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="javascript">  <span class="built_in">document</span>.getElementById(<span class="string">"button"</span>).addEventListener(</span></span><br><span class="line"><span class="actionscript">    <span class="string">"click"</span>,</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">"button"</span>);</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="actionscript">    <span class="literal">true</span></span></span><br><span class="line">  );</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS-事件机制&quot;&gt;&lt;a href=&quot;#JS-事件机制&quot; class=&quot;headerlink&quot; title=&quot;JS 事件机制&quot;&gt;&lt;/a&gt;JS 事件机制&lt;/h1&gt;&lt;h2 id=&quot;js-里一般的阻止事件默认行为怎么做？&quot;&gt;&lt;a href=&quot;#js-里一般的阻止事件默认行为怎么做？&quot; class=&quot;headerlink&quot; title=&quot;js 里一般的阻止事件默认行为怎么做？&quot;&gt;&lt;/a&gt;js 里一般的阻止事件默认行为怎么做？&lt;/h2&gt;&lt;p&gt;event.preventDefault()可以取消默认事件&lt;/p&gt;
&lt;p&gt;event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS静态作用域</title>
    <link href="http://yoursite.com/2019/07/11/JS%E9%9D%99%E6%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2019/07/11/JS静态作用域/</id>
    <published>2019-07-11T03:01:34.000Z</published>
    <updated>2019-11-10T14:37:39.020Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-静态作用域"><a href="#JS-静态作用域" class="headerlink" title="JS 静态作用域"></a>JS 静态作用域</h1><h2 id="js-的作用域和别的编程语言的作用域有什么区别"><a href="#js-的作用域和别的编程语言的作用域有什么区别" class="headerlink" title="js 的作用域和别的编程语言的作用域有什么区别"></a>js 的作用域和别的编程语言的作用域有什么区别</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域是指程序源代码中定义变量的区域。</p><p>作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。</p><p>JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。</p><a id="more"></a><h3 id="静态作用域与动态作用域"><a href="#静态作用域与动态作用域" class="headerlink" title="静态作用域与动态作用域"></a>静态作用域与动态作用域</h3><p>因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。</p><p>而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。</p><p>让我们认真看个例子就能明白之间的区别：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value = <span class="number">2</span>;</span><br><span class="line">  foo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果是 ???</span></span><br></pre></td></tr></table></figure><p>假设 JavaScript 采用静态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p><p>假设 JavaScript 采用动态作用域，让我们分析下执行过程：</p><p>执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。</p><p>前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。</p><p>最后，让我们看一个《JavaScript 权威指南》中的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f();</span><br><span class="line">&#125;</span><br><span class="line">checkscope();</span><br><span class="line"><span class="keyword">var</span> scope = <span class="string">"global scope"</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">"local scope"</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br><span class="line">checkscope()();</span><br></pre></td></tr></table></figure><p>猜猜两段代码各自的执行结果是多少？</p><p>这里直接告诉大家结果，两段代码都会打印：<code>local scope</code>。</p><p>原因也很简单，因为 JavaScript 采用的是词法作用域，函数的作用域基于函数创建的位置。</p><p>而引用《JavaScript 权威指南》的回答就是：</p><p>JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。</p><p><strong>bash 就是动态作用域</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JS-静态作用域&quot;&gt;&lt;a href=&quot;#JS-静态作用域&quot; class=&quot;headerlink&quot; title=&quot;JS 静态作用域&quot;&gt;&lt;/a&gt;JS 静态作用域&lt;/h1&gt;&lt;h2 id=&quot;js-的作用域和别的编程语言的作用域有什么区别&quot;&gt;&lt;a href=&quot;#js-的作用域和别的编程语言的作用域有什么区别&quot; class=&quot;headerlink&quot; title=&quot;js 的作用域和别的编程语言的作用域有什么区别&quot;&gt;&lt;/a&gt;js 的作用域和别的编程语言的作用域有什么区别&lt;/h2&gt;&lt;h3 id=&quot;作用域&quot;&gt;&lt;a href=&quot;#作用域&quot; class=&quot;headerlink&quot; title=&quot;作用域&quot;&gt;&lt;/a&gt;作用域&lt;/h3&gt;&lt;p&gt;作用域是指程序源代码中定义变量的区域。&lt;/p&gt;
&lt;p&gt;作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。&lt;/p&gt;
&lt;p&gt;JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。&lt;/p&gt;
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
