<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>01不是包子脸</title>
  
  <subtitle>小01的程序猿成长之路</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-06T07:28:21.028Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Linyi Li</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ES2020新特性</title>
    <link href="http://yoursite.com/2020/08/07/ES2020%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/07/ES2020新特性/</id>
    <published>2020-08-07T08:20:32.000Z</published>
    <updated>2020-09-06T07:28:21.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES2020-新特性"><a href="#ES2020-新特性" class="headerlink" title="ES2020 新特性"></a>ES2020 新特性</h1><h2 id="可选链操作符（Optional-Chaining）"><a href="#可选链操作符（Optional-Chaining）" class="headerlink" title="可选链操作符（Optional Chaining）"></a>可选链操作符（Optional Chaining）</h2><p><strong>可选链</strong> 可让我们在查询具有多个层级的对象时，不再需要进行冗余的各种前置校验。</p><p>日常开发中，当需要访问嵌套在对象内部好几层的属性时，可能就会得到臭名昭著的错误<code>Uncaught TypeError: Cannot read property...</code>，这种错误，让整段程序运行中止。</p><p><a href="https://camo.githubusercontent.com/5dd39f8b1a832b271dbb11613c66f525581d4187/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323032302f312f31382f313666623763356539633838343736363f773d36383226683d31333926663d706e6726733d3433353333" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/5dd39f8b1a832b271dbb11613c66f525581d4187/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323032302f312f31382f313666623763356539633838343736363f773d36383226683d31333926663d706e6726733d3433353333" alt="img"></a></p><p>于是，你就要修改你的代码来处理来处理属性链中每一个可能的 undefined 对象，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nestedProp = obj &amp;&amp; obj.first &amp;&amp; obj.first.second;</span><br></pre></td></tr></table></figure><p>在访问 obj.first.second 之前，要先确认 obj 和 obj.first 的值非 null(且不是 undefined)。</p><p>有了可选链式调用 ，可以大量简化类似繁琐的前置校验操作，而且更安全：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nestedProp = obj?.first?.second;</span><br></pre></td></tr></table></figure><p>如果 obj 或 obj.first 是 null/undefined，表达式将会短路计算直接返回 undefined。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33y8mlibj31640ac4p3.jpg" alt="image-20200825155157963"></p><h2 id="空位合并操作符（Nullish-coalescing-Operator）"><a href="#空位合并操作符（Nullish-coalescing-Operator）" class="headerlink" title="空位合并操作符（Nullish coalescing Operator）"></a>空位合并操作符（Nullish coalescing Operator）</h2><p>当我们查询某个属性时，经常会给没有该属性就设置一个默认的值，比如下面两种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = a ? a : b; <span class="comment">// 方式1</span></span><br><span class="line"><span class="keyword">let</span> c = a || b; <span class="comment">// 方式2</span></span><br></pre></td></tr></table></figure><p>这两种方式有个明显的弊端，它都会覆盖所有的假值，如(0, ‘’, false)，这些值可能是在某些情况下有效的输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = &#123;</span><br><span class="line">  profile: &#123;</span><br><span class="line">    name: <span class="string">"浪里行舟"</span>,</span><br><span class="line">    age: <span class="string">""</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(x.profile.age || <span class="number">18</span>); <span class="comment">//18</span></span><br></pre></td></tr></table></figure><p>上例中 age 的属性为空字符串，却被等同为假值，为了解决这个问题，ES2020 诞生了个新特性–空位合并操作符，用 ?? 表示。如果表达式在??的左侧运算符求值为 <strong>undefined 或 null</strong>，就返回其右侧默认值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c = a ?? b;</span><br><span class="line"><span class="comment">// 等价于let c = a !== undefined &amp;&amp; a !== null ? a : b;</span></span><br></pre></td></tr></table></figure><p>例如有以下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> x = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> y = x ?? <span class="number">500</span>;</span><br><span class="line"><span class="built_in">console</span>.log(y); <span class="comment">// 500</span></span><br><span class="line"><span class="keyword">const</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> m = n ?? <span class="number">9000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(m); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>空位合并操作符的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33ysp404j312808qh6v.jpg" alt="image-20200825155230523"></p><h2 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h2><p>我们知道 Promise.all 具有并发执行异步任务的能力。但它的最大问题就是<strong>如果参数中的任何一个 promise 为 reject 的话，则整个 Promise.all 调用会立即终止</strong>，并返回一个 reject 的新的 Promise 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</span><br><span class="line">  <span class="built_in">Promise</span>.reject(<span class="string">"error"</span>),</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.all(promises)</span><br><span class="line">  .then(<span class="function">(<span class="params">responses</span>) =&gt;</span> <span class="built_in">console</span>.log(responses))</span><br><span class="line">  .catch(<span class="function">(<span class="params">e</span>) =&gt;</span> <span class="built_in">console</span>.log(e)); <span class="comment">// "error"</span></span><br></pre></td></tr></table></figure><p>假如有这样的场景：一个页面有三个区域，分别对应三个独立的接口数据，使用 Promise.all 来并发请求三个接口，如果其中任意一个接口出现异常，状态是 reject,这会导致页面中该三个区域数据全都无法出来，这个状况我们是无法接受，Promise.allSettled 的出现就可以解决这个痛点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.allSettled([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(&#123; <span class="attr">code</span>: <span class="number">500</span>, <span class="attr">msg</span>: <span class="string">"服务异常"</span> &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;),</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(&#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">list</span>: [] &#125;),</span><br><span class="line">]).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">        0: &#123;status: "rejected", reason: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">        1: &#123;status: "fulfilled", value: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">        2: &#123;status: "fulfilled", value: &#123;…&#125;&#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">  <span class="comment">// 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染</span></span><br><span class="line">  RenderContent(</span><br><span class="line">    res.filter(<span class="function">(<span class="params">el</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> el.status !== <span class="string">"rejected"</span>;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Promise.allSettled 跟 Promise.all 类似, 其参数接受一个 Promise 的数组, 返回一个新的 Promise, <strong>唯一的不同在于, 它不会进行短路</strong>, 也就是说当 Promise 全部处理完成后,我们可以拿到每个 Promise 的状态, 而不管是否处理成功。</p><p>Promise.allSettled 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33zcn5fhj30xm07ewts.jpg" alt="image-20200825155303066"></p><h2 id="Dynamic-import"><a href="#Dynamic-import" class="headerlink" title="Dynamic import"></a>Dynamic import</h2><p>现在前端打包资源越来越大，前端应用初始化时根本不需要全部加载这些逻辑资源，为了首屏渲染速度更快，很多时候都是动态导入（按需加载）模块，比如懒加载图片等，这样可以帮助您提高应用程序的性能。</p><p>其中按需加载这些逻辑资源都一般会在某一个事件回调中去执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">el.onclick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">import</span>(<span class="string">"/modules/my-module.js"</span>)</span><br><span class="line">    .then(<span class="function">(<span class="params"><span class="built_in">module</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// Do something with the module.</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// load error;</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>import()可以用于 script 脚本中,<strong>import(module) 函数可以在任何地方调用。它返回一个解析为模块对象的 promise。</strong></p><p>这种使用方式也支持 await 关键字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">"/modules/my-module.js"</span>);</span><br></pre></td></tr></table></figure><p>通过动态导入代码，您可以减少应用程序加载所需的时间，并尽可能快地将某些内容返回给用户。</p><p>Dynamic import 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi340ezt3sj30zg09uavz.jpg" alt="image-20200825155404809"></p><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p>globalThis 是一个全新的标准方法用来获取全局 this 。之前开发者会通过如下的一些方法获取：</p><ul><li>全局变量 window：是一个经典的获取全局对象的方法。但是它在 Node.js 和 Web Workers 中并不能使用</li><li>全局变量 self：通常只在 Web Workers 和浏览器中生效。但是它不支持 Node.js。一些人会通过判断 self 是否存在识别代码是否运行在 Web Workers 和浏览器中</li><li>全局变量 global：只在 Node.js 中生效</li></ul><p>过去获取全局对象，可通过一个全局函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES10之前的解决方案</span></span><br><span class="line"><span class="keyword">const</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">"undefined"</span>) <span class="keyword">return</span> self;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span>) <span class="keyword">return</span> <span class="built_in">window</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">"undefined"</span>) <span class="keyword">return</span> global;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"unable to locate global object"</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES10内置</span></span><br><span class="line">globalThis.Array(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// [0,1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个全局对象v = &#123; value:true &#125; ,ES10用如下方式定义</span></span><br><span class="line">globalThis.v = &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;;</span><br></pre></td></tr></table></figure><p>而 <strong>globalThis 目的就是提供一种标准化方式访问全局对象</strong>，有了 globalThis 后，你可以在任意上下文，任意时刻都能获取到全局对象。</p><p>如果您在浏览器上，globalThis 将为 window，如果您在 Node 上，globalThis 则将为 global。因此，不再需要考虑不同的环境问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// worker.js</span></span><br><span class="line">globalThis === self;</span><br><span class="line"><span class="comment">// node.js</span></span><br><span class="line">globalThis === global;</span><br><span class="line"><span class="comment">// browser.js</span></span><br><span class="line">globalThis === <span class="built_in">window</span>;</span><br></pre></td></tr></table></figure><p>新提案也规定了，Object.prototype 必须在全局对象的原型链中。下面的代码在最新浏览器中已经会返回 true 了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(globalThis); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>globalThis 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi3411fr4rj316g09ituj.jpg" alt="image-20200825155440446"></p><h2 id="类的私有变量"><a href="#类的私有变量" class="headerlink" title="类的私有变量"></a>类的私有变量</h2><p>最新提案之一是在类中添加私有变量的方法。我们将<strong>使用 # 符号表示类的私有变量</strong>。这样就不需要使用闭包来隐藏不想暴露给外界的私有变量。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">  #x = 0;</span><br><span class="line"></span><br><span class="line">  #increment() &#123;</span><br><span class="line">    this.#x++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onClick() &#123;</span><br><span class="line">    this.#increment();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Counter();</span><br><span class="line">c.onClick(); <span class="comment">// 正常</span></span><br><span class="line">c.#increment(); // 报错</span><br></pre></td></tr></table></figure><p>通过 # 修饰的成员变量或成员函数就成为了私有变量，如果试图在 Class 外部访问，则会抛出异常。现在，此特性可在最新版本的 Chrome 和 Node.js 中使用。</p><h2 id="static-字段"><a href="#static-字段" class="headerlink" title="static 字段"></a>static 字段</h2><p>它允许类拥有静态字段，类似于大多数 OOP 语言。静态字段可以用来代替枚举，也可以用于私有字段。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colors</span> </span>&#123;</span><br><span class="line">  <span class="comment">// public static 字段</span></span><br><span class="line">  <span class="keyword">static</span> red = <span class="string">"#ff0000"</span>;</span><br><span class="line">  <span class="keyword">static</span> green = <span class="string">"#00ff00"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// private static 字段</span></span><br><span class="line">  static #secretColor = "#f0f0f0";</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">font.color = Colors.red;</span><br><span class="line">font.color = Colors.#secretColor; // 出错</span><br></pre></td></tr></table></figure><p>现在，此特性可在最新版本的 Chrome 和 Node.js 中使用。</p><h2 id="WeakRef"><a href="#WeakRef" class="headerlink" title="WeakRef"></a>WeakRef</h2><p>一般来说，在 JavaScript 中，对象的引用是强保留的，这意味着只要持有对象的引用，它就不会被垃圾回收。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ref = &#123; <span class="attr">x</span>: <span class="number">42</span>, <span class="attr">y</span>: <span class="number">51</span> &#125;;</span><br><span class="line"><span class="comment">// 只要我们访问 ref 对象（或者任何其他引用指向该对象），这个对象就不会被垃圾回收</span></span><br></pre></td></tr></table></figure><p>目前在 Javascript 中，WeakMap 和 WeakSet 是弱引用对象的唯一方法：将对象作为键添加到 WeakMap 或 WeakSet 中，是不会阻止它被垃圾回收的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wm = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> ref = &#123;&#125;;</span><br><span class="line">  <span class="keyword">const</span> metaData = <span class="string">"foo"</span>;</span><br><span class="line">  wm.set(ref, metaData);</span><br><span class="line">  wm.get(ref);</span><br><span class="line">  <span class="comment">// 返回 metaData</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在这个块范围内，我们已经没有对 ref 对象的引用。</span></span><br><span class="line"><span class="comment">// 因此，虽然它是 wm 中的键，我们仍然可以访问，但是它能够被垃圾回收。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(ref);</span><br><span class="line">ws.has(ref); <span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><p><strong>JavaScript 的 WeakMap 并不是真正意义上的弱引用</strong>：实际上，只要键仍然存活，它就强引用其内容。WeakMap 仅在键被垃圾回收之后，才弱引用它的内容。</p><p>WeakRef 是一个更高级的 API，它提供了真正的弱引用，Weakref 实例具有一个方法 deref，该方法返回被引用的原始对象，如果原始对象已被收集，则返回 undefined 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">const</span> setValue = <span class="function">(<span class="params">key, obj</span>) =&gt;</span> &#123;</span><br><span class="line">  cache.set(key, <span class="keyword">new</span> WeakRef(obj));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getValue = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> ref = cache.get(key);</span><br><span class="line">  <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">    <span class="keyword">return</span> ref.deref();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// this will look for the value in the cache</span></span><br><span class="line"><span class="comment">// and recalculate if it's missing</span></span><br><span class="line"><span class="keyword">const</span> fibonacciCached = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> cached = getValue(number);</span><br><span class="line">  <span class="keyword">if</span> (cached) <span class="keyword">return</span> cached;</span><br><span class="line">  <span class="keyword">const</span> sum = calculateFibonacci(number);</span><br><span class="line">  setValue(number, sum);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>总而言之，JavaScript 中对象的引用是强引用，WeakMap 和 WeakSet 可以提供部分的弱引用功能，若想在 JavaScript 中实现真正的弱引用，可以通过配合使用 WeakRef 和终结器（Finalizer）来实现。</p><p>现在，此特性可在最新版本的 Chrome 和 Node.js 中使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES2020-新特性&quot;&gt;&lt;a href=&quot;#ES2020-新特性&quot; class=&quot;headerlink&quot; title=&quot;ES2020 新特性&quot;&gt;&lt;/a&gt;ES2020 新特性&lt;/h1&gt;&lt;h2 id=&quot;可选链操作符（Optional-Chaining）&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES7、ES8、ES9、ES10新特性</title>
    <link href="http://yoursite.com/2020/08/01/ES7%E3%80%81ES8%E3%80%81ES9%E3%80%81ES10%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://yoursite.com/2020/08/01/ES7、ES8、ES9、ES10新特性/</id>
    <published>2020-08-01T07:58:55.000Z</published>
    <updated>2020-09-06T07:28:21.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES7、ES8、ES9、ES10-新特性"><a href="#ES7、ES8、ES9、ES10-新特性" class="headerlink" title="ES7、ES8、ES9、ES10 新特性"></a>ES7、ES8、ES9、ES10 新特性</h1><h2 id="ES7-新特性"><a href="#ES7-新特性" class="headerlink" title="ES7 新特性"></a>ES7 新特性</h2><h3 id="1-Array-prototype-includes-方法"><a href="#1-Array-prototype-includes-方法" class="headerlink" title="1.Array.prototype.includes()方法"></a>1.Array.prototype.includes()方法</h3><p>在 ES6 中我们有 String.prototype.includes() 可以查询给定字符串是否包含一个字符，而在 ES7 中，我们在数组中也可以用 Array.prototype.includes 方法来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="string">"8"</span>, <span class="literal">NaN</span>, <span class="number">-0</span>];</span><br><span class="line">arr.includes(<span class="number">1</span>); <span class="comment">// true</span></span><br><span class="line">arr.includes(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// false 该方法的第二个参数表示搜索的起始位置，默认为0</span></span><br><span class="line">arr.includes(<span class="string">"1"</span>); <span class="comment">// false</span></span><br><span class="line">arr.includes(<span class="literal">NaN</span>); <span class="comment">// true</span></span><br><span class="line">arr.includes(+<span class="number">0</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>在 ES7 之前想判断数组中是否包含一个元素，有如下两种方法,但都不如 includes 来得直观：</p><ul><li>indexOf()</li></ul><p>indexOf()方法返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (arr.indexOf(el) !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过这种方法有两个缺点，一是不够语义化，要先找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>); <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><ul><li>find() 和 findIndex()</li></ul><p>数组实例的 find 方法，用于找出第一个符合条件的数组成员。另外，这两个方法都可以发现 NaN，弥补了数组的 indexOf 方法的不足。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>]</span><br><span class="line">  .find(<span class="function">(<span class="params">n</span>) =&gt;</span> n &lt; <span class="number">0</span>) <span class="comment">// -5</span></span><br><span class="line">  [(<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>)].findIndex(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value &gt; <span class="number">9</span>;</span><br><span class="line">  &#125;) <span class="comment">// 2</span></span><br><span class="line">  [<span class="literal">NaN</span>].findIndex(<span class="function">(<span class="params">y</span>) =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>Array.prototype.includes()的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi339t634fj30ze09se0t.jpg" alt="image-20200825152818632"></p><h3 id="2-求幂运算符"><a href="#2-求幂运算符" class="headerlink" title="2.求幂运算符**"></a>2.求幂运算符**</h3><p>在 ES7 中引入了指数运算符，具有与 Math.pow()等效的计算结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">10</span>); <span class="comment">// 输出1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 输出1024</span></span><br></pre></td></tr></table></figure><p>求幂运算符的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33ajvhgoj314s09iavr.jpg" alt="image-20200825152912695"></p><h2 id="ES8-新特性"><a href="#ES8-新特性" class="headerlink" title="ES8 新特性"></a>ES8 新特性</h2><h3 id="1-Async-Await"><a href="#1-Async-Await" class="headerlink" title="1.Async/Await"></a>1.Async/Await</h3><p>我们都知道使用 Promise 能很好地解决回调地狱的问题，但如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程，那有没有比 Promise 更优雅的异步方式呢？</p><p>假如有这样一个使用场景：需要先请求 a 链接，等返回信息之后，再请求 b 链接的另外一个资源。下面代码展示的是使用 fetch 来实现这样的需求，fetch 被定义在 window 对象中，它返回的是一个 Promise 对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"https://blog.csdn.net/"</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">    <span class="keyword">return</span> fetch(<span class="string">"https://juejin.im/"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>虽然上述代码可以实现这个需求，但语义化不明显，代码不能很好地表示执行流程。基于这个原因，ES8 引入了 async/await，这是 JavaScript 异步编程的一个重大改进，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> response1 = <span class="keyword">await</span> fetch(<span class="string">"https://blog.csdn.net/"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response1);</span><br><span class="line">    <span class="keyword">let</span> response2 = <span class="keyword">await</span> fetch(<span class="string">"https://juejin.im/"</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(response2);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure><p>通过上面代码，你会发现整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这感觉就在写同步代码，所以是非常符合人的线性思维的。需要强调的是，<strong>await 不可以脱离 async 单独使用</strong>，await 后面一定是 Promise 对象，如果不是会自动包装成 Promise 对象。</p><p>根据 MDN 定义，<strong>async 是一个通过异步执行并隐式返回 Promise 作为结果的函数</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"01小仙女"</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 01小仙女</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上述代码，我们可以看到调用 async 声明的 foo 函数返回了一个 Promise 对象，等价于下面代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(<span class="string">"01小仙女"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo().then(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(val); <span class="comment">// 01小仙女</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>Async/Await 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33c09msfj318208qgqu.jpg" alt="image-20200825153035899"></p><h3 id="2-Object-values-，Object-entries"><a href="#2-Object-values-，Object-entries" class="headerlink" title="2.Object.values()，Object.entries()"></a>2.Object.values()，Object.entries()</h3><p>ES5 引入了 Object.keys 方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。ES8 引入了跟 Object.keys 配套的 Object.values 和 Object.entries，作为遍历一个对象的补充手段，供 for…of 循环使用。</p><p>Object.values 方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">"bar"</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ["bar", 42]</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">"a"</span>, <span class="number">2</span>: <span class="string">"b"</span>, <span class="number">7</span>: <span class="string">"c"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj); <span class="comment">// ["b", "c", "a"]</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>如果属性名为数值的属性，是按照数值大小，从小到大遍历的</strong>，因此返回的顺序是 b、c、a。</p><p>Object.entries()方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。这个特性我们后面介绍 ES10 的 Object.fromEntries()还会再提到。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">foo</span>: <span class="string">"bar"</span>, <span class="attr">baz</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [ ["foo", "bar"], ["baz", 42] ]</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">10</span>: <span class="string">"xxx"</span>, <span class="number">1</span>: <span class="string">"yyy"</span>, <span class="number">3</span>: <span class="string">"zzz"</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.entries(obj); <span class="comment">// [['1', 'yyy'], ['3', 'zzz'], ['10': 'xxx']]</span></span><br></pre></td></tr></table></figure><p>Object.values()与 Object.entries()兼容性一致，下面以 Object.values()为例：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33cl97q0j30v608mnfm.jpg" alt="image-20200825153109961"></p><h3 id="3-String-padding"><a href="#3-String-padding" class="headerlink" title="3.String padding"></a>3.String padding</h3><p>在 ES8 中 String 新增了两个实例函数 String.prototype.padStart 和 String.prototype.padEnd，允许将空字符串或其他字符串添加到原始字符串的开头或结尾。我们先看下使用语法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.padStart(targetLength, [padString]);</span><br></pre></td></tr></table></figure><ul><li>targetLength(必填):当前字符串需要填充到的目标长度。如果这个数值小于当前字符串的长度，则返回当前字符串本身。</li><li>padString(可选):填充字符串。如果字符串太长，使填充后的字符串长度超过了目标长度，则只保留最左侧的部分，其他部分会被截断，此参数的缺省值为 “ “。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"x"</span>.padStart(<span class="number">4</span>, <span class="string">"ab"</span>); <span class="comment">// 'abax'</span></span><br><span class="line"><span class="string">"x"</span>.padEnd(<span class="number">5</span>, <span class="string">"ab"</span>); <span class="comment">// 'xabab'</span></span><br></pre></td></tr></table></figure><p>有时候我们处理日期、金额的时候经常要格式化，这个特性就派上用场：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"12"</span>.padStart(<span class="number">10</span>, <span class="string">"YYYY-MM-DD"</span>); <span class="comment">// "YYYY-MM-12"</span></span><br><span class="line"><span class="string">"09-12"</span>.padStart(<span class="number">10</span>, <span class="string">"YYYY-MM-DD"</span>); <span class="comment">// "YYYY-09-12"</span></span><br></pre></td></tr></table></figure><p>String padding 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33ddwi7dj314u0ekb29.jpg" alt="image-20200825153152648"></p><h3 id="4-Object-getOwnPropertyDescriptors"><a href="#4-Object-getOwnPropertyDescriptors" class="headerlink" title="4.Object.getOwnPropertyDescriptors()"></a>4.Object.getOwnPropertyDescriptors()</h3><p>ES5 的 Object.getOwnPropertyDescriptor()方法会返回某个对象属性的描述对象（descriptor）。ES8 引入了 Object.getOwnPropertyDescriptors()方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33e2o2zgj30n20k20y2.jpg" alt="image-20200825153235558"></p><p>得到的结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33f3lgtnj30tg0ekal2.jpg" alt="image-20200825153333802">该方法的引入目的，主要是为了解决 Object.assign()无法正确拷贝 get 属性和 set 属性的问题。<br>上面代码中，source 对象的 foo 属性的值是一个赋值函数，Object.assign 方法将这个属性拷贝给 target1 对象，结果该属性的值变成了 undefined。这是因为<strong>Object.assign 方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法</strong>。</p><p>这时，Object.getOwnPropertyDescriptors()方法配合 Object.defineProperties()方法，就可以实现正确拷贝。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33fhjydwj30sk07igtj.jpg" alt="image-20200825153356763">Object.getOwnPropertyDescriptors()的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33gdvmwmj311g08iwzt.jpg" alt="image-20200825153449112"></p><h2 id="ES9-新特性"><a href="#ES9-新特性" class="headerlink" title="ES9 新特性"></a>ES9 新特性</h2><h3 id="1-for-await-of"><a href="#1-for-await-of" class="headerlink" title="1.for await of"></a>1.for await of</h3><p>for of 方法能够遍历具有 Symbol.iterator 接口的同步迭代器数据，但是不能遍历异步迭代器。<br>ES9 新增的 for await of 可以用来遍历具有 Symbol.asyncIterator 方法的数据结构，也就是异步迭代器，且会等待前一个成员的状态改变后才会遍历到下一个成员，相当于 async 函数内部的 await。现在我们有三个异步任务，想要实现依次输出结果，该如何实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// for of遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(time);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [Gen(<span class="number">2000</span>), Gen(<span class="number">100</span>), Gen(<span class="number">3000</span>)];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), item.then(<span class="built_in">console</span>.log));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>得到如下结果：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33h193ozj30lq0icgxz.jpg" alt="image-20200825153525626"></p><p>上述代码证实了 for of 方法不能遍历异步迭代器，得到的结果并不是我们所期待的，于是 for await of 就粉墨登场啦！</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Gen</span>(<span class="params">time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      resolve(time);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [Gen(<span class="number">2000</span>), Gen(<span class="number">100</span>), Gen(<span class="number">3000</span>)];</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> item <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Date</span>.now(), item);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">test();</span><br><span class="line"><span class="comment">// 1575536194608 2000</span></span><br><span class="line"><span class="comment">// 1575536194608 100</span></span><br><span class="line"><span class="comment">// 1575536195608 3000</span></span><br></pre></td></tr></table></figure><p>使用 for await of 遍历时，会等待前一个 Promise 对象的状态改变后，再遍历到下一个成员。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33hfb3rvj30mo0bqmzv.jpg" alt="image-20200825153549426"></p><p>异步迭代器的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33ihtuyyj30z60833zy.jpg" alt="image-20200825153649292"></p><h3 id="2-Object-Rest-Spread"><a href="#2-Object-Rest-Spread" class="headerlink" title="2.Object Rest Spread"></a>2.Object Rest Spread</h3><p>ES6 中添加的最意思的特性之一是 spread 操作符。你不仅可以用它替换 cancat()和 slice()方法，使数组的操作(复制、合并)更加简单，还可以在数组必须以拆解的方式作为函数参数的情况下，spread 操作符也很实用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>];</span><br><span class="line"><span class="keyword">const</span> copy = [...arr1]; <span class="comment">// 复制</span></span><br><span class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// [10, 20, 30]</span></span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">const</span> merge = [...arr1, ...arr2]; <span class="comment">// 合并</span></span><br><span class="line"><span class="built_in">console</span>.log(merge); <span class="comment">// [10, 20, 30, 40, 50]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.max(...arr)); <span class="comment">// 30 拆解</span></span><br></pre></td></tr></table></figure><p>ES9 通过向对象文本添加扩展属性进一步扩展了这种语法。他可以将一个对象的属性拷贝到另一个对象上，参考以下情形:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> output = &#123;</span><br><span class="line">  ...input,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(output); <span class="comment">// &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure><p>上面代码可以把 input 对象的数据都添加到 output 对象中，需要注意的是，<strong>如果存在相同的属性名，只有最后一个会生效</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> output = &#123;</span><br><span class="line">  ...input,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line">input.a = <span class="string">"浪里行舟"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(input, output); <span class="comment">// &#123;a: "浪里行舟", b: 2&#125; &#123;a: 1, b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure><p>上面例子中，修改 input 对象中的值，output 并没有改变，说明扩展运算符拷贝一个对象（类似这样 obj2 = {…obj1}），<strong>实现只是一个对象的浅拷贝</strong>。值得注意的是，如果属性的值是一个对象的话，该对象的引用会被拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">x</span>: &#123; <span class="attr">y</span>: <span class="number">10</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">const</span> copy1 = &#123; ...obj &#125;;</span><br><span class="line"><span class="keyword">const</span> copy2 = &#123; ...obj &#125;;</span><br><span class="line">obj.x.y = <span class="string">"01小仙女"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(copy1, copy2); <span class="comment">// x: &#123;y: "01小仙女"&#125; x: &#123;y: "01小仙女"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(copy1.x === copy2.x); <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>copy1.x 和 copy2.x 指向同一个对象的引用，所以他们严格相等。</p><p>我们再来看下 Object rest 的示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = &#123;</span><br><span class="line">  a: <span class="number">1</span>,</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">  c: <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; a, ...rest &#125; = input;</span><br><span class="line"><span class="built_in">console</span>.log(a, rest); <span class="comment">// 1 &#123;b: 2, c: 3&#125;</span></span><br></pre></td></tr></table></figure><p>当对象 key-value 不确定的时候，把必选的 key 赋值给变量，用一个变量收敛其他可选的 key 数据，这在之前是做不到的。注意，<strong>rest 属性必须始终出现在对象的末尾</strong>，否则将抛出错误。</p><p>Rest 与 Spread 兼容性一致，下列以 spread 为例：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33kf6licj31640aana8.jpg" alt="image-20200825153842047"></p><h3 id="3-Promise-prototype-finally"><a href="#3-Promise-prototype-finally" class="headerlink" title="3.Promise.prototype.finally()"></a>3.Promise.prototype.finally()</h3><p>Promise.prototype.finally() 方法返回一个 Promise，在 promise 执行结束时，无论结果是 fulfilled 或者是 rejected，在执行 then()和 catch()后，都会执行 finally 指定的回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">"https://www.google.com"</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(error);</span><br><span class="line">  &#125;)</span><br><span class="line">  .finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">document</span>.querySelector(<span class="string">"#spinner"</span>).style.display = <span class="string">"none"</span>;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>无论操作是否成功，当您需要在操作完成后进行一些清理时，finally()方法就派上用场了。这为指定执行完 promise 后，无论结果是 fulfilled 还是 rejected 都需要执行的代码提供了一种方式，<strong>避免同样的语句需要在 then()和 catch()中各写一次的情况</strong>。</p><p>Promise.prototype.finally()的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33ky6wlej314w0bk1kx.jpg" alt="image-20200825153909704"></p><h3 id="4-新的正则表达式特性"><a href="#4-新的正则表达式特性" class="headerlink" title="4.新的正则表达式特性"></a>4.新的正则表达式特性</h3><p>ES9 为正则表达式添加了四个新特性，进一步提高了 JavaScript 的字符串处理能力。这些特点如下:</p><ul><li>s (dotAll) 标志</li><li>命名捕获组</li><li>Lookbehind 后行断言</li><li>Unicode 属性转义</li></ul><h4 id="（1）s-dotAll-flag"><a href="#（1）s-dotAll-flag" class="headerlink" title="（1）s(dotAll)flag"></a>（1）s(dotAll)flag</h4><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 u 修饰符解决；另一个是行终止符,如换行符(\n)或回车符(\r),这个可以通过 ES9 的 s(dotAll)flag，在原正则表达式基础上添加 s 表示:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/foo.bar/</span>.test(<span class="string">"foo\nbar"</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/foo.bar/</span>s.test(<span class="string">"foo\nbar"</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>那如何判断当前正则是否使用了 dotAll 模式呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/foo.bar/</span>s; <span class="comment">// Or, `const re = new RegExp('foo.bar', 's');`.</span></span><br><span class="line"><span class="built_in">console</span>.log(re.test(<span class="string">"foo\nbar"</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.dotAll); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(re.flags); <span class="comment">// 's'</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33ous127j316209we40.jpg" alt="image-20200825154256574"></p><h4 id="（2）命名捕获组"><a href="#（2）命名捕获组" class="headerlink" title="（2）命名捕获组"></a>（2）命名捕获组</h4><p>在一些正则表达式模式中，使用数字进行匹配可能会令人混淆。例如，使用正则表达式/(\d{4})-(\d{2})-(\d{2})/来匹配日期。因为美式英语中的日期表示法和英式英语中的日期表示法不同，所以很难区分哪一组表示日期，哪一组表示月份:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">const</span> match = re.exec(<span class="string">"2019-01-01"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">0</span>]); <span class="comment">// → 2019-01-01</span></span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">1</span>]); <span class="comment">// → 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">2</span>]); <span class="comment">// → 01</span></span><br><span class="line"><span class="built_in">console</span>.log(match[<span class="number">3</span>]); <span class="comment">// → 01</span></span><br></pre></td></tr></table></figure><p>ES9 引入了命名捕获组，允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">const</span> match = re.exec(<span class="string">"2019-01-01"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(match.groups); <span class="comment">// → &#123;year: "2019", month: "01", day: "01"&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(match.groups.year); <span class="comment">// → 2019</span></span><br><span class="line"><span class="built_in">console</span>.log(match.groups.month); <span class="comment">// → 01</span></span><br><span class="line"><span class="built_in">console</span>.log(match.groups.day); <span class="comment">// → 01</span></span><br></pre></td></tr></table></figure><p>上面代码中，“命名捕获组”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在 exec 方法返回结果的 groups 属性上引用该组名。</p><p>命名捕获组也可以使用在 replace()方法中，例如将日期转换为美国的 MM-DD-YYYY 格式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> re = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>;</span><br><span class="line"><span class="keyword">const</span> usDate = <span class="string">"2018-04-30"</span>.replace(re, <span class="string">"$&lt;month&gt;-$&lt;day&gt;-$&lt;year&gt;"</span>);</span><br><span class="line"><span class="built_in">console</span>.log(usDate); <span class="comment">// 04-30-2018</span></span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33p1c6f0j30zm07uar5.jpg" alt="image-20200825154308140"></p><h4 id="（3）Lookbehind-后行断言"><a href="#（3）Lookbehind-后行断言" class="headerlink" title="（3）Lookbehind 后行断言"></a>（3）Lookbehind 后行断言</h4><p>JavaScript 语言的正则表达式，只支持先行断言，不支持后行断言，先行断言我们可以简单理解为”先遇到一个条件，再判断后面是否满足”，如下面例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="string">"hello world"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.match(<span class="regexp">/hello(?=\sworld)/</span>));</span><br><span class="line"><span class="comment">// ["hello", index: 0, input: "hello world", groups: undefined]</span></span><br></pre></td></tr></table></figure><p>但有时我们想判断前面是 world 的 hello，这个代码是实现不了的。在 ES9 就支持这个后行断言了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> test = <span class="string">"world hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(test.match(<span class="regexp">/(?&lt;=world\s)hello/</span>));</span><br><span class="line"><span class="comment">// ["hello", index: 6, input: "world hello", groups: undefined]</span></span><br></pre></td></tr></table></figure><p><strong>(?&lt;…)是后行断言的符号，(?..)是先行断言的符号</strong>，然后结合 =(等于)、!(不等)、\1(捕获匹配)。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33p8imbsj313q09kay3.jpg" alt="image-20200825154319290"></p><h4 id="（4）Unicode-属性转义"><a href="#（4）Unicode-属性转义" class="headerlink" title="（4）Unicode 属性转义"></a>（4）Unicode 属性转义</h4><p>ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。比如你可以使用\p{Number}来匹配所有的 Unicode 数字，例如，假设你想匹配的 Unicode 字符 ㉛ 字符串:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"㉛"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\d/u</span>.test(str)); <span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\p&#123;Number&#125;/u</span>.test(str)); <span class="comment">// → true</span></span><br></pre></td></tr></table></figure><p>同样的，你可以使用\p{Alphabetic}来匹配所有的 Unicode 单词字符:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"ض"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\p&#123;Alphabetic&#125;/u</span>.test(str)); <span class="comment">// → true</span></span><br><span class="line"><span class="comment">// the \w shorthand cannot match ض</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\w/u</span>.test(str)); <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>同样有一个负向的 Unicode 属性转义模板 \P{…}</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\P&#123;Number&#125;/u</span>.test(<span class="string">"㉛"</span>)); <span class="comment">// → false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\P&#123;Number&#125;/u</span>.test(<span class="string">"ض"</span>)); <span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\P&#123;Alphabetic&#125;/u</span>.test(<span class="string">"㉛"</span>)); <span class="comment">// → true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="regexp">/\P&#123;Alphabetic&#125;/u</span>.test(<span class="string">"ض"</span>)); <span class="comment">// → false</span></span><br></pre></td></tr></table></figure><p>除了字母和数字之外，Unicode 属性转义中还可以使用其他一些属性。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33pduk5jj30xs07mk52.jpg" alt="image-20200825154328453"></p><h2 id="ES10-新特性"><a href="#ES10-新特性" class="headerlink" title="ES10 新特性"></a>ES10 新特性</h2><h3 id="1-Array-prototype-flat"><a href="#1-Array-prototype-flat" class="headerlink" title="1.Array.prototype.flat()"></a>1.Array.prototype.flat()</h3><p>多维数组是一种常见的数据格式，特别是在进行数据检索的时候。将多维数组打平是个常见的需求。通常我们能够实现，但是不够优雅。</p><p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newArray = arr.flat(depth); <span class="comment">// depth是指定要提取嵌套数组的结构深度，默认值为 1</span></span><br></pre></td></tr></table></figure><p>接下来我们看两个例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers1 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(numbers1.flat()); <span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br><span class="line"><span class="keyword">const</span> numbers2 = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, [<span class="number">5</span>, <span class="number">6</span>]]];</span><br><span class="line"><span class="built_in">console</span>.log(numbers2.flat(<span class="number">2</span>)); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure><p>上面两个例子说明 flat 的参数没有设置，取默认值 1，也就是说只扁平化第一级；当 flat 的参数大于等于 2，返回值就是 [1, 2, 3, 4, 5, 6] 了。</p><p>Array.prototype.flat 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33pxn3ksj310o08eati.jpg" alt="image-20200825154359939"></p><h3 id="2-Array-prototype-flatMap"><a href="#2-Array-prototype-flatMap" class="headerlink" title="2.Array.prototype.flatMap()"></a>2.Array.prototype.flatMap()</h3><p>有了 flat 方法，那自然而然就有 Array.prototype.flatMap 方法，flatMap() 方法首先使用映射函数映射每个元素，然后将结果压缩成一个新数组。从方法的名字上也可以看出来它包含两部分功能一个是 map，一个是 flat（深度为 1）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> [item * <span class="number">2</span>]).flat()); <span class="comment">// [2, 4, 6]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr.flatMap(<span class="function">(<span class="params">item</span>) =&gt;</span> [item * <span class="number">2</span>])); <span class="comment">// [2, 4, 6]</span></span><br></pre></td></tr></table></figure><p>实际上 flatMap 是综合了 map 和 flat 的操作，所以<strong>它也只能打平一层</strong>。</p><p>Array.prototype.flatmap 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33qhr5gxj30xu07mh0x.jpg" alt="image-20200825154431843"></p><h3 id="3-Object-fromEntries"><a href="#3-Object-fromEntries" class="headerlink" title="3.Object.fromEntries()"></a>3.Object.fromEntries()</h3><p>Object.fromEntries 这个新的 API 实现了与 Object.entries 相反的操作。这使得根据对象的 entries 很容易得到 object。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">x</span>: <span class="number">23</span>, <span class="attr">y</span>: <span class="number">24</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> entries = <span class="built_in">Object</span>.entries(object); <span class="comment">// [['x', 23], ['y', 24]]</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="built_in">Object</span>.fromEntries(entries); <span class="comment">// &#123; x: 23, y: 24 &#125;</span></span><br></pre></td></tr></table></figure><p>ES2017 引入了 Object.entries, 这个方法可以将对象转换为数组,这样对象就可以使用数组原型中的众多内置方法，比如 map, filter、reduce，举个例子，我们想提取下列对象 obj 中所有 value 大于 21 的键值对，如何操作呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES10之前</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">21</span>,</span><br><span class="line">  b: <span class="number">22</span>,</span><br><span class="line">  c: <span class="number">23</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.entries(obj)); <span class="comment">// [['a',21],["b", 22],["c", 23]]</span></span><br><span class="line"><span class="keyword">let</span> arr = <span class="built_in">Object</span>.entries(obj).filter(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> b &gt; <span class="number">21</span>); <span class="comment">// [["b", 22],["c", 23]]</span></span><br><span class="line"><span class="keyword">let</span> obj1 = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [name, age] <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  obj1[name] = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj1); <span class="comment">// &#123;b: 22, c: 23&#125;</span></span><br></pre></td></tr></table></figure><p>上例中得到了数组 arr，想再次转化为对象，就需要手动写一些代码来处理，但是有了 Object.fromEntries()就很容易实现</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用Object.fromEntries()来实现</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  a: <span class="number">21</span>,</span><br><span class="line">  b: <span class="number">22</span>,</span><br><span class="line">  c: <span class="number">23</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> res = <span class="built_in">Object</span>.fromEntries(<span class="built_in">Object</span>.entries(obj).filter(<span class="function">(<span class="params">[a, b]</span>) =&gt;</span> b &gt; <span class="number">21</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">111</span>, res); <span class="comment">// &#123;b: 22, c: 23&#125;</span></span><br></pre></td></tr></table></figure><p>Object.fromEntries()的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33r38jb8j314k098x1m.jpg" alt="image-20200825154506584"></p><h3 id="4-String-trimStart-和-String-trimEnd"><a href="#4-String-trimStart-和-String-trimEnd" class="headerlink" title="4.String.trimStart 和 String.trimEnd"></a>4.String.trimStart 和 String.trimEnd</h3><p>移除开头和结尾的空格，之前我们用正则表达式来实现，现在 ES10 新增了两个新特性，让这变得更简单！</p><p>trimStart() 方法从字符串的开头删除空格，trimLeft()是此方法的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">" 01小仙女 "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 7</span></span><br><span class="line">str = str.trimStart();</span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> str1 = str.trim(); <span class="comment">// 清除前后的空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.length); <span class="comment">// 5</span></span><br><span class="line">str.replace(<span class="regexp">/^\s+/g</span>, <span class="string">""</span>); <span class="comment">// 也可以用正则实现开头删除空格</span></span><br></pre></td></tr></table></figure><p>trimEnd() 方法从一个字符串的右端移除空白字符，trimRight 是 trimEnd 的别名。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">" 01小仙女 "</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 7</span></span><br><span class="line">str = str.trimEnd();</span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 6</span></span><br><span class="line"><span class="keyword">let</span> str1 = str.trim(); <span class="comment">//清除前后的空格</span></span><br><span class="line"><span class="built_in">console</span>.log(str1.length); <span class="comment">// 5</span></span><br><span class="line">str.replace(<span class="regexp">/\s+$/g</span>, <span class="string">""</span>); <span class="comment">// 也可以用正则实现右端移除空白字符</span></span><br></pre></td></tr></table></figure><p>String.trimStart 和 String.trimEnd 两者兼容性一致，下图以 trimStart 为例：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33s9kumtj313o0a61jn.jpg" alt="image-20200825154614390"></p><h3 id="5-String-prototype-matchAll"><a href="#5-String-prototype-matchAll" class="headerlink" title="5.String.prototype.matchAll"></a>5.String.prototype.matchAll</h3><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用 g 修饰符或 y 修饰符，在循环里面逐一取出。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectGroup1</span>(<span class="params">regExp, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> matches = [];</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> match = regExp.exec(str);</span><br><span class="line">    <span class="keyword">if</span> (match === <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line">    matches.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> matches;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(collectGroup1(<span class="regexp">/"([^"]*)"/g</span>, <span class="string">`"foo" and "bar" and "baz"`</span>));</span><br><span class="line"><span class="comment">// [ 'foo', 'bar', 'baz' ]</span></span><br></pre></td></tr></table></figure><p>值得注意的是，如果没有修饰符 /g, .exec() 只返回第一个匹配。现在通过 ES9 的 String.prototype.matchAll 方法，可以一次性取出所有匹配。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectGroup1</span>(<span class="params">regExp, str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> match <span class="keyword">of</span> str.matchAll(regExp)) &#123;</span><br><span class="line">    results.push(match[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(collectGroup1(<span class="regexp">/"([^"]*)"/g</span>, <span class="string">`"foo" and "bar" and "baz"`</span>));</span><br><span class="line"><span class="comment">// ["foo", "bar", "baz"]</span></span><br></pre></td></tr></table></figure><p>上面代码中，由于 string.matchAll(regex)返回的是遍历器，所以可以用 for…of 循环取出。</p><p>String.prototype.matchAll 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33sv5f9wj30zg07sh2h.jpg" alt="image-20200825154648376"></p><h3 id="6-try…catch"><a href="#6-try…catch" class="headerlink" title="6.try…catch"></a>6.try…catch</h3><p>在 ES10 中，try-catch 语句中的参数变为了一个可选项。以前我们写 catch 语句时，必须传递一个异常参数。这就意味着，即便我们在 catch 里面根本不需要用到这个异常参数也必须将其传递进去</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES10之前</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// tryCode</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="comment">// catchCode</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 err 是必须的参数，在 ES10 可以省略这个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES10</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Foobar"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">"Bar"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>try…catch 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33tdbzbvj31a209ee2n.jpg" alt="image-20200825154718170"></p><h3 id="7-BigInt"><a href="#7-BigInt" class="headerlink" title="7.BigInt"></a>7.BigInt</h3><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 Infinity。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>现在 ES10 引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p><p>创建 BigInt 类型的值也非常简单，只需要在数字后面加上 n 即可。例如，123 变为 123n。也可以使用全局方法 BigInt(value) 转化，入参 value 为数字或数字字符串。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> aNumber = <span class="number">111</span>;</span><br><span class="line"><span class="keyword">const</span> aBigInt = BigInt(aNumber);</span><br><span class="line">aBigInt === <span class="number">111</span>n; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> aBigInt === <span class="string">"bigint"</span>; <span class="comment">// true</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">111</span>; <span class="comment">// "number"</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">111</span>n; <span class="comment">// "bigint"</span></span><br></pre></td></tr></table></figure><p>如果算上 BigInt，JavaScript 中原始类型就从 6 个变为了 7 个。</p><ul><li>Boolean</li><li>Null</li><li>Undefined</li><li>Number</li><li>String</li><li>Symbol (new in ECMAScript 2015)</li><li>BigInt (new in ECMAScript 2019)</li></ul><p>BigInt 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33tvyqm3j30va08u1ac.jpg" alt="image-20200825154748077"></p><h3 id="8-Symbol-prototype-description"><a href="#8-Symbol-prototype-description" class="headerlink" title="8.Symbol.prototype.description"></a>8.Symbol.prototype.description</h3><p>我们知道，Symbol 的描述只被存储在内部的 [[Description]]，没有直接对外暴露，我们只有调用 Symbol 的 toString() 时才可以读取这个属性：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">"desc"</span>).description; <span class="comment">// "desc"</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">""</span>).description; <span class="comment">// ""</span></span><br><span class="line"><span class="built_in">Symbol</span>().description; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>Symbol.prototype.description 的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33uahh3bj31a00bg1ic.jpg" alt="image-20200825154811216"></p><h3 id="9-Function-prototype-toString"><a href="#9-Function-prototype-toString" class="headerlink" title="9.Function.prototype.toString()"></a>9.Function.prototype.toString()</h3><p>ES2019 中，Function.toString()发生了变化。之前执行这个方法时，得到的字符串是去空白符号的。而现在，得到的字符串呈现出原本源码的样子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sum.toString());</span><br><span class="line"><span class="comment">// function sum(a, b) &#123;</span></span><br><span class="line"><span class="comment">//  return a + b;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>Function.prototype.toString()的支持情况：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gi33uopix0j31g40a4nmv.jpg" alt="image-20200825154833401"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ES7、ES8、ES9、ES10-新特性&quot;&gt;&lt;a href=&quot;#ES7、ES8、ES9、ES10-新特性&quot; class=&quot;headerlink&quot; title=&quot;ES7、ES8、ES9、ES10 新特性&quot;&gt;&lt;/a&gt;ES7、ES8、ES9、ES10 新特性&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue.js 服务器端渲染SSR指南</title>
    <link href="http://yoursite.com/2020/07/26/Vue.js%20%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E6%B8%B2%E6%9F%93SSR%E6%8C%87%E5%8D%97/"/>
    <id>http://yoursite.com/2020/07/26/Vue.js 服务器端渲染SSR指南/</id>
    <published>2020-07-26T03:00:21.000Z</published>
    <updated>2020-08-04T13:42:39.201Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-服务器端渲染SSR指南"><a href="#Vue-js-服务器端渲染SSR指南" class="headerlink" title="Vue.js 服务器端渲染SSR指南"></a>Vue.js 服务器端渲染SSR指南</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="什么是服务器端渲染-SSR-？"><a href="#什么是服务器端渲染-SSR-？" class="headerlink" title="什么是服务器端渲染 (SSR)？"></a>什么是服务器端渲染 (SSR)？</h3><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。</p><p>服务器渲染的 Vue.js 应用程序也可以被认为是”同构”或”通用”，因为应用程序的大部分代码都可以在<strong>服务器</strong>和<strong>客户端</strong>上运行。</p><h3 id="为什么使用服务器端渲染-SSR-？"><a href="#为什么使用服务器端渲染-SSR-？" class="headerlink" title="为什么使用服务器端渲染 (SSR)？"></a>为什么使用服务器端渲染 (SSR)？</h3><p>与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：</p><ul><li><p>更好的 SEO，由于搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</p><p>请注意，截至目前，Google 和 Bing 可以很好对同步 JavaScript 应用程序进行索引。在这里，同步是关键。如果你的应用程序初始展示 loading 菊花图，然后通过 Ajax 获取内容，抓取工具并不会等待异步完成后再行抓取页面内容。也就是说，如果 SEO 对你的站点至关重要，而你的页面又是异步获取内容，则你可能需要服务器端渲染(SSR)解决此问题。</p></li><li><p>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</p><p>无需等待所有的 JavaScript 都完成下载并执行，才显示服务器渲染的标记，所以你的用户将会更快速地看到完整渲染的页面。通常可以产生更好的用户体验，并且对于那些「内容到达时间(time-to-content) 与转化率直接相关」的应用程序而言，服务器端渲染 (SSR) 至关重要。</p></li></ul><p>使用服务器端渲染 (SSR) 时还需要有一些权衡之处：</p><ul><li>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</li><li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</li><li>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><h3 id="服务器端渲染-vs-预渲染-SSR-vs-Prerendering"><a href="#服务器端渲染-vs-预渲染-SSR-vs-Prerendering" class="headerlink" title="服务器端渲染 vs 预渲染 (SSR vs Prerendering)"></a>服务器端渲染 vs 预渲染 (SSR vs Prerendering)</h3><p>如果你调研服务器端渲染 (SSR) 只是用来改善少数营销页面（例如 <code>/</code>, <code>/about</code>, <code>/contact</code> 等）的 SEO，那么你可能需要<strong>预渲染</strong>。无需使用 web 服务器实时动态编译 HTML，而是使用预渲染方式，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点。</p><h2 id="编写通用代码"><a href="#编写通用代码" class="headerlink" title="编写通用代码"></a>编写通用代码</h2><h3 id="服务器上的数据响应"><a href="#服务器上的数据响应" class="headerlink" title="服务器上的数据响应"></a>服务器上的数据响应</h3><p>在纯客户端应用程序 (client-only app) 中，每个用户会在他们各自的浏览器中使用新的应用程序实例。对于服务器端渲染，我们也希望如此：每个请求应该都是全新的、独立的应用程序实例，以便不会有交叉请求造成的状态污染 (cross-request state pollution)。</p><p>因为实际的渲染过程需要确定性，所以我们也将在服务器上“预取”数据 (“pre-fetching” data) - 这意味着在我们开始渲染时，我们的应用程序就已经解析完成其状态。也就是说，将数据进行响应式的过程在服务器上是多余的，所以默认情况下禁用。<strong>禁用响应式数据</strong>，还可以避免将「数据」转换为「响应式对象」的性能开销。</p><h3 id="组件生命周期钩子函数"><a href="#组件生命周期钩子函数" class="headerlink" title="组件生命周期钩子函数"></a>组件生命周期钩子函数</h3><p>由于没有动态更新，所有的生命周期钩子函数中，只有 <code>beforeCreate</code> 和 <code>created</code> 会在服务器端渲染 (SSR) 过程中被调用。这就是说任何其他生命周期钩子函数中的代码（例如 <code>beforeMount</code> 或 <code>mounted</code>），只会在客户端执行。</p><p>避免在 <code>beforeCreate</code> 和 <code>created</code> 生命周期时产生全局副作用的代码</p><h3 id="访问特定平台-Platform-Specific-API"><a href="#访问特定平台-Platform-Specific-API" class="headerlink" title="访问特定平台(Platform-Specific) API"></a>访问特定平台(Platform-Specific) API</h3><p>通用代码不可接受特定平台的 API，因此如果你的代码中，直接使用了像 <code>window</code> 或 <code>document</code>，这种仅浏览器可用的全局变量，则会在 Node.js 中执行时抛出错误，反之也是如此。</p><h3 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h3><p>大多数自定义指令直接操作 DOM，因此会在服务器端渲染 (SSR) 过程中导致错误。有两种方法可以解决这个问题：</p><ul><li>推荐使用组件作为抽象机制，并运行在「虚拟 DOM 层级(Virtual-DOM level)」（例如，使用渲染函数(render function)）。</li><li>如果你有一个自定义指令，但是不是很容易替换为组件，则可以在创建服务器 renderer 时，使用 <a href="https://ssr.vuejs.org/zh/api/#directives" target="_blank" rel="noopener"><code>directives</code></a> 选项所提供”服务器端版本(server-side version)”。</li></ul><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><h3 id="避免状态单例避免状态单例"><a href="#避免状态单例避免状态单例" class="headerlink" title="避免状态单例避免状态单例"></a>避免状态单例避免状态单例</h3><p>当编写纯客户端 (client-only) 代码时，我们习惯于每次在新的上下文中对代码进行取值。但是，Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。</p><p><strong>为每个请求创建一个新的根 Vue 实例</strong>。这与每个用户在自己的浏览器中使用新应用程序的实例类似。如果我们在多个请求之间使用一个共享的实例，很容易导致交叉请求状态污染。因此，我们不应该直接创建一个应用程序实例，而是应该暴露一个可以重复执行的工厂函数，为每个请求创建新的应用程序实例</p><h3 id="介绍构建步骤"><a href="#介绍构建步骤" class="headerlink" title="介绍构建步骤"></a>介绍构建步骤</h3><p>对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7or6vnmpj30l808s75t.jpg" alt="image-20200729113332631"></p><h3 id="使用-webpack-的源码结构"><a href="#使用-webpack-的源码结构" class="headerlink" title="使用 webpack 的源码结构"></a>使用 webpack 的源码结构</h3><p>一个基本项目可能像是这样：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── components</span><br><span class="line">│   ├── Foo.vue</span><br><span class="line">│   ├── Bar.vue</span><br><span class="line">│   └── Baz.vue</span><br><span class="line">├── App.vue</span><br><span class="line">├── app.js # 通用 entry(universal entry)</span><br><span class="line">├── entry-client.js # 仅运行于浏览器</span><br><span class="line">└── entry-server.js # 仅运行于服务器</span><br></pre></td></tr></table></figure><h4 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a><code>app.js</code></h4><p><code>app.js</code> 是我们应用程序的「通用 entry」。在纯客户端应用程序中，我们将在此文件中创建根 Vue 实例，并直接挂载到 DOM。但是，对于服务器端渲染(SSR)，责任转移到纯客户端 entry 文件。<code>app.js</code> 简单地使用 export 导出一个 <code>createApp</code> 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App.vue'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出一个工厂函数，用于创建新的</span></span><br><span class="line"><span class="comment">// 应用程序、router 和 store 实例</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createApp</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    <span class="comment">// 根实例简单的渲染应用程序组件。</span></span><br><span class="line">    render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123; app &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="entry-client-js"><a href="#entry-client-js" class="headerlink" title="entry-client.js:"></a><code>entry-client.js</code>:</h4><p>客户端 entry 只需创建应用程序，并且将其挂载到 DOM 中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端特定引导逻辑……</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里假定 App.vue 模板中根元素具有 `id="app"`</span></span><br><span class="line">app.$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><h4 id="entry-server-js"><a href="#entry-server-js" class="headerlink" title="entry-server.js:"></a><code>entry-server.js</code>:</h4><p>服务器 entry 使用 default export 导出函数，并在每次渲染中重复调用此函数。此时，除了创建和返回应用程序实例之外，它不会做太多事情 - 但是稍后我们将在此执行服务器端路由匹配 (server-side route matching) 和数据预取逻辑 (data pre-fetching logic)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; app &#125; = createApp()</span><br><span class="line">  <span class="keyword">return</span> app</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据预取和状态"><a href="#数据预取和状态" class="headerlink" title="数据预取和状态"></a>数据预取和状态</h2><h3 id="数据预取存储容器-Data-Store"><a href="#数据预取存储容器-Data-Store" class="headerlink" title="数据预取存储容器 (Data Store)"></a>数据预取存储容器 (Data Store)</h3><p>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的”快照”，所以如果应用程序依赖于一些异步数据，<strong>那么在开始渲染过程之前，需要先预取和解析好这些数据</strong>。</p><p>另一个需要关注的问题是在客户端，在挂载 (mount) 到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。</p><p>获取的数据需要位于视图组件之外，即放置在专门的数据预取存储容器(data store)或”状态容器(state container)）”中。首先，在服务器端，我们可以在渲染之前预取数据，并将数据填充到 store 中。此外，我们将在 HTML 中序列化(serialize)和内联预置(inline)状态。这样，在挂载(mount)到客户端应用程序之前，可以直接从 store 获取到内联预置(inline)状态。</p><h3 id="带有逻辑配置的组件-Logic-Collocation-with-Components"><a href="#带有逻辑配置的组件-Logic-Collocation-with-Components" class="headerlink" title="带有逻辑配置的组件 (Logic Collocation with Components)"></a>带有逻辑配置的组件 (Logic Collocation with Components)</h3><p>事实上，给定路由所需的数据，也是在该路由上渲染组件时所需的数据。所以在路由组件中放置数据预取逻辑，是很自然的事情。</p><p>我们将在路由组件上暴露出一个自定义静态函数 <code>asyncData</code>。注意，由于此函数会在组件实例化之前调用，所以它无法访问 <code>this</code>。需要将 store 和路由信息作为参数传递进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- Item.vue --&gt;</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;&#123;&#123; item.title &#125;&#125;&lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  asyncData (&#123; store, route &#125;) &#123;</span><br><span class="line">    // 触发 action 后，会返回 Promise</span><br><span class="line">    return store.dispatch(&apos;fetchItem&apos;, route.params.id)</span><br><span class="line">  &#125;,</span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 从 store 的 state 对象中的获取 item。</span><br><span class="line">    item () &#123;</span><br><span class="line">      return this.$store.state.items[this.$route.params.id]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="服务器端数据预取-Server-Data-Fetching"><a href="#服务器端数据预取-Server-Data-Fetching" class="headerlink" title="服务器端数据预取 (Server Data Fetching)"></a>服务器端数据预取 (Server Data Fetching)</h3><p>在 <code>entry-server.js</code> 中，我们可以通过路由获得与 <code>router.getMatchedComponents()</code> 相匹配的组件，如果组件暴露出 <code>asyncData</code>，我们就调用这个方法。然后我们需要将解析完成的状态，附加到渲染上下文(render context)中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry-server.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">'./app'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> context =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</span><br><span class="line"></span><br><span class="line">    router.push(context.url)</span><br><span class="line"></span><br><span class="line">    router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> matchedComponents = router.getMatchedComponents()</span><br><span class="line">      <span class="keyword">if</span> (!matchedComponents.length) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(&#123; <span class="attr">code</span>: <span class="number">404</span> &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对所有匹配的路由组件调用 `asyncData()`</span></span><br><span class="line">      <span class="built_in">Promise</span>.all(matchedComponents.map(<span class="function"><span class="params">Component</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (Component.asyncData) &#123;</span><br><span class="line">          <span class="keyword">return</span> Component.asyncData(&#123;</span><br><span class="line">            store,</span><br><span class="line">            route: router.currentRoute</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 在所有预取钩子(preFetch hook) resolve 后，</span></span><br><span class="line">        <span class="comment">// 我们的 store 现在已经填充入渲染应用程序所需的状态。</span></span><br><span class="line">        <span class="comment">// 当我们将状态附加到上下文，</span></span><br><span class="line">        <span class="comment">// 并且 `template` 选项用于 renderer 时，</span></span><br><span class="line">        <span class="comment">// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span></span><br><span class="line">        context.state = store.state</span><br><span class="line"></span><br><span class="line">        resolve(app)</span><br><span class="line">      &#125;).catch(reject)</span><br><span class="line">    &#125;, reject)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用 <code>template</code> 时，<code>context.state</code> 将作为 <code>window.__INITIAL_STATE__</code> 状态，自动嵌入到最终的 HTML 中。而在客户端，在挂载到应用程序之前，store 就应该获取到状态：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry-client.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; app, router, store &#125; = createApp()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.__INITIAL_STATE__) &#123;</span><br><span class="line">  store.replaceState(<span class="built_in">window</span>.__INITIAL_STATE__)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端数据预取-Client-Data-Fetching"><a href="#客户端数据预取-Client-Data-Fetching" class="headerlink" title="客户端数据预取 (Client Data Fetching)"></a>客户端数据预取 (Client Data Fetching)</h3><p>在客户端，处理数据预取有两种不同方式：</p><ol><li><strong>在路由导航之前解析数据：</strong></li></ol><p>使用此策略，应用程序会等待视图所需数据全部解析之后，再传入数据并处理当前视图。好处在于，可以直接在数据准备就绪时，传入视图渲染完整内容，但是如果数据预取需要很长时间，用户在当前视图会感受到”明显卡顿”。因此，如果使用此策略，建议提供一个数据加载指示器 (data loading indicator)。</p><p>我们可以通过检查匹配的组件，并在全局路由钩子函数中执行 <code>asyncData</code> 函数，来在客户端实现此策略。注意，在初始路由准备就绪之后，我们应该注册此钩子，这样我们就不必再次获取服务器提取的数据。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entry-client.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...忽略无关代码</span></span><br><span class="line"></span><br><span class="line">router.onReady(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 添加路由钩子函数，用于处理 asyncData.</span></span><br><span class="line">  <span class="comment">// 在初始路由 resolve 后执行，</span></span><br><span class="line">  <span class="comment">// 以便我们不会二次预取(double-fetch)已有的数据。</span></span><br><span class="line">  <span class="comment">// 使用 `router.beforeResolve()`，以便确保所有异步组件都 resolve。</span></span><br><span class="line">  router.beforeResolve(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> matched = router.getMatchedComponents(to)</span><br><span class="line">    <span class="keyword">const</span> prevMatched = router.getMatchedComponents(<span class="keyword">from</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们只关心非预渲染的组件</span></span><br><span class="line">    <span class="comment">// 所以我们对比它们，找出两个匹配列表的差异组件</span></span><br><span class="line">    <span class="keyword">let</span> diffed = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">const</span> activated = matched.filter(<span class="function">(<span class="params">c, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> diffed || (diffed = (prevMatched[i] !== c))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!activated.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> next()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里如果有加载指示器 (loading indicator)，就触发</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">Promise</span>.all(activated.map(<span class="function"><span class="params">c</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.asyncData) &#123;</span><br><span class="line">        <span class="keyword">return</span> c.asyncData(&#123; store, <span class="attr">route</span>: to &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 停止加载指示器(loading indicator)</span></span><br><span class="line"></span><br><span class="line">      next()</span><br><span class="line">    &#125;).catch(next)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  app.$mount(<span class="string">'#app'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>匹配要渲染的视图后，再获取数据：</strong></li></ol><p>此策略将客户端数据预取逻辑，放在视图组件的 <code>beforeMount</code> 函数中。当路由导航被触发时，可以立即切换视图，因此应用程序具有更快的响应速度。然而，传入视图在渲染时不会有完整的可用数据。因此，对于使用此策略的每个视图组件，都需要具有条件加载状态。</p><p>这可以通过纯客户端 (client-only) 的全局 mixin 来实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Vue.mixin(&#123;</span><br><span class="line">  beforeMount () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; asyncData &#125; = <span class="keyword">this</span>.$options</span><br><span class="line">    <span class="keyword">if</span> (asyncData) &#123;</span><br><span class="line">      <span class="comment">// 将获取数据操作分配给 promise</span></span><br><span class="line">      <span class="comment">// 以便在组件中，我们可以在数据准备就绪后</span></span><br><span class="line">      <span class="comment">// 通过运行 `this.dataPromise.then(...)` 来执行其他任务</span></span><br><span class="line">      <span class="keyword">this</span>.dataPromise = asyncData(&#123;</span><br><span class="line">        store: <span class="keyword">this</span>.$store,</span><br><span class="line">        route: <span class="keyword">this</span>.$route</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="客户端激活-client-side-hydration"><a href="#客户端激活-client-side-hydration" class="headerlink" title="客户端激活 (client-side hydration)"></a>客户端激活 (client-side hydration)</h2><p>所谓客户端激活，指的是 Vue 在浏览器端接管由服务端发送的静态 HTML，使其变为由 Vue 管理的动态 DOM 的过程。</p><p>在 <code>entry-client.js</code> 中，我们用下面这行挂载(mount)应用程序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里假定 App.vue template 根元素的 `id="app"`</span></span><br><span class="line">app.$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure><p>由于服务器已经渲染好了 HTML，我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要”激活”这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。</p><p>如果你检查服务器渲染的输出结果，你会注意到应用程序的根元素上添加了一个特殊的属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;app&quot; data-server-rendered=&quot;true&quot;&gt;</span><br></pre></td></tr></table></figure><p><code>data-server-rendered</code> 特殊属性，让客户端 Vue 知道这部分 HTML 是由 Vue 在服务端渲染的，并且应该以激活模式进行挂载。注意，这里并没有添加 <code>id=&quot;app&quot;</code>，而是添加 <code>data-server-rendered</code> 属性：你需要自行添加 ID 或其他能够选取到应用程序根元素的选择器，否则应用程序将无法正常激活。</p><p>注意，在没有 <code>data-server-rendered</code> 属性的元素上，还可以向 <code>$mount</code> 函数的 <code>hydrating</code> 参数位置传入 <code>true</code>，来强制使用激活模式(hydration)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 强制使用应用程序的激活模式</span></span><br><span class="line">app.$mount(<span class="string">'#app'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>在开发模式下，Vue 将推断客户端生成的虚拟 DOM 树 (virtual DOM tree)，是否与从服务器渲染的 DOM 结构 (DOM structure) 匹配。如果无法匹配，它将退出混合模式，丢弃现有的 DOM 并从头开始渲染。<strong>在生产模式下，此检测会被跳过，以避免性能损耗</strong></p><h3 id="一些需要注意的坑"><a href="#一些需要注意的坑" class="headerlink" title="一些需要注意的坑"></a>一些需要注意的坑</h3><p>使用「SSR + 客户端混合」时，需要了解的一件事是，浏览器可能会更改的一些特殊的 HTML 结构。例如，当你在 Vue 模板中写入：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器会在 <code>&lt;table&gt;</code> 内部自动注入 <code>&lt;tbody&gt;</code>，然而，由于 Vue 生成的虚拟 DOM (virtual DOM) 不包含 <code>&lt;tbody&gt;</code>，所以会导致无法匹配。为能够正确匹配，请确保在模板中写入有效的 HTML。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Vue-js-服务器端渲染SSR指南&quot;&gt;&lt;a href=&quot;#Vue-js-服务器端渲染SSR指南&quot; class=&quot;headerlink&quot; title=&quot;Vue.js 服务器端渲染SSR指南&quot;&gt;&lt;/a&gt;Vue.js 服务器端渲染SSR指南&lt;/h1&gt;&lt;h2 id=&quot;介
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js学习笔记（四）</title>
    <link href="http://yoursite.com/2020/07/17/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/07/17/深入浅出Node.js学习笔记（四）/</id>
    <published>2020-07-17T03:26:23.000Z</published>
    <updated>2020-08-01T06:11:58.335Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Node-js学习笔记（四）"><a href="#深入浅出Node-js学习笔记（四）" class="headerlink" title="深入浅出Node.js学习笔记（四）"></a>深入浅出Node.js学习笔记（四）</h1><h2 id="第九章-玩转进程"><a href="#第九章-玩转进程" class="headerlink" title="第九章 玩转进程"></a>第九章 玩转进程</h2><h3 id="服务模型的变迁"><a href="#服务模型的变迁" class="headerlink" title="服务模型的变迁"></a>服务模型的变迁</h3><h4 id="石器时代-同步"><a href="#石器时代-同步" class="headerlink" title="石器时代:同步"></a>石器时代:同步</h4><p>它的服务模式是一次只为一个请求服务，所有请求都 得按次序等待服务。这意味除了当前的请求被处理外，其余请求都处于耽误的状态。它的处理能 力相当低下，假设每次响应服务耗用的时间稳定为N秒，这类服务的QPS为1/N。</p><h4 id="青铜时代-复制进程"><a href="#青铜时代-复制进程" class="headerlink" title="青铜时代:复制进程"></a>青铜时代:复制进程</h4><p>通过进程的复制同时服务更多的请求和用 户。这样每个连接都需要一个进程来服务，即100个连接需要启动100个进程来进行服务，这是非 常昂贵的代价。在进程复制的过程中，需要复制进程内部的状态，对于每个连接都进行这样的复 制的话，相同的状态将会在内存中存在很多份，造成浪费。并且这个过程由于要复制较多的数据， 启动是较为缓慢的。</p><p>为了解决启动缓慢的问题，预复制(prefork)被引入服务模型中，即预先复制一定数量的进 程。同时将进程复用，避免进程创建、销毁带来的开销。</p><p>假设通过进行复制和预复制的方式搭建的服务器有资源的限制，且进程数上限为M，那这类 服务的QPS为M/N。</p><h4 id="白银时代-多线程"><a href="#白银时代-多线程" class="headerlink" title="白银时代:多线程"></a>白银时代:多线程</h4><p>让一个线程服务一个请求。线程相 对进程的开销要小许多，并且线程之间可以共享数据，内存浪费的问题可以得到解决，并且利用线 程池可以减少创建和销毁线程的开销。</p><p>由于一个CPU核心在 一个时刻只能做一件事情，操作系统只能通过将CPU切分为时间片的方法，让线程可以较为均匀地 使用CPU资源，但是操作系统内核在切换线程的同时也要切换线程的上下文，当线程数量过多时， 时间将会被耗用在上下文切换中。所以在大并发量时，多线程结构还是无法做到强大的伸缩性。</p><p>如果忽略掉多线程上下文切换的开销，假设线程所占用的资源为进程的1/L，受资源上限的 影响，它的QPS则为M * L/N。</p><h4 id="黄金时代-事件驱动"><a href="#黄金时代-事件驱动" class="headerlink" title="黄金时代:事件驱动"></a>黄金时代:事件驱动</h4><p>由于所有处理都在单线程上进行，影响事件驱动服务模型性能的点在于CPU的计算能力，它 的上限决定这类服务模型的性能上限，但它不受多进程或多线程模式中资源上限的影响，可伸缩 性远比前两者高。</p><h3 id="多进程架构"><a href="#多进程架构" class="headerlink" title="多进程架构"></a>多进程架构</h3><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gglqcw4nqij30h307vt98.jpg" alt="image-20200710114641594"></p><p>Master-Worker模式，又称主从模式。</p><p>图9-1中的进程分为两种:主进程和工 作进程。这是典型的分布式架构中用于并行处理业务的模式，具备较好的可伸缩性和稳定性。主 进程不负责具体的业务处理，而是负责调度或管理工作进程，它是趋向于稳定的。工作进程负责 具体的业务处理，因为业务的多种多样，甚至一项业务由多人开发完成，所以工作进程的稳定性 值得开发者关注。</p><h4 id="创建子进程"><a href="#创建子进程" class="headerlink" title="创建子进程"></a>创建子进程</h4><p>child_process模块给予Node可以随意创建子进程(child_process)的能力。它提供了4个方 法用于创建子进程。</p><ul><li><p>spawn():启动一个子进程来执行命令。</p></li><li><p>exec():启动一个子进程来执行命令，与spawn()不同的是其接口不同，它有一个回调函数获知子进程的状况。</p></li><li><p>execFile():启动一个子进程来执行可执行文件。</p></li><li><p>fork():与spawn()类似，不同点在于它创建Node的子进程只需指定要执行的JavaScript文件模块即可。</p><ul><li><p>spawn()与exec()、execFile()不同的是，后两者创建时可以指定timeout属性设置超时时间，一旦创建的进程运行超过设定的时间将会被杀死。</p></li><li><p>exec()与execFile()不同的是，exec()适合执行已有的命令，execFile()适合执行文件。</p></li><li><p>如果是JavaScript文件通过execFile()运行，它的首行内容必须添加如下代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gglqlz21blj30mw05t74s.jpg" alt="image-20200710115527844"></p><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>为了实现父子进程之间的通信，父进程与子进程之间将会创建IPC通道。通过IPC通道，父子进程之间才能通过message和send()传递消息。</p><h5 id="进程间通信原理"><a href="#进程间通信原理" class="headerlink" title="进程间通信原理"></a>进程间通信原理</h5><p>IPC的全称是Inter-Process Communication，即进程间通信。进程间通信的目的是为了让不同 的进程能够互相访问资源并进行协调工作。</p><p>Node中实现IPC通道的是管道(pipe) 技术。表现在应 4 用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gglxlb7bbxj30av08j3yw.jpg" alt="image-20200710155651836"></p><p>父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正创建出子进程，并通 过环境变量(NODE_CHANNEL_FD)告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中， 根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gglxmpsgpjj30bg06b3ys.jpg" alt="image-20200710155822149"></p><p>IPC通道属于双向通信。在Node中，IPC通道被抽象为Stream对 象，在调用send()时发送数据(类似于write())，接收到的消息会通过message事件(类似于data) 触发给应用层。</p><h4 id="句柄传递"><a href="#句柄传递" class="headerlink" title="句柄传递"></a>句柄传递</h4><p>通过代理，可以避免端口不能重复监听的问题，甚至可以在代理进程上做适当的负载均衡， 使得每个子进程可以较为均衡地执行任务。由于进程每接收到一个连接，将会用掉一个文件描述 符，因此代理方案中客户端连接到代理进程，代理进程连接到工作进程的过程需要用掉两个文件 描述符。操作系统的文件描述符是有限的，代理方案浪费掉一倍数量的文件描述符的做法影响了 系统的扩展能力。</p><p>句柄是一种可以用来标识资源的引用，它的内部包含了指向对象的文件描述 符。</p><p>发送句柄意味着什么?在前一个问题中，我们可以去掉代理这种方案，使主进程接收到socket 请求后，将这个socket直接发送给工作进程，而不是重新与工作进程之间建立新的socket连接来转 发数据。文件描述符浪费的问题可以通过这样的方式轻松解决。</p><h5 id="1-句柄发送与还原"><a href="#1-句柄发送与还原" class="headerlink" title="1. 句柄发送与还原"></a>1. 句柄发送与还原</h5><p>目前子进程对象send()方法可以发送的句柄类型包括如下几种。</p><ul><li><p>net.Socket。TCP套接字。</p></li><li><p>net.Server。TCP服务器，任意建立在TCP服务上的应用层服务都可以享受到它带来的</p><p>好处。</p></li><li><p>net.Native。C++层面的TCP套接字或IPC管道。</p></li><li><p>dgram.Socket。UDP套接字。</p></li><li><p>dgram.Native。C++层面的UDP套接字。</p></li></ul><p>send()方法在将消息发送到IPC管道前，将消息组装成两个对象，一个参数是handle，另一个 是message。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  cmd: <span class="string">'NODE_HANDLE'</span>, </span><br><span class="line">  type: <span class="string">'net.Server'</span>, </span><br><span class="line">  msg: message</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送到IPC管道中的实际上是我们要发送的句柄文件描述符，文件描述符实际上是一个整数 值。这个message对象在写入到IPC管道时也会通过JSON.stringify()进行序列化。所以最终发送 到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任意对象。</p><p>连接了IPC通道的子进程可以读取到父进程发来的消息，将字符串通过JSON.parse()解析还 原为对象后，才触发message事件将消息体传递给应用层使用。在这个过程中，消息对象还要被 进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage。</p><p>如果message.cmd值为NODE_HANDLE，它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gglyc7wck2j30ic02xq38.jpg" alt="image-20200710162252691"></p><p><strong>Node进程之间只有消息传递，不会真正地传递对象，这种错 觉是抽象封装的结果。</strong></p><h5 id="2-端口共同监听"><a href="#2-端口共同监听" class="headerlink" title="2. 端口共同监听"></a>2. 端口共同监听</h5><p>Node底层对每个端口监听都设置了SO_REUSEADDR选项，这个选项的涵义是不同进程可以就相 同的网卡和端口进行监听，这个服务器端套接字可以被不同的进程复用</p><p>由于独立启动的进程互相之间并不知道文件描述符，所以监听相同端口时就会失败。但对于 send()发送的句柄还原出来的服务而言，它们的文件描述符是相同的，所以监听相同端口不会引 起异常。</p><p>多个应用监听相同端口时，文件描述符同一时间只能被某个进程所用。换言之就是网络请求 向服务器端发送时，只有一个幸运的进程能够抢到连接，也就是说只有它能为这个请求进行服务。 这些进程服务是抢占式的。</p><h3 id="集群稳定之路"><a href="#集群稳定之路" class="headerlink" title="集群稳定之路"></a>集群稳定之路</h3><h4 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h4><ul><li>error:当子进程无法被复制创建、无法被杀死、无法发送消息时会触发该事件。</li><li>exit:子进程退出时触发该事件，子进程如果是正常退出，这个事件的第一个参数为退出 码，否则为null。如果进程是通过kill()方法被杀死的，会得到第二个参数，它表示杀死进程时的信号。kill()方法并不能真正地将通过IPC相连的子进程杀死，它只是给子进程 发送了一个系统信号。默认情况下，父进程将通过kill()方法给子进程发送一个SIGTERM信号。</li><li>close:在子进程的标准输入输出流中止时触发该事件，参数与exit相同。</li><li>disconnect:在父进程或子进程中调用disconnect()方法时触发该事件，在调用该方法时将关闭监听IPC通道。</li></ul><h4 id="自动重启"><a href="#自动重启" class="headerlink" title="自动重启"></a>自动重启</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggqaeax7u9j30eg06h0tc.jpg" alt="image-20200714102219158"></p><h5 id="1-自杀信号"><a href="#1-自杀信号" class="headerlink" title="1. 自杀信号"></a>1. 自杀信号</h5><p>在退出的流程中增加一个自杀 (suicide)信号。工作进程在得知要退出时，向主进程发送一个自杀信号，然后才停止接收新的 连接，当所有连接断开后才退出。主进程在接收到自杀信号后，立即创建新的工作进程服务。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggt0p7zb2ij30fy0890td.jpg" alt="image-20200716190328377"></p><h5 id="2-限量重启"><a href="#2-限量重启" class="headerlink" title="2. 限量重启"></a>2. 限量重启</h5><p>工 作进程不能无限制地被重启，如果启动的过程中就发生了错误，或者启动后接到连接就收到错误， 会导致工作进程被频繁重启，这种频繁重启不属于我们捕捉未知异常的情况，因为这种短时间内 频繁重启已经不符合预期的设置，极有可能是程序编写的错误。</p><p>为了消除这种无意义的重启，在满足一定规则的限制下，不应当反复重启。比如在单位时间 内规定只能重启多少次，超过限制就触发giveup事件，告知放弃重启工作进程这个重要事件。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>保证多个处理单元工作量公平的策略叫负载均衡。</p><p>Node默认提供的机制是采用操作系统的抢占式策略。所谓的抢占式就是在一堆工作进程中，闲着的进程对到来的请求进行争抢，谁抢到谁服务。</p><p>对于Node而言，需要分清的是它的繁忙是由CPU、I/O两个部分构成的，影响抢占的是CPU 的繁忙度。对不同的业务，可能存在I/O繁忙，而CPU较为空闲的情况，这可能造成某个进程能 够抢到较多请求，形成负载不均衡的情况。</p><p>Round-Robin，又叫轮叫调度。轮叫调度的工作方式是由主进程接受连接，将其依次分发给工作 进程。分发的策略是在N个工作进程中，每次选择第i = (i + 1) mod n个进程来发送连接。</p><p>Round-Robin非常简单，可以避免CPU和I/O繁忙差异导致的负载不均衡。Round-Robin策略也 可以通过代理服务器来实现，但是它会导致服务器上消耗的文件描述符是平常方式的两倍。</p><h4 id="状态共享"><a href="#状态共享" class="headerlink" title="状态共享"></a>状态共享</h4><p>Node进程中不宜存放太多数据，Node也不允许在多个进程之间共享数据</p><h5 id="1-第三方数据存储"><a href="#1-第三方数据存储" class="headerlink" title="1. 第三方数据存储"></a>1. 第三方数据存储</h5><p>解决数据共享最直接、简单的方式就是通过第三方来进行数据存储，比如将数据存放到数据 库、磁盘文件、缓存服务(如Redis)中，所有工作进程启动时将其读取进内存中。但这种方式 存在的问题是如果数据发生改变，还需要一种机制通知到各个子进程，使得它们的内部状态也得 到更新。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggt22eodjej30ge0bkq3m.jpg" alt="image-20200716195047959"></p><p>定时轮询带来的问题是轮询时间不能过密，如果子进程过多，会形成并发处理，如果数据没 有发生改变，这些轮询会没有意义，白白增加查询状态的开销。如果轮询时间过长，数据发生改 变时，不能及时更新到子进程中，会有一定的延迟。</p><h5 id="2-主动通知"><a href="#2-主动通知" class="headerlink" title="2. 主动通知"></a>2. 主动通知</h5><p>当数据发生更新时，主动通知子进程。</p><p>我们将这种用来发送通知和查询状态是否更改的进程叫做通知进程。为了不混合业务逻辑，可以 将这个进程设计为只进行轮询和通知，不处理任何业务逻辑</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggt23zalzij30g00dkwf5.jpg" alt="image-20200716195217372"></p><p>这种推送机制如果按进程间信号传递，在跨多台服务器时会无效，是故可以考虑采用TCP或 UDP的方案。进程在启动时从通知服务处除了读取第一次数据外，还将进程信息注册到通知服务 处。一旦通过轮询发现有数据更新后，根据注册信息，将更新后的数据发送给工作进程。由于不 涉及太多进程去向同一地方进行状态查询，状态响应处的压力不至于太过巨大，单一的通知服务 轮询带来的压力并不大，所以可以将轮询时间调整得较短，一旦发现更新，就能实时地推送到各 个子进程中。</p><h3 id="Cluster-模块"><a href="#Cluster-模块" class="headerlink" title="Cluster 模块"></a>Cluster 模块</h3><p>v0.8时直接引入了cluster模块，用以解决多核CPU的利用率问题，同时也提供了较完 善的API，用以处理进程的健壮性问题</p><h4 id="Cluster-工作原理"><a href="#Cluster-工作原理" class="headerlink" title="Cluster 工作原理"></a>Cluster 工作原理</h4><p>cluster模块就是child_process和net模块的组合应用。</p><p>cluster启动时，如同我们在 9.2.3节里的代码一样，它会在内部启动TCP服务器，在cluster.fork()子进程时，将这个TCP服 务器端socket的文件描述符发送给工作进程。如果进程是通过cluster.fork()复制出来的，那么 它的环境变量里就存在NODE_UNIQUE_ID，如果工作进程中存在listen()侦听网络端口的调用，它 将拿到该文件描述符，通过SO_REUSEADDR端口重用，从而实现多个子进程共享端口。对于普通方 式启动的进程，则不存在文件描述符传递共享等事情。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggt27qmj1bj30fy0633yu.jpg" alt="image-20200716195554501"></p><h4 id="Cluster-事件"><a href="#Cluster-事件" class="headerlink" title="Cluster 事件"></a>Cluster 事件</h4><ul><li>fork:复制一个工作进程后触发该事件。</li><li>online:复制好一个工作进程后，工作进程主动发送一条online消息给主进程，主进程收到消息后，触发该事件。</li><li>listening:工作进程中调用listen()(共享了服务器端Socket)后，发送一条listening消息给主进程，主进程收到消息后，触发该事件。</li><li>disconnect:主进程和工作进程之间IPC通道断开后会触发该事件。</li><li>exit:有工作进程退出时触发该事件。</li><li>setup:cluster.setupMaster()执行后触发该事件。</li></ul><h2 id="第十章-测试"><a href="#第十章-测试" class="headerlink" title="第十章 测试"></a>第十章 测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="单元测试的意义"><a href="#单元测试的意义" class="headerlink" title="单元测试的意义"></a>单元测试的意义</h4><p>编写可测试代码的原则：</p><ul><li><p>单一职责。如果一段代码承担的职责越多，为其编写单元测试的时候就要构造更多的输入数据，然后推测它的输出。</p></li><li><p>接口抽象。通过对程序代码进行接口抽象后，我们可以针对接口进行测试，而具体代码</p><p>实现的变化不影响为接口编写的单元测试。</p></li><li><p>层次分离。层次分离实际上是单一职责的一种实现。在MVC结构的应用中，就是典型的层次分离模型，如果不分离各个层次，无法想象这个代码该如何切入测试。通过分层之后，可以逐层测试，逐层保证。</p></li></ul><h4 id="单元测试介绍"><a href="#单元测试介绍" class="headerlink" title="单元测试介绍"></a>单元测试介绍</h4><p>单元测试主要包含断言、测试框架、测试用例、测试覆盖率、mock、持续集成等几个方面， 由于Node的特殊性，它还会加入异步代码测试和私有方法的测试这两个部分。</p><h5 id="1-断言"><a href="#1-断言" class="headerlink" title="1. 断言"></a>1. 断言</h5><p>断言就是单元测试中用来保证最小单元是否正常的检测方法。断言用于检查程序在运行时是否满足期望。</p><p>在断言规范中，我们定义了以下几种检测方法。</p><ul><li>ok():判断结果是否为真。</li><li>equal():判断实际值与期望值是否相等。</li><li>notEqual():判断实际值与期望值是否不相等。</li><li>deepEqual():判断实际值与期望值是否深度相等(对象或数组的元素是否相等)。 </li><li>notDeepEqual():判断实际值与期望值是否不深度相等。</li><li>strictEqual():判断实际值与期望值是否严格相等(相当于===)</li><li>notStrictEqual():判断实际值与期望值是否不严格相等(相当于!==)。 </li><li>throws():判断代码块是否抛出异常。</li><li>doesNotThrow():判断代码块是否没有抛出异常。</li><li>ifError():判断实际值是否为一个假值(null、undefined、0、’’、false)，如果实际值为真值，将会抛出异常。</li></ul><h5 id="2-测试框架"><a href="#2-测试框架" class="headerlink" title="2. 测试框架"></a>2. 测试框架</h5><p>测试框架用于为测试服务，它本身并不参与测试，主要用于管理测试用例和生成测试报告， 提升测试用例的开发速度，提高测试用例的可维护性和可读性，以及一些周边性的工作。</p><h6 id="测试风格"><a href="#测试风格" class="headerlink" title="测试风格"></a>测试风格</h6><p>我们将测试用例的不同组织方式称为测试风格，现今流行的单元测试风格主要有TDD(测试驱动开发)和BDD(行为驱动开发)两种，它们的差别如下所示。</p><ul><li>关注点不同。TDD关注所有功能是否被正确实现，每一个功能都具备对应的测试用例;BDD关注整体行为是否符合预期，适合自顶向下的设计方式。</li><li>表达方式不同。TDD的表述方式偏向于功能说明书的风格;BDD的表述方式更接近于自然语言的习惯。</li></ul><p>BDD对测试用例的组织主要采用describe和it进行组织。describe可以描述多层级的结构， 具体到测试用例时，用it。另外，它还提供before、after、beforeEach和afterEach这4个钩子方 法，用于协助describe中测试用例的准备、安装、卸载和回收等工作。before和after分别在进入 和退出describe时触发执行，beforeEach和afterEach则分别在describe中每一个测试用例(it) 执行前和执行后触发执行。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggt3snv1jij30jl07h75l.jpg" alt="image-20200716205032544"></p><p>TDD对测试用例的组织主要采用suite和test完成。suite也可以实现多层级描述，测试用例用test。它提供的钩子函数仅包含setup和teardown，对应BDD中的before和after。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggt3tbuuwqj30h307ojsn.jpg" alt="image-20200716205116492"></p><h5 id="3-测试用例"><a href="#3-测试用例" class="headerlink" title="3. 测试用例"></a>3. 测试用例</h5><p>测试用例最少需要通过正向测试和反向测试来保证测试对功能的覆盖，这是最基本的测试用 例。对于Node而言，不仅有这样简单的方法调用，还有异步代码和超时设置需要关注。</p><h5 id="4-私有方法的测试"><a href="#4-私有方法的测试" class="headerlink" title="4. 私有方法的测试"></a>4. 私有方法的测试</h5><p>rewire模块提供了一种巧妙的 方式实现对私有方法的访问。每一个被rewire引入的模块都有<strong>set</strong>()和<strong>get</strong>()方法。它巧妙地利用了闭包的诀窍，在eval()执行时，实现了对模块内部局部变量的访问，从而可以将局部变量导出给测试用例调用执行。</p><h4 id="工程化与自动化"><a href="#工程化与自动化" class="headerlink" title="工程化与自动化"></a>工程化与自动化</h4><h5 id="1-工程化"><a href="#1-工程化" class="headerlink" title="1. 工程化"></a>1. 工程化</h5><p>Node在*nix系统下可以很好地利用一些成熟工具，其中Makefile比较小巧灵活，适合用来构建工程。</p><ul><li>Makefile文件的缩进必须是tab符号，不能用空格。</li><li>记得在包描述文件中配置blanket。</li></ul><h5 id="2-持续集成"><a href="#2-持续集成" class="headerlink" title="2. 持续集成"></a>2. 持续集成</h5><p>GitHub提供了代码托管和社交编程的良好环境，程 序员们可以在上面很社交化地进行代码的clone、fork、pull request、issues等操作，travis-ci则补足了GitHub在持续集成方面的缺点。Git版本控制系统提供了hook机制，用户在push代码后会 触发一个hook脚本，而travis-ci即是通过这种方式与GitHub衔接起来的。</p><p>(1) 在<a href="https://travis-ci.org/上通过OAuth授权绑定你的GitHub账号。" target="_blank" rel="noopener">https://travis-ci.org/上通过OAuth授权绑定你的GitHub账号。</a></p><p>(2) 在GitHub仓库的管理面板(admin)中打开services hook页，在这个页面中可以发现GitHub 上提供了很多基于git hook方式的钩子服务。</p><p>(3) 找到travis服务，点击激活即可。<br>(4) 每次将代码push到GitHub的仓库上后，将会触发该钩子服务。</p><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><p>基准测试要统计的就是在多少 时间内执行了多少次某个方法。为了增强可比性，一般会以次数作为参照物，然后比较时间，以 此来判别性能的差距。</p><h4 id="压力测试"><a href="#压力测试" class="headerlink" title="压力测试"></a>压力测试</h4><p>对网络接口做压力测试需要考查的几个指标有吞吐率、响应时间和 并发数，这些指标反映了服务器的并发处理能力。</p><p>最常用的工具是ab、siege、http_load等</p><h4 id="基准测试驱动开发"><a href="#基准测试驱动开发" class="headerlink" title="基准测试驱动开发"></a>基准测试驱动开发</h4><p>BDD，全称为Benchmark Driven Development，即基准测试驱动开发</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggt4d1thjgj30hz06574u.jpg" alt="image-20200716211012072"></p><h2 id="第十一章-产品化"><a href="#第十一章-产品化" class="headerlink" title="第十一章 产品化"></a>第十一章 产品化</h2><h3 id="项目工程化"><a href="#项目工程化" class="headerlink" title="项目工程化"></a>项目工程化</h3><p>所谓的工程化，可以理解为项目的组织能力。体现在文件上，就是文件的组织能力。对于不同 类型的项目，其组织方式也有所不同。除此之外，还应当有能够将整个项目串联起来的灵魂性文件。</p><h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>常见的Web应用都是以MVC为主要框架的，其余部分在这个基础上进行扩展。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><h4 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h4><p>异常日志通常用来记录那些意外产生的异常错误。通过日志的记录，开发者可以根据异常信 息去定位bug出现的具体位置，以快速修复问题。</p><p>异常日志通常有完善的分级，Node中提供的console对象就简单地实现了这几种划分</p><ul><li>console.log:普通日志。 </li><li>console.info:普通信息。 </li><li>console.warn:警告信息。</li><li>console.error:错误信息。</li></ul><h3 id="监控报警"><a href="#监控报警" class="headerlink" title="监控报警"></a>监控报警</h3><h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><ol><li>日志监控</li><li>响应时间</li><li>进程监控</li><li>磁盘监控</li><li>内存监控</li><li>CPU占用监控</li><li>CPU load监控</li><li>I/O负载</li><li>网络监控</li><li>应用状态监控</li><li>DNS监控</li></ol><h4 id="报警的实现"><a href="#报警的实现" class="headerlink" title="报警的实现"></a>报警的实现</h4><ul><li>邮件报警</li><li>短信或电话报警</li></ul><h4 id="监控系统的稳定性"><a href="#监控系统的稳定性" class="headerlink" title="监控系统的稳定性"></a>监控系统的稳定性</h4><h3 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h3><ul><li>多机器</li><li>多机房</li><li>容灾备份</li></ul><h1 id="完结撒花🎉"><a href="#完结撒花🎉" class="headerlink" title="完结撒花🎉"></a>完结撒花🎉</h1><p>（终于把这本书看完了，笔记也不是很认真，希望以后在实践中慢慢领悟吧～）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Node-js学习笔记（四）&quot;&gt;&lt;a href=&quot;#深入浅出Node-js学习笔记（四）&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Node.js学习笔记（四）&quot;&gt;&lt;/a&gt;深入浅出Node.js学习笔记（四）&lt;/h1&gt;&lt;h2 id=&quot;第
      
    
    </summary>
    
      <category term="Node.js" scheme="http://yoursite.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>行业黑话</title>
    <link href="http://yoursite.com/2020/07/10/%E8%A1%8C%E4%B8%9A%E9%BB%91%E8%AF%9D/"/>
    <id>http://yoursite.com/2020/07/10/行业黑话/</id>
    <published>2020-07-10T06:32:51.000Z</published>
    <updated>2020-08-01T06:11:58.336Z</updated>
    
    <content type="html"><![CDATA[<h1 id="行业黑话"><a href="#行业黑话" class="headerlink" title="行业黑话"></a>行业黑话</h1><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggtyk9h37uj31p90u0n5x.jpg" alt="img"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;行业黑话&quot;&gt;&lt;a href=&quot;#行业黑话&quot; class=&quot;headerlink&quot; title=&quot;行业黑话&quot;&gt;&lt;/a&gt;行业黑话&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/007S8ZIlgy1ggtyk9h37uj
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出Node.js学习笔记（三）</title>
    <link href="http://yoursite.com/2020/07/02/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%20/"/>
    <id>http://yoursite.com/2020/07/02/深入浅出Node.js学习笔记（三） /</id>
    <published>2020-07-01T16:35:24.000Z</published>
    <updated>2020-07-01T16:41:03.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深入浅出Node-js学习笔记（三）"><a href="#深入浅出Node-js学习笔记（三）" class="headerlink" title="深入浅出Node.js学习笔记（三）"></a>深入浅出Node.js学习笔记（三）</h1><h2 id="第七章-网络编程"><a href="#第七章-网络编程" class="headerlink" title="第七章 网络编程"></a>第七章 网络编程</h2><h3 id="构建TCP服务"><a href="#构建TCP服务" class="headerlink" title="构建TCP服务"></a>构建TCP服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP全名为传输控制协议，在OSI模型(由七层组成，分别为物理层、数据链结层、网络层、 传输层、会话层、表示层、应用层)中属于传输层协议。许多应用层协议基于TCP构建，典型的 是HTTP、SMTP、IMAP等协议。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga6odzsgm4j30f00ecgmy.jpg" alt="image-20191223151304958"></p><p>TCP是面向连接的协议，其显著的特征是在传输之前需要3次握手形成会话</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga6oefcwg4j30hm0hwmy7.jpg" alt="image-20191223151332410"></p><p>只有会话形成之后，服务器端和客户端之间才能互相发送数据。在创建会话的过程中，服务 器端和客户端分别提供一个套接字，这两个套接字共同形成一个连接。服务器端与客户端则通过 套接字实现两者之间连接的操作。</p><h4 id="创建TCP服务器端"><a href="#创建TCP服务器端" class="headerlink" title="创建TCP服务器端"></a>创建TCP服务器端</h4><p>创建一个TCP服务器端来接受网络请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> server = net.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 新的连接</span></span><br><span class="line">  socket.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    socket.write(<span class="string">"你好"</span>); </span><br><span class="line">  &#125;);</span><br><span class="line">  socket.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'连接断开'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">  socket.write(<span class="string">"欢迎光临《深入浅出Node.js》示例:\n"</span>); </span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8124</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server bound'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过net.createServer(listener)即可创建一个TCP服务器，listener是连接事件connection的侦听器</p><p>也可以采用如下的方式进行侦听:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> server = net.createServer();</span><br><span class="line">server.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 新的连接</span></span><br><span class="line">&#125;); server.listen(<span class="number">8124</span>);</span><br></pre></td></tr></table></figure><p>我们可以利用Telnet工具作为客户端对刚才创建的简单服务器进行会话交流</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ telnet <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="number">8124</span></span><br><span class="line">Trying <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is <span class="string">'^]'</span>. 欢迎光临《深入浅出Node.js》示例: </span><br><span class="line">hi</span><br><span class="line">你好</span><br></pre></td></tr></table></figure><p>除了端口外，同样我们也可以对Domain Socket进行监听</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server.listen(<span class="string">'/tmp/echo.sock'</span>);</span><br></pre></td></tr></table></figure><p>通过net模块自行构造客户端进行会话</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> net = <span class="built_in">require</span>(<span class="string">'net'</span>);</span><br><span class="line"><span class="keyword">var</span> client = net.connect(&#123;<span class="attr">port</span>: <span class="number">8124</span>&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">//'connect' listener</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>);</span><br><span class="line">  client.write(<span class="string">'world!\r\n'</span>); </span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">  client.end();</span><br><span class="line">&#125;);</span><br><span class="line">client.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client disconnected'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>将以上客户端代码存为client.js并执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node client.js</span><br><span class="line">client connected 欢迎光临《深入浅出Node.js》示例:</span><br><span class="line"></span><br><span class="line">你好</span><br><span class="line">client disconnected</span><br></pre></td></tr></table></figure><h4 id="TCP-服务的事件"><a href="#TCP-服务的事件" class="headerlink" title="TCP 服务的事件"></a>TCP 服务的事件</h4><h5 id="1-服务器事件"><a href="#1-服务器事件" class="headerlink" title="1. 服务器事件"></a>1. 服务器事件</h5><p>对于通过net.createServer()创建的服务器而言，它是一个EventEmitter实例，它的自定义 事件有如下几种。</p><ul><li>listening:在调用server.listen()绑定端口或者Domain Socket后触发，简洁写法为 server.listen(port,listeningListener)，通过listen()方法的第二个参数传入。</li><li>connection:每个客户端套接字连接到服务器端时触发，简洁写法为通过net.createServer()，最后一个参数传递。</li></ul><ul><li>close:当服务器关闭时触发，在调用server.close()后，服务器将停止接受新的套接字连接，但保持当前存在的连接，等待所有连接都断开后，会触发该事件。</li><li>error:当服务器发生异常时，将会触发该事件。比如侦听一个使用中的端口，将会触发 一个异常，如果不侦听error事件，服务器将会抛出异常。</li></ul><h5 id="2-连接事件"><a href="#2-连接事件" class="headerlink" title="2. 连接事件"></a>2. 连接事件</h5><p>服务器可以同时与多个客户端保持连接，对于每个连接而言是典型的可写可读Stream对象。 Stream对象可以用于服务器端和客户端之间的通信，既可以通过data事件从一端读取另一端发来 的数据，也可以通过write()方法从一端向另一端发送数据。它具有如下自定义事件。</p><ul><li>data:当一端调用write()发送数据时，另一端会触发data事件，事件传递的数据即是 write()发送的数据。</li><li>end:当连接中的任意一端发送了FIN数据时，将会触发该事件。</li><li>connect:该事件用于客户端，当套接字与服务器端连接成功时会被触发。</li><li>drain:当任意一端调用write()发送数据时，当前这端会触发该事件。</li><li>error:当异常发生时，触发该事件。</li><li>close:当套接字完全关闭时，触发该事件。</li><li>timeout:当一定时间后连接不再活跃时，该事件将会被触发，通知用户当前该连接已经被闲置了。</li></ul><p>TCP针对网络中的小数据包有一定的优化策略:Nagle算法。如果每次只发送一个字节的内容而不优化，网络中将充满只有极少数有效数据的数据包，将十分浪费网络资源。 Nagle算法针对这种情况，要求缓冲区的数据达到一定数量或者一定时间后才将其发出，所以小 数据包将会被Nagle算法合并，以此来优化网络。这种优化虽然使网络带宽被有效地使用，但是 数据有可能被延迟发送。</p><p>在Node中，由于TCP默认启用了Nagle算法，可以调用socket.setNoDelay(true)去掉Nagle算 法，使得write()可以立即发送数据到网络中。</p><p>尽管在网络的一端调用write()会触发另一端的data事件，但是并不 意味着每次write()都会触发一次data事件，在关闭掉Nagle算法后，另一端可能会将接收到的多 个小数据包合并，然后只触发一次data事件。</p><h3 id="构建UDP服务"><a href="#构建UDP服务" class="headerlink" title="构建UDP服务"></a>构建UDP服务</h3><p>UDP又称用户数据包协议，与TCP一样同属于网络传输层。UDP与TCP最大的不同是UDP不是 面向连接的。在UDP中，一个套接字可以与多个UDP服务通信，它 虽然提供面向事务的简单不可靠信息传输服务，在网络差的情况下存在丢包严重的问题，但是由于 它无须连接，资源消耗低，处理快速且灵活。</p><h4 id="创建UDP套接字"><a href="#创建UDP套接字" class="headerlink" title="创建UDP套接字"></a>创建UDP套接字</h4><p>创建UDP套接字十分简单，UDP套接字一旦创建，既可以作为客户端发送数据，也可以作为服务器端接收数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">var</span> socket = dgram.createSocket(<span class="string">"udp4"</span>);</span><br></pre></td></tr></table></figure><h4 id="创建UDP服务器端"><a href="#创建UDP服务器端" class="headerlink" title="创建UDP服务器端"></a>创建UDP服务器端</h4><p>若想让UDP套接字接收网络消息，只要调用dgram.bind(port, [address])方法对网卡和端口进行绑定即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">"dgram"</span>);</span><br><span class="line"><span class="keyword">var</span> server = dgram.createSocket(<span class="string">"udp4"</span>);</span><br><span class="line">server.on(<span class="string">"message"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">msg, rinfo</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"server got: "</span> + msg + <span class="string">" from "</span> +</span><br><span class="line">rinfo.address + <span class="string">":"</span> + rinfo.port); </span><br><span class="line">&#125;);</span><br><span class="line">server.on(<span class="string">"listening"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> address = server.address();</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"server listening "</span> + address.address + <span class="string">":"</span> + address.port);</span><br><span class="line">&#125;); </span><br><span class="line">server.bind(<span class="number">41234</span>);</span><br></pre></td></tr></table></figure><p>该套接字将接收所有网卡上41234端口上的消息。在绑定完成后，将触发listening事件。</p><h4 id="创建UDP客户端"><a href="#创建UDP客户端" class="headerlink" title="创建UDP客户端"></a>创建UDP客户端</h4><p>我们创建一个客户端与服务器端进行对话</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dgram = <span class="built_in">require</span>(<span class="string">'dgram'</span>);</span><br><span class="line"><span class="keyword">var</span> message = <span class="keyword">new</span> Buffer(<span class="string">"深入浅出Node.js"</span>);</span><br><span class="line"><span class="keyword">var</span> client = dgram.createSocket(<span class="string">"udp4"</span>);</span><br><span class="line">client.send(message, <span class="number">0</span>, message.length, <span class="number">41234</span>, <span class="string">"localhost"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, bytes</span>) </span>&#123;</span><br><span class="line">  client.close(); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>保存为client.js并执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br><span class="line">server listening <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">41234</span></span><br><span class="line">server got: 深入浅出Node.js <span class="keyword">from</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">58682</span></span><br></pre></td></tr></table></figure><p>当套接字对象用在客户端时，可以调用send()方法发送消息到网络中。send()方法的参数如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socket.send(buf, offset, length, port, address, [callback])</span><br></pre></td></tr></table></figure><p>这些参数分别为要发送的Buffer、Buffer的偏移、Buffer的长度、目标端口、目标地址、发送 完成后的回调。与TCP套接字的write()相比，send()方法的参数列表相对复杂，但是它更灵活的 地方在于可以随意发送数据到网络中的服务器端，而TCP如果要发送数据给另一个服务器端，则 需要重新通过套接字构造新的连接。</p><h4 id="UDP-套接字事件"><a href="#UDP-套接字事件" class="headerlink" title="UDP 套接字事件"></a>UDP 套接字事件</h4><p>UDP套接字相对TCP套接字使用起来更简单，它只是一个EventEmitter的实例，而非Stream的实例。它具备如下自定义事件。</p><ul><li>message:当UDP套接字侦听网卡端口后，接收到消息时触发该事件，触发携带的数据为 消息Buffer对象和一个远程地址信息。</li><li>listening:当UDP套接字开始侦听时触发该事件。</li><li>close:调用close()方法时触发该事件，并不再触发message事件。如需再次触发message事件，重新绑定即可。</li><li>error:当异常发生时触发该事件，如果不侦听，异常将直接抛出，使进程退出。</li></ul><h3 id="构建HTTP服务"><a href="#构建HTTP服务" class="headerlink" title="构建HTTP服务"></a>构建HTTP服务</h3><p>构建HTTP服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>); http.createServer(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br><span class="line">  res.end(<span class="string">'Hello World\n'</span>);</span><br><span class="line">&#125;).listen(<span class="number">1337</span>, <span class="string">'127.0.0.1'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Server running at http://127.0.0.1:1337/'</span>);</span><br></pre></td></tr></table></figure><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP的全称是超文本传输协议，英文写作HyperText Transfer Protocol。</p><p>HTTP构建在TCP之上，属于应用层协议。在HTTP的两 端是服务器和浏览器，即著名的B/S模式。</p><p>HTTP是基于请求响应式的，以一问一答的方式实 现服务，虽然基于TCP会话，但是本身却并无会话的特点。</p><p>HTTP服务只做两件事情:处理HTTP请求和发送HTTP响应</p><h4 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h4><p>Node的http模块包含对HTTP处理的封装。在Node中，HTTP服务继承自TCP服务器(net模块)，它能够与多个客户端保持连接，由于其采用事件驱动的形式，并不为每一个连接创建额外的线程或进程，保持很低的内存占用，所以能实现高并发。HTTP服务与TCP服务模型有区别的 地方在于，在开启keepalive后，一个TCP会话可以用于多次请求和响应。TCP服务以connection 为单位进行服务，HTTP服务以request为单位进行服务。http模块即是将connection到request的 过程进行了封装</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga6qfnzupdj310q0d2wfl.jpg" alt="image-20191223162355440"></p><p>http模块将连接所用套接字的读写抽象为ServerRequest和ServerResponse对象， 它们分别对应请求和响应操作。在请求产生的过程中，http模块拿到连接中传来的数据，调用二 进制模块http_parser进行解析，在解析完请求报文的报头后，触发request事件，调用用户的业 务逻辑。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga6qhkd2djj30og0m2jst.jpg" alt="image-20191223162545615"></p><h5 id="1-HTTP请求"><a href="#1-HTTP请求" class="headerlink" title="1. HTTP请求"></a>1. HTTP请求</h5><p>对于TCP连接的读操作，http模块将其封装为ServerRequest对象。报文头部将会通过http_parser进行解析。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; GET / HTTP/1.1</span><br><span class="line">&gt; User-Agent: curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5 2</span><br><span class="line">&gt; Host: 127.0.0.1:1337 &gt; Accept: */*</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>报文头第一行GET / HTTP/1.1被解析之后分解为如下属性。</p><ul><li>req.method属性:值为GET，是为请求方法，常见的请求方法有GET、POST、DELETE、PUT、CONNECT等几种。</li><li>req.url属性:值为/。</li><li>req.httpVersion属性:值为1.1。</li></ul><p>其余报头是很规律的Key: Value格式，被解析后放置在req.headers属性上传递给业务逻辑以供调用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">headers: &#123; </span><br><span class="line">  <span class="string">'user-agent'</span>: <span class="string">'curl/7.24.0 (x86_64-apple-darwin12.0) libcurl/7.24.0 OpenSSL/0.9.8r zlib/1.2.5'</span>,</span><br><span class="line">    host: <span class="string">'127.0.0.1:1337'</span>, </span><br><span class="line">    accept: <span class="string">'*/*'</span> </span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>报文体部分则抽象为一个只读流对象，如果业务逻辑需要读取报文体中的数据，则要在这个 数据流结束后才能进行操作</p><h5 id="2-HTTP响应"><a href="#2-HTTP响应" class="headerlink" title="2. HTTP响应"></a>2. HTTP响应</h5><p>它封装了对底层连接的写操作，可以将 其看成一个可写的流对象。它影响响应报文头部信息的API为res.setHeader()和res. writeHead()。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;);</span><br></pre></td></tr></table></figure><p>可以调用setHeader进行多次设置，但只有调用writeHead后，报头才会写入到连接中。除此之外，http模块会自动帮你设置一些头信息</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt; <span class="built_in">Date</span>: Sat, <span class="number">06</span> Apr <span class="number">2013</span> <span class="number">08</span>:<span class="number">01</span>:<span class="number">44</span> GMT</span><br><span class="line">&lt; Connection: keep-alive</span><br><span class="line">&lt; Transfer-Encoding: chunked </span><br><span class="line">&lt;</span><br></pre></td></tr></table></figure><p>报文体部分则是调用res.write()和res.end()方法实现，后者与前者的差别在于res.end()会 先调用write()发送数据，然后发送信号告知服务器这次响应结束</p><p>响应结束后，HTTP服务器可能会将当前的连接用于下一个请求，或者关闭连接。</p><p>报头是在报文体发送前发送的，一旦开始了数据的发送，writeHead()和setHeader()将不 再生效。这由协议的特性决定。</p><p>无论服务器端在处理业务逻辑时是否发生异常，务必在结束时调用res.end()结束请 求，否则客户端将一直处于等待的状态。当然，也可以通过延迟res.end()的方式实现客户端与 服务器端之间的长连接，但结束时务必关闭连接。</p><h5 id="3-HTTP服务的事件"><a href="#3-HTTP服务的事件" class="headerlink" title="3. HTTP服务的事件"></a>3. HTTP服务的事件</h5><ul><li>connection事件:在开始HTTP请求和响应前，客户端与服务器端需要建立底层的TCP连接，这个连接可能因为开启了keep-alive，可以在多次请求响应之间使用;当这个连接建立时，服务器触发一次connection事件。</li><li>request事件:建立TCP连接后，http模块底层将在数据流中抽象出HTTP请求和HTTP响应，当请求数据发送到服务器端，在解析出HTTP请求头后，将会触发该事件;在res.end() 后，TCP连接可能将用于下一次请求响应。</li><li>close事件:与TCP服务器的行为一致，调用server.close()方法停止接受新的连接，当已有的连接都断开时，触发该事件;可以给server.close()传递一个回调函数来快速注册该事件。</li><li>checkContinue事件:某些客户端在发送较大的数据时，并不会将数据直接发送，而是先发送一个头部带Expect: 100-continue的请求到服务器，服务器将会触发checkContinue 事件;如果没有为服务器监听这个事件，服务器将会自动响应客户端100 Continue的状态码，表示接受数据上传;如果不接受数据的较多时，响应客户端400 Bad Request拒绝客 户端继续发送数据即可。需要注意的是，当该事件发生时不会触发request事件，两个事件之间互斥。当客户端收到100 Continue后重新发起请求时，才会触发request事件。</li><li>connect事件:当客户端发起CONNECT请求时触发，而发起CONNECT请求通常在HTTP代理时出现;如果不监听该事件，发起该请求的连接将会关闭。</li><li>upgrade事件:当客户端要求升级连接的协议时，需要和服务器端协商，客户端会在请求 头中带上Upgrade字段，服务器端会在接收到这样的请求时触发该事件。这在后文的 WebSocket部分有详细流程的介绍。如果不监听该事件，发起该请求的连接将会关闭。</li><li>clientError事件:连接的客户端触发error事件时，这个错误会传递到服务器端，此时触发该事件。</li></ul><h4 id="HTTP-客户端"><a href="#HTTP-客户端" class="headerlink" title="HTTP 客户端"></a>HTTP 客户端</h4><p>http模块提供了一个底层API:http.request(options, connect)，用于构造HTTP客户端</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> options = &#123; </span><br><span class="line">  hostname: <span class="string">'127.0.0.1'</span>, </span><br><span class="line">  port: <span class="number">1334</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'GET'</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">var</span> req = http.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'STATUS: '</span> + res.statusCode);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'HEADERS: '</span> + <span class="built_in">JSON</span>.stringify(res.headers));</span><br><span class="line">  res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk);</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure><p>其中options参数决定了这个HTTP请求头中的内容</p><ul><li>host:服务器的域名或IP地址，默认为localhost。</li><li>hostname:服务器名称。</li><li>port:服务器端口，默认为80。</li><li>localAddress:建立网络连接的本地网卡。 </li><li>socketPath:Domain套接字路径。</li><li>method:HTTP请求方法，默认为GET。</li><li>path:请求路径，默认为/。</li><li>headers:请求头对象。</li><li>auth:Basic认证，这个值将被计算成请求头中的Authorization部分。</li></ul><p>报文体的内容由请求对象的write()和end()方法实现:通过write()方法向连接中写入数据， 通过end()方法告知报文结束。它与浏览器中的Ajax调用几近相同，Ajax的实质就是一个异步的 网络HTTP请求。</p><h5 id="1-HTTP响应"><a href="#1-HTTP响应" class="headerlink" title="1. HTTP响应"></a>1. HTTP响应</h5><p>在ClientRequest对象中，它的事件叫做 response。ClientRequest在解析响应报文时，一解析完响应头就触发response事件，同时传递一 个响应对象以供操作ClientResponse。后续响应报文体以只读流的方式提供</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'STATUS: '</span> + res.statusCode);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'HEADERS: '</span> + <span class="built_in">JSON</span>.stringify(res.headers));</span><br><span class="line">  res.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(chunk); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-HTTP-代理"><a href="#2-HTTP-代理" class="headerlink" title="2. HTTP 代理"></a>2. HTTP 代理</h5><p>http提供的ClientRequest对象也是基于TCP层实现的，在 keepalive的情况下，一个底层会话连接可以多次用于请求。为了重用TCP连接，http模块包含一 个默认的客户端代理对象http.globalAgent。它对每个服务器端(host + port)创建的连接进行了 管理，默认情况下，通过ClientRequest对象对同一个服务器端发起的HTTP请求最多可以创建5 个连接。它的实质是一个连接池</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga6smaeshbj30lc0l8jtb.jpg" alt="image-20191223173929894"></p><p>调用HTTP客户端同时对一个服务器发起10次HTTP请求时，其实质只有5个请求处于并发状态，后续的请求需要等待某个请求完成服务后才真正发出。这与浏览器对同一个域名有下载连接 数的限制是相同的行为。</p><p>设置agent选项为false值，以脱离连接池的管理，使得请求不受并发的限制。Agent对象的sockets和requests属性分别表示当前连接池中使用中的连接数和处于等待状态 的请求数，在业务中监视这两个值有助于发现业务状态的繁忙程度。</p><h5 id="3-HTTP客户端事件"><a href="#3-HTTP客户端事件" class="headerlink" title="3. HTTP客户端事件"></a>3. HTTP客户端事件</h5><ul><li>response:与服务器端的request事件对应的客户端在请求发出后得到服务器端响应时， 会触发该事件。</li></ul><ul><li>socket:当底层连接池中建立的连接分配给当前请求对象时，触发该事件。</li><li>connect:当客户端向服务器端发起CONNECT请求时，如果服务器端响应了200状态码，客户端将会触发该事件。 </li><li>upgrade:客户端向服务器端发起Upgrade请求时，如果服务器端响应了101 Switching Protocols状态，客户端将会触发该事件。</li><li>continue:客户端向服务器端发起Expect: 100-continue头信息，以试图发送较大数据量，如果服务器端响应100 Continue状态，客户端将触发该事件。</li></ul><h3 id="构建WebSocket服务"><a href="#构建WebSocket服务" class="headerlink" title="构建WebSocket服务"></a>构建WebSocket服务</h3><ul><li>WebSocket客户端基于事件的编程模型与Node中自定义事件相差无几。</li><li>WebSocket实现了客户端与服务器端之间的长连接，而Node事件驱动的方式十分擅长与大量的客户端保持高并发连接。</li></ul><p>WebSocket与传统HTTP有如下好处：</p><ul><li>客户端与服务器端只建立一个TCP连接，可以使用更少的连接。</li><li>WebSocket服务器端可以推送数据到客户端，这远比HTTP请求响应模式更灵活、更高效。 </li><li>有更轻量级的协议头，减少数据传送量。</li></ul><p>浏览器与服务器端创建WebSocket协议请求，在请求完成后连接打开，每50毫 秒向服务器端发送一次数据，同时可以通过onmessage()方法接收服务器端传来的数据。能够双向通信。</p><p>长轮询的原理是客户端向服务器端发起请求， 服务器端只在超时或有数据响应时断开连接(res.end());客户端在收到数据或者超时后重新发起请求。</p><p>WebSocket更接近于传输层协 议，它并没有在HTTP的基础上模拟服务器端的推送，而是在TCP上定义独立的协议。</p><p>WebSocket协议主要分为两个部分:<strong>握手和数据传输。</strong></p><h4 id="WebSocket-握手"><a href="#WebSocket-握手" class="headerlink" title="WebSocket 握手"></a>WebSocket 握手</h4><p>客户端建立连接时，通过HTTP发起请求报文</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/chat</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Host</span>: server.example.com</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ== </span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat </span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><p>与普通的HTTP请求协议略有区别的部分在于如下这些协议头</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Upgrade</span>: websocket </span><br><span class="line"><span class="attribute">Connection</span>: Upgrade</span><br></pre></td></tr></table></figure><p>上述两个字段表示请求服务器端升级协议为WebSocket。</p><p>其中Sec-WebSocket-Key用于安全校验：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Sec-WebSocket-Key</span>: dGhlIHNhbXBsZSBub25jZQ==</span><br></pre></td></tr></table></figure><p>Sec-WebSocket-Key的值是随机生成的Base64编码的字符串。服务器端接收到之后将其与字符串258EAFA5-E914-47DA-95CA-C5AB0DC85B11相连，形成字符串dGhlIHNhbXBsZSBub25jZQ==258EAFA5- 3 E914-47DA-95CA-C5AB0DC85B11，然后通过sha1安全散列算法计算出结果后，再进行Base64编码， 最后返回给客户端。</p><p>算法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> crypto = <span class="built_in">require</span>(<span class="string">'crypto'</span>);</span><br><span class="line"><span class="keyword">var</span> val = crypto.createHash(<span class="string">'sha1'</span>).update(key).digest(<span class="string">'base64'</span>);</span><br></pre></td></tr></table></figure><p>下面两个字段指定子协议和版本号:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat, superchat </span><br><span class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</span><br></pre></td></tr></table></figure><p>服务器端在处理完请求后，响应如下报文</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</span><br><span class="line"><span class="attribute">Upgrade</span>: websocket</span><br><span class="line"><span class="attribute">Connection</span>: Upgrade 6 Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=</span><br><span class="line"><span class="attribute">Sec-WebSocket-Protocol</span>: chat</span><br></pre></td></tr></table></figure><p>上面的报文告之客户端正在更换协议，更新应用层协议为WebSocket协议，并在当前的套接 字连接上应用新协议。剩余的字段分别表示服务器端基于Sec-WebSocket-Key生成的字符串和选中的子协议。客户端将会校验Sec-WebSocket-Accept的值，如果成功，将开始接下来的数据传输。</p><p>一旦WebSocket握手成功，服务器端与客户端将会呈现对等的效果，都能接收和发送消息。</p><h4 id="WebSocket-数据传输"><a href="#WebSocket-数据传输" class="headerlink" title="WebSocket 数据传输"></a>WebSocket 数据传输</h4><p>在握手顺利完成后，当前连接将不再进行HTTP的交互，而是开始WebSocket的数据帧协议，实现客户端与服务器端的数据交换</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7v775i6uj30lg0k6jsy.jpg" alt="image-20191224155417997"></p><p>握手完成后，客户端的onopen()将会被触发执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">socket.onopen = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> opened()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务器端则没有onopen()方法可言</p><p>为了完成TCP套接字事件到WebSocket事件的封装，需要在接收数据时进行处理，WebSocket的数据帧协议即是在底层data事件上封装完成的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">WebSocket.prototype.setSocket = <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.socket = socket;</span><br><span class="line">  <span class="keyword">this</span>.socket.on(<span class="string">'data'</span>, <span class="keyword">this</span>.receiver);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样的数据发送时，也需要做封装操作</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebSocket.prototype.send = <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>._send(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当客户端调用send()发送数据时，服务器端触发onmessage();当服务器端调用send()发送数据时，客户端的onmessage()触发。当我们调用send()发送一条数据时，协议可能将这个数据封装 为一帧或多帧数据，然后逐帧发送。</p><p>为了安全考虑，客户端需要对发送的数据帧进行掩码处理，服务器一旦收到无掩码帧(比如 中间拦截破坏)，连接将关闭。而服务器发送到客户端的数据帧则无须做掩码处理，同样，如果客户端收到带掩码的数据帧，连接也将关闭。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7ws1ac04j311m0f0wg0.jpg" alt="image-20191224164858601"></p><p>每8位为一列，也即1个字节</p><ul><li>fin:如果这个数据帧是最后一帧，这个fin位为1，其余情况为0。当一个数据没有被分为 多帧时，它既是第一帧也是最后一帧。</li><li>rsv1、rsv2、rsv3:各为1位长，3个标识用于扩展，当有已协商的扩展时，这些值可能为 1，其余情况为0。</li><li>opcode:长为4位的操作码，可以用来表示0到15的值，用于解释当前数据帧。<ul><li>0表示附加数据帧</li><li>1表示文本数据帧</li><li>2表示二进制数据帧</li><li>8表示发送一个连接关闭的数据帧</li><li>9 表示ping数据帧</li><li>10表示pong数据帧（ping数据帧和pong数据帧用于心跳检测，当一端发送ping数据帧时，另一端必须发送pong数据帧作为响应，告知对方这一端仍然处于响应状态。）</li><li>其余值暂时没有定义。</li></ul></li><li>masked:表示是否进行掩码处理，长度为1。客户端发送给服务器端时为1，服务器端发送给客户端时为0。</li><li>payload length:一个7、7+16或7+64位长的数据位，标识数据的长度<ul><li>如果值在0~125 之间，那么该值就是数据的真实长度;</li><li>如果值是126，则后面16位的值是数据的真实长度; </li><li>如果值是127，则后面64位的值是数据的真实长度</li></ul></li><li>masking key:当masked为1时存在，是一个32位长的数据位，用于解密数据。 </li><li>payload data:我们的目标数据，位数为8的倍数。</li></ul><p>客户端发送消息时，需要构造一个或多个数据帧协议报文。</p><h3 id="网络服务与安全"><a href="#网络服务与安全" class="headerlink" title="网络服务与安全"></a>网络服务与安全</h3><p>SSL作为一种安全协议，它在传输层提供对网络连接加密的功能。对于应用层而 言，它是透明的，数据在传递到应用层之前就已经完成了加密和解密的过程。</p><p>最初的SSL应用在 Web上，被服务器端和浏览器端同时支持，随后IETF将其标准化，称为TLS(Transport Layer Security，安全传输层协议)。</p><p>Node在网络安全上提供了3个模块，分别为crypto、tls、https。其中crypto主要用于加密解密。tls模块提供了与net模块类似的功能，区别在于它建立在TLS/SSL加密的TCP 连接上。对于https而言，它完全与http模块接口一致，区别也仅在于它建立于安全的连接 之上。</p><h4 id="TLS-SSL"><a href="#TLS-SSL" class="headerlink" title="TLS/SSL"></a>TLS/SSL</h4><h5 id="1-密钥"><a href="#1-密钥" class="headerlink" title="1. 密钥"></a>1. 密钥</h5><p>TLS/SSL是一个公钥/私钥的结构，它是一个非对称的结构，每个服务器端和客户端都有自己 的公私钥。公钥用来加密要传输的数据，私钥用来解密接收到的数据。公钥和私钥是配对的，通 过公钥加密的数据，只有通过私钥才能解密，所以在建立安全传输之前，客户端和服务器端之间 需要互换公钥。客户端发送数据时要通过服务器端的公钥进行加密，服务器端发送数据时则需要 客户端的公钥进行加密，如此才能完成加密解密的过程</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga7x4t082vj311e0fm40g.jpg" alt="image-20191224170115187"></p><p>Node在底层采用的是openssl实现TLS/SSL的，为此要生成公钥和私钥可以通过openssl完成。</p><p>我们分别为服务器端和客户端生成私钥</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成服务器端私钥</span></span><br><span class="line">$ openssl genrsa -out server.key <span class="number">1024</span> </span><br><span class="line"><span class="comment">// 生成客户端私钥</span></span><br><span class="line">$ openssl genrsa -out client.key <span class="number">1024</span></span><br></pre></td></tr></table></figure><p>上述命令生成了两个1024位长的RSA私钥文件，我们可以通过它继续生成公钥</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ openssl rsa -<span class="keyword">in</span> server.key -pubout -out server.pem</span><br><span class="line">$ openssl rsa -<span class="keyword">in</span> client.key -pubout -out client.pem</span><br></pre></td></tr></table></figure><p>中间人攻击：为了解决这种问题，数据传 输过程中还需要对得到的公钥进行认证，以确认得到的公钥是出自目标服务器。如果不能保证这 种认证，中间人可能会将伪造的站点响应给用户，从而造成经济损失。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga80yq45adj30oa0bujs6.jpg" alt="image-20191224191346081"></p><p>TLS/SSL引入了数字证书来进行认证。与直接用公钥不同，数字证书中 包含了服务器的名称和主机名、服务器的公钥、签名颁发机构的名称、来自签名颁发机构的签名。 在连接建立前，会通过证书中的签名确认收到的公钥是来自目标服务器的，从而产生信任关系。</p><h5 id="2-数字证书"><a href="#2-数字证书" class="headerlink" title="2. 数字证书"></a>2. 数字证书</h5><p>CA(Certificate Authority，数字证 书认证中心)。CA的作用是为站点颁发证书，且这个证书中具有CA通过自己的公钥和私钥实现 的签名。</p><p>为了得到签名证书，服务器端需要通过自己的私钥生成CSR(Certificate Signing Request，证 书签名请求)文件。CA机构将通过这个文件颁发属于该服务器端的签名证书，只要通过CA机构 就能验证证书是否合法。</p><p>自签名证书：自己扮演CA机构，给自 己的服务器端颁发签名证书。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ openssl genrsa -out ca.key <span class="number">1024</span></span><br><span class="line">$ openssl req -<span class="keyword">new</span> -key ca.key -out ca.csr</span><br><span class="line">$ openssl x509 -req -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga8117jmefj30hu0a8q3i.jpg" alt="image-20191224191611387"></p><p>服务器端需要向CA机构申请签名证书。这个过程中的 Common Name要匹配服务器域名，否则在后续的认证过程中会出错。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl req -<span class="keyword">new</span> -key server.key -out server.csr</span><br></pre></td></tr></table></figure><p>签名过程需要CA的证书和私钥参与， 最终颁发一个带有CA签名的证书</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -<span class="keyword">in</span> server.csr -out server.crt</span><br></pre></td></tr></table></figure><p>客户端在发起安全连接前会去获取服务器端的证书，并通过CA的证书验证服务器端证书的 真伪。除了验证真伪外，通常还含有对服务器名称、IP地址等进行验证的过程。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1ga813fr14qj30su09w0tp.jpg" alt="image-20191224191819509"></p><p>CA机构将证书颁发给服务器端后，证书在请求的过程中会被发送给客户端，客户端需要通 过CA的证书验证真伪。如果是知名的CA机构，它们的证书一般预装在浏览器中。如果是自己扮 演CA机构，颁发自有签名证书则不能享受这个福利，客户端需要获取到CA的证书才能进行验证。</p><p>上述的过程中可以看出，签名证书是一环一环地颁发的，但是在CA那里的证书是不需要上 级证书参与签名的，这个证书我们通常称为根证书。</p><h4 id="TLS-服务"><a href="#TLS-服务" class="headerlink" title="TLS 服务"></a>TLS 服务</h4><h5 id="1-创建服务器端"><a href="#1-创建服务器端" class="headerlink" title="1. 创建服务器端"></a>1. 创建服务器端</h5><p>创建一个安全的TCP服务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tls = <span class="built_in">require</span>(<span class="string">'tls'</span>); </span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'./keys/server.key'</span>), </span><br><span class="line">  cert: fs.readFileSync(<span class="string">'./keys/server.crt'</span>),</span><br><span class="line">  requestCert: <span class="literal">true</span>,</span><br><span class="line">  ca: [ fs.readFileSync(<span class="string">'./keys/ca.crt'</span>) ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> server = tls.createServer(options, <span class="function"><span class="keyword">function</span> (<span class="params">stream</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server connected'</span>, stream.authorized ? <span class="string">'authorized'</span> : <span class="string">'unauthorized'</span>);</span><br><span class="line">  stream.write(<span class="string">"welcome!\n"</span>);</span><br><span class="line">  stream.setEncoding(<span class="string">'utf8'</span>);</span><br><span class="line">  stream.pipe(stream);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">8000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'server bound'</span>); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动上述服务后，通过下面的命令可以测试证书是否正常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ openssl s_client -connect <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span></span><br></pre></td></tr></table></figure><h5 id="2-TLS客户端"><a href="#2-TLS客户端" class="headerlink" title="2. TLS客户端"></a>2. TLS客户端</h5><p>模拟客户端，要为客户端生成属于自己的私钥和 签名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建私钥</span></span><br><span class="line">$ openssl genrsa -out client.key <span class="number">1024</span></span><br><span class="line"><span class="comment">// 生成CSR</span></span><br><span class="line">$ openssl req -<span class="keyword">new</span> -key client.key -out client.csr</span><br><span class="line"><span class="comment">// 生成签名证书</span></span><br><span class="line">$ openssl x509 -req -CA ca.crt -CAkey ca.key -CAcreateserial -<span class="keyword">in</span> client.csr -out client.crt</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//并创建客户端，代码如下:</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line"><span class="keyword">var</span> tls = <span class="built_in">require</span>(<span class="string">'tls'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'./keys/client.key'</span>), </span><br><span class="line">  cert: fs.readFileSync(<span class="string">'./keys/client.crt'</span>), </span><br><span class="line">  ca: [ fs.readFileSync(<span class="string">'./keys/ca.crt'</span>) ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stream = tls.connect(<span class="number">8000</span>, options, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'client connected'</span>, stream.authorized ? <span class="string">'authorized'</span> : <span class="string">'unauthorized'</span>);</span><br><span class="line">  process.stdin.pipe(stream);</span><br><span class="line">&#125;);</span><br><span class="line">stream.setEncoding(<span class="string">'utf8'</span>); </span><br><span class="line">stream.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data); </span><br><span class="line">&#125;);</span><br><span class="line">stream.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  server.close();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动客户端的过程中，用到了为客户端生成的私钥、证书、CA证书。客户端启动之后可以 9 在输入流中输入数据，服务器端将会回应相同的数据。</p><p>至此我们完成了TLS的服务器端和客户端的创建。与普通的TCP服务器端和客户端相比，TLS 的服务器端和客户端仅仅只在证书的配置上有差别，其余部分基本相同。</p><h4 id="HTTPS-服务"><a href="#HTTPS-服务" class="headerlink" title="HTTPS 服务"></a>HTTPS 服务</h4><h5 id="1-准备证书"><a href="#1-准备证书" class="headerlink" title="1. 准备证书"></a>1. 准备证书</h5><p>HTTPS服务需要用到私钥和签名证书，我们可以直接用上文生成的私钥和证书。</p><h5 id="2-创建HTTPS服务"><a href="#2-创建HTTPS服务" class="headerlink" title="2. 创建HTTPS服务"></a>2. 创建HTTPS服务</h5><p>创建HTTPS服务只比HTTP服务多一个选项配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>); </span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  key: fs.readFileSync(<span class="string">'./keys/server.key'</span>), </span><br><span class="line">  cert: fs.readFileSync(<span class="string">'./keys/server.crt'</span>)</span><br><span class="line">&#125;;</span><br><span class="line">https.createServer(options, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(<span class="string">"hello world\n"</span>);</span><br><span class="line">&#125;).listen(<span class="number">8000</span>);</span><br></pre></td></tr></table></figure><h5 id="3-HTTPS客户端"><a href="#3-HTTPS客户端" class="headerlink" title="3. HTTPS客户端"></a>3. HTTPS客户端</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">'https'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>); </span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">  hostname: <span class="string">'localhost'</span>,</span><br><span class="line">  port: <span class="number">8000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>, </span><br><span class="line">  method: <span class="string">'GET'</span>,</span><br><span class="line">  key: fs.readFileSync(<span class="string">'./keys/client.key'</span>),</span><br><span class="line">  cert: fs.readFileSync(<span class="string">'./keys/client.crt'</span>),</span><br><span class="line">  ca: [fs.readFileSync(<span class="string">'./keys/ca.crt'</span>)]</span><br><span class="line">&#125;;</span><br><span class="line">options.agent = <span class="keyword">new</span> https.Agent(options);</span><br><span class="line"><span class="keyword">var</span> req = https.request(options, <span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  res.setEncoding(<span class="string">'utf-8'</span>);</span><br><span class="line">  res.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(d); </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;); </span><br><span class="line">req.end();</span><br><span class="line">req.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="第八章-构建Web应用"><a href="#第八章-构建Web应用" class="headerlink" title="第八章 构建Web应用"></a>第八章 构建Web应用</h2><h3 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h3><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>最常见的请求方法是GET和POST，除此之外，还有HEAD、DELETE、PUT、CONNECT等方法。</p><p>HTTP_Parser在解析请求报文的时候，将报文头抽取出来，设置为req.method。</p><p>通过请求方法来决定响应行为：PUT代表新建一个资源，POST表示要更新一个资源，GET表示查看一个资源， 而DELETE表示删除一个资源。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">switch</span> (req.method) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'POST'</span>:</span><br><span class="line">      update(req, res);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'DELETE'</span>:</span><br><span class="line">      remove(req, res);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'PUT'</span>:</span><br><span class="line">      create(req, res);</span><br><span class="line">      <span class="keyword">break</span>; </span><br><span class="line">    <span class="keyword">case</span> <span class="string">'GET'</span>: </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">get</span>(req, res); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="路径解析"><a href="#路径解析" class="headerlink" title="路径解析"></a>路径解析</h4><p>路径部分存在于报文的第一行的第二部分,HTTP_Parser将其解析为req.url</p><p>客户端代理(浏览器)会将这个地址解析成报文，将路径和查询部分放在报文第一行。需要 注意的是，hash部分会被丢弃，不会存在于报文的任何地方。</p><h4 id="查询字符串"><a href="#查询字符串" class="headerlink" title="查询字符串"></a>查询字符串</h4><p>查询字符串位于路径之后，在地址栏中路径后的?foo=bar&amp;baz=val字符串就是查询字符串。 这个字符串会跟随在路径后，形成请求报文首行的第二部分。这部分内容经常需要为业务逻辑所 用，Node提供了querystring模块用于处理这部分数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">var</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">var</span> query = querystring.parse(url.parse(req.url).query);</span><br></pre></td></tr></table></figure><p>更简洁的方法是给url.parse()传递第二个参数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> query = url.parse(req.url, <span class="literal">true</span>).query;</span><br></pre></td></tr></table></figure><p>它会将foo=bar&amp;baz=val解析为一个JSON对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: <span class="string">'bar'</span>,</span><br><span class="line">  baz: <span class="string">'val'</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意的点是，如果查询字符串中的键出现多次，那么它的值会是一个数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo=bar&amp;foo=baz</span></span><br><span class="line"><span class="keyword">var</span> query = url.parse(req.url, <span class="literal">true</span>).query; </span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// foo: ['bar', 'baz']</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>业务的判断一定要检查值是数组还是字符串，否则可能出现TypeError异常的情况。</p><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie的处理分为如下几步。</p><ul><li>服务器向客户端发送Cookie。</li><li>浏览器将Cookie保存。</li><li>之后每次浏览器都会将Cookie发向服务器端。</li></ul><p>客户端发送的Cookie在请求报文的Cookie字段中，我们可以通过curl工具构造这个字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v -H <span class="string">"Cookie: foo=bar; baz=val"</span> <span class="string">"http://127.0.0.1:1337/path?foo=bar&amp;foo=baz"</span></span><br></pre></td></tr></table></figure><p>HTTP_Parser会将所有的报文字段解析到req.headers上，那么Cookie就是req.headers. cookie。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span>-Cookie: name=value; Path=<span class="regexp">/; Expires=Sun, 23-Apr-23 09:01:35 GMT; Domain=.domain.com;</span></span><br></pre></td></tr></table></figure><p>name=value是必须包含的部分，其余部分皆是可选参数。</p><ul><li>path表示这个Cookie影响到的路径，当前访问的路径不满足该匹配时，浏览器则不发送这 个Cookie。</li><li>Expires和Max-Age是用来告知浏览器这个Cookie何时过期的，如果不设置该选项，在关闭浏览器时会丢失掉这个Cookie。如果设置了过期时间，浏览器将会把Cookie内容写入到磁盘中并保存，下次打开浏览器依旧有效。Expires的值是一个UTC格式的时间字符串，告知浏览器此Cookie何时将过期，Max-Age则告知浏览器此Cookie多久后过期。前者一般而言不存在问题，但是如果服务器端的时间和客户端的时间不能匹配，这种时间设置就会存在偏差。为此，Max-Age告知浏览器这条Cookie多久之后过期，而不是一个具体的时间点。</li><li>HttpOnly告知浏览器不允许通过脚本document.cookie去更改这个Cookie值，事实上，设置 HttpOnly之后，这个值在document.cookie中不可见。但是在HTTP请求的过程中，依然会 发送这个Cookie到服务器端。</li><li>Secure。当Secure值为true时，在HTTP中是无效的，在HTTPS中才有效，表示创建的Cookie只能在HTTPS连接中被浏览器传递到服务器端进行会话验证，如果是HTTP连接则不会传递该信息，所以很难被窃听到。</li></ul><h5 id="Cookie的性能影响"><a href="#Cookie的性能影响" class="headerlink" title="Cookie的性能影响"></a>Cookie的性能影响</h5><p>由于Cookie的实现机制，一旦服务器端向客户端发送了设置Cookie的意图，除非Cookie过期， 否则客户端每次请求都会发送这些Cookie到服务器端，一旦设置的Cookie过多，将会导致报头较 大。大多数的Cookie并不需要每次都用上，因为这会造成带宽的部分浪费。在YSlow的性能优化 规则中有这么一条:</p><ul><li><p>减小Cookie的大小</p><p>如果在域名的根节点设置Cookie，几乎所有子路径下的请求都会带上这些Cookie，这些Cookie在某些情况下是有用的，但是在有些情况下是完全无用的。其中以静态文件 最为典型，静态文件的业务定位几乎不关心状态，Cookie对它而言几乎是无用的，但是一旦有 Cookie设置到相同域下，它的请求中就会带上Cookie。</p></li><li><p>为静态组件使用不同的域名</p><ul><li>为不需要Cookie的组件换个域名可以实现减少无效Cookie的传输。</li><li>额外的域名还可以突破浏览器下载线程数量的限制，因为域名不同，可以将下载线程数翻倍</li><li>缺点：多一个域名就多一次DNS查询</li></ul></li><li><p>减少DNS查询</p><p>浏览器都会进行DNS缓存，以削弱这个副作用的影响</p></li></ul><p><strong>Cookie对于敏感数据的保护是无效的。</strong></p><h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session的数据只保留在服务器端，客户 端无法修改，这样数据的安全性得到一定的保障，数据也无须在协议中每次都被传递。</p><h5 id="将每个客户和服务器中的数据一一对应的方法"><a href="#将每个客户和服务器中的数据一一对应的方法" class="headerlink" title="将每个客户和服务器中的数据一一对应的方法"></a>将每个客户和服务器中的数据一一对应的方法</h5><ul><li><p>第一种:基于Cookie来实现用户和数据的映射</p><p>将口令放在Cookie中。口令一旦被篹改，就丢失了映射关系，也无法修改服务器端存在的数据了。并且Session的有效期通常较短， 普遍的设置是20分钟，如果在20分钟内客户端和服务器端没有交互产生，服务器端就将数据删除。由于数据过期时间较短，且在服务器端存储数据，因此安全性相对较高。</p><p>一旦服务器端启用了Session，它将约定一个键值作为Session的口令，这个值可以随意约定一旦服务器检查到用户请求 Cookie中没有携带该值，它就会为之生成一个值，这个值是唯一且不重复的值，并设定超时时间。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sessions = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> key = <span class="string">'session_id'</span>;</span><br><span class="line"><span class="keyword">var</span> EXPIRES = <span class="number">20</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">var</span> generate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> session = &#123;&#125;;</span><br><span class="line">  session.id = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() +<span class="built_in">Math</span>.random(); </span><br><span class="line">  session.cookie = &#123;</span><br><span class="line">    expire: (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES </span><br><span class="line">  &#125;;</span><br><span class="line">  sessions[session.id] = session;</span><br><span class="line">  <span class="keyword">return</span> session; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个请求到来时，检查Cookie中的口令与服务器端的数据，如果过期，就重新生成</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = req.cookies[key]; </span><br><span class="line">  <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">    req.session = generate(); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> session = sessions[id]; </span><br><span class="line">    <span class="keyword">if</span> (session) &#123;</span><br><span class="line">      <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</span><br><span class="line">        <span class="comment">// 更新超时时间</span></span><br><span class="line">        session.cookie.expire = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES; </span><br><span class="line">        req.session = session;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 超时了，删除旧的数据，并重新生成 </span></span><br><span class="line">        <span class="keyword">delete</span> sessions[id];</span><br><span class="line">        req.session = generate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果session过期或口令不对，重新生成session</span></span><br><span class="line">      req.session = generate(); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  handle(req, res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅仅重新生成Session还不足以完成整个流程，还需要在响应给客户端时设置新的值，以便下次请求时能够对应服务器端的数据。</p><p>hack响应对象的writeHead()方法，在它的内部 注入设置Cookie的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeHead = res.writeHead; </span><br><span class="line">res.writeHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cookies = res.getHeader(<span class="string">'Set-Cookie'</span>);</span><br><span class="line">  <span class="keyword">var</span> session = serialize(key, req.session.id);</span><br><span class="line">  cookies = <span class="built_in">Array</span>.isArray(cookies) ?cookies.concat(session) : [cookies, session];</span><br><span class="line">  res.setHeader(<span class="string">'Set-Cookie'</span>, cookies);</span><br><span class="line">  <span class="keyword">return</span> writeHead.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>第二种:通过查询字符串来实现浏览器端和服务器端数据的对应</p><p>它的原理是检查请求的查询字符串，如果没有值，会先生成新的带值的URL</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getURL = <span class="function"><span class="keyword">function</span> (<span class="params">_url, key, value</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> obj = url.parse(_url, <span class="literal">true</span>); </span><br><span class="line">  obj.query[key] = value;</span><br><span class="line">  <span class="keyword">return</span> url.format(obj);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后形成跳转，让客户端重新发起请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> redirect = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">'Location'</span>, url);</span><br><span class="line">    res.writeHead(<span class="number">302</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">var</span> id = req.query[key]; </span><br><span class="line">  <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">    <span class="keyword">var</span> session = generate();</span><br><span class="line">    redirect(getURL(req.url, key, session.id)); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> session = sessions[id]; </span><br><span class="line">    <span class="keyword">if</span> (session) &#123;</span><br><span class="line">      <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</span><br><span class="line">        <span class="comment">// 更新超时时间</span></span><br><span class="line">        session.cookie.expire = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES; </span><br><span class="line">        req.session = session;</span><br><span class="line">        handle(req, res); </span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 超时了，删除旧的数据，并重新生成</span></span><br><span class="line">        <span class="keyword">delete</span> sessions[id];</span><br><span class="line">        <span class="keyword">var</span> session = generate();</span><br><span class="line">        redirect(getURL(req.url, key, session.id));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果session过期或口令不对，重新生成session </span></span><br><span class="line">      <span class="keyword">var</span> session = generate();</span><br><span class="line">      redirect(getURL(req.url, key, session.id));</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用户访问<a href="http://localhost/pathname时，如果服务器端发现查询字符串中不带session_id参数，" target="_blank" rel="noopener">http://localhost/pathname时，如果服务器端发现查询字符串中不带session_id参数，</a> 就会将用户跳转到<a href="http://localhost/pathname?session_id=12344567这样一个类似的地址。如果浏览" target="_blank" rel="noopener">http://localhost/pathname?session_id=12344567这样一个类似的地址。如果浏览</a> 器收到302状态码和Location报头，就会重新发起新的请求</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt; HTTP/<span class="number">1.1</span> <span class="number">302</span> Moved Temporarily</span><br><span class="line">&lt; Location: <span class="regexp">/pathname?session_id=12344567</span></span><br></pre></td></tr></table></figure><p>这样，新的请求到来时就能通过Session的检查，除非内存中的数据过期。</p><p>有的服务器在客户端禁用Cookie时，会采用这种方案实现退化。通过这种方案，无须在响应 时设置Cookie。但是这种方案带来的风险远大于基于Cookie实现的风险，因为只要将地址栏中的 地址发给另外一个人，那么他就拥有跟你相同的身份。Cookie的方案在换了浏览器或者换了电脑 之后无法生效，相对较为安全</p></li></ul><h5 id="Session与内存"><a href="#Session与内存" class="headerlink" title="Session与内存"></a>Session与内存</h5><p>用户请求的连接将可能随意分配到各个进程中，Node的进程与进程之间是不能直接共享内存 的，用户的Session可能会引起错乱。</p><p>为了解决性能问题和Session数据无法跨进程共享的问题，常用的方案是将Session集中化，将 原本可能分散在多个进程里的数据，统一转移到集中的数据存储中。</p><p>目前常用的工具是Redis、 Memcached等，通过这些高效的缓存，Node进程无须在内部维护数据对象，垃圾回收问题和内存 限制问题都可以迎刃而解，并且这些高速缓存设计的缓存过期策略更合理更高效，比在Node中自 行设计缓存策略更好。</p><p>采用第三方缓存来存储Session引起的一个问题是会引起网络访问，尽管如此但依然会采用这些高速缓存的理由有以下几条:</p><ul><li>Node与缓存服务保持长连接，而非频繁的短连接，握手导致的延迟只影响初始化。</li><li>高速缓存直接在内存中进行数据存储和访问。</li><li>缓存服务通常与Node进程运行在相同的机器上或者相同的机房里，网络速度受到的影响较小。</li></ul><p>Session异步的方式获取：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = req.cookies[key]; </span><br><span class="line">  <span class="keyword">if</span> (!id) &#123;</span><br><span class="line">    req.session = generate();</span><br><span class="line">    handle(req, res); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    store.get(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, session</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">if</span> (session) &#123;</span><br><span class="line">        <span class="keyword">if</span> (session.cookie.expire &gt; (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime()) &#123;</span><br><span class="line">          <span class="comment">// 更新超时时间</span></span><br><span class="line">          session.cookie.expire = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() + EXPIRES; </span><br><span class="line">          req.session = session;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 超时了，删除旧的数据，并重新生成 </span></span><br><span class="line">          <span class="keyword">delete</span> sessions[id];</span><br><span class="line">          req.session = generate();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果session过期或口令不对，重新生成session</span></span><br><span class="line">        req.session = generate(); </span><br><span class="line">      &#125;</span><br><span class="line">      handle(req, res); </span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在响应时，将新的session保存回缓存中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> writeHead = res.writeHead; </span><br><span class="line">res.writeHead = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> cookies = res.getHeader(<span class="string">'Set-Cookie'</span>);</span><br><span class="line">  <span class="keyword">var</span> session = serialize(<span class="string">'Set-Cookie'</span>, req.session.id);</span><br><span class="line">  cookies = <span class="built_in">Array</span>.isArray(cookies) ? cookies.concat(session) : [cookies, session];</span><br><span class="line">  res.setHeader(<span class="string">'Set-Cookie'</span>, cookies);</span><br><span class="line">  <span class="comment">// 保存回缓存</span></span><br><span class="line">  store.save(req.session);</span><br><span class="line">  <span class="keyword">return</span> writeHead.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="Session与安全"><a href="#Session与安全" class="headerlink" title="Session与安全"></a>Session与安全</h5><p>Session的安全，就 主要指如何让这个口令更加安全</p><p>有一种做法是将这个口令通过私钥加密进行签名，使得伪造的成本较高。客户端尽管可以伪 造口令值，但是由于不知道私钥值，签名信息很难伪造。如此，我们只要在响应时将口令和签名 进行对比，如果签名非法，我们将服务器端的数据立即过期即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将值通过私钥签名，由.分割原值和签名 </span></span><br><span class="line"><span class="keyword">var</span> sign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> val + <span class="string">'.'</span> + crypto </span><br><span class="line">    .createHmac(<span class="string">'sha256'</span>, secret) </span><br><span class="line">    .update(val) </span><br><span class="line">    .digest(<span class="string">'base64'</span>) </span><br><span class="line">    .replace(<span class="regexp">/\=+$/</span>, <span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在响应时，设置session值到Cookie中或者跳转URL中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> val = sign(req.sessionID, secret); res.setHeader(<span class="string">'Set-Cookie'</span>, cookie.serialize(key, val));</span><br></pre></td></tr></table></figure><p>接收请求时，检查签名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取出口令部分进行签名，对比用户提交的值 </span></span><br><span class="line"><span class="keyword">var</span> unsign = <span class="function"><span class="keyword">function</span> (<span class="params">val, secret</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = val.slice(<span class="number">0</span>,val.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">  <span class="keyword">return</span> sign(str, secret) == val ? str : <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样一来，即使攻击者知道口令中.号前的值是服务器端Session的ID值，只要不知道secret 私钥的值，就无法伪造签名信息，以此实现对Session的保护。该方法被Connect中间件框架所使 用，保护好私钥，就是在保障自己Web应用的安全。</p><p>将客户端的某些独有信息与口令作为原值， 然后签名，这样攻击者一旦不在原始的客户端上进行访问，就会导致签名失败。这些独有信息包 9 括用户IP和用户代理(User Agent)。</p><ul><li><p>XSS漏洞</p><p>XSS的全称是跨站脚本攻击(Cross Site Scripting，通常简称为XSS)。XSS漏洞会让别的脚本执行。它的主要形成原因多数是 用户的输入没有被转义，而被直接执行</p></li></ul><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><ul><li>添加Expires 或Cache-Control 到报文头中。</li><li>配置 ETags。</li><li>让Ajax 可缓存。</li></ul><p>POST、DELETE、PUT这类带行为性的请求操作一般不做任何缓存，大多数缓存只应用在GET请求中。</p><p><img src="https://tva1.sinaimg.cn/large/006tNbRwgy1gajfb4b6e0j30i80pi0uq.jpg" alt="image-20200103155111525"></p><p>本地没有文件时，浏览器必然会请求服务器端的内容，并将这部分内容放置在本 地的某个缓存目录中。在第二次请求时，它将对本地文件进行检查，如果不能确定这份本地文件 是否可以直接使用，它将会发起一次条件请求。所谓条件请求，就是在普通的GET请求报文中， 附带If-Modified-Since字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If-Modified-Since: Sun, 03 Feb 2013 06:01:12 GMT</span><br></pre></td></tr></table></figure><p>它将询问服务器端是否有更新的版本，本地文件的最后修改时间。如果服务器端没有新的版 本，只需响应一个304状态码，客户端就使用本地版本。如果服务器端有新的版本，就将新的内 容发送给客户端，客户端放弃本地版本。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  fs.stat(filename, <span class="function"><span class="keyword">function</span> (<span class="params">err, stat</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lastModified = stat.mtime.toUTCString();</span><br><span class="line">    <span class="keyword">if</span> (lastModified === req.headers[<span class="string">'if-modified-since'</span>]) &#123;</span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">"Not Modified"</span>);</span><br><span class="line">      res.end(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> lastModified = stat.mtime.toUTCString();</span><br><span class="line">        res.setHeader(<span class="string">"Last-Modified"</span>, lastModified);</span><br><span class="line">        res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</span><br><span class="line">        res.end(file);</span><br><span class="line">      &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的条件请求采用时间戳的方式实现，但是时间戳有一些缺陷存在。</p><ul><li>文件的时间戳改动但内容并不一定改动。</li><li>时间戳只能精确到秒级别，更新频繁的内容将无法生效。</li></ul><p>为此HTTP1.1中引入了ETag来解决这个问题。ETag的全称是Entity Tag，由服务器端生成，服 务器端可以决定它的生成规则。如果根据文件内容生成散列值，那么条件请求将不会受到时间戳 改动造成的带宽浪费。</p><p>根据内容生成散列值的方法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getHash = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> shasum = crypto.createHash(<span class="string">'sha1'</span>); </span><br><span class="line">  <span class="keyword">return</span> shasum.update(str).digest(<span class="string">'base64'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与If-Modified-Since/Last-Modified不同的是，ETag的请求和响应是If-None-Match/ETag</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> hash = getHash(file);</span><br><span class="line">    <span class="keyword">var</span> noneMatch = req.headers[<span class="string">'if-none-match'</span>];</span><br><span class="line">    <span class="keyword">if</span> (hash === noneMatch) &#123;</span><br><span class="line">      res.writeHead(<span class="number">304</span>, <span class="string">"Not Modified"</span>);</span><br><span class="line">      res.end(); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      res.setHeader(<span class="string">"ETag"</span>, hash); res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>); </span><br><span class="line">      res.end(file);</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>HTTP1.0时，在服务器端设置Expires可以告知浏览器要缓存文件内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> expires = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    expires.setTime(expires.getTime() + <span class="number">10</span> * <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>); </span><br><span class="line">    res.setHeader(<span class="string">"Expires"</span>, expires.toUTCString());</span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</span><br><span class="line">    res.end(file);</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Expires是一个GMT格式的时间字符串。浏览器在接到这个过期值后，只要本地还存在这个 缓存文件，在到期时间之前它都不会再发起请求</p><p>Cache-Control以更丰富的形式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  fs.readFile(filename, <span class="function"><span class="keyword">function</span>(<span class="params">err, file</span>) </span>&#123;</span><br><span class="line">    res.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"max-age="</span> + <span class="number">10</span> * <span class="number">365</span> * <span class="number">24</span> * <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>); </span><br><span class="line">    res.writeHead(<span class="number">200</span>, <span class="string">"Ok"</span>);</span><br><span class="line">    res.end(file);</span><br><span class="line">  &#125;); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Cache-Control 能够避免浏览器端与服务器端时间不同步带来的不一致性问题，只要进行类似倒计时的方式计算 过期时间即可。除此之外，Cache-Control的值还能设置public、private、no-cache、no-store 等能够更精细地控制缓存的选项。</p><p>由于在HTTP1.0时还不支持max-age，如今的服务器端在模块的支持下多半同时对Expires和 Cache-Control进行支持。在浏览器中如果两个值同时存在，且被同时支持时，max-age会覆盖 Expires。</p><h5 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h5><p>缓存一旦设定，当服务器端意外更新内容时，却无法通知客户端更新。这使得我们在使用缓存时也要为其设定版本号，所幸浏览器是根据URL进行缓存，那么一旦内容有所更新时，我们就让浏览器发起新的URL请求， 使得新内容能够被客户端更新。</p><p>更新机制:</p><ul><li>每次发布，路径中跟随Web应用的版本号:<a href="http://url.com/?v=20130501。" target="_blank" rel="noopener">http://url.com/?v=20130501。</a></li><li>每次发布，路径中跟随该文件内容的hash值:<a href="http://url.com/?hash=afadfadwe。" target="_blank" rel="noopener">http://url.com/?hash=afadfadwe。</a></li></ul><p>根据文件内容的hash值进行缓存淘汰会更加高效，因为文件内容不一定随着Web 应用的版本而更新，而内容没有更新时，版本号的改动导致的更新毫无意义，因此以文件内容形 成的hash值更精准。</p><h4 id="Basic-认证"><a href="#Basic-认证" class="headerlink" title="Basic 认证"></a>Basic 认证</h4><p>Basic认证是当客户端与服务器端进行请求时，允许通过用户名和密码实现的一种身份认证方式。</p><ul><li>如果一个页面需要Basic认证，它会检查请求报文头中的Authorization字段的内容，该字段 的值由认证方式和加密值构成</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ curl -v <span class="string">"http://user:pass@www.baidu.com/"</span></span><br><span class="line">&gt; GET / HTTP/<span class="number">1.1</span></span><br><span class="line">&gt; Authorization: Basic dXNlcjpwYXNz</span><br><span class="line">&gt; User-Agent: curl/<span class="number">7.24</span><span class="number">.0</span> (x86_64-apple-darwin12<span class="number">.0</span>) libcurl/<span class="number">7.24</span><span class="number">.0</span> OpenSSL/<span class="number">0.9</span><span class="number">.8</span>r zlib/<span class="number">1.2</span><span class="number">.5</span></span><br><span class="line">&gt; Host: www.baidu.com</span><br><span class="line">&gt; Accept: *<span class="comment">/*</span></span><br></pre></td></tr></table></figure><ul><li>在Basic认证中，它会将用户和密码部分组合:username + “:” + password。然后进行Base64编码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> encode = <span class="function"><span class="keyword">function</span> (<span class="params">username, password</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Buffer(username + <span class="string">':'</span> + password).toString(<span class="string">'base64'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如果用户首次访问该网页，URL地址中也没携带认证内容，那么浏览器会响应一个401未授 权的状态码</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> auth = req.headers[<span class="string">'authorization'</span>] || <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">var</span> parts = auth.split(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">var</span> method = parts[<span class="number">0</span>] || <span class="string">''</span>; <span class="comment">// Basic</span></span><br><span class="line">  <span class="keyword">var</span> encoded = parts[<span class="number">1</span>] || <span class="string">''</span>; <span class="comment">// dXNlcjpwYXNz</span></span><br><span class="line">  <span class="keyword">var</span> decoded = <span class="keyword">new</span> Buffer(encoded, <span class="string">'base64'</span>).toString(<span class="string">'utf-8'</span>).split(<span class="string">":"</span>); <span class="keyword">var</span> user = decoded[<span class="number">0</span>]; <span class="comment">// user</span></span><br><span class="line">  <span class="keyword">var</span> pass = decoded[<span class="number">1</span>]; <span class="comment">// pass</span></span><br><span class="line">  <span class="keyword">if</span> (!checkUser(user, pass)) &#123;</span><br><span class="line">    res.setHeader(<span class="string">'WWW-Authenticate'</span>, <span class="string">'Basic realm="Secure Area"'</span>);<span class="comment">//响应头中的WWW-Authenticate字段告知浏览器采用什么样的认证和加密方式</span></span><br><span class="line">    res.writeHead(<span class="number">401</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    handle(req, res);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当认证通过，服务器端响应200状态码之后，浏览器会保存用户名和密码口令，在后续的请 求中都携带上Authorization信息。</li></ul><p>Basic认证有太多的缺点，它虽然经过Base64加密后在网络中传送，但是这近乎于明文，十分 危险，一般只有在HTTPS的情况下才会使用。不过Basic认证的支持范围十分广泛，几乎所有的 浏览器都支持它。</p><h3 id="数据上传"><a href="#数据上传" class="headerlink" title="数据上传"></a>数据上传</h3><p>如果请求中还带 4 有内容部分(如POST请求，它具有报头和内容)，内容部分需要用户自行接收和解析。通过报头 的Transfer-Encoding或Content-Length即可判断请求中是否带有内容</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasBody = <span class="function"><span class="keyword">function</span>(<span class="params">req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'transfer-encoding'</span> <span class="keyword">in</span> req.headers || <span class="string">'content-length'</span> <span class="keyword">in</span> req.headers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在HTTP_Parser解析报头结束后，报文内容部分会通过data事件触发，我们只需以流的方式处理即可</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (hasBody(req)) &#123; </span><br><span class="line">    <span class="keyword">var</span> buffers = [];</span><br><span class="line">    req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123; </span><br><span class="line">      buffers.push(chunk);</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      req.rawBody = Buffer.concat(buffers).toString();</span><br><span class="line">      handle(req, res);</span><br><span class="line">    &#125;); </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    handle(req, res);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将接收到的Buffer列表转化为一个Buffer对象后，再转换为没有乱码的字符串，暂时挂置在 req.rawBody处。</p><h4 id="表单数据"><a href="#表单数据" class="headerlink" title="表单数据"></a>表单数据</h4><p>默认的表单提交，请求头中的Content-Type字段值为application/x-www-form-urlencoded</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure><p>由于它的报文体内容跟查询字符串相同:<code>foo=bar&amp;baz=val</code></p><p>解析它十分容易</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.headers[<span class="string">'content-type'</span>] === <span class="string">'application/x-www-form-urlencoded'</span>) &#123;</span><br><span class="line">    req.body = querystring.parse(req.rawBody); </span><br><span class="line">  &#125;</span><br><span class="line">  todo(req, res); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>后续业务中直接访问req.body就可以得到表单中提交的数据</p><h4 id="其他格式"><a href="#其他格式" class="headerlink" title="其他格式"></a>其他格式</h4><p>常见的提交还有JSON和XML文件,依据Content-Type中的值决定，其中JSON类型的值为application/json，XML的值为 application/xml</p><p>需要注意的是，在Content-Type中可能还附带如下所示的编码信息<code>Content-Type: application/json; charset=utf-8</code>所以在做判断时，需要注意区分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mime = <span class="function"><span class="keyword">function</span> (<span class="params">req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> str = req.headers[<span class="string">'content-type'</span>] || <span class="string">''</span>; </span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">';'</span>)[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="1-JSON文件"><a href="#1-JSON文件" class="headerlink" title="1. JSON文件"></a>1. JSON文件</h5><p>如果从客户端提交JSON内容，这对于Node来说，要处理它都不需要额外的任何库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mime(req) === <span class="string">'application/json'</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      req.body = <span class="built_in">JSON</span>.parse(req.rawBody);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="comment">// 异常内容，响应Bad request </span></span><br><span class="line">      res.writeHead(<span class="number">400</span>); </span><br><span class="line">      res.end(<span class="string">'Invalid JSON'</span>); </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  todo(req, res); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-XML文件"><a href="#2-XML文件" class="headerlink" title="2. XML文件"></a>2. XML文件</h5><p>解析XML文件稍微复杂一点，但是社区有支持XML文件到JSON对象转换的库</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xml2js = <span class="built_in">require</span>(<span class="string">'xml2js'</span>);</span><br><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (mime(req) === <span class="string">'application/xml'</span>) &#123;</span><br><span class="line">    xml2js.parseString(req.rawBody, <span class="function"><span class="keyword">function</span> (<span class="params">err, xml</span>) </span>&#123; </span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 异常内容，响应Bad request </span></span><br><span class="line">        res.writeHead(<span class="number">400</span>); </span><br><span class="line">        res.end(<span class="string">'Invalid XML'</span>); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      req.body = xml; todo(req, res);</span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="附件上传"><a href="#附件上传" class="headerlink" title="附件上传"></a>附件上传</h4><p>通常的表单，其内容 可以通过urlencoded的方式编码内容形成报文体，再发送给服务器端，但是业务场景往往需要用 户直接提交文件。在前端HTML代码中，特殊表单与普通表单的差异在于该表单中可以含有file 类型的控件，以及需要指定表单属性enctype为multipart/form-data</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/upload"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"username"</span>&gt;</span>Username:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">id</span>=<span class="string">"username"</span> /&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>Filename:<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Submit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>浏览器在遇到multipart/form-data表单提交时，构造的请求报文与普通表单完全不同。首先它的报头中最为特殊的</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Type</span>: multipart/form-data; boundary=AaB03x </span><br><span class="line"><span class="attribute">Content-Length</span>: 18231</span><br></pre></td></tr></table></figure><p>它代表本次提交的内容是由多部分构成的，其中boundary=AaB03x指定的是每部分内容的分界 符，AaB03x是随机生成的一段字符串，报文体的内容将通过在它前面添加–进行分割，报文结束 时在它前后都加上–表示结束。另外，Content-Length的值必须确保是报文体的长度。</p><p>假设上面的表单选择了一个名为diveintonode.js的文件，并进行提交上传，那么生成的报文如 下所示:</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">--AaB03x\r\n</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="username"\r\n</span><br><span class="line">\r\n</span><br><span class="line">Jackson Tian\r\n</span><br><span class="line">--AaB03x\r\n</span><br><span class="line"><span class="attribute">Content-Disposition</span>: form-data; name="file"; filename="diveintonode.js"\r\n Content-Type: application/javascript\r\n</span><br><span class="line">\r\n</span><br><span class="line">... contents of diveintonode.js ... </span><br><span class="line">--AaB03x--</span><br></pre></td></tr></table></figure><p>接收 大小未知的数据量时，我们需要十分谨慎</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</span><br><span class="line">    <span class="keyword">var</span> done = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">      handle(req, res);</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (mime(req) === <span class="string">'application/json'</span>) &#123;</span><br><span class="line">      parseJSON(req, done);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mime(req) === <span class="string">'application/xml'</span>) &#123;</span><br><span class="line">      parseXML(req, done);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mime(req) === <span class="string">'multipart/form-data'</span>) &#123;</span><br><span class="line">      parseMultipart(req, done); &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    handle(req, res);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们将req这个流对象直接交给对应的解析方法，由解析方法自行处理上传的内容，或接收内容并保存在内存中，或流式处理掉。</p><p>formidable模块，基于流式处理解析报文，将接收到的文件写入到系统 的临时文件夹中，并返回对应的路径。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> formidable = <span class="built_in">require</span>(<span class="string">'formidable'</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (hasBody(req)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mime(req) === <span class="string">'multipart/form-data'</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> form = <span class="keyword">new</span> formidable.IncomingForm(); </span><br><span class="line">      form.parse(req, <span class="function"><span class="keyword">function</span>(<span class="params">err, fields, files</span>) </span>&#123;</span><br><span class="line">        req.body = fields; </span><br><span class="line">        req.files = files; </span><br><span class="line">        handle(req, res);</span><br><span class="line">      &#125;); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">    handle(req, res);</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此在业务逻辑中只要检查req.body和req.files中的内容即可</p><h4 id="数据上传与安全"><a href="#数据上传与安全" class="headerlink" title="数据上传与安全"></a>数据上传与安全</h4><h5 id="1-内存限制"><a href="#1-内存限制" class="headerlink" title="1. 内存限制"></a>1. 内存限制</h5><p>在解析表单、JSON和XML部分，我们采取的策略是先保存用户提交的所有数据，然后再解 析处理，最后才传递给业务逻辑。这种策略存在潜在的问题是，它仅仅适合数据量小的提交请求， 一旦数据量过大，将发生内存被占光的情况。攻击者通过客户端能够十分容易地模拟伪造大量数 据，如果攻击者每次提交1 MB的内容，那么只要并发请求数量一大，内存就会很快地被吃光。</p><p>要解决这个问题主要有两个方案。</p><ul><li>限制上传内容的大小，一旦超过限制，停止接收数据，并响应400状态码。 </li><li>通过流式解析，将数据流导向到磁盘中，Node只保留文件路径等小数据。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bytes = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> received = <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">var</span> len = req.headers[<span class="string">'content-length'</span>] ? <span class="built_in">parseInt</span>(req.headers[<span class="string">'content-length'</span>], <span class="number">10</span>) : <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 如果内容超过长度限制，返回请求实体过长的状态码 </span></span><br><span class="line">  <span class="keyword">if</span> (len &amp;&amp; len &gt; bytes) &#123;</span><br><span class="line">    res.writeHead(<span class="number">413</span>); </span><br><span class="line">    res.end();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// limit</span></span><br><span class="line">  req.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    received += chunk.length; </span><br><span class="line">    <span class="keyword">if</span> (received &gt; bytes) &#123;</span><br><span class="line">      <span class="comment">// 停止接收数据，触发end()</span></span><br><span class="line">      req.destroy(); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  handle(req, res); </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>数据是由包含Content-Length的请求报文判断是否长度超过 限制的，超过则直接响应413状态码。对于没有Content-Length的请求报文，略微简略一点，在每 个data事件中判定即可。一旦超过限制值，服务器停止接收新的数据片段。如果是JSON文件或 XML文件，极有可能无法完成解析。对于上线的Web应用，添加一个上传大小限制十分有利于保 护服务器，在遭遇攻击时，能镇定从容应对。</p><h5 id="2-CSRF"><a href="#2-CSRF" class="headerlink" title="2. CSRF"></a>2. CSRF</h5><p>用户通过POST提交content字段就能成功留言。服务器端会自动从Session数据中判断是谁提交的数据，补足username和updatedAt两个字段后向数据库中写入数据。攻击者只要引诱某个domain_a的登录用户访问这个domain_b的网站，就会自动 提交一个留言。由于在提交到domain_a的过程中，浏览器会将domain_a的Cookie发送到服务器， 尽管这个请求是来自domain_b的，但是服务器并不知情，用户也不知情。</p><h3 id="路由解析"><a href="#路由解析" class="headerlink" title="路由解析"></a>路由解析</h3><h4 id="文件路径型"><a href="#文件路径型" class="headerlink" title="文件路径型"></a>文件路径型</h4><h5 id="1-静态文件"><a href="#1-静态文件" class="headerlink" title="1. 静态文件"></a>1. 静态文件</h5><p>URL的路径与网站 目录的路径一致，无须转换，非常直观。将请求路径对应的文 件发送给客户端即可</p><h5 id="2-动态文件"><a href="#2-动态文件" class="headerlink" title="2. 动态文件"></a>2. 动态文件</h5><p>根据文件路径执行动态脚本也是基本的路由方式，它的处理原 理是Web服务器根据URL路径找到对应的文件，Web服务器根据文件名 后缀去寻找脚本的解析器，并传入HTTP请求的上下文。<br>（现今大多数的服务器都能很智能 地根据后缀同时服务动态和静态文件。这种方式在Node中不太常见，主要原因是文件的后缀都 是.js，分不清是后端脚本，还是前端脚本，而且Node中Web服务器与应 用业务脚本是一体的，无须按这种方式实现。）</p><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>MVC模型的主要思想是<strong>将业务逻辑按职责分离</strong>，主要分为以下几种。 </p><ul><li>控制器(Controller)，一组行为的集合。</li><li>模型(Model)，数据相关的操作和封装。</li><li>视图(View)，视图的渲染。</li></ul><p>工作模式：</p><ul><li>路由解析，根据URL寻找到对应的控制器和行为。<ul><li>根据URL做路由映射<ul><li>手工关联映射：有一个对应的路由文件来将URL映射到对应的控制器</li><li>自然关联映射：没有映射的文件</li></ul></li></ul></li><li>行为调用相关的模型，进行数据操作。</li><li>数据操作结束后，调用视图和相关数据进行页面渲染，输出到客户端。</li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggbsshjjicj30m40cmjs8.jpg" alt="image-20200701213512319"></p><h5 id="1-手工映射"><a href="#1-手工映射" class="headerlink" title="1. 手工映射"></a>1. 手工映射</h5><p>手工映射除了需要手工配置路由外较为原始外，它对URL的要求十分灵活，几乎没有格式上 的限制。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/user/setting</span><br><span class="line">/setting/user</span><br></pre></td></tr></table></figure><p>这里假设已经拥有了一个处理设置用户信息的控制器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.setting = <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再添加一个映射的方法就行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> routes = [];</span><br><span class="line"><span class="keyword">var</span> use = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123; </span><br><span class="line">  routes.push([path, action]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们在入口程序中判断URL，然后执行对应的逻辑，于是就完成了基本的路由映射过程</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> route = routes[i];</span><br><span class="line">    <span class="keyword">if</span> (pathname === route[<span class="number">0</span>]) &#123;</span><br><span class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>]; </span><br><span class="line">      action(req, res); </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理404请求</span></span><br><span class="line">  handle404(req, res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>正则匹配</li></ul><p>根据不同的用户显示不同的内容，我们就不太可能去手工维护所有用户的路由请求，因此正则匹配应运而生</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">use(<span class="string">'/profile/:username'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在通过use注册路由时需要将路径转换为一个正则表达式，然后通过它来进行匹配</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathRegexp = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123; </span><br><span class="line">  path = path</span><br><span class="line">    .concat(strict ? <span class="string">''</span> : <span class="string">'/?'</span>)</span><br><span class="line">    .replace(<span class="regexp">/\/\(/g</span>, <span class="string">'(?:/'</span>)</span><br><span class="line">    .replace(<span class="regexp">/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">_, slash, format, key, capture,</span></span></span><br><span class="line"><span class="function"><span class="params">optional, star</span>)</span>&#123;</span><br><span class="line">    slash = slash || <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">      + (optional ? <span class="string">''</span> : slash)</span><br><span class="line">      + <span class="string">'(?:'</span></span><br><span class="line">      + (optional ? slash : <span class="string">''</span>)</span><br><span class="line">      + (format || <span class="string">''</span>) + (capture || (format &amp;&amp; <span class="string">'([^/.]+?)'</span> || <span class="string">'([^/]+?)'</span>)) + <span class="string">')'</span> </span><br><span class="line">      + (optional || <span class="string">''</span>)</span><br><span class="line">      + (star ? <span class="string">'(/*)?'</span> : <span class="string">''</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">    .replace(<span class="regexp">/([\/.])/g</span>, <span class="string">'\\$1'</span>) </span><br><span class="line">    .replace(<span class="regexp">/\*/g</span>, <span class="string">'(.*)'</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + path + <span class="string">'$'</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> use = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123;</span><br><span class="line">  routes.push([pathRegexp(path), action]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> route = routes[i];</span><br><span class="line">    <span class="comment">// 正则匹配</span></span><br><span class="line">    <span class="keyword">if</span> (route[<span class="number">0</span>].exec(pathname)) &#123;</span><br><span class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>]; </span><br><span class="line">      action(req, res);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理404请求</span></span><br><span class="line">  handle404(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参数解析</li></ul><p>:username到底匹配了啥，还没有解决。为此我们还需要进一步将匹配到的内容抽取出来，希望在业务中能如下这样调用:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">use(<span class="string">'/profile/:username'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> username = req.params.username;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这里的目标是将抽取的内容设置到req.params处。那么第一步就是将键值抽取出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pathRegexp = <span class="function"><span class="keyword">function</span>(<span class="params">path</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> keys = [];</span><br><span class="line">  path = path</span><br><span class="line">    .concat(strict ? <span class="string">''</span> : <span class="string">'/?'</span>)</span><br><span class="line">    .replace(<span class="regexp">/\/\(/g</span>, <span class="string">'(?:/'</span>)</span><br><span class="line">    .replace(<span class="regexp">/(\/)?(\.)?:(\w+)(?:(\(.*?\)))?(\?)?(\*)?/g</span>,<span class="function"><span class="keyword">function</span>(<span class="params">_, slash, format, key, capture,</span></span></span><br><span class="line"><span class="function"><span class="params"> optional, star</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 将匹配到的键值保存起来 </span></span><br><span class="line">    keys.push(key);</span><br><span class="line">    slash = slash || <span class="string">''</span>; </span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span></span><br><span class="line">      + (optional ? <span class="string">''</span> : slash)</span><br><span class="line">      + <span class="string">'(?:'</span> <span class="number">8</span> + (optional ? slash : <span class="string">''</span>)</span><br><span class="line">        + (format || <span class="string">''</span>) + (capture || (format &amp;&amp; <span class="string">'([^/.]+?)'</span> || <span class="string">'([^/]+?)'</span>)) + <span class="string">')'</span></span><br><span class="line">        + (optional || <span class="string">''</span>)</span><br><span class="line">        + (star ? <span class="string">'(/*)?'</span> : <span class="string">''</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">    .replace(<span class="regexp">/([\/.])/g</span>, <span class="string">'\\$1'</span>) </span><br><span class="line">    .replace(<span class="regexp">/\*/g</span>, <span class="string">'(.*)'</span>);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    keys: keys,</span><br><span class="line">    regexp: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'^'</span> + path + <span class="string">'$'</span>)</span><br><span class="line">  &#125;; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们将根据抽取的键值和实际的URL得到键值匹配到的实际值，并设置到req.params处</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; routes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> route = routes[i];</span><br><span class="line">    <span class="comment">// 正则匹配</span></span><br><span class="line">    <span class="keyword">var</span> reg = route[<span class="number">0</span>].regexp;</span><br><span class="line">    <span class="keyword">var</span> keys = route[<span class="number">0</span>].keys;</span><br><span class="line">    <span class="keyword">var</span> matched = reg.exec(pathname); </span><br><span class="line">    <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">      <span class="comment">// 抽取具体值</span></span><br><span class="line">      <span class="keyword">var</span> params = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = matched[i + <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">          params[keys[i]] = value; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      req.params = params;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>]; </span><br><span class="line">      action(req, res); </span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理404请求</span></span><br><span class="line">  handle404(req, res); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们除了从查询字符串(req.query)或提交数据(req.body)中取到值外，还能从路 径的映射里取到值。</p><h5 id="2-自然映射"><a href="#2-自然映射" class="headerlink" title="2. 自然映射"></a>2. 自然映射</h5><p>实际上并非没有路由，而是路由按一种约定的方式自然而然地实现了路由，而无 须去维护路由映射。</p><p>它将如下路径进行了划 分处理:<code>/controller/action/param1/param2/param3</code></p><p>以/user/setting/12/1987为例，它会按约定去找controllers目录下的user文件，将其require出来后，调用这个文件模块的setting()方法，而其余的值作为参数直接传递给这个方法。</p><p>由于这种自然映射的方式没有指明参数的名称，所以无法采用req.params的方式提取，但是直接通过参数获取更简洁</p><h4 id="RESTful"><a href="#RESTful" class="headerlink" title="RESTful"></a>RESTful</h4><p>REST的全称是Representational State Transfer，中文含义为表现层状态转化。符合REST规范 的设计，我们称为RESTful设计。它的设计哲学主要将服务器端提供的内容实体看作一个资源， 并表现在URL上。</p><p>地址代表了一个资源，对这个资源的操作，主要体现在HTTP请求方法上，不是体现在URL上。</p><p>过去我们对用户的增删改查或许是如下这样设计URL的:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /user/add?username=jacksontian </span><br><span class="line">GET /user/remove?username=jacksontian </span><br><span class="line">POST /user/update?username=jacksontian </span><br><span class="line">GET /user/get?username=jacksontian</span><br></pre></td></tr></table></figure><p>在RESTful设计中，它是如 下这样的:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST /user/jacksontian </span><br><span class="line">DELETE /user/jacksontian </span><br><span class="line">PUT /user/jacksontian </span><br><span class="line">GET /user/jacksontian</span><br></pre></td></tr></table></figure><p><strong>它将DELETE和PUT请求方法引入设计中，参与资源的操作和更改资源的状态。</strong></p><p>在RESTful设计中，<strong>资源的具体格式由请求报头中的Accept字段和服务器端的支持情况来决定</strong>。如果客户端同时接受JSON和XML格式的响应，那么它的Accept字段值是如下这样的:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept: application/json,application/xml</span><br></pre></td></tr></table></figure><p>靠谱的服务器端应该要顾及这个字段，然后根据自己能响应的格式做出响应。在响应报文中， 通过Content-Type字段告知客户端是什么格式</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application/json</span><br></pre></td></tr></table></figure><p><strong>通过URL设计资源、请求方法 定义资源的操作，通过Accept决定资源的表现形式</strong></p><h5 id="1-请求方法"><a href="#1-请求方法" class="headerlink" title="1. 请求方法"></a>1. 请求方法</h5><p>为了让Node能够支持RESTful需求，我们改进了我们的设计。在RESTful的场景下，我们需要区分请求方法设计。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> routes = &#123;<span class="string">'all'</span>: []&#125;;</span><br><span class="line"><span class="keyword">var</span> app = &#123;&#125;;</span><br><span class="line">app.use = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123;</span><br><span class="line">  routes.all.push([pathRegexp(path), action]); </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="string">'get'</span>, <span class="string">'put'</span>, <span class="string">'delete'</span>, <span class="string">'post'</span>].forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  routes[method] = [];</span><br><span class="line">  app[method] = <span class="function"><span class="keyword">function</span> (<span class="params">path, action</span>) </span>&#123;</span><br><span class="line">    routes[method].push([pathRegexp(path), action]); </span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面的代码添加了get()、put()、delete()、post()4个方法后，我们希望通过如下的方式完成路由映射:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 增加用户</span></span><br><span class="line">app.post(<span class="string">'/user/:username'</span>, addUser);</span><br><span class="line"><span class="comment">// 删除用户</span></span><br><span class="line">app.delete(<span class="string">'/user/:username'</span>, removeUser); </span><br><span class="line"><span class="comment">// 修改用户</span></span><br><span class="line">app.put(<span class="string">'/user/:username'</span>, updateUser); </span><br><span class="line"><span class="comment">// 查询用户</span></span><br><span class="line">app.get(<span class="string">'/user/:username'</span>, getUser);</span><br></pre></td></tr></table></figure><p>将匹配 的部分抽取为match()方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> match = <span class="function"><span class="keyword">function</span> (<span class="params">pathname, routes</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; routes.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> route = routes[i];</span><br><span class="line">    <span class="comment">// 正则匹配</span></span><br><span class="line">    <span class="keyword">var</span> reg = route[<span class="number">0</span>].regexp;</span><br><span class="line">    <span class="keyword">var</span> keys = route[<span class="number">0</span>].keys;</span><br><span class="line">    <span class="keyword">var</span> matched = reg.exec(pathname); </span><br><span class="line">    <span class="keyword">if</span> (matched) &#123;</span><br><span class="line">      <span class="comment">// 抽取具体值</span></span><br><span class="line">      <span class="keyword">var</span> params = &#123;&#125;;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> value = matched[i + <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">          params[keys[i]] = value; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      req.params = params;</span><br><span class="line">      <span class="keyword">var</span> action = route[<span class="number">1</span>]; </span><br><span class="line">      action(req, res); </span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>改进分发部分</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pathname = url.parse(req.url).pathname; <span class="comment">// 将请求方法变为小写</span></span><br><span class="line">  <span class="keyword">var</span> method = req.method.toLowerCase();</span><br><span class="line">  <span class="keyword">if</span> (routes.hasOwnPerperty(method)) &#123;</span><br><span class="line">    <span class="comment">// 根据请求方法分发</span></span><br><span class="line">    <span class="keyword">if</span> (match(pathname, routes[method])) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果路径没有匹配成功，尝试让all()来处理 </span></span><br><span class="line">      <span class="keyword">if</span> (match(pathname, routes.all)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 直接让all()来处理</span></span><br><span class="line">    <span class="keyword">if</span> (match(pathname, routes.all)) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 处理404请求 </span></span><br><span class="line">  handle404(req, res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>引入中间件(middleware)来简 化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升 开发效率的目的。</p><ul><li>在最早的中间件的定义中，它是一种在操作系统上为应用软件提供服务的计算机软件。它既 不是操作系统的一部分，也不是应用软件的一部分，它处于操作系统与应用软件之间，让应用软 件更好、更方便地使用底层服务。</li><li>如今中间件的含义借指了这种封装底层细节，为上层提供更方 便服务的意义，并非限定在操作系统层面。</li></ul><p>中间件的行为比较类似Java中过滤器(filter)的工作原理，就是在进入具体的业务处理之前， 先让过滤器处理。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggbtuybqsbj30zk0n0whd.jpg" alt="image-20200701221214769"></p><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>next()方法添加err参数，并捕获中间件直接抛出的同步异常</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, stack</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> handle500(err, req, res, stack);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从stack数组中取出中间件并执行 </span></span><br><span class="line">    <span class="keyword">var</span> middleware = stack.shift(); </span><br><span class="line">    <span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">      <span class="comment">// 传入next()函数自身，使中间件能够执行结束后递归</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        middleware(req, res, next);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">        next(err);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 启动执行</span></span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>异步方法的异常不能直接捕获，中间件异步产生的异常需要自己 传递出来</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> session = <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> id = req.cookies.sessionid; </span><br><span class="line">  store.get(id, <span class="function"><span class="keyword">function</span> (<span class="params">err, session</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 将异常通过next()传递</span></span><br><span class="line">      <span class="keyword">return</span> next(err);</span><br><span class="line">    &#125;</span><br><span class="line">    req.session = session;</span><br><span class="line">    next(); </span><br><span class="line">  &#125;);</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure><p>Next()方法接到异常对象后，会将其交给handle500()进行处理。为了将中间件的思想延续下去，我们认为进行异常处理的中间件也是能进行数组式处理的。由于要同时传递异常，所以用于 处理异常的中间件的设计与普通中间件略有差别，它的参数有4个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> middleware = <span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了区分普通中间件和异常处理中间件，handle500()方法将会对中间件按参数进行选取，然后递归执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handle500 = <span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, stack</span>) </span>&#123; </span><br><span class="line">  <span class="comment">// 选取异常处理中间件</span></span><br><span class="line">  stack = stack.filter(<span class="function"><span class="keyword">function</span> (<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> middleware.length === <span class="number">4</span>; </span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从stack数组中取出中间件并执行</span></span><br><span class="line">    <span class="keyword">var</span> middleware = stack.shift();</span><br><span class="line">    <span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">      <span class="comment">// 传递异常对象</span></span><br><span class="line">      middleware(err, req, res, next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 启动执行</span></span><br><span class="line">  next();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="中间件与性能"><a href="#中间件与性能" class="headerlink" title="中间件与性能"></a>中间件与性能</h4><p>为了让业务逻辑提早执行，尽早响应给终端用户，中间件的编写和使用是需要一番考究的。两个主要的能提升的点。</p><ul><li>编写高效的中间件。</li><li>合理利用路由，避免不必要的中间件执行。</li></ul><h5 id="1-编写高效的中间件"><a href="#1-编写高效的中间件" class="headerlink" title="1. 编写高效的中间件"></a>1. 编写高效的中间件</h5><p>编写高效的中间件其实就是提升单个处理单元的处理速度，以尽早调用next()执行后续逻 辑。需要知道的事情是，一旦中间件被匹配，那么每个请求都会使该中间件执行一次，哪怕它只 浪费1毫秒的执行时间，都会让我们的QPS显著下降。常见的优化方法有几种。</p><ul><li>使用高效的方法。必要时通过jsperf.com测试基准性能。</li><li>缓存需要重复计算的结果(需要控制缓存用量，原因在第5章阐述过)。</li><li>避免不必要的计算。比如HTTP报文体的解析，对于GET方法完全不需要。</li></ul><h5 id="2-合理使用路由"><a href="#2-合理使用路由" class="headerlink" title="2. 合理使用路由"></a>2. 合理使用路由</h5><p>合理的路由使得不必要的 中间件不参与请求处理的过程。</p><h3 id="页面渲染"><a href="#页面渲染" class="headerlink" title="页面渲染"></a>页面渲染</h3><h4 id="内容响应"><a href="#内容响应" class="headerlink" title="内容响应"></a>内容响应</h4><h5 id="1-MIME"><a href="#1-MIME" class="headerlink" title="1. MIME"></a>1. MIME</h5><p>浏览器正是通过不同的 Content-Type的值来决定采用不同的渲染方式，这个值我们简称为MIME值。</p><p>MIME的全称是Multipurpose Internet Mail Extensions。</p><p>不同的文件类型具有不同的MIME值，如JSON文件的值为 application/json、XML文件的值为application/xml、PDF文件的值为application/pdf。</p><h5 id="2-附件下载"><a href="#2-附件下载" class="headerlink" title="2. 附件下载"></a>2. 附件下载</h5><p>Content- Disposition字段影响的行为是客户端会根据它的值判断是应该将报文数据当做即时浏览的内 容，还是可下载的附件。当内容只需即时查看时，它的值为inline，当数据可以存为附件时，它 的值为attachment。另外，Content-Disposition字段还能通过参数指定保存时应该使用的文件名。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Content-Disposition</span>: attachment; filename="filename.ext"</span><br></pre></td></tr></table></figure><h5 id="3-响应JSON"><a href="#3-响应JSON" class="headerlink" title="3. 响应JSON"></a>3. 响应JSON</h5><p>为了快捷地响应JSON数据，我们也可以如下这样进行封装:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res.json = <span class="function"><span class="keyword">function</span> (<span class="params">json</span>) </span>&#123; </span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json'</span>);</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  res.end(<span class="built_in">JSON</span>.stringify(json));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-响应跳转"><a href="#4-响应跳转" class="headerlink" title="4. 响应跳转"></a>4. 响应跳转</h5><p>当我们的URL因为某些问题(譬如权限限制)不能处理当前请求，需要将用户跳转到别的 URL时，我们也可以封装出一个快捷的方法实现跳转</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">res.redirect = <span class="function"><span class="keyword">function</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">'Location'</span>, url);</span><br><span class="line">  res.writeHead(<span class="number">302</span>);</span><br><span class="line">  res.end(<span class="string">'Redirect to '</span> + url);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h4><p>Web应用最终呈现 在界面上的内容，都是通过一系列的视图渲染呈现出来的。在动态页面技术中，最终的视图是由 模板和数据共同生成出来的。</p><p>模板是带有特殊标签的HTML片段，通过与数据的渲染，将数据填充到这些特殊标签中，最 后生成普通的带数据的HTML片段。通常我们将渲染方法设计为render()，参数就是模板路径和 数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">res.render = <span class="function"><span class="keyword">function</span> (<span class="params">view, data</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/html'</span>);</span><br><span class="line">  res.writeHead(<span class="number">200</span>);</span><br><span class="line">  <span class="comment">// 实际渲染 </span></span><br><span class="line">  <span class="keyword">var</span> html = render(view, data);</span><br><span class="line">  res.end(html);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h4><p>形成模板技术的4个要素：</p><ul><li>模板语言。</li><li>包含模板语言的模板文件。 </li><li>拥有动态数据的数据对象。 </li><li>模板引擎。</li></ul><p>模板技术并不是什么神秘的技术，它干的实际上是拼接字符串这样很底层的活，只是各种 模板有着各自的优缺点和技巧。</p><p>例如，&lt;%=%&gt;就是我们制定的模板标签，<code>Hello &lt;%= username%&gt;</code>如果我们的数据是{username: “JacksonTian”}，那么我们期望的结果就是Hello JacksonTian。<strong>具体实现的过程是模板分为Hello和&lt;%= username%&gt;两个部分，前者为普通字符串，后者是表达式。 表达式需要继续处理，与数据关联后成为一个变量值，最终将字符串与变量值连成最终的字符串。</strong></p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggbve5ww57j30gy0eagmo.jpg" alt="image-20200701230518087"></p><h5 id="1-模版引擎"><a href="#1-模版引擎" class="headerlink" title="1. 模版引擎"></a>1. 模版引擎</h5><p>这个模板引擎会将Hello &lt;%= username%&gt;转换为”Hello “ + obj.username。该过程进行以下几个步骤。</p><ul><li>语法分解。提取出普通字符串和表达式，这个过程通常用正则表达式匹配出来，&lt;%=%&gt;的正则表达式为/&lt;%=([\s\S]+?)%&gt;/g。</li><li>处理表达式。将标签表达式转换成普通的语言表达式。</li><li>生成待执行的语句。</li><li>与数据一起执行，生成最终字符串。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模板技术呢，就是替换特殊标签的技术</span></span><br><span class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"' + obj."</span> + code + <span class="string">"+ '"</span>; </span><br><span class="line">  &#125;);</span><br><span class="line">  tpl = <span class="string">"var tpl = '"</span> + tpl + <span class="string">"'\nreturn tpl;"</span>;</span><br><span class="line">  <span class="keyword">var</span> complied = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, tpl);</span><br><span class="line">  <span class="keyword">return</span> complied(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="模板编译"><a href="#模板编译" class="headerlink" title="模板编译"></a><strong>模板编译</strong></h6><p>为了能够最终与数据一起执行生成字符串，我们需要将原始的模板字符串转换成一个函数对象。这个过程称为模板编译，生成的中间函数只与模板字符串相关，与具体的数据无关。如果每 次都生成这个中间函数，就会浪费CPU。为了提升模板渲染的性能速度，我们通常会采用模板预编译的方式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complie = <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"' + obj."</span> + code + <span class="string">"+ '"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  tpl = <span class="string">"var tpl = '"</span> + tpl + <span class="string">"'\nreturn tpl;"</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj, escape'</span>, tpl);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">complied, data</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> complied(data);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过预编译缓存模板编译后的结果，实际应用中就可以实现一次编译，多次执行。</p><h5 id="2-with的应用"><a href="#2-with的应用" class="headerlink" title="2. with的应用"></a>2. with的应用</h5><p>上面实现的模板引擎非常弱，只能替换变量，&lt;%=”Jackson Tian”%&gt;就无法支持了。为了让它 更灵活，我们需要改进它的实现，使字符串能继续表达为字符串，变量能够自动寻找属于它的对 象。于是with关键字引入到我们的实现中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> complie = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 模板技术呢，就是替换特殊标签的技术</span></span><br><span class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"' + "</span> + code + <span class="string">"+ '"</span>; </span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">  tpl = <span class="string">"tpl = '"</span> + tpl + <span class="string">"'"</span>;</span><br><span class="line">  tpl = <span class="string">'var tpl = "";\nwith (obj) &#123;'</span> + tpl + <span class="string">'&#125;\nreturn tpl;'</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, tpl);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="模板安全"><a href="#模板安全" class="headerlink" title="模板安全"></a>模板安全</h6><p>为了提高安全性，大多数模板都提供了转义的功能。转义就是将能形成HTML 标签的字符转换成安全的字符，这些字符主要有&amp;、&lt;、&gt;、”、’。</p><p>转义函数如下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">escape</span> = <span class="function"><span class="keyword">function</span> (<span class="params">html</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">String</span>(html)</span><br><span class="line">    .replace(<span class="regexp">/&amp;(?!\w+;)/g</span>, <span class="string">'&amp;amp;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/&lt;/g</span>, <span class="string">'&amp;lt;'</span>) </span><br><span class="line">    .replace(<span class="regexp">/&gt;/g</span>, <span class="string">'&amp;gt;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/"/g</span>, <span class="string">'&amp;quot;'</span>)</span><br><span class="line">    .replace(<span class="regexp">/'/g</span>, <span class="string">'&amp;#039;'</span>); <span class="comment">// IE下不支持&amp;apos;(单引号)转义</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不确定要输出HTML标签的字符最好都转义</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> render = <span class="function"><span class="keyword">function</span> (<span class="params">str, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> tpl = str.replace(<span class="regexp">/\n/g</span>, <span class="string">'\\n'</span>) <span class="comment">// 将换行符替换</span></span><br><span class="line">  .replace(<span class="regexp">/&lt;%=([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 转义</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"' + escape("</span> + code + <span class="string">") + '"</span>;</span><br><span class="line">  &#125;).replace(<span class="regexp">/&lt;%-([\s\S]+?)%&gt;/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, code</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 正常输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"' + "</span> + code + <span class="string">"+ '"</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  tpl = <span class="string">"tpl = '"</span> + tpl + <span class="string">"'"</span>;</span><br><span class="line">  tpl = <span class="string">'var tpl = "";\nwith (obj) &#123;'</span> + tpl + <span class="string">'&#125;\nreturn tpl;'</span>;</span><br><span class="line">  <span class="comment">// 加上escape()函数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'obj'</span>, <span class="string">'escape'</span>, tpl);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模板引擎通过正则分别匹配-和=并区别对待，最后不要忘记传入escape()函数。最终上面的危险代码会转换为安全的输出</p><h5 id="3-模板逻辑"><a href="#3-模板逻辑" class="headerlink" title="3. 模板逻辑"></a>3. 模板逻辑</h5><p>尽管模板技术已经将业务逻辑与视图部分分离开来，但是视图上还是会存在一些逻辑来控制 页面的最终渲染。为了让上述模板变得强大一点，我们为它添加逻辑代码，使得模板可以像ASP、 PHP那样控制页面渲染。</p><h5 id="4-集成文件系统"><a href="#4-集成文件系统" class="headerlink" title="4. 集成文件系统"></a>4. 集成文件系统</h5><p>前文我们实现的complie()和render()函数已经能够实现将输入的模板字符串进行编译和替 换的功能。如果与前文的HTTP响应对象组合起来处理的话，其缺点有如下几点</p><ul><li>每次请求需要反复读磁盘上的模板文件。</li><li>每次请求需要编译。</li><li>调用烦琐。</li></ul><p>我们需要一个更简洁、性能更好的render()函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> VIEW_FOLDER = <span class="string">'/path/to/wwwroot/views'</span>;</span><br><span class="line">res.render = <span class="function"><span class="keyword">function</span> (<span class="params">viewname, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!cache[viewname]) &#123;  </span><br><span class="line">    <span class="keyword">var</span> text;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      text = fs.readFileSync(path.join(VIEW_FOLDER, viewname), <span class="string">'utf8'</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line"> </span><br><span class="line">      res.writeHead(<span class="number">500</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">      res.end(<span class="string">'模板文件错误'</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cache[viewname] = complie(text);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> complied = cache[viewname];</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">  <span class="keyword">var</span> html = complied(data);</span><br><span class="line">  res.end(html);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个res.render()实现中，虽然有同步读取文件的情况，但是由于采用了缓存，只会在第一次读取的时候造成整个进程的阻塞，一旦缓存生效，将不会反复读取模板文件。其次，缓存之前 已经进行了编译，也不会每次读取都编译</p><p>与文件系统集成之后，再引入缓存，可以很好地解决性能问题，接口也大大得到简化。由于 模板文件内容都不太大，也不属于动态改动的，所以使用进程的内存来缓存编译结果，并不会引 起太大的垃圾回收问题。</p><h5 id="5-子模板"><a href="#5-子模板" class="headerlink" title="5. 子模板"></a>5. 子模板</h5><p>有时候模板文件太大，太过复杂，会增加维护上的难度，而且有些模板是可以重用的，这催 生了子模板(Partial View)的产生。子模板可以嵌套在别的模板中，多个模板可以嵌入同一个子 模板中。维护多个子模板比维护完整而复杂的大模板的成本要低很多，很多复杂问题可以降解为 多个小而简单的问题。</p><p>这里我们采用include关键字来实现模板的嵌套。</p><p>母模板如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">users.forEach</span>(<span class="attr">function</span>(<span class="attr">user</span>)&#123; %&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">include</span> <span class="attr">user</span>/<span class="attr">show</span> %&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>子模板user/show内容如下:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=user.name%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br></pre></td></tr></table></figure><p>渲染出来的效果应当跟以下代码渲染出来的效果别无二致:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">users.forEach</span>(<span class="attr">function</span>(<span class="attr">user</span>)&#123; %&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=user.name%</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以实现子模板的诀窍就是先将include语句进行替换，再进行整体性编译</p><h5 id="6-布局视图"><a href="#6-布局视图" class="headerlink" title="6. 布局视图"></a>6. 布局视图</h5><p>子模板的另一种使用方式就是布局视图 (layout)，布局视图又称母版页，它与子模板的原理相同，但是场景稍有区别。一般而言模板指 定了子模板，那它的子模板就无法进行替换了，子模板被嵌入到多个父模板中属于正常需求，但 是如果在多个父模板中只是嵌入的子视图不同，模板内容却完全一样，也会出现重复。</p><p>比如下面两个简单的父模板:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 模板1 </span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">users.forEach</span>(<span class="attr">function</span>(<span class="attr">user</span>)&#123; %&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">include</span> <span class="attr">user</span>/<span class="attr">show</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">// 模板2 </span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> <span class="attr">users.forEach</span>(<span class="attr">function</span>(<span class="attr">user</span>)&#123; %&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">%</span> <span class="attr">include</span> <span class="attr">profile</span> %&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这些重复的内容主要用来布局，为了能将这些布局模板重用起来，模板技术必须支持布局视 图。支持布局视图之后，布局模板就只有一份，渲染视图时，指定好布局视图就可以了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res.render(<span class="string">'viewname'</span>, &#123; </span><br><span class="line">  layout: <span class="string">'layout.html'</span>, </span><br><span class="line">  users: []</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>对于布局模板文件，我们设计为将&lt;%- body %&gt;部分替换为我们的子模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">users.forEach</span>(<span class="attr">function</span>(<span class="attr">user</span>)&#123; %&gt;</span> </span><br><span class="line"> <span class="tag">&lt;<span class="name">%-</span> <span class="attr">body</span> %&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">%</span> &#125;) %&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="7-模板性能"><a href="#7-模板性能" class="headerlink" title="7. 模板性能"></a>7. 模板性能</h5><p>模板引擎的优化步骤:</p><ul><li>缓存模板文件。</li><li>缓存模板文件编译后的函数。</li><li>优化模板中的执行表达式</li></ul><h4 id="Bigpipe"><a href="#Bigpipe" class="headerlink" title="Bigpipe"></a>Bigpipe</h4><p>它的提出主要是为了解决重数据页面 的加载速度问题</p><p>Bigpipe的解决思路则是将页面分割成多个部分(pagelet)，先向用户输出没有数据的布局(框 架)，将每个部分逐步输出到前端，再最终渲染填充框架，完成整个网页的渲染。这个过程中需 要前端JavaScript的参与，它负责将后续输出的数据渲染到页面上。</p><p>Bigpipe是一个需要前后端配合实现的优化技术，这个技术有几个重要的点。 </p><ul><li><p>页面布局框架(无数据的)。</p></li><li><p>后端持续性的数据输出。</p></li><li><p>前端渲染</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggbxbyx0e4j31500f4abp.jpg" alt="image-20200702001224073"></p><h5 id="1-页面布局框架"><a href="#1-页面布局框架" class="headerlink" title="1. 页面布局框架"></a>1. 页面布局框架</h5><p>页面布局框架依然由后端渲染而出</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> layout = <span class="string">'layout.html'</span>;</span><br><span class="line">app.get(<span class="string">'/profile'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!cache[layout]) &#123;</span><br><span class="line">    cache[layout] = fs.readFileSync(path.join(VIEW_FOLDER, layout), <span class="string">'utf8'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/html'</span>&#125;);</span><br><span class="line">  res.write(render(complie(cache[layout])));</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这个布局文件中要引入必要的前端脚本，如jQuery、Underscore等常用库，其次要引入我们 重要的前端脚本，这里的文件名为bigpipe.js。</p><p>整体模板文件如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// layout.html </span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Bigpipe示例<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"underscore.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bigpipe.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"body"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tpl_body"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">%=articles%</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/template"</span> <span class="attr">id</span>=<span class="string">"tpl_footer"</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">%=users%</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span></span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> bigpipe = <span class="keyword">new</span> Bigpipe(); </span></span><br><span class="line"><span class="actionscript">  bigpipe.ready(<span class="string">'articles'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#body'</span>).html(_.render($(<span class="string">'#tpl_body'</span>).html(), &#123;<span class="attr">articles</span>: data&#125;)); </span></span><br><span class="line">  &#125;);</span><br><span class="line"><span class="actionscript">  bigpipe.ready(<span class="string">'copyright'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(data)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#footer'</span>).html(_.render($(<span class="string">'#tpl_footer'</span>).html(), &#123;<span class="attr">users</span>: data&#125;));</span></span><br><span class="line">  &#125;); </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2-持续数据输出"><a href="#2-持续数据输出" class="headerlink" title="2. 持续数据输出"></a>2. 持续数据输出</h5><p>模板输出后，整个网页的渲染并没有结束，但用户已经可以看到整个页面的大体样子。接下 来我们继续数据输出，与普通的数据输出不同，这里的数据输出之后需要被前端脚本处理，是故 需要对它进行封装处理</p><h5 id="3-前端渲染"><a href="#3-前端渲染" class="headerlink" title="3. 前端渲染"></a>3. 前端渲染</h5><p>前文的bigpipe.ready()和bigpipe.set()是整个前端的渲染机制，前者以一个key注册一个事 件，后者则触发一个事件，以此完成页面的渲染机制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Bigpipe = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">this</span>.callbacks = &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bigpipe.prototype.ready = <span class="function"><span class="keyword">function</span> (<span class="params">key, callback</span>) </span>&#123; </span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">this</span>.callbacks[key]) &#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks[key] = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.callbacks[key].push(callback);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Bigpipe.prototype.set = <span class="function"><span class="keyword">function</span> (<span class="params">key, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> callbacks = <span class="keyword">this</span>.callbacks[key] || [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; callbacks.length; i++) &#123;</span><br><span class="line">    callbacks[i].call(<span class="keyword">this</span>, data); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Bigpipe将网页布局和数据渲染分离，使得用户在视觉上觉得网页提前渲染好了，其随着数据 输出的过程逐步渲染页面，使得用户能够感知到页面是活的。这远比一开始给出空白页面，然后 在某个时候突然渲染好带给用户的体验更好。Node在这个过程中，其异步特性使得数据的输出能 够并行，数据的输出与数据调用的顺序无关，越早调用完的数据可以越早渲染到页面中，这个特 性使得Bigpipe更趋完美。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深入浅出Node-js学习笔记（三）&quot;&gt;&lt;a href=&quot;#深入浅出Node-js学习笔记（三）&quot; class=&quot;headerlink&quot; title=&quot;深入浅出Node.js学习笔记（三）&quot;&gt;&lt;/a&gt;深入浅出Node.js学习笔记（三）&lt;/h1&gt;&lt;h2 id=&quot;第
      
    
    </summary>
    
      <category term="Node.js" scheme="http://yoursite.com/categories/Node-js/"/>
    
    
      <category term="Node.js" scheme="http://yoursite.com/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>单页应用优缺点</title>
    <link href="http://yoursite.com/2020/06/20/%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E4%BC%98%E7%BC%BA%E7%82%B9/"/>
    <id>http://yoursite.com/2020/06/20/单页应用优缺点/</id>
    <published>2020-06-20T14:08:44.000Z</published>
    <updated>2020-07-01T12:24:17.964Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单页应用优缺点？"><a href="#单页应用优缺点？" class="headerlink" title="单页应用优缺点？"></a>单页应用优缺点？</h1><h2 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h2><p>1、具有桌面应用的即时性、网站的可移植性和可访问性。<br>2、用户体验好、快，内容的改变不需要重新加载整个页面，web应用更具响应性和更令人着迷。<br>3、基于上面一点，SPA相对对服务器压力小。<br>4、良好的前后端分离。SPA和RESTful架构一起使用，后端不再负责模板渲染、输出页面工作，web前端和各种移动终端地位对等，后端API通用化。<br>5、对前端人员javascript技能要求更高，促使团队技能提升。</p><h2 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h2><p><strong>1) SEO难度较高</strong></p><p>由于所有的内容都在一个页面中动态替换显示，所以在SEO上其有着天然的弱势，所以如果你的站点对SEO很看重，且要用单页应用，那么就做些静态页面给搜索引擎用吧；</p><p><strong>2) 前进、后退管理</strong></p><p>由于单页Web应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理，当然此问题也有解决方案，比如利用URI中的散列+iframe实现；</p><p><strong>3) 初次加载耗时多</strong></p><p>为实现单页Web应用功能及显示效果，需要在加载页面的时候将JavaScript、CSS统一加载，部分页面可以在需要的时候加载。所以必须对JavaScript及CSS代码进行合并压缩处理；</p><p><strong>4)分功能模块的鉴权不好实现。</strong></p><p><strong>5)对开发人员技能水平、开发成本高。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单页应用优缺点？&quot;&gt;&lt;a href=&quot;#单页应用优缺点？&quot; class=&quot;headerlink&quot; title=&quot;单页应用优缺点？&quot;&gt;&lt;/a&gt;单页应用优缺点？&lt;/h1&gt;&lt;h2 id=&quot;优点：&quot;&gt;&lt;a href=&quot;#优点：&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>VUE和REACT简要对比</title>
    <link href="http://yoursite.com/2020/06/11/VUE%E5%92%8CREACT%E7%AE%80%E8%A6%81%E5%AF%B9%E6%AF%94/"/>
    <id>http://yoursite.com/2020/06/11/VUE和REACT简要对比/</id>
    <published>2020-06-11T13:52:10.000Z</published>
    <updated>2020-07-01T12:20:01.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="VUE和REACT简要对比"><a href="#VUE和REACT简要对比" class="headerlink" title="VUE和REACT简要对比"></a>VUE和REACT简要对比</h1><h2 id="1-相同点："><a href="#1-相同点：" class="headerlink" title="1.相同点："></a>1.相同点：</h2><ul><li><p>React采用特殊的JSX语法，Vue.js在组件开发中也推崇编写.vue特殊文件格式，对文件内容都有一些约定，两者都需要编译后使用；</p></li><li><p>中心思想相同：一切都是组件，组件实例之间可以嵌套；</p></li><li><p>都提供合理的钩子函数，可以让开发者定制化地去处理需求；</p></li><li><p>在组件开发中都支持mixins的特性。</p></li><li><p>使用 Virtual DOM，有自己的diff渲染算法</p></li><li><p>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</p></li><li><p>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。都不内置列数AJAX，Route等功能到核心包，而是以插件的方式加载。</p><h2 id="2-Virtual-DOM渲染不同点："><a href="#2-Virtual-DOM渲染不同点：" class="headerlink" title="2.Virtual DOM渲染不同点："></a>2.Virtual DOM渲染不同点：</h2></li></ul><p>Virtual DOM是一个映射真实DOM的JavaScript对象，如果需要改变任何元素的状态，那么是先在Virtual DOM上进行改变，而不是直接改变真实的DOM。当有变化产生时，一个新的Virtual DOM对象会被创建并计算新旧Virtual DOM之间的差别。之后这些差别会应用在真实的DOM上。</p><h3 id="React："><a href="#React：" class="headerlink" title="React："></a>React：</h3><p>React采用的Virtual DOM会对渲染出来的结果做脏检查；在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。</p><p>如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 PureComponent，或是手动实现 shouldComponentUpdate 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。</p><p>然而，使用 PureComponent 和 shouldComponentUpdate 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。</p><h3 id="Vue："><a href="#Vue：" class="headerlink" title="Vue："></a>Vue：</h3><p>在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 shouldComponentUpdate，并且没有上述的子树问题限制。</p><p>Vue.js在模板中提供了指令，过滤器等，可以非常方便，快捷地操作Virtual DOM。</p><h2 id="3-状态管理-vs-对象属性"><a href="#3-状态管理-vs-对象属性" class="headerlink" title="3.状态管理 vs 对象属性"></a>3.状态管理 vs 对象属性</h2><h3 id="React：-1"><a href="#React：-1" class="headerlink" title="React："></a>React：</h3><p>React在state状态管理存储数据的，不能修改数据，修改数据在Setstate中 setState是异步的，如果需要马上利用结果，需要在setState传入回调，具体可以看看<a href="https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000014498196" target="_blank" rel="noopener"> React中setState几个现象—先知道再理解</a></p><h3 id="Vue：-1"><a href="#Vue：-1" class="headerlink" title="Vue："></a>Vue：</h3><p>在Vue中，state对象并不是必须的，数据由data属性在Vue对象中进行管理</p><h2 id="4-JSX-vs-Templates"><a href="#4-JSX-vs-Templates" class="headerlink" title="4.JSX vs Templates"></a>4.JSX vs Templates</h2><h3 id="React：-2"><a href="#React：-2" class="headerlink" title="React："></a>React：</h3><p>在 React 中，所有的组件的渲染功能都依靠 JSX。 使用 JSX 的渲染函数有下面这些优势：</p><ul><li>你可以使用完整的编程语言 JavaScript 功能来构建你的视图页面。比如你可以使用临时变量、JS 自带的流程控制、以及直接引用当前 JS 作用域中的值等等。</li><li>开发工具对 JSX 的支持相比于现有可用的其他 Vue 模板还是比较先进的 (比如，linting、类型检查、编辑器的自动完成)。</li></ul><h3 id="Vue：-2"><a href="#Vue：-2" class="headerlink" title="Vue："></a>Vue：</h3><p>虽然Vue也可以使用JSX，但基本都使用模版语法，这也带来了一些特有的优势：</p><ul><li>对于很多习惯了 HTML 的开发者来说，模板比起 JSX 读写起来更自然。这里当然有主观偏好的成分，但如果这种区别会导致开发效率的提升，那么它就有客观的价值存在。</li><li>基于 HTML 的模板使得将已有的应用逐步迁移到 Vue 更为容易。</li></ul><h2 id="5-组件作用域内的-CSS"><a href="#5-组件作用域内的-CSS" class="headerlink" title="5.组件作用域内的 CSS"></a>5.组件作用域内的 CSS</h2><h3 id="Vue：-3"><a href="#Vue：-3" class="headerlink" title="Vue："></a>Vue：</h3><p>设置样式的默认方法是单文件组件里类似 style 的标签。 单文件组件让你可以在同一个文件里完全控制 CSS，将其作为组件代码的一部分。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">  <span class="selector-class">.container</span>&#123;</span><br><span class="line">      <span class="attribute">display</span>:flex;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><p>这个可选 scoped 属性会自动添加一个唯一的属性 (比如 data-v-8123) 为组件内 CSS 指定作用域。</p><h3 id="React"><a href="#React" class="headerlink" title="React:"></a>React:</h3><p>语法不太一样，React设置class是用className字段，而设置css是使用对象的形式，当然，一般还是引入外部的css(经过编译的sass或者less文件)比较合适。</p><h2 id="6-规模"><a href="#6-规模" class="headerlink" title="6.规模"></a>6.规模</h2><p>Vue 和 React 都提供了强大的路由来应对大型应用。React 社区在状态管理方面非常有创新精神 (比如 Flux、Redux)，而这些状态管理模式甚至 Redux 本身也可以非常容易的集成在 Vue 应用中。实际上，Vue 更进一步地采用了这种模式 (Vuex)，更加深入集成 Vue 的状态管理解决方案 Vuex 相信能为你带来更好的开发体验。</p><p>两者另一个重要差异是，Vue 的路由库和状态管理库都是由官方维护支持且与核心库同步更新的。React 则是选择把这些问题交给社区维护，因此创建了一个更分散的生态系统。但相对的，React 的生态系统相比 Vue 更加繁荣。</p><h2 id="7-构建工具"><a href="#7-构建工具" class="headerlink" title="7.构建工具"></a>7.构建工具</h2><p>React和Vue都有自己的构建工具，你可以使用它快速搭建开发环境。</p><h3 id="React：-3"><a href="#React：-3" class="headerlink" title="React："></a>React：</h3><p>React可以使用Create React App (CRA)，由于CRA有很多选项，使用起来会稍微麻烦一点。这个工具会逼迫你使用Webpack和Babel。</p><h3 id="Vue：-4"><a href="#Vue：-4" class="headerlink" title="Vue："></a>Vue：</h3><p>Vue对应的则是vue-cli。vue-cli则有模板列表可选，能按需创造不同模板，使用起来更灵活一点。</p><p>两个工具都能让你得到一个根据最佳实践设置的项目模板。都能为你建立一个好环境。</p><h1 id="react"><a href="#react" class="headerlink" title="react"></a>react</h1><h2 id="React是什么特性的，有什么用？配套的全家桶是什么？"><a href="#React是什么特性的，有什么用？配套的全家桶是什么？" class="headerlink" title="React是什么特性的，有什么用？配套的全家桶是什么？"></a>React是什么特性的，有什么用？配套的全家桶是什么？</h2><ul><li>React不是一个MVC框架，它是构建易于可重复调用的web组件，侧重于UI, 也就是view层</li><li>其次React是单向的从数据到视图的渲染，非双向数据绑定</li><li>不直接操作DOM对象，而是通过虚拟DOM通过diff算法以最小的步骤作用到真实的DOM上。</li><li>不便于直接操作DOM，大多数时间只是对 virtual DOM 进行编程</li></ul><p>配套redux</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;VUE和REACT简要对比&quot;&gt;&lt;a href=&quot;#VUE和REACT简要对比&quot; class=&quot;headerlink&quot; title=&quot;VUE和REACT简要对比&quot;&gt;&lt;/a&gt;VUE和REACT简要对比&lt;/h1&gt;&lt;h2 id=&quot;1-相同点：&quot;&gt;&lt;a href=&quot;#1-相
      
    
    </summary>
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
  <entry>
    <title>setInterval</title>
    <link href="http://yoursite.com/2020/06/02/setInterval/"/>
    <id>http://yoursite.com/2020/06/02/setInterval/</id>
    <published>2020-06-02T00:15:39.000Z</published>
    <updated>2020-07-01T12:16:43.831Z</updated>
    
    <content type="html"><![CDATA[<h1 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval"></a>setInterval</h1><h2 id="setInterval-基础"><a href="#setInterval-基础" class="headerlink" title="setInterval()基础"></a>setInterval()基础</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>setInterval函数的用法与setTimeout完全一致，区别仅仅在于setInterval指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p><h3 id="间隔"><a href="#间隔" class="headerlink" title="间隔"></a>间隔</h3><p><code>setInterval</code> 指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的事件。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code> 指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后 95 毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要 105 毫秒，那么它结束后，下一次执行就会立即开始。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(i++);</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>上面代码每隔2000毫秒，就跳出一个alert对话框。如果用户一直不点击“确定”，整个浏览器就处于“堵塞”状态，后面的执行就一直无法触发，将会累积起来。举例来说，第一次跳出alert对话框后，用户过了6000毫秒才点击“确定”，那么第二次、第三次、第四次执行将累积起来，它们之间不会再有等待间隔。</p><p><strong>HTML 5标准规定，<code>setInterval</code> 的最短间隔时间是10毫秒，也就是说，小于10毫秒的时间间隔会被调整到10毫秒。</strong></p><h2 id="setInterval运行机制"><a href="#setInterval运行机制" class="headerlink" title="setInterval运行机制"></a><strong>setInterval运行机制</strong></h2><p><strong>setInterval</strong> 的运行机制是，将指定的代码移出本次执行，等到下一轮Event Loop时，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就等到再下一轮Event Loop时重新判断。这意味着，<code>setTimeout</code> 和 <code>setInterval</code> 指定的代码，必须等到本次执行的所有代码都执行完，才会执行。</p><p>每一轮Event Loop时，都会将“任务队列”中需要执行的任务，一次执行完。setTimeout 和 setInterval 都是把任务添加到“任务队列”的尾部。因此，它们实际上要等到当前脚本的所有同步任务执行完，然后再等到本次 Event Loop 的“任务队列”的所有任务执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证 <code>setTimeout</code> 和 <code>setInterval</code> 指定的任务，一定会按照预定时间执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;,<span class="number">1000</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  sleeping(<span class="number">3000</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>上面的第一行语句要求每隔1000毫秒，就输出一个2。但是，第二行语句需要3000毫秒才能完成，请问会发生什么结果？</p><p><u>结果就是等到第二行语句运行完成以后，立刻连续输出三个2，然后开始每隔1000毫秒，输出一个2。也就是说，setIntervel具有<strong>累积效应</strong>，如果某个操作特别耗时，超过了setInterval的时间间隔，排在后面的操作会被累积起来，然后在很短的时间内连续触发，这可能或造成性能问题（比如集中发出Ajax请求）。</u></p><p><strong>如果执行时间大于预设间隔时间，很可能导致连续执行，中间没有时间间隔，这是很糟糕的，很可能会耗费大量cpu.</strong></p><blockquote><p>如果你在一个大的JavaScript代码块正在执行的时候把所有的interval回调函数都囤起来的话，其结果就是在JavaScript代码块执行完 了之后会有一堆的interval事件被执行，而执行过程中不会有间隔。因此，取代的作法是浏览器情愿先等一等，以确保在一个interval进入队列的 时候队列中没有别的interval。</p></blockquote><p><strong>setInterval去排队时，如果发现自己还在队列中未执行，则会被drop调，同一个interval，在队列里只会有一个</strong></p><blockquote><p>interval是不管当前在执行些什么的，在任何情况下它都会进入到队列中去，即使这样意味着每次回调之间的时间就不准确了。<a href="https://www.cnblogs.com/youxin/p/3354924.html" target="_blank" rel="noopener">https://www.cnblogs.com/youxin/p/3354924.html</a></p></blockquote><p>但上一示例，在Nodejs环境下测试，并不会连续输出三个2；理由：setInterval 在准备把回调函数加入到事件队列的时候，会判断队列中是否还有未执行的回调，如果有的话，它就不会再往队列中添加回调函数。</p><h2 id="弹窗会让-Chrome-Opera-Safari-内的时钟停止"><a href="#弹窗会让-Chrome-Opera-Safari-内的时钟停止" class="headerlink" title="弹窗会让 Chrome/Opera/Safari 内的时钟停止"></a>弹窗会让 Chrome/Opera/Safari 内的时钟停止</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每 2 秒重复一次</span></span><br><span class="line"><span class="keyword">let</span> timerId = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> alert(<span class="string">'tick'</span>), <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5 秒之后停止</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123; clearInterval(timerId); alert(<span class="string">'stop'</span>); &#125;, <span class="number">5000</span>);</span><br></pre></td></tr></table></figure><p>在众多浏览器中，IE 和 Firefox 在显示 <code>alert/confirm/prompt</code> 时，内部的定时器仍旧会继续滴答，但是在 Chrome、Opera 和 Safari 中，内部的定时器会暂停/冻结。</p><p>所以，在执行以上代码时，如果在一定时间内没有关掉 <code>alert</code> 弹窗，那么在你关闭弹窗后，Firefox/IE 会立即显示下一个 <code>alert</code> 弹窗（前提是距离上一次执行超过了 2 秒），而 Chrome/Opera/Safari 这三个则需要再等待 2 秒以上的时间才会再显示（因为在 <code>alert</code> 弹窗期间，定时器并没有滴答）。</p><h2 id="标签处于非活动状态时不同浏览器的表现"><a href="#标签处于非活动状态时不同浏览器的表现" class="headerlink" title="标签处于非活动状态时不同浏览器的表现"></a>标签处于非活动状态时不同浏览器的表现</h2><p><strong>如果网页不在浏览器的当前窗口（或tab），许多浏览器限制 <code>setInteral</code> 指定的反复运行的任务最多每秒执行一次。</strong></p><h3 id="chrome"><a href="#chrome" class="headerlink" title="chrome"></a>chrome</h3><p>当标签处于非活动状态时，Chrome会将最小间隔<code>setInterval</code>限制为大约1000毫秒。 如果间隔高于1000毫秒，它将以指定的间隔运行。 窗口是否失焦并不重要，只有当您切换到不同的选项卡时才会限制间隔。 </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Provides control over the minimum timer interval for background tabs.</span></span><br><span class="line"><span class="keyword">const</span> double kBackgroundTabTimerInterval = <span class="number">1.0</span>;</span><br></pre></td></tr></table></figure><p>[<a href="https://codereview.chromium.org/6546021/patch/1001/2001]" target="_blank" rel="noopener">https://codereview.chromium.org/6546021/patch/1001/2001]</a></p><h3 id="火狐"><a href="#火狐" class="headerlink" title="火狐"></a>火狐</h3><p>与Chrome类似，当标签页（非窗口）处于非活动状态时，Firefox会将最小间隔<code>setInterval</code>限制为大约1000毫秒。 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The default shortest interval/timeout we permit</span></span><br><span class="line">#define DEFAULT_MIN_TIMEOUT_VALUE 4 // 4ms</span><br><span class="line">#define DEFAULT_MIN_BACKGROUND_TIMEOUT_VALUE 1000 // 1000ms</span><br></pre></td></tr></table></figure><p>[<a href="https://hg.mozilla.org/releases/mozilla-release/file/0bf1cadfb004/dom/base/nsGlobalWindow.cpp#l296]" target="_blank" rel="noopener">https://hg.mozilla.org/releases/mozilla-release/file/0bf1cadfb004/dom/base/nsGlobalWindow.cpp#l296]</a></p><h3 id="IE浏览器"><a href="#IE浏览器" class="headerlink" title="IE浏览器"></a>IE浏览器</h3><p>当选项卡处于非活动状态时，IE不会限制<code>setInterval</code>中的延迟，窗口是否失焦并不重要。</p><h3 id="Edge"><a href="#Edge" class="headerlink" title="Edge"></a>Edge</h3><p>从Edge 14开始，<code>setInterval</code>在非活动选项卡中的上限为1000毫秒。</p><h3 id="safari"><a href="#safari" class="headerlink" title="safari"></a>safari</h3><p>就像Chrome一样，当标签处于非活动状态时，Safari会在1000毫秒时限制<code>setInterval</code>。 </p><h3 id="Opera"><a href="#Opera" class="headerlink" title="Opera"></a>Opera</h3><p>自从采用Webkit引擎以来，Opera表现出与Chrome相同的行为。 <code>setInterval</code>上限为1000毫秒。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;setInterval&quot;&gt;&lt;a href=&quot;#setInterval&quot; class=&quot;headerlink&quot; title=&quot;setInterval&quot;&gt;&lt;/a&gt;setInterval&lt;/h1&gt;&lt;h2 id=&quot;setInterval-基础&quot;&gt;&lt;a href=&quot;#set
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JSBridge</title>
    <link href="http://yoursite.com/2020/05/22/JSBridge/"/>
    <id>http://yoursite.com/2020/05/22/JSBridge/</id>
    <published>2020-05-22T04:35:51.000Z</published>
    <updated>2020-07-01T12:12:59.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JsBridge"><a href="#JsBridge" class="headerlink" title="JsBridge"></a>JsBridge</h1><p><a href="https://www.cnblogs.com/dailc/p/5931324.html" target="_blank" rel="noopener">JS bridge原理</a></p><h2 id="JSBridge-的用途"><a href="#JSBridge-的用途" class="headerlink" title="JSBridge 的用途"></a>JSBridge 的用途</h2><p>JSBridge 简单来讲，主要是 <strong>给 JavaScript 提供调用 Native 功能的接口</strong>，让混合开发中的『前端部分』可以方便地使用地址位置、摄像头甚至支付等 Native 功能。</p><p>既然是『简单来讲』，那么 JSBridge 的用途肯定不只『调用 Native 功能』这么简单宽泛。实际上，JSBridge 就像其名称中的『Bridge』的意义一样，是 Native 和非 Native 之间的桥梁，它的核心是 <strong>构建 Native 和非 Native 间消息通信的通道</strong>，而且是 <strong>双向通信的通道</strong>。</p><p>所谓 <strong>双向通信的通道</strong></p><ul><li>JS 向 Native 发送消息 : 调用相关功能、通知 Native 当前 JS 的相关状态等。</li><li>Native 向 JS 发送消息 : 回溯调用结果、消息推送、通知 JS 当前 Native 的状态等。</li></ul><h2 id="JSBridge-的实现原理"><a href="#JSBridge-的实现原理" class="headerlink" title="JSBridge 的实现原理"></a>JSBridge 的实现原理</h2><p>JavaScript 是运行在一个单独的 JS Context 中（例如，WebView 的 Webkit 引擎、JSCore）。由于这些 Context 与原生运行环境的天然隔离，我们可以将这种情况与 RPC（Remote Procedure Call，远程过程调用）通信进行类比，将 Native 与 JavaScript 的每次互相调用看做一次 RPC 调用。</p><p>在 JSBridge 的设计中，可以把前端看做 RPC 的客户端，把 Native 端看做 RPC 的服务器端，从而 JSBridge 要实现的主要逻辑就出现了：<strong>通信调用（Native 与 JS 通信）</strong> 和 <strong>句柄解析调用</strong>。（如果你是个前端，而且并不熟悉 RPC 的话，你也可以把这个流程类比成 JSONP 的流程）</p><p>通过以上的分析，可以清楚地知晓 JSBridge 主要的功能和职责，接下来就以 <strong>Hybrid 方案</strong> 为案例从这几点来剖析 JSBridge 的实现原理。</p><h3 id="JavaScript-调用-Native"><a href="#JavaScript-调用-Native" class="headerlink" title="JavaScript 调用 Native"></a>JavaScript 调用 Native</h3><p>JavaScript 调用 Native 的方式，主要有两种：<strong>注入 API</strong> 和 <strong>拦截 URL SCHEME</strong>。</p><h4 id="注入API"><a href="#注入API" class="headerlink" title="注入API"></a>注入API</h4><p>注入 API 方式的主要原理是，通过 WebView 提供的接口，向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</p><h4 id="拦截-URL-SCHEME"><a href="#拦截-URL-SCHEME" class="headerlink" title="拦截 URL SCHEME"></a>拦截 URL SCHEME</h4><p>先解释一下 URL SCHEME：URL SCHEME是一种类似于url的链接，是为了方便app直接互相调用设计的，形式和普通的 url 近似，主要区别是 protocol 和 host 一般是自定义的，例如: qunarhy://hy/url?url=<a href="https://link.juejin.im?target=http%3A%2F%2Fymfe.tech" target="_blank" rel="noopener">ymfe.tech</a>，protocol 是 qunarhy，host 则是 hy。</p><p>拦截 URL SCHEME 的主要流程是：Web 端通过某种方式（例如 iframe.src）发送 URL Scheme 请求，之后 Native 拦截到请求并根据 URL SCHEME（包括所带的参数）进行相关操作。</p><p>在时间过程中，这种方式有一定的 <strong>缺陷</strong>：</p><ul><li>使用 iframe.src 发送 URL SCHEME 会有 url 长度的隐患。</li><li>创建请求，需要一定的耗时，比注入 API 的方式调用同样的功能，耗时会较长。</li></ul><p>但是之前为什么很多方案使用这种方式呢？因为它 <strong>支持 iOS6</strong>。而现在的大环境下，iOS6 占比很小，基本上可以忽略，所以并不推荐为了 iOS6 使用这种 <strong>并不优雅</strong> 的方式。</p><p>【注】：有些方案为了规避 url 长度隐患的缺陷，在 iOS 上采用了使用 Ajax 发送同域请求的方式，并将参数放到 head 或 body 里。这样，虽然规避了 url 长度的隐患，但是 WKWebView 并不支持这样的方式。</p><p>【注2】：为什么选择 iframe.src 不选择 locaiton.href ？因为如果通过 location.href 连续调用 Native，很容易丢失一些调用。</p><h3 id="Native-调用-JavaScript"><a href="#Native-调用-JavaScript" class="headerlink" title="Native 调用 JavaScript"></a>Native 调用 JavaScript</h3><p>相比于 JavaScript 调用 Native， Native 调用 JavaScript 较为简单，毕竟不管是 iOS 的 UIWebView 还是 WKWebView，还是 Android 的 WebView 组件，都以子组件的形式存在于 View/Activity 中，直接调用相应的 API 即可。</p><p>Native 调用 JavaScript，其实就是<strong>执行拼接 JavaScript 字符串，从外部调用 JavaScript 中的方法</strong>，因此 <strong>JavaScript 的方法必须在全局的 window 上</strong>。（闭包里的方法，JavaScript 自己都调用不了，更不用想让 Native 去调用了）</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id = <span class="number">0</span>,</span><br><span class="line">        callbacks = &#123;&#125;,</span><br><span class="line">        registerFuncs = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.JSBridge = &#123;</span><br><span class="line">        <span class="comment">// 调用 Native</span></span><br><span class="line">        invoke: <span class="function"><span class="keyword">function</span>(<span class="params">bridgeName, callback, data</span>) </span>&#123;</span><br><span class="line">            <span class="comment">// 判断环境，获取不同的 nativeBridge</span></span><br><span class="line">            <span class="keyword">var</span> thisId = id ++; <span class="comment">// 获取唯一 id</span></span><br><span class="line">            callbacks[thisId] = callback; <span class="comment">// 存储 Callback</span></span><br><span class="line">            nativeBridge.postMessage(&#123;</span><br><span class="line">                bridgeName: bridgeName,</span><br><span class="line">                data: data || &#123;&#125;,</span><br><span class="line">                callbackId: thisId <span class="comment">// 传到 Native 端</span></span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        receiveMessage: <span class="function"><span class="keyword">function</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> bridgeName = msg.bridgeName,</span><br><span class="line">                data = msg.data || &#123;&#125;,</span><br><span class="line">                callbackId = msg.callbackId, <span class="comment">// Native 将 callbackId 原封不动传回</span></span><br><span class="line">                responstId = msg.responstId;</span><br><span class="line">            <span class="comment">// 具体逻辑</span></span><br><span class="line">            <span class="comment">// bridgeName 和 callbackId 不会同时存在</span></span><br><span class="line">            <span class="keyword">if</span> (callbackId) &#123;</span><br><span class="line">                <span class="keyword">if</span> (callbacks[callbackId]) &#123; <span class="comment">// 找到相应句柄</span></span><br><span class="line">                    callbacks[callbackId](msg.data); <span class="comment">// 执行调用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; elseif (bridgeName) &#123;</span><br><span class="line">                <span class="keyword">if</span> (registerFuncs[bridgeName]) &#123; <span class="comment">// 通过 bridgeName 找到句柄</span></span><br><span class="line">                    <span class="keyword">var</span> ret = &#123;&#125;,</span><br><span class="line">                        flag = <span class="literal">false</span>;</span><br><span class="line">                    registerFuncs[bridgeName].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">callback</span>) =&gt; </span>&#123;</span><br><span class="line">                        callback(data, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">                            flag = <span class="literal">true</span>;</span><br><span class="line">                            ret = <span class="built_in">Object</span>.assign(ret, r);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;);</span><br><span class="line">                    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                        nativeBridge.postMessage(&#123; <span class="comment">// 回调 Native</span></span><br><span class="line">                            responstId: responstId,</span><br><span class="line">                            ret: ret</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        register: <span class="function"><span class="keyword">function</span>(<span class="params">bridgeName, callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!registerFuncs[bridgeName])  &#123;</span><br><span class="line">                registerFuncs[bridgeName] = [];</span><br><span class="line">            &#125;</span><br><span class="line">            registerFuncs[bridgeName].push(callback); <span class="comment">// 存储回调</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h2 id="JsBridge调用过程"><a href="#JsBridge调用过程" class="headerlink" title="JsBridge调用过程"></a>JsBridge调用过程</h2><ol><li>Native初始化webview，注册Handler；加载页面完成后，将WebViewJavascriptBridge.js文件注入页面。查询消息队列是否有信息需要被接收。</li><li>H5页面初始化，注册Handler，查询消息队列是否有信息需要别接收。</li><li>用户操作，H5调用本地功能：Js将消息内容放在<code>sendMessageQueue</code>中，并设置iframe的src为<code>yy://__QUEUE_MESSAGE__/</code> </li><li>Webview设置的WebViewClient拦截到约定url，调用Webview的刷新消息队列的方法<code>flushMessageQueue</code>，此方法就是加载了一个url：<code>javascript:WebViewJavascriptBridge._fetchQueue();</code>,这也是Js中定义的方法，另外定义了一个回调；回调方法主要做了两件事：①判断Native是否为此返回数据保有响应回调操作，若有，则执行，若没有，则为判断callId，不为空时为这个callId初始化一个回调。②通过handlername判断是否为默认的Handler还是自定义的Handler，调用相应Handler的handler方法，入参为消息数据内容和第一步中定义的回调。【这段较为难消化，需要阅读代码来理解】</li><li>Js中<code>_fetchQueue</code>设置了iframe的src，内容为：<code>yy://return/_fetchQueue/</code>+第二步中放入<code>sendMessageQueue</code>中的消息内容。</li><li>WebViewClient拦截到url为<code>yy://return/</code>，调用WebView的<code>handlerReturnData</code>方法；通过url中定义的方法名，找到第四个步骤中定义的回调，并调用。回调方法走完后，删除此回调方法。</li><li>如果Js在调用Handler的时候设置了回调方法，也就是在第四步骤中的含有callId，就会调用queueMessage的方法，然后往下就是走Native给Js发送消息的步骤。<br><strong>Ps:</strong> Native给Js发送消息的步骤跟上述从第三步骤到第七步骤完全相同，只不过Native和Js对象调换位置即可。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JsBridge&quot;&gt;&lt;a href=&quot;#JsBridge&quot; class=&quot;headerlink&quot; title=&quot;JsBridge&quot;&gt;&lt;/a&gt;JsBridge&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/dailc/p/59313
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深浅拷贝</title>
    <link href="http://yoursite.com/2020/05/13/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2020/05/13/深浅拷贝/</id>
    <published>2020-05-13T10:07:23.000Z</published>
    <updated>2020-07-01T12:09:36.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><h2 id="a-1-2-3-b-a-如何让-b-push-不影响数组-a（深浅拷贝）"><a href="#a-1-2-3-b-a-如何让-b-push-不影响数组-a（深浅拷贝）" class="headerlink" title="a=[1,2,3],b=a,如何让 b.push 不影响数组 a（深浅拷贝）"></a>a=[1,2,3],b=a,如何让 b.push 不影响数组 a（深浅拷贝）</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> b = a.concat();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> b = [...a];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...b] = a;</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> b = a.slice();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Array</span>.from(a)</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = [];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(b,a);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> b = a.map(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> item;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p>拓展：对象赋值如何能够做到不影响原对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="string">'name'</span>: <span class="string">'wangying'</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Object</span>.assign(&#123;&#125;, a);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON.parse(JSON.stringify(object))</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">    name: <span class="string">"muyiy"</span>,</span><br><span class="line">    book: &#123;</span><br><span class="line">        title: <span class="string">"You Don't Know JS"</span>,</span><br><span class="line">        price: <span class="string">"45"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(a));</span><br></pre></td></tr></table></figure><ul><li><code>JSON.parse(JSON.stringify(object))</code>实现深拷贝的坑：<ul><li>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式。而不是时间对象；</li><li>如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象；</li><li>如果obj里有函数，undefined，则序列化的结果会把函数或 undefined丢失；</li><li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null</li><li>JSON.stringify()只能序列化对象的可枚举的自有属性，例如 如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor；</li><li>如果对象中存在循环引用的情况也无法正确实现深拷贝；</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h1&gt;&lt;h2 id=&quot;a-1-2-3-b-a-如何让-b-push-不影响数组-a（深浅拷贝）&quot;&gt;&lt;a href=&quot;#a-1-2-3-b
      
    
    </summary>
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>CSS 重排（回流）重绘</title>
    <link href="http://yoursite.com/2020/05/03/CSS%20%E9%87%8D%E6%8E%92%EF%BC%88%E5%9B%9E%E6%B5%81%EF%BC%89%E9%87%8D%E7%BB%98/"/>
    <id>http://yoursite.com/2020/05/03/CSS 重排（回流）重绘/</id>
    <published>2020-05-03T12:03:26.000Z</published>
    <updated>2020-07-01T12:06:04.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重排重绘"><a href="#重排重绘" class="headerlink" title="重排重绘"></a>重排重绘</h1><h2 id="重排重绘的影响范围是基于什么的"><a href="#重排重绘的影响范围是基于什么的" class="headerlink" title="重排重绘的影响范围是基于什么的"></a>重排重绘的影响范围是基于什么的</h2><ul><li><p>重绘：某些元素的外观被改变，例如：元素的填充颜色</p><p>当一个元素的外观发生改变，但没有改变布局,重新把元素外观绘制出来的过程，叫做重绘。</p></li><li><p>重排（回流）：重新生成布局，重新排列元素。</p><p>当DOM的变化影响了元素的几何信息(DOM对象的位置和尺寸大小)，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排。</p><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种：</p><ul><li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul></li></ul><h3 id="1）常见引起回流属性和方法"><a href="#1）常见引起回流属性和方法" class="headerlink" title="1）常见引起回流属性和方法"></a>1）常见引起回流属性和方法</h3><p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发回流，</p><ul><li>添加或者删除可见的DOM元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在input框中输入文字</li><li>浏览器窗口尺寸改变——resize事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li><li>设置 style 属性的值</li></ul><h3 id="2）常见引起重绘属性和方法"><a href="#2）常见引起重绘属性和方法" class="headerlink" title="2）常见引起重绘属性和方法"></a>2）常见引起重绘属性和方法</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g81dslpyruj30w40eegnb.jpg" alt="image-20191017183756722"></p><h3 id="3）如何减少回流、重绘"><a href="#3）如何减少回流、重绘" class="headerlink" title="3）如何减少回流、重绘"></a>3）如何减少回流、重绘</h3><ul><li>使用 transform 替代 top</li><li>使用 visibility 替换 display: none ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>不要把节点的属性值放在一个循环里当成循环里的变量。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 获取 offsetTop 会导致回流，因为需要去获取正确的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.querySelector(<span class="string">'.test'</span>).style.offsetTop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 requestAnimationFrame</li><li>CSS 选择符从右往左匹配查找，避免节点层级过多</li><li>将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响别的节点。比如对于 video 标签来说，浏览器会自动将该节点变为图层。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;重排重绘&quot;&gt;&lt;a href=&quot;#重排重绘&quot; class=&quot;headerlink&quot; title=&quot;重排重绘&quot;&gt;&lt;/a&gt;重排重绘&lt;/h1&gt;&lt;h2 id=&quot;重排重绘的影响范围是基于什么的&quot;&gt;&lt;a href=&quot;#重排重绘的影响范围是基于什么的&quot; class=&quot;header
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="布局" scheme="http://yoursite.com/tags/%E5%B8%83%E5%B1%80/"/>
    
  </entry>
  
  <entry>
    <title>webpack模块热替换</title>
    <link href="http://yoursite.com/2020/04/25/webpack%E6%A8%A1%E5%9D%97%E7%83%AD%E6%9B%BF%E6%8D%A2/"/>
    <id>http://yoursite.com/2020/04/25/webpack模块热替换/</id>
    <published>2020-04-25T06:51:22.000Z</published>
    <updated>2020-07-01T11:50:42.880Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack模块热替换"><a href="#webpack模块热替换" class="headerlink" title="webpack模块热替换"></a>webpack模块热替换</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>模块热替换(HMR - hot module replacement)功能会在应用程序运行过程中，替换、添加或删除 <a href="https://webpack.docschina.org/concepts/modules/" target="_blank" rel="noopener">模块</a>，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：</p><ul><li>保留在完全重新加载页面期间丢失的应用程序状态。</li><li>只更新变更内容，以节省宝贵的开发时间。</li><li>在源代码中对 CSS/JS 进行修改，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。</li></ul><h2 id="如何运作的"><a href="#如何运作的" class="headerlink" title="如何运作的"></a>如何运作的</h2><h3 id="在应用程序中"><a href="#在应用程序中" class="headerlink" title="在应用程序中"></a>在应用程序中</h3><p>通过以下步骤，可以做到在应用程序中置换(swap in and out)模块：</p><ol><li>应用程序要求 HMR runtime 检查更新。</li><li>HMR runtime 异步地下载更新，然后通知应用程序。</li><li>应用程序要求 HMR runtime 应用更新。</li><li>HMR runtime 同步地应用更新。</li></ol><p>你可以设置 HMR，以使此进程自动触发更新，或者你可以选择要求在用户交互时进行更新。</p><h3 id="在-compiler-中"><a href="#在-compiler-中" class="headerlink" title="在 compiler 中"></a>在 compiler 中</h3><p>除了普通资源，compiler 需要发出 “update”，将之前的版本更新到新的版本。”update” 由两部分组成：</p><ol><li>更新后的 <a href="https://webpack.docschina.org/concepts/manifest" target="_blank" rel="noopener">manifest</a> (JSON)</li><li>一个或多个 updated chunk (JavaScript)</li></ol><p>manifest 包括新的 compilation hash 和所有的 updated chunk 列表。每个 chunk 都包含着全部更新模块的最新代码（或一个 flag 用于表明此模块需要被移除）。</p><p>compiler 会确保在这些构建之间的模块 ID 和 chunk ID 保持一致。通常将这些 ID 存储在内存中（例如，使用 <a href="https://webpack.docschina.org/configuration/dev-server/" target="_blank" rel="noopener">webpack-dev-server</a> 时），但是也可能会将它们存储在一个 JSON 文件中。</p><h3 id="在模块中"><a href="#在模块中" class="headerlink" title="在模块中"></a>在模块中</h3><p>HMR 是可选功能，只会影响包含 HMR 代码的模块。举个例子，通过 <a href="https://github.com/webpack-contrib/style-loader" target="_blank" rel="noopener"><code>style-loader</code></a> 为 style 追加补丁。为了运行追加补丁，<code>style-loader</code> 实现了 HMR 接口；当它通过 HMR 接收到更新，它会使用新的样式替换旧的样式。</p><p>类似的，当在一个模块中实现了 HMR 接口，你可以描述出当模块被更新后发生了什么。然而在多数情况下，不需要在每个模块中强行写入 HMR 代码。如果一个模块没有 HMR 处理函数，更新就会冒泡(bubble up)。这意味着某个单独处理函数能够更新整个模块树。如果在模块树的一个单独模块被更新，那么整组依赖模块都会被重新加载。</p><p>有关 <code>module.hot</code> 接口的详细信息，请查看 <a href="https://webpack.docschina.org/api/hot-module-replacement" target="_blank" rel="noopener">HMR API 页面</a>。</p><h3 id="在-HMR-runtime-中"><a href="#在-HMR-runtime-中" class="headerlink" title="在 HMR runtime 中"></a>在 HMR runtime 中</h3><p>对于模块系统运行时(module system runtime)，会发出额外代码，来跟踪模块 <code>parents</code> 和 <code>children</code> 关系。在管理方面，runtime 支持两个方法 <code>check</code> 和 <code>apply</code>。</p><ul><li><p><code>check</code> 方法，发送一个 HTTP 请求来更新 manifest。如果请求失败，说明没有可用更新。如果请求成功，会将 updated chunk 列表与当前的 loaded chunk 列表进行比较。每个 loaded chunk 都会下载相应的 updated chunk。当所有更新 chunk 完成下载，runtime 就会切换到 <code>ready</code> 状态。</p></li><li><p><code>apply</code> 方法，将所有 updated module 标记为无效。对于每个无效 module，都需要在模块中有一个 update handler，或者在此模块的父级模块中有 update handler。否则，会进行无效标记冒泡，并且父级也会被标记为无效。继续每个冒泡，直到到达应用程序入口起点，或者到达带有 update handler 的 module（以最先到达为准，冒泡停止）。如果它从入口起点开始冒泡，则此过程失败。</p></li></ul><p>之后，所有无效 module 都会被（通过 dispose handler）处理和解除加载。然后更新当前 hash，并且调用所有 <code>accept</code> handler。runtime 切换回 <code>idle</code> 状态，一切照常继续。</p><h3 id="应用在项目中"><a href="#应用在项目中" class="headerlink" title="应用在项目中"></a>应用在项目中</h3><p>在开发环境，可以将 HMR 作为 LiveReload 的替代。<a href="https://webpack.docschina.org/configuration/dev-server/" target="_blank" rel="noopener">webpack-dev-server</a> 支持 <code>hot</code> 模式，在试图重新加载整个页面之前，<code>hot</code> 模式会尝试使用 HMR 来更新。</p><h2 id="HMR的更新流程"><a href="#HMR的更新流程" class="headerlink" title="HMR的更新流程"></a>HMR的更新流程</h2><ul><li>修改了一个或多个文件。</li><li>文件系统接收更改并通知Webpack。</li><li>Webpack重新编译构建一个或多个模块，并通知HMR服务器进行了更新。</li><li>HMR Server使用websockets通知HMR Runtime需要更新。（HMR运行时通过HTTP请求这些更新。）</li><li>HMR运行时再替换更新中的模块。如果确定这些模块无法更新，则触发整个页面刷新</li></ul><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6t1ojx1mlj30k00kt3ze.jpg" alt="img"></p><p>上图是webpack 配合 webpack-dev-server 进行应用开发的模块热更新流程图。</p><ul><li><p>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</p></li><li><p>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</p></li><li><p>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</p></li><li><p>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</p></li><li><p>webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</p></li><li><p>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</p></li><li><p>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</p></li><li><p>最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack模块热替换&quot;&gt;&lt;a href=&quot;#webpack模块热替换&quot; class=&quot;headerlink&quot; title=&quot;webpack模块热替换&quot;&gt;&lt;/a&gt;webpack模块热替换&lt;/h1&gt;&lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;
      
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack流程</title>
    <link href="http://yoursite.com/2020/04/17/webpack%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/04/17/webpack流程/</id>
    <published>2020-04-17T02:29:41.000Z</published>
    <updated>2020-07-01T11:46:19.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack流程"><a href="#webpack流程" class="headerlink" title="webpack流程"></a>webpack流程</h1><p><a href="http://taobaofed.org/blog/2016/09/09/webpack-flow/" target="_blank" rel="noopener">细说webapck流程</a></p><p><a href="https://juejin.im/entry/5b0e3eba5188251534379615" target="_blank" rel="noopener">webpack原理</a></p><p><a href="https://juejin.im/post/5aa54608f265da23826d9b34" target="_blank" rel="noopener"> webpack 模块加载机制</a></p><p>流程概述：</p><p>Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：</p><ol><li>初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；</li><li>开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li><li>确定入口：根据配置中的 entry 找出所有的入口文件；</li><li>编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；</li><li>完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；</li><li>输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；</li><li>输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</li></ol><h2 id="webpack配置"><a href="#webpack配置" class="headerlink" title="webpack配置"></a>webpack配置</h2><p><strong>webpack.config.js</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">var</span> node_modules = path.resolve(__dirname, <span class="string">'node_modules'</span>);</span><br><span class="line"><span class="keyword">var</span> pathToReact = path.resolve(node_modules, <span class="string">'react/dist/react.min.js'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件，是模块构建的起点，同时每一个入口文件对应最后生成的一个 chunk。</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    bundle: [</span><br><span class="line">      <span class="string">'webpack/hot/dev-server'</span>,</span><br><span class="line">      <span class="string">'webpack-dev-server/client?http://localhost:8080'</span>,</span><br><span class="line">      path.resolve(__dirname, <span class="string">'app/app.js'</span>)</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 文件路径指向(可加快打包过程)。</span></span><br><span class="line">  resolve: &#123;</span><br><span class="line">    alias: &#123;</span><br><span class="line">      <span class="string">'react'</span>: pathToReact</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 生成文件，是模块构建的终点，包括输出文件与输出路径。</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'build'</span>),</span><br><span class="line">    filename: <span class="string">'[name].js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 这里配置了处理各模块的 loader ，包括 css 预处理 loader ，es6 编译 loader，图片处理 loader。</span></span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    loaders: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        loader: <span class="string">'babel'</span>,</span><br><span class="line">        query: &#123;</span><br><span class="line">          presets: [<span class="string">'es2015'</span>, <span class="string">'react'</span>]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    noParse: [pathToReact]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// webpack 各插件对象，在 webpack 的事件流中执行对应的方法。</span></span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li><p><strong>loader</strong>：能转换各类资源，并处理成对应模块的加载器。loader 间可以串行使用。</p><p>loader引用顺序：loader从右往左执行，依次传递参数，有依赖的放在右边。</p><p>loader 可以链式调用，上一个 loader 的输出被作为输入传给下一个 loader。 使用 <a href="https://www.webpackjs.com/configuration/module#rule-use" target="_blank" rel="noopener">rule.use</a> 配置选项，<code>use</code> 可以设置为一个 loader 数组。 在 webpack 1 中，loader 通常被用 <code>!</code> 连写。这一写法在 webpack 2 中只在使用旧的选项 <code>module.loaders</code> 时才有效。</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  module: &#123;</span><br><span class="line"><span class="deletion">-   loaders: [&#123;</span></span><br><span class="line"><span class="addition">+   rules: [&#123;</span></span><br><span class="line">      test: /\.less$/,</span><br><span class="line"><span class="deletion">-     loader: "style-loader!css-loader!less-loader"</span></span><br><span class="line"><span class="addition">+     use: [</span></span><br><span class="line"><span class="addition">+       "style-loader",  // 将 JS 字符串生成为 style 节点</span></span><br><span class="line"><span class="addition">+       "css-loader",   // 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line"><span class="addition">+       "less-loader"   // 将 Sass 编译成 CSS</span></span><br><span class="line"><span class="addition">+     ]</span></span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>loader 可以配置以下参数:</p><ul><li>test: 匹配处理文件的扩展名的正则表达式</li><li>use: loader名称</li><li>include/exclude: 手动指定必须处理的文件夹或屏蔽不需要处理的文件夹</li><li>query: 为loader提供额外的设置选项</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="comment">//other code</span></span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css/</span>,</span><br><span class="line">                use: [<span class="string">'style-loader'</span>, <span class="string">'css-loader'</span>],</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">                include: path.resolve(__dirname, <span class="string">'src'</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>chunk</strong>：code splitting 后的产物，也就是按需加载的分块，装载了不同的 module。</p><p>对于 module 和 chunk 的关系可以参照 webpack 官方的这张图：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5wen5koj314r0u0k6k.jpg" alt="image-20190721095459839"></p></li><li><p>plugin：webpack 的插件实体，这里以 UglifyJsPlugin 为例。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UglifyJsPlugin</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.options = options;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = UglifyJsPlugin;</span><br><span class="line"></span><br><span class="line">UglifyJsPlugin.prototype.apply = <span class="function"><span class="keyword">function</span>(<span class="params">compiler</span>) </span>&#123;</span><br><span class="line">  compiler.plugin(<span class="string">"compilation"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    compilation.plugin(<span class="string">"build-module"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">module</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"optimize-chunk-assets"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">chunks, callback</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// Uglify 逻辑</span></span><br><span class="line">    &#125;);</span><br><span class="line">    compilation.plugin(<span class="string">"normal-module-loader"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">context</span>) </span>&#123;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 webpack 中你经常可以看到 compilation.plugin(‘xxx’, callback) ，你可以把它当作是一个事件的绑定，这些事件在打包时由 webpack 来触发。</p></li></ul><h2 id="流程总览"><a href="#流程总览" class="headerlink" title="流程总览"></a>流程总览</h2><p>在具体流程学习前，可以先通过这幅 <a href="https://img.alicdn.com/tps/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" target="_blank" rel="noopener">webpack 整体流程图</a> 了解一下大致流程（建议保存下来查看）。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5wkkj2jj30vd0u04qp.jpg" alt="TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244"></p><h2 id="shell-与-config-解析"><a href="#shell-与-config-解析" class="headerlink" title="shell 与 config 解析"></a>shell 与 config 解析</h2><p>每次在命令行输入 webpack 后，操作系统都会去调用 <code>./node_modules/.bin/webpack</code> 这个 shell 脚本。这个脚本会去调用 <code>./node_modules/webpack/bin/webpack.js</code> 并追加输入的参数，如 -p , -w 。(图中 webpack.js 是 webpack 的启动文件，而 $@ 是后缀参数)</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5wp0xr3j30dw03374c.jpg" alt="img"></p><p>在 webpack.js 这个文件中 webpack 通过 optimist 将用户配置的 webpack.config.js 和 shell 脚本传过来的参数整合成 options 对象传到了下一个流程的控制对象中。</p><h3 id="1-optimist"><a href="#1-optimist" class="headerlink" title="1. optimist"></a>1. optimist</h3><p>和 commander 一样，<a href="https://github.com/substack/node-optimist" target="_blank" rel="noopener">optimist</a> 实现了 node 命令行的解析，其 API 调用非常方便。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> optimist = <span class="built_in">require</span>(<span class="string">"optimist"</span>);</span><br><span class="line"></span><br><span class="line">optimist</span><br><span class="line">  .boolean(<span class="string">"json"</span>).alias(<span class="string">"json"</span>, <span class="string">"j"</span>).describe(<span class="string">"json"</span>)</span><br><span class="line">  .boolean(<span class="string">"colors"</span>).alias(<span class="string">"colors"</span>, <span class="string">"c"</span>).describe(<span class="string">"colors"</span>)</span><br><span class="line">  .boolean(<span class="string">"watch"</span>).alias(<span class="string">"watch"</span>, <span class="string">"w"</span>).describe(<span class="string">"watch"</span>)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>获取到后缀参数后，optimist 分析参数并以键值对的形式把参数对象保存在 optimist.argv 中，来看看 argv 究竟有什么？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack --hot -w</span></span><br><span class="line">&#123;</span><br><span class="line">  hot: <span class="literal">true</span>,</span><br><span class="line">  profile: <span class="literal">false</span>,</span><br><span class="line">  watch: <span class="literal">true</span>,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-config-合并与插件加载"><a href="#2-config-合并与插件加载" class="headerlink" title="2. config 合并与插件加载"></a>2. config 合并与插件加载</h3><p>在加载插件之前，webpack 将 webpack.config.js 中的各个配置项拷贝到 options 对象中，并加载用户配置在 webpack.config.js 的 plugins 。接着 optimist.argv 会被传入到 <code>./node_modules/webpack/bin/convert-argv.js</code> 中，通过判断 argv 中参数的值决定是否去加载对应插件。(至于 webpack 插件运行机制，在之后的运行机制篇会提到)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ifBooleanArg(<span class="string">"hot"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ensureArray(options, <span class="string">"plugins"</span>);</span><br><span class="line">  <span class="keyword">var</span> HotModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">"../lib/HotModuleReplacementPlugin"</span>);</span><br><span class="line">  options.plugins.push(<span class="keyword">new</span> HotModuleReplacementPlugin());</span><br><span class="line">&#125;);</span><br><span class="line">...</span><br><span class="line"><span class="keyword">return</span> options;</span><br></pre></td></tr></table></figure><p><code>options</code> 作为最后返回结果，包含了之后构建阶段所需的重要信息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  entry: &#123;&#125;,<span class="comment">//入口配置</span></span><br><span class="line">  output: &#123;&#125;, <span class="comment">//输出配置</span></span><br><span class="line">  plugins: [], <span class="comment">//插件集合(配置文件 + shell指令) </span></span><br><span class="line">  <span class="built_in">module</span>: &#123; <span class="attr">loaders</span>: [ [<span class="built_in">Object</span>] ] &#125;, <span class="comment">//模块配置</span></span><br><span class="line">  context: <span class="comment">//工程路径</span></span><br><span class="line">  ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这和 webpack.config.js 的配置非常相似，只是多了一些经 shell 传入的插件对象。插件对象一初始化完毕， options 也就传入到了下个流程中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> webpack = <span class="built_in">require</span>(<span class="string">"../lib/webpack.js"</span>);</span><br><span class="line"><span class="keyword">var</span> compiler = webpack(options);</span><br></pre></td></tr></table></figure><h2 id="编译与构建流程"><a href="#编译与构建流程" class="headerlink" title="编译与构建流程"></a>编译与构建流程</h2><p>在加载配置文件和 shell 后缀参数申明的插件，并传入构建信息 options 对象后，开始整个 webpack 打包最漫长的一步。而这个时候，真正的 webpack 对象才刚被初始化，具体的初始化逻辑在 <code>lib/webpack.js</code> 中，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">webpack</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> compiler = <span class="keyword">new</span> Compiler();</span><br><span class="line">  ...<span class="comment">// 检查options,若watch字段为true,则开启watch线程</span></span><br><span class="line">  <span class="keyword">return</span> compiler;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>webpack 的实际入口是 Compiler 中的 run 方法，run 一旦执行后，就开始了编译和构建流程 ，其中有几个比较关键的 webpack 事件节点。</p><ul><li><code>compile</code> 开始编译</li><li><code>make</code> 从入口点分析模块及其依赖的模块，创建这些模块对象</li><li><code>build-module</code> 构建模块</li><li><code>after-compile</code> 完成构建</li><li><code>seal</code> 封装构建结果</li><li><code>emit</code> 把各个chunk输出到结果文件</li><li><code>after-emit</code> 完成输出</li></ul><h3 id="1-核心对象-Compilation"><a href="#1-核心对象-Compilation" class="headerlink" title="1. 核心对象 Compilation"></a>1. 核心对象 Compilation</h3><p>compiler.run 后首先会触发 compile ，这一步会构建出 Compilation 对象：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5wtuu15j30j90q4ta1.jpg" alt="compilation类图"></p><h4 id="这个对象有两个作用"><a href="#这个对象有两个作用" class="headerlink" title="这个对象有两个作用:"></a>这个对象有<strong>两个作用</strong>:</h4><ul><li>一是负责组织整个打包过程，包含了每个构建环节及输出环节所对应的方法，可以从图中看到比较关键的步骤，如 <code>addEntry()</code> , <code>_addModuleChain()</code> ,<code>buildModule()</code> , <code>seal()</code> , <code>createChunkAssets()</code> (在每一个节点都会触发 webpack 事件去调用各插件)。</li><li>二是该对象内部存放着所有 module ，chunk，生成的 asset 以及用来生成最后打包文件的 template 的信息。</li></ul><h3 id="2-编译与构建主流程"><a href="#2-编译与构建主流程" class="headerlink" title="2. 编译与构建主流程"></a>2. 编译与构建主流程</h3><p>在创建 module 之前，Compiler 会触发 make，并调用 <code>Compilation.addEntry</code> 方法，通过 options 对象的 entry 字段找到我们的入口js文件。之后，在 addEntry 中调用私有方法 <code>_addModuleChain</code> ，这个方法主要做了两件事情。一是根据模块的类型获取对应的模块工厂并创建模块，二是构建模块。</p><h4 id="而构建模块作为最耗时的一步，又可细化为三步："><a href="#而构建模块作为最耗时的一步，又可细化为三步：" class="headerlink" title="而构建模块作为最耗时的一步，又可细化为三步："></a>而构建模块作为最耗时的一步，又可细化为三步：</h4><ul><li><p>调用各 loader 处理模块之间的依赖</p><p>webpack 提供的一个很大的便利就是能将所有资源都整合成模块，不仅仅是 js 文件。所以需要一些 loader ，比如 <code>url-loader</code> ， <code>jsx-loader</code> ， <code>css-loader</code> 等等来让我们可以直接在源文件中引用各类资源。webpack 调用 <code>doBuild()</code> ，对每一个 require() 用对应的 loader 进行加工，最后生成一个 js module。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype._addModuleChain = <span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params">context, dependency, onModule, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="keyword">this</span>.profile &amp;&amp; +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 根据模块的类型获取对应的模块工厂并创建模块</span></span><br><span class="line">  <span class="keyword">var</span> moduleFactory = <span class="keyword">this</span>.dependencyFactories.get(dependency.constructor);</span><br><span class="line">  ...</span><br><span class="line">  moduleFactory.create(context, dependency, <span class="function"><span class="keyword">function</span>(<span class="params">err, module</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">this</span>.addModule(<span class="built_in">module</span>);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">this</span>.buildModule(<span class="built_in">module</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="comment">// 构建模块，添加依赖模块</span></span><br><span class="line">    &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>调用 <a href="https://github.com/ternjs/acorn" target="_blank" rel="noopener">acorn</a> 解析经 loader 处理后的源文件生成抽象语法树 AST</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> Parser.prototype.parse = <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params">source, initialState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ast;</span><br><span class="line">  <span class="keyword">if</span> (!ast) &#123;</span><br><span class="line">    <span class="comment">// acorn以es6的语法进行解析</span></span><br><span class="line">    ast = acorn.parse(source, &#123;</span><br><span class="line">      ranges: <span class="literal">true</span>,</span><br><span class="line">      locations: <span class="literal">true</span>,</span><br><span class="line">      ecmaVersion: <span class="number">6</span>,</span><br><span class="line">      sourceType: <span class="string">"module"</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>遍历 AST，构建该模块所依赖的模块</p><p>对于当前模块，或许存在着多个依赖模块。当前模块会开辟一个依赖模块的数组，在遍历 AST 时，将 require() 中的模块通过 <code>addDependency()</code> 添加到数组中。当前模块构建完成后，webpack 调用 <code>processModuleDependencies</code> 开始递归处理依赖的 module，接着就会重复之前的构建步骤。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> Compilation.prototype.addModuleDependencies = <span class="function"><span class="keyword">function</span>(<span class="params">module, dependencies, bail, cacheGroup, recursive, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 根据依赖数组(dependencies)创建依赖模块对象</span></span><br><span class="line">  <span class="keyword">var</span> factories = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; dependencies.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> factory = _this.dependencyFactories.get(dependencies[i][<span class="number">0</span>].constructor);</span><br><span class="line">    factories[i] = [factory, dependencies[i]];</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 与当前模块构建步骤相同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-构建细节"><a href="#3-构建细节" class="headerlink" title="3. 构建细节"></a>3. 构建细节</h3><p>module 是 webpack 构建的核心实体，也是所有 module 的 父类，它有几种不同子类：<code>NormalModule</code> , <code>MultiModule</code> , <code>ContextModule</code> , <code>DelegatedModule</code> 等。但这些核心实体都是在构建中都会去调用对应方法，也就是 <code>build()</code> 。来看看其中具体做了什么：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化module信息，如context,id,chunks,dependencies等。</span></span><br><span class="line">NormalModule.prototype.build = <span class="function"><span class="keyword">function</span> <span class="title">build</span>(<span class="params">options, compilation, resolver, fs, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.buildTimestamp = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime(); <span class="comment">// 构建计时</span></span><br><span class="line">  <span class="keyword">this</span>.built = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.doBuild(options, compilation, resolver, fs, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 指定模块引用，不经acorn解析</span></span><br><span class="line">    <span class="keyword">if</span> (options.module &amp;&amp; options.module.noParse) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(options.module.noParse)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (options.module.noParse.some(<span class="function"><span class="keyword">function</span>(<span class="params">regExp</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">typeof</span> regExp === <span class="string">"string"</span> ?</span><br><span class="line">            <span class="keyword">this</span>.request.indexOf(regExp) === <span class="number">0</span> :</span><br><span class="line">              regExp.test(<span class="keyword">this</span>.request);</span><br><span class="line">          &#125;, <span class="keyword">this</span>)) &#123;</span><br><span class="line">          <span class="keyword">return</span> callback();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> options.module.noParse === <span class="string">"string"</span> ?</span><br><span class="line">        <span class="keyword">this</span>.request.indexOf(options.module.noParse) === <span class="number">0</span> :</span><br><span class="line">          options.module.noParse.test(<span class="keyword">this</span>.request)) &#123;</span><br><span class="line">        <span class="keyword">return</span> callback();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 由acorn解析生成ast</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.parser.parse(<span class="keyword">this</span>._source.source(), &#123;</span><br><span class="line">        current: <span class="keyword">this</span>,</span><br><span class="line">        <span class="built_in">module</span>: <span class="keyword">this</span>,</span><br><span class="line">        compilation: compilation,</span><br><span class="line">        options: options</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">var</span> source = <span class="keyword">this</span>._source.source();</span><br><span class="line">      <span class="keyword">this</span>._source = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">return</span> callback(<span class="keyword">new</span> ModuleParseError(<span class="keyword">this</span>, source, e));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> callback();</span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对于每一个 module ，它都会有这样一个构建方法。当然，它还包括了从构建到输出的一系列的有关 module 生命周期的函数，我们通过 module 父类类图其子类类图(这里以 NormalModule 为例)来观察其真实形态：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5wzssoaj30cd0y4t9d.jpg" alt="module类图"></p><p>可以看到无论是构建流程，处理依赖流程，包括后面的封装流程都是与 module 密切相关的。</p><h2 id="打包输出"><a href="#打包输出" class="headerlink" title="打包输出"></a>打包输出</h2><p>在所有模块及其依赖模块 build 完成后，webpack 会监听 <code>seal</code> 事件调用各插件对构建后的结果进行封装，要逐次对每个 module 和 chunk 进行整理，生成编译后的源码，合并，拆分，生成 hash 。 同时这是我们在开发时进行代码优化和功能添加的关键环节。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Compilation.prototype.seal = <span class="function"><span class="keyword">function</span> <span class="title">seal</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.applyPlugins(<span class="string">"seal"</span>); <span class="comment">// 触发插件的seal事件</span></span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a.name &lt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a.name &gt; b.name) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.preparedChunks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">preparedChunk</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = preparedChunk.module;</span><br><span class="line">    <span class="keyword">var</span> chunk = <span class="keyword">this</span>.addChunk(preparedChunk.name, <span class="built_in">module</span>);</span><br><span class="line">    chunk.initial = chunk.entry = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 整理每个Module和chunk，每个chunk对应一个输出文件。</span></span><br><span class="line">    chunk.addModule(<span class="built_in">module</span>);</span><br><span class="line">    <span class="built_in">module</span>.addChunk(chunk);</span><br><span class="line">  &#125;, <span class="keyword">this</span>);</span><br><span class="line">  <span class="keyword">this</span>.applyPluginsAsync(<span class="string">"optimize-tree"</span>, <span class="keyword">this</span>.chunks, <span class="keyword">this</span>.modules, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> callback(err);</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">    <span class="keyword">this</span>.createChunkAssets(); <span class="comment">// 生成最终assets</span></span><br><span class="line">    ... <span class="comment">// 触发插件的事件</span></span><br><span class="line">  &#125;.bind(<span class="keyword">this</span>));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-生成最终-assets"><a href="#1-生成最终-assets" class="headerlink" title="1. 生成最终 assets"></a>1. 生成最终 assets</h4><p>在封装过程中，webpack 会调用 Compilation 中的 <code>createChunkAssets</code> 方法进行打包后代码的生成。 createChunkAssets 流程如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5x54h28j30qn0mf74x.jpg" alt="createChunkAssets流程"></p><ul><li><p>不同的 Template</p><p>从上图可以看出通过判断是入口 js 还是需要异步加载的 js 来选择不同的模板对象进行封装，入口 js 会采用 webpack 事件流的 render 事件来触发 <code>Template类</code> 中的 <code>renderChunkModules()</code> (异步加载的 js 会调用 chunkTemplate 中的 render 方法)。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(chunk.entry) &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.mainTemplate.render(<span class="keyword">this</span>.hash, chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  source = <span class="keyword">this</span>.chunkTemplate.render(chunk, <span class="keyword">this</span>.moduleTemplate, <span class="keyword">this</span>.dependencyTemplates);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 webpack 中有四个 Template 的子类，分别是 <code>MainTemplate.js</code> ， <code>ChunkTemplate.js</code> ，<code>ModuleTemplate.js</code> ， <code>HotUpdateChunkTemplate.js</code> ，前两者先前已大致有介绍，而 ModuleTemplate 是对所有模块进行一个代码生成，HotUpdateChunkTemplate 是对热替换模块的一个处理。</p></li><li><p>模块封装</p><p>模块在封装的时候和它在构建时一样，都是调用各模块类中的方法。封装通过调用 <code>module.source()</code> 来进行各操作，比如说 require() 的替换。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MainTemplate.prototype.requireFn = <span class="string">"__webpack_require__"</span>;</span><br><span class="line">MainTemplate.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params">hash, chunk, moduleTemplate, dependencyTemplates</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> buf = [];</span><br><span class="line">    <span class="comment">// 每一个module都有一个moduleId,在最后会替换。</span></span><br><span class="line">    buf.push(<span class="string">"function "</span> + <span class="keyword">this</span>.requireFn + <span class="string">"(moduleId) &#123;"</span>);</span><br><span class="line">    buf.push(<span class="keyword">this</span>.indent(<span class="keyword">this</span>.applyPluginsWaterfall(<span class="string">"require"</span>, <span class="string">""</span>, chunk, hash)));</span><br><span class="line">    buf.push(<span class="string">"&#125;"</span>);</span><br><span class="line">    buf.push(<span class="string">""</span>);</span><br><span class="line">    ... <span class="comment">// 其余封装操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>生成 assets</p><p>各模块进行 doBlock 后，把 module 的最终代码循环添加到 source 中。一个 source 对应着一个 asset 对象，该对象保存了单个文件的文件名( name )和最终代码( value )。</p></li></ul><h4 id="2-输出"><a href="#2-输出" class="headerlink" title="2. 输出"></a>2. 输出</h4><p>最后一步，webpack 调用 Compiler 中的 <code>emitAssets()</code> ，按照 output 中的配置项将文件输出到了对应的 path 中，从而 webpack 整个打包过程结束。要注意的是，若想对结果进行处理，则需要在 <code>emit</code> 触发后对自定义插件进行扩展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>webpack 的整体流程主要还是依赖于 <code>compilation</code> 和 <code>module</code> 这两个对象，但其思想远不止这么简单。最开始也说过，webpack 本质是个插件集合，并且由 <code>tapable</code> 控制各插件在 webpack 事件流上运行。同时，在业务开发中，无论是为了提升构建效率，或是减小打包文件大小，我们都可以通过编写 webpack 插件来进行流程上的控制，这个也会在之后提到</p><h1 id="Webpack-4"><a href="#Webpack-4" class="headerlink" title="Webpack 4"></a>Webpack 4</h1><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><p>Webpack 4 是最流行的模块捆绑器之一。它提供了很多新特性，例如零配置、合理的默认值、性能改进、开箱即用的优化工具，等等。</p><p>零配置：Webpack 4 不需要配置文件，这是 Webpack 4 的一个全新的变更。</p><p>性能提升：Webpack 4 是迄今为止最快的 Webpack 版本。</p><p>合理的默认值：Webpack 4 的主要概念包括入口、输出、加载器和插件。</p><h2 id="webpack4和之前版本里一些主要的变化："><a href="#webpack4和之前版本里一些主要的变化：" class="headerlink" title="webpack4和之前版本里一些主要的变化："></a>webpack4和之前版本里一些主要的变化：</h2><p>1、webpack不再支持node v4，这是因为新的webpack和附属插件使用了es6的语法，v4版本对es6不是很到位，所以，就不伺候了。</p><p>2、开始采取约定优于配置的思路，<a href="mailto:webpack@4.x" target="_blank" rel="noopener">webpack@4.x</a>里把很多选项都设置了默认值，比如入口就是./src，输出目录就是./dist，当然如果你自己去设置，它也不会拦着。所以在用<a href="mailto:webpack@4.x" target="_blank" rel="noopener">webpack@4.x</a>的时候，我们甚至都可以没有webpack.config.js这个配置文件也能一样打包。</p><p>3、拆分了旧版本里的webpack，分成了用来处理逻辑的webpack和提供可执行命令的webpack-cli，这也是有的同学把webpack装成新版本以后会报找不到webpack-cli模块这个错误的原因。</p><p>4、添加了mode选项，用来区分编译的环境，提供了development、production和none三个选项，理论上这个选项是强制指定的，其实不指定的话它也是有默认值的，但会给出一个warning，官方这么强烈建议了，就显式的指定一下吧。指定方式有两种，一是在启动命令里：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./node_modules/.bin/webpack --mode production</span><br></pre></td></tr></table></figure><p>另外一种就是在配置文件里指定，方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var config = &#123;</span><br><span class="line">    mode: &apos;production&apos;  // 可选development、production和none</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、配置上的变动，类似删除了commonChunksPlugin，用optimization来代替这种。还有loader的用法也和1.15.0不一样了，但这个升级是在之前版本里就有的，不是<a href="mailto:webpack@4.x" target="_blank" rel="noopener">webpack@4.x</a>带来的。</p><p>6、性能优化，提高了打包性能。另外从webpack2起，引入了Tree-shaking机制来提出没有被引用的模块。它的原理是按着引用关系重新建立一个新的依赖树，而没有被引用的模块就不会被打包到最后的代码里。之前的压缩优化方式是先把所有模块都挂到树上，然后通过分析后，删掉没被引用的模块。从字面意思来看，我觉得原来的方式更像在摇树，把没用的摇下来。这两种方式最后压缩完的结果可能类似，但设计思路完全是从两个方向走的。</p><p>7、其他。以上这些就是一些比较主要的变化，更详细的升级文档可以参考下官方的说明：[<a href="https://github.com/webpack/webpack/releases]" target="_blank" rel="noopener">https://github.com/webpack/webpack/releases]</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack流程&quot;&gt;&lt;a href=&quot;#webpack流程&quot; class=&quot;headerlink&quot; title=&quot;webpack流程&quot;&gt;&lt;/a&gt;webpack流程&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://taobaofed.org/blog/2016/09
      
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack插件</title>
    <link href="http://yoursite.com/2020/04/10/webpack%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/04/10/webpack插件/</id>
    <published>2020-04-10T11:33:23.000Z</published>
    <updated>2020-07-01T11:37:25.895Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack插件"><a href="#webpack插件" class="headerlink" title="webpack插件"></a>webpack插件</h1><p>插件目的在于解决 <a href="https://webpack.docschina.org/concepts/loaders" target="_blank" rel="noopener">loader</a> 无法实现的<strong>其他事</strong>。</p><p>##1.什么是 webpack 插件</p><p>一个完整的 webpack 插件需要满足以下几点规则和特征：</p><ul><li>是一个独立的模块。</li><li>模块对外暴露一个 js 函数。</li><li>函数的原型 (prototype) 上定义了一个注入 <code>compiler</code> 对象的 <code>apply</code> 方法。</li><li><code>apply</code> 函数中需要有通过 compiler 对象挂载的 webpack 事件钩子，钩子的回调中能拿到当前编译的 compilation 对象，如果是异步编译插件的话可以拿到回调 callback。</li><li>完成自定义子编译流程并处理 complition 对象的内部数据。</li><li>如果异步编译插件的话，数据处理完成后执行 callback 回调。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1、some-webpack-plugin.js 文件（独立模块）</span></span><br><span class="line"><span class="comment">// 2、模块对外暴露的 js 函数function </span></span><br><span class="line">SomewebpackPlugin(pluginOpions) &#123;    </span><br><span class="line">  <span class="keyword">this</span>.options = pluginOptions;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3、原型定义一个 apply 函数，并注入了 compiler 对象</span></span><br><span class="line">SomewebpackPlugin.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">compiler</span>) </span>&#123;    </span><br><span class="line">  <span class="comment">// 4、挂载 webpack 事件钩子（这里挂载的是 emit 事件）    </span></span><br><span class="line">  compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, callback</span>) </span>&#123;        </span><br><span class="line">    <span class="comment">// ... 内部进行自定义的编译操作        </span></span><br><span class="line">    <span class="comment">// 5、操作 compilation 对象的内部数据        </span></span><br><span class="line">    <span class="built_in">console</span>.log(compilation);        </span><br><span class="line">    <span class="comment">// 6、执行 callback 回调        </span></span><br><span class="line">    callback();    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 暴露 js 函数</span></span><br><span class="line"><span class="built_in">module</span>.exports = SomewebpackPlugin;<span class="string">`</span></span><br></pre></td></tr></table></figure><h2 id="2-compiler-amp-compilation-对象"><a href="#2-compiler-amp-compilation-对象" class="headerlink" title="2.compiler &amp; compilation 对象"></a>2.compiler &amp; compilation 对象</h2><h3 id="compiler-对象"><a href="#compiler-对象" class="headerlink" title="compiler 对象"></a>compiler 对象</h3><p>compiler 对象是 webpack 的编译器对象，前文已经提到，webpack 的核心就是编译器，compiler 对象会在启动 webpack 的时候被一次性的初始化，compiler 对象中包含了所有 webpack 可自定义操作的配置，例如 loader 的配置，plugin 的配置，entry 的配置等各种原始 webpack 配置等，在 webpack 插件中的自定义子编译流程中，我们肯定会用到 compiler 对象中的相关配置信息，我们相当于可以通过 compiler 对象拿到 webpack 的主环境所有的信息。</p><h3 id="compilation-对象"><a href="#compilation-对象" class="headerlink" title="compilation 对象"></a>compilation 对象</h3><p>这里首先需要了解一下什么是编译资源，编译资源是 webpack 通过配置生成的一份静态资源管理 Map（一切都在内存中保存），以 key-value 的形式描述一个 webpack 打包后的文件，编译资源就是这一个个 key-value 组成的 Map。而编译资源就是需要由 compilation 对象生成的。</p><p>compilation 实例继承于 compiler，compilation 对象代表了一次单一的版本 webpack 构建和生成编译资源的过程。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，一次新的编译将被创建，从而生成一组新的编译资源以及新的 compilation 对象。一个 compilation 对象包含了 <code>当前的模块资源</code>、<code>编译生成资源</code>、<code>变化的文件</code>、以及 <code>被跟踪依赖的状态信息</code>。编译对象也提供了很多关键点回调供插件做自定义处理时选择使用。</p><p>由此可见，如果开发者需要通过一个插件的方式完成一个自定义的编译工作的话，如果涉及到需要改变编译后的资源产物，必定离不开这个 compilation 对象。</p><h2 id="3-webpack-插件机制"><a href="#3-webpack-插件机制" class="headerlink" title="3.webpack 插件机制"></a>3.webpack 插件机制</h2><p>webpack 以插件的形式提供了灵活强大的自定义 api 功能。使用插件，我们可以为 webpack 添加功能。另外，webpack 提供生命周期钩子以便注册插件。在每个生命周期点，webpack 会运行所有注册的插件，并提供当前 webpack 编译状态信息。这一插件机制追根溯源却离不开一个叫做 Tapable 的库。</p><h3 id="Tapable-amp-Tapable-实例"><a href="#Tapable-amp-Tapable-实例" class="headerlink" title="Tapable &amp; Tapable 实例"></a>Tapable &amp; Tapable 实例</h3><p>webpack 的插件架构主要基于 <a href="https://github.com/webpack/tapable" target="_blank" rel="noopener">Tapable</a> 实现的，Tapable 是 webpack 项目组的一个内部库，主要是抽象了一套插件机制。webpack 源代码中的一些 Tapable 实例都继承或混合了 Tapable 类。Tapable 能够让我们为 javaScript 模块添加并应用插件。 它可以被其它模块继承或混合。它类似于 NodeJS 的 EventEmitter 类，专注于自定义事件的触发和操作。 除此之外, Tapable 允许你通过回调函数的参数访问事件的生产者。</p><p>Tapable 实例对象都有四组成员函数:</p><ul><li><code>plugin(name&lt;string&gt;, handler&lt;function&gt;)</code> - 这个方法允许给 Tapable 实例事件注册一个自定义插件。 这个操作类似于 EventEmitter 的 <code>on()</code>, <code>注册一个处理函数</code> -&gt; <code>监听器到某个信号</code> -&gt; <code>事件发生时执行</code>（<strong>开发者自定义的插件需要频繁的用到此方法来自定义事件钩子的处理函数，以便被主编译流程 emit 触发</strong>）。</li><li><code>apply(...pluginInstances&lt;AnyPlugin|function&gt;[])</code> - AnyPlugin 是 AbstractPlugin 的子类，或者是一个有 apply 方法的类（或者，少数情况下是一个对象），或者只是一个有注册代码的函数。这个方法只是 apply 插件的定义，所以真正的事件监听器会被注册到 Tapable 实例的注册表。</li><li><code>applyPlugins*(name&lt;string&gt;, ...)</code> - 这是一组函数，使用这组函数，Tapable 实例可以对指定 hash 下的所有插件执行 apply。 这些方法执行类似于 EventEmitter 的 <code>emit()</code>, 可以针对不同的使用情况采用不同的策略控制事件发射（<strong>webpack 内部实现机制中在主流程的编译过程中频繁的使用此方法来 emit 外界插件的自定义的插件自定义的事件钩子</strong>）。</li><li><code>mixin(pt&lt;Object&gt;)</code> - 一个简单的方法能够以混合的方式扩展 Tapable 的原型，而非继承。</li></ul><p>Tapable 的 <a href="https://github.com/webpack/tapable/blob/master/README.md" target="_blank" rel="noopener">README</a> 中也有详细的描述，值得注意的是这组 <code>applyPlugins*</code> 方法，<code>*</code> 表示着不同情况的事件注册，这组 <code>applyPlugins*</code> 方法在 webpack 的源码中随处可见，它们也涉及到 webpack 插件的执行顺序，不同的 <code>applyPlugins*</code> 对应着以下不同的情况：</p><ul><li>同步串行执行插件 - <code>applyPlugins()</code></li><li>并行执行插件 - <code>applyPluginsParallel()</code></li><li>插件一个接一个的执行,并且每个插件接收上一个插件的返回值(瀑布) - <code>applyPluginsWaterfall()</code></li><li>异步执行插件 - <code>applyPluginsAsync()</code></li><li>保护模式终止插件执行: 一旦某个插件返回 <code>非 undefined</code>，会退出运行流程并返回 这个插件的返回值。这看起来像 EventEmitter 的 <code>once()</code>，但他们是完全不同的 - <code>applyPluginsBailResult()</code></li></ul><p>很多 webpack 中的对象都继承了 Tapable 类，暴露了一个 <code>plugin</code> 方法。插件可以使用 <code>plugin</code>方法注入自定义的构建步骤。在各种 webpack 插件中你可以看到 <code>compiler.plugin</code> 和 <code>compilation.plugin</code> 被频繁使用。基本上，每个插件的调用都在构建流程中绑定了回调来触发特定的步骤。每个插件会在 webpack 启动时被安装一次，webpack 通过调用插件的 <code>apply</code> 方法来安装它们，并且传递一个 webpack compiler 对象的引用。然后你可以调用 <code>compiler.plugin</code> 来访问资源的编译和它们独立的构建步骤。</p><p>下面是一个 webpack 插件示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyPlugin.jsfunction </span></span><br><span class="line">MyPlugin(options) &#123;    </span><br><span class="line">  <span class="comment">// Configure your plugin with options...</span></span><br><span class="line">&#125;</span><br><span class="line">MyPlugin.prototype.apply = <span class="function"><span class="keyword">function</span> (<span class="params">compiler</span>) </span>&#123;    </span><br><span class="line">  compiler.plugin(<span class="string">'compile'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">params</span>) </span>&#123;        </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The compiler is starting to compile...'</span>);    </span><br><span class="line">  &#125;);    </span><br><span class="line">  compiler.plugin(<span class="string">'compilation'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;        </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The compiler is starting a new compilation...'</span>);        </span><br><span class="line">    compilation.plugin(<span class="string">'optimize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;            </span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'The compilation is starting to optimize files...'</span>);        </span><br><span class="line">    &#125;);    </span><br><span class="line">  &#125;);    </span><br><span class="line">  <span class="comment">// 异步的事件钩子    </span></span><br><span class="line">  compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, callback</span>) </span>&#123;        </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The compilation is going to emit files...'</span>);        </span><br><span class="line">    callback();    </span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = MyPlugin;<span class="string">`</span></span><br></pre></td></tr></table></figure><h3 id="webpack-运行流程"><a href="#webpack-运行流程" class="headerlink" title="webpack 运行流程"></a>webpack 运行流程</h3><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5w0mnpnj30vd0u04qp.jpg" alt="img"></p><p>####webpack 插件相关的事件钩子</p><p>webpack 通过继承的 Tapable 实例的方法，分别在 compile 对象和 compilation 对象都注册了一系列的事件钩子，这样可以使得开发者能够在 webpack 编译的任何过程中都能够插入自己的自定义处理逻辑。webpack 的做法就是使用 Tapable 实例的 <code>applyPlugins*</code> 方法来预先设定好这些事件钩子。</p><p>#####compiler 事件钩子</p><p>为了让开发者能够方便的写出 webpack plugin，官方也给出了 compiler 对象的 <a href="https://webpack.js.org/api/plugins/compiler/#event-hooks" target="_blank" rel="noopener">事件钩子(Event Hooks)</a>。</p><p>![image-20190703205042029](/Users/lilinyi/Library/Application Support/typora-user-images/image-20190703205042029.png)</p><p>由于 webpack 自身在继承于 Tapable 的 compiler 对象的各个关键时间点已经通过 <code>applyPlugins*()</code> 方法注册了事件钩子，开发者只需要绑定事件就行，compiler 会在合适的时机去 emit 开发者绑定的事件，compiler 的绑定事件钩子的方式如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前提是先要拿到 compiler 对象，apply 方法的回调中就能拿到，这里假设能拿到 compiler 对象</span></span><br><span class="line">compiler.plugin(<span class="string">'emit'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation, callback</span>) </span>&#123;    </span><br><span class="line">  <span class="comment">// 可以得到 compilation 对象，如果是异步的事件钩子，能拿到 callback 回调。    </span></span><br><span class="line">  <span class="comment">// 做一些异步的事情    </span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;        </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Done with async work..."</span>);        </span><br><span class="line">    callback();    </span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);<span class="string">`</span></span><br></pre></td></tr></table></figure><p>可以明显的看出，compiler 的事件钩子是建立在整个编译过程的基础上的，粒度较粗，通常对编译的结果要做细粒度的处理的时候，少不了 compilation 对象上定义的事件钩子。</p><h5 id="compilation-事件钩子"><a href="#compilation-事件钩子" class="headerlink" title="compilation 事件钩子"></a>compilation 事件钩子</h5><p>compilation 对象代表了一次单一的版本 webpack 构建和生成编译资源的过程，compilation 对象可以访问所有的模块和它们的依赖（大部分是循环依赖）。在编译阶段，模块被 <code>加载</code>，<code>封闭</code>，<code>优化</code>，<code>分块</code>，<code>哈希</code> 和 <code>重建</code> 等等，这将是编译中任何操作主要的生命周期。</p><ul><li><strong>normal-module-loader</strong></li></ul><p>普通模块 loader，真实地一个一个加载模块图(分析之后的所有模块的一种数据结构)中所有的模块的函数。</p><blockquote><p>模块，就是通常所说的 AMD, CMD 等模块化的模块。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前提是能先取到 complation 对象（可以通过 compiler 事件钩子取到）</span></span><br><span class="line">compilation.plugin(<span class="string">'normal-module-loader'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">loaderContext, module</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是所有模块被加载的地方</span></span><br><span class="line">    <span class="comment">// 一个接一个，此时还没有依赖被创建，想拿到啥模块直接通过 module 取</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>seal</strong></li></ul><p>编译的封闭已经开始，这个时候再也收不到任何的模块了，进入编译封闭阶段（参考 webpack 流程图）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compilation.plugin(<span class="string">'seal'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 你已经不能再接收到任何模块</span></span><br><span class="line">    <span class="comment">// 回调没有参数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>optimize</strong></li></ul><p>优化编译，这个事件钩子特别重要，很多插件的优化工作都是基于这个事件钩子，表示 webpack 已经进入优化阶段。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compilation.plugin(<span class="string">'optimize'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// webpack 已经进入优化阶段</span></span><br><span class="line">    <span class="comment">// 回调没有参数</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>optimize-modules</strong></li></ul><p>模块的优化</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compilation.plugin(<span class="string">'optimize-modules'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">modules</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 等待处理的模块数组</span></span><br><span class="line">    <span class="built_in">console</span>.log(modules);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>optimize-chunks</strong></li></ul><p>这是个重要的事件钩子，webpack 的 chunk 优化阶段。可以拿到模块的依赖，loader 等，并进行相应的处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">compilation.plugin(<span class="string">'optimize-chunks'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunks</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//这里一般只有一个 chunk，除非你在配置中指定了多个入口</span></span><br><span class="line">    chunks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// chunk 含有模块的循环引用</span></span><br><span class="line">        chunk.modules.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">module</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">module</span>);</span><br><span class="line">            <span class="comment">// module.loaders, module.rawRequest, module.dependencies 等。</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>additional-assets</strong></li></ul><p>这是一个异步的事件钩子，在这个阶段可以为 compilation 对象创建额外的 assets，也就是说可以异步的在最后的产物中加入自己自定义的一些资源，可以看一下往 assets 里面新增一个 svg 资源的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">compiler.plugin(<span class="string">'compilation'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">compilation</span>) </span>&#123;</span><br><span class="line">    compilation.plugin(<span class="string">'additional-assets'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">        download(<span class="string">'https://some.host/some/path/some.svg'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resp</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (resp.status === <span class="number">200</span>) &#123;</span><br><span class="line">                compilation.assets[<span class="string">'webpack-version.svg'</span>] = toAsset(resp);</span><br><span class="line">                callback();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'[webpack-example-plugin] Unable to download the image'</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>optimize-chunk-assets</strong></li></ul><p>优化 chunk 的 assets 的事件钩子，这个优化阶段可以改变 chunk 的 assets 以达到重新改变资源内容的目。assets 被存储在 this.assets 中，但是它们并不都是 chunk 的 assets。一个 chunk 有一个 files 属性指出这个 chunk 创建的所有文件。附加的 assets 被存储在 this.additionalChunkAssets 中。</p><p>下面是一个为每个 chunk 添加注释头信息的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">compilation.plugin(<span class="string">"optimize-chunk-assets"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunks, callback</span>) </span>&#123;</span><br><span class="line">    chunks.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">        chunk.files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">file</span>) </span>&#123;</span><br><span class="line">            compilation.assets[file] = <span class="string">'/**some comments info**/\n'</span> + compilation.assets[file];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><strong>optimize-assets</strong></li></ul><p>优化所有的 assets 的异步事件钩子，在这个阶段可以直接通过 this.assets 拿到所有的 assets，并进行自定义操作。类似 <strong>optimize-chunk-assets</strong>，但是这个事件钩子的回调是拿不到 chunks 的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">compilation.plugin(<span class="string">"optimize-assets"</span>, <span class="function"><span class="keyword">function</span> (<span class="params">asstes, callback</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(assets);</span><br><span class="line">    <span class="comment">// 可以直接操作 assets 里面的 file</span></span><br><span class="line">    callback();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="4-webpack常用的plugin"><a href="#4-webpack常用的plugin" class="headerlink" title="4.webpack常用的plugin"></a>4.webpack常用的plugin</h2><ul><li><p>官网介绍<a href="https://link.juejin.im?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2F" target="_blank" rel="noopener">plugins</a></p></li><li><p>第三方插件<a href="https://link.juejin.im?target=https%3A%2F%2Fgithub.com%2Fwebpack-contrib%2Fawesome-webpack%23webpack-plugins" target="_blank" rel="noopener">awesome-webpack</a></p></li><li><p>webpack内置<code>UglifyJsPlugin</code>，压缩和混淆代码。</p></li><li><p>webpack内置<code>CommonsChunkPlugin</code>，提高打包效率，将第三方库和业务代码分开打包。</p></li><li><p><code>ProvidePlugin</code>：自动加载模块，代替require和import</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.ProvidePlugin(&#123;</span><br><span class="line">  $: <span class="string">'jquery'</span>,</span><br><span class="line">  jQuery: <span class="string">'jquery'</span></span><br><span class="line">&#125;)复制代码</span><br></pre></td></tr></table></figure></li><li><p><code>html-webpack-plugin</code>可以根据模板自动生成html代码，并自动引用css和js文件</p></li><li><p><code>extract-text-webpack-plugin</code> 将js文件中引用的样式单独抽离成css文件</p></li><li><p><code>DefinePlugin</code> 编译时配置全局变量，这对开发模式和发布模式的构建允许不同的行为非常有用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.DefinePlugin(&#123;</span><br><span class="line">  PRODUCTION: <span class="built_in">JSON</span>.stringify(<span class="literal">true</span>),</span><br><span class="line">  VERSION: <span class="built_in">JSON</span>.stringify(<span class="string">"5fa3b9"</span>),</span><br><span class="line">  BROWSER_SUPPORTS_HTML5: <span class="literal">true</span>,</span><br><span class="line">  TWO: <span class="string">"1+1"</span>,</span><br><span class="line">  <span class="string">"typeof window"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"object"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p><code>HotModuleReplacementPlugin</code> 热更新</p><ul><li>添加HotModuleReplacementPlugin</li><li>entry中添加 “webpack-dev-server/client?<a href="https://link.juejin.im?target=http%3A%2F%2Flocalhost%3A8080%2F" target="_blank" rel="noopener">http://localhost:8080/</a>“,</li><li>entry中添加 “webpack/hot/dev-server”</li><li>(热更新还可以直接用webpack_dev_server –hot –inline,原理也是在entry中添加了上述代码)</li></ul></li><li><p>webpack 内置的<code>DllPlugin</code>和<code>DllReferencePlugin</code>相互配合，前置第三方包的构建，只构建业务代码，同时能解决Externals多次引用问题。DllReferencePlugin引用DllPlugin配置生成的manifest.json文件,manifest.json包含了依赖模块和module id的映射关系</p></li><li><p><code>babili-webpack-plugin、transform-runtime 、transform-object-rest-spread</code></p><ul><li>babili-webpack-plugin:构建在babel之上 <a href="https://link.juejin.im?target=https%3A%2F%2Fwebpack.js.org%2Fplugins%2Fbabili-webpack-plugin%2F%23why" target="_blank" rel="noopener">why</a></li><li>transform-runtime :解决了babel在每个文件都插入了辅助代码，代码体积过大的问题。</li><li>transform-object-rest-spread：<br>Transform rest properties for object destructuring assignment and spread properties for object literals<br>为对象字面量添加解构赋值和spread属性</li></ul></li><li><p><code>optimize-css-assets-webpack-plugin</code> 不同组件中重复的css可以快速去重</p></li><li><p><code>webpack-bundle-analyzer</code> 一个webpack的bundle文件分析工具，将bundle文件以可交互缩放的treemap的形式展示。</p></li><li><p><code>compression-webpack-plugin</code> 生产环境可采用gzip压缩JS和CSS</p></li><li><p><code>happypack</code>：通过多进程模型，来加速代码构建</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">'os'</span>);</span><br><span class="line"><span class="keyword">let</span> HappyPack = <span class="built_in">require</span>(<span class="string">'happypack'</span>);</span><br><span class="line"><span class="keyword">let</span> happyThreadPool = HappyPack.ThreadPool(&#123;<span class="attr">size</span>: os.cpus().length&#125;);</span><br><span class="line">exports.plugins = [</span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'jsx'</span>,</span><br><span class="line">    threadPool: happyThreadPool,</span><br><span class="line">    loaders: [ <span class="string">'babel-loader'</span> ]</span><br><span class="line">  &#125;),</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> HappyPack(&#123;</span><br><span class="line">    id: <span class="string">'coffeescripts'</span>,</span><br><span class="line">    threadPool: happyThreadPool,</span><br><span class="line">    loaders: [ <span class="string">'coffee-loader'</span> ]</span><br><span class="line">  &#125;)</span><br><span class="line">];</span><br><span class="line">  </span><br><span class="line">exports.module.loaders = [</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loaders: [ <span class="string">'happypack/loader?id=jsx'</span> ]</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    test: <span class="regexp">/\.coffee$/</span>,</span><br><span class="line">    loaders: [ <span class="string">'happypack/loader?id=coffeescripts'</span> ]</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li></ul><h2 id="5-写一个webpack插件"><a href="#5-写一个webpack插件" class="headerlink" title="5.写一个webpack插件"></a>5.写一个webpack插件</h2><h5 id="主要的步骤如下"><a href="#主要的步骤如下" class="headerlink" title="主要的步骤如下:"></a>主要的步骤如下:</h5><ul><li>编写一个JavaScript命名函数。</li><li>在它的原型上定义一个apply方法。</li><li>指定挂载的webpack事件钩子。</li><li>处理webpack内部实例的特定数据。</li><li>功能完成后调用webpack提供的回调。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack插件&quot;&gt;&lt;a href=&quot;#webpack插件&quot; class=&quot;headerlink&quot; title=&quot;webpack插件&quot;&gt;&lt;/a&gt;webpack插件&lt;/h1&gt;&lt;p&gt;插件目的在于解决 &lt;a href=&quot;https://webpack.docschin
      
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>babel</title>
    <link href="http://yoursite.com/2020/04/01/babel/"/>
    <id>http://yoursite.com/2020/04/01/babel/</id>
    <published>2020-04-01T07:22:34.000Z</published>
    <updated>2020-04-03T06:23:06.567Z</updated>
    
    <content type="html"><![CDATA[<h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><h2 id="Babel-是什么"><a href="#Babel-是什么" class="headerlink" title="Babel 是什么"></a>Babel 是什么</h2><p><strong>Babel 是一个 JavaScript 编译器</strong></p><p>Babel 是一个工具链，主要用于将 ECMAScript 2015+ 版本的代码转换为向后兼容的 JavaScript 语法，以便能够运行在当前和旧版本的浏览器或其他环境中。下面列出的是 Babel 能为你做的事情：</p><ul><li>语法转换</li><li>通过 Polyfill 方式在目标环境中添加缺失的特性 (通过 <a href="https://www.babeljs.cn/docs/babel-polyfill" target="_blank" rel="noopener">@babel/polyfill</a> 模块)</li><li>源码转换 (codemods)</li></ul><p>Babel的功能非常纯粹，以字符串的形式将源代码传给它，它就会返回一段新的代码字符串（以及sourcemap）。他既不会运行你的代码，也不会将多个代码打包到一起，它就是个编译器，输入语言是ES6+，编译目标语言是ES5。</p><p>babel 内部使用的解析类库叫做 babylon，并非 babel 自行开发</p><h2 id="Babel工作的三个阶段"><a href="#Babel工作的三个阶段" class="headerlink" title="Babel工作的三个阶段"></a>Babel工作的三个阶段</h2><p>Babel的编译过程跟绝大多数其他语言的编译器大致同理，分为三个阶段：</p><ol><li><strong>解析</strong>：将代码字符串解析成抽象语法树</li><li><strong>变换</strong>：对抽象语法树进行变换操作</li><li><strong>再建</strong>：根据变换后的抽象语法树再生成代码字符串</li></ol><p>第1步转换的过程中可以验证语法的正确性，同时由字符串变为对象结构后更有利于精准地分析以及进行代码结构调整。</p><p>第2步原理就很简单了，就是遍历这个对象所描述的抽象语法树，遇到哪里需要做一下改变，就直接在对象上进行操作，比如我把IfStatement给改成WhileStatement就达到了把条件判断改成循环的效果。</p><p>第3步也简单，递归遍历这颗语法树，然后生成相应的代码。</p><h2 id="抽象语法树是如何产生的"><a href="#抽象语法树是如何产生的" class="headerlink" title="抽象语法树是如何产生的"></a>抽象语法树是如何产生的</h2><p>解析这一步又分成两个步骤：</p><ol><li><strong>分词</strong>：将整个代码字符串分割成 <em>语法单元</em> 数组</li><li><strong>语义分析</strong>：在分词结果的基础之上分析 <em>语法单元之间的关系</em></li></ol><h3 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h3><p>首先解释一下<strong>什么是语法单元</strong>：语法单元是被解析语法当中具备实际意义的最小单元，通俗点说就是类似于自然语言中的词语。</p><h4 id="JS代码有哪些语法单元"><a href="#JS代码有哪些语法单元" class="headerlink" title="JS代码有哪些语法单元"></a>JS代码有哪些语法单元</h4><ul><li><strong>空白</strong>：JS中连续的空格、换行、缩进等这些如果不在字符串里，就没有任何实际逻辑意义，所以把连续的空白符直接组合在一起作为一个语法单元。</li><li><strong>注释</strong>：行注释或块注释，虽然对于人类来说有意义，但是对于计算机来说知道这是个“注释”就行了，并不关心内容，所以直接作为一个不可再拆的语法单元</li><li><strong>字符串</strong>：对于机器而言，字符串的内容只是会参与计算或展示，里面再细分的内容也是没必要分析的</li><li><strong>数字</strong>：JS语言里就有16、10、8进制以及科学表达法等数字表达语法，数字也是个具备含义的最小单元</li><li><strong>标识符</strong>：没有被引号扩起来的连续字符，可包含字母、_、$、及数字（数字不能作为开头）。标识符可能代表一个变量，或者true、false这种内置常量、也可能是if、return、function这种关键字，是哪种语义，分词阶段并不在乎，只要正确切分就好了。</li><li><strong>运算符</strong>：+、-、*、/、&gt;、&lt;等等</li><li><strong>括号</strong>：(…)可能表示运算优先级、也可能表示函数调用，分词阶段并不关注是哪种语义，只把“(”或“)”当做一种基本语法单元</li><li>还有其他：如中括号、大括号、分号、冒号、点等等不再一一列举</li></ul><p>这拆分过程其实没啥可取巧的，就是简单粗暴地一个字符一个字符地遍历，然后分情况讨论，整个实现方法就是顺序遍历和大量的条件判断。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析就是把词汇进行立体的组合，确定有多重意义的词语最终是什么意思、多个词语之间有什么关系以及又应该再哪里断句等。</p><p>在编程语言解释当中，这就是要最终生成语法树的步骤了。不像自然语言，像“从句”这种结构往往最多只有一层，编程语言的各种从属关系更加复杂。</p><p>在编程语言的解析中有两个很相似但是又有区别的重要概念：</p><ul><li><strong>语句</strong>：语句是一个具备边界的代码区域，相邻的两个语句之间从语法上来讲互不干扰，调换顺序虽然可能会影响执行结果，但不会产生语法错误<br>比如return true、var a = 10、if (…) {…}</li><li><strong>表达式</strong>：最终有个结果的一小段代码，它的特点是可以原样嵌入到另一个表达式<br>比如myVar、1+1、str.replace(‘a’, ‘b’)、i &lt; 10 &amp;&amp; i &gt; 0等</li></ul><p>很多情况下一个语句可能只包含一个表达式，比如console.log(‘hi’);。estree标准当中，这种语句节点称作ExpressionStatement。</p><p>语义分析的过程又是个遍历语法单元的过程，不过相比较而言更复杂，因为分词过程中，每个语法单元都是独立平铺的，而语法分析中，语句和表达式会以树状的结构互相包含。针对这种情况我们可以用栈，也可以用递归来实现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;babel&quot;&gt;&lt;a href=&quot;#babel&quot; class=&quot;headerlink&quot; title=&quot;babel&quot;&gt;&lt;/a&gt;babel&lt;/h1&gt;&lt;h2 id=&quot;Babel-是什么&quot;&gt;&lt;a href=&quot;#Babel-是什么&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack DllPlugin</title>
    <link href="http://yoursite.com/2020/03/24/webpack%20DllPlugin/"/>
    <id>http://yoursite.com/2020/03/24/webpack DllPlugin/</id>
    <published>2020-03-23T18:19:08.000Z</published>
    <updated>2020-04-03T06:20:35.930Z</updated>
    
    <content type="html"><![CDATA[<h1 id="webpack-DllPlugin"><a href="#webpack-DllPlugin" class="headerlink" title="webpack DllPlugin"></a>webpack DllPlugin</h1><h2 id="DllPlugin-和-DllReferencePlugin"><a href="#DllPlugin-和-DllReferencePlugin" class="headerlink" title="DllPlugin 和 DllReferencePlugin"></a>DllPlugin 和 DllReferencePlugin</h2><p>在使用webpack进行打包时候，对于依赖的第三方库，比如vue，vuex等这些不会修改的依赖，我们可以让它和我们自己编写的代码分开打包，这样做的好处是每次更改我本地代码的文件的时候，webpack只需要打包我项目本身的文件代码，而不会再去编译第三方库，那么第三方库在第一次打包的时候只打包一次，以后只要我们不升级第三方包的时候，那么webpack就不会对这些库去打包，这样的可以快速的提高打包的速度。因此为了解决这个问题，DllPlugin 和 DllReferencePlugin插件就产生了。</p><p>那么对于目前webpack社区来讲，我们希望和自己编写的代码分离开的话，webpack社区提供了2种方案：<br><strong>1. CommonsChunkPlugin</strong><br><strong>2. DLLPlugin</strong></p><p><strong>CommonsChunkPlugin</strong> 插件每次打包的时候还是会去处理一些第三方依赖库，只是它能把第三方库文件和我们的代码分开掉，生成一个独立的js文件。但是它还是不能提高打包的速度。</p><p><strong>DLLPlugin</strong> 它能把第三方库代码分离开，并且每次文件更改的时候，它只会打包该项目自身的代码。所以打包速度会更快。</p><h2 id="DllPlugin的作用"><a href="#DllPlugin的作用" class="headerlink" title="DllPlugin的作用"></a>DllPlugin的作用</h2><h3 id="DLLPlugin"><a href="#DLLPlugin" class="headerlink" title="DLLPlugin"></a>DLLPlugin</h3><p>这个插件是在一个额外独立的webpack设置中创建一个只有dll的bundle，也就是说我们在项目根目录下除了有webpack.config.js，还会新建一个webpack.dll.config.js文件。webpack.dll.config.js作用是把所有的第三方库依赖打包到一个bundle的dll文件里面，还会生成一个名为 manifest.json文件。该manifest.json的作用是用来让 DllReferencePlugin 映射到相关的依赖上去的。</p><h3 id="DllReferencePlugin"><a href="#DllReferencePlugin" class="headerlink" title="DllReferencePlugin"></a>DllReferencePlugin</h3><p>这个插件是在webpack.config.js中使用的，该插件的作用是把刚刚在webpack.dll.config.js中打包生成的dll文件引用到需要的预编译的依赖上来。什么意思呢？就是说在webpack.dll.config.js中打包后比如会生成 vendor.dll.js文件和vendor-manifest.json文件，vendor.dll.js文件包含所有的第三方库文件，vendor-manifest.json文件会包含所有库代码的一个索引，当在使用webpack.config.js文件打包DllReferencePlugin插件的时候，会使用该DllReferencePlugin插件读取vendor-manifest.json文件，看看是否有该第三方库。vendor-manifest.json文件就是有一个第三方库的一个映射而已。</p><p>所以说 第一次使用 webpack.dll.config.js 文件会对第三方库打包，打包完成后就不会再打包它了，然后每次运行 webpack.config.js文件的时候，都会打包项目中本身的文件代码，当需要使用第三方依赖的时候，会使用 DllReferencePlugin插件去读取第三方依赖库。所以说它的打包速度会得到一个很大的提升。</p><p>##在项目中如何使用 DllPlugin 和 DllReferencePlugin？</p><p> 在使用之前，我们首先看下我们项目现在的整个目录架构如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">### 目录结构如下：</span><br><span class="line">demo1                                       # 工程名</span><br><span class="line">|   |--- dist                               # 打包后生成的目录文件             </span><br><span class="line">|   |--- node_modules                       # 所有的依赖包</span><br><span class="line">|   |--- js                                 # 存放所有js文件</span><br><span class="line">|   | |-- demo1.js  </span><br><span class="line">|   | |-- main.js                           # js入口文件</span><br><span class="line">|   |--- webpack.config.js                  # webpack配置文件</span><br><span class="line">|   |--- webpack.dll.config.js              # 打包第三方依赖的库文件</span><br><span class="line">|   |--- index.html                         # html文件</span><br><span class="line">|   |--- styles                             # 存放所有的css样式文件   </span><br><span class="line">|   | |-- main.styl                         # main.styl文件   </span><br><span class="line">|   | |-- index.styl                        </span><br><span class="line">|   |--- .gitignore  </span><br><span class="line">|   |--- README.md</span><br><span class="line">|   |--- package.json</span><br><span class="line">|   |--- .babelrc                           # babel转码文件</span><br></pre></td></tr></table></figure><p>因此我们首先需要在我们的项目根目录下创建一个 webpack.dll.config.js 文件。然后配置代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> DllPlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllPlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 项目中用到该两个依赖库文件</span></span><br><span class="line">    jquery: [<span class="string">'jquery'</span>],</span><br><span class="line">    echarts: [<span class="string">'echarts'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 输出文件</span></span><br><span class="line">  output: &#123;</span><br><span class="line">    <span class="comment">// 文件名称</span></span><br><span class="line">    filename: <span class="string">'[name].dll.js'</span>, </span><br><span class="line">    <span class="comment">// 将输出的文件放到dist目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     存放相关的dll文件的全局变量名称，比如对于jquery来说的话就是 _dll_jquery, 在前面加 _dll</span></span><br><span class="line"><span class="comment">     是为了防止全局变量冲突。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    library: <span class="string">'_dll_[name]'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 使用插件 DllPlugin</span></span><br><span class="line">    <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。</span></span><br><span class="line"><span class="comment">       比如在jquery.manifest文件中有 name: '_dll_jquery'</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      name: <span class="string">'_dll_[name]'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 生成manifest文件输出的位置和文件名称 */</span></span><br><span class="line">      path: path.join(__dirname, <span class="string">'dist'</span>, <span class="string">'[name].manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]a</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DllPlugin 插件有三个配置项参数如下：</strong><br><strong>context(可选)：</strong> manifest文件中请求的上下文，默认为该webpack文件上下文。<br><strong>name:</strong> 公开的dll函数的名称，和 output.library保持一致。<br><strong>path:</strong> manifest.json 生成文件的位置和文件名称。</p><p>下面我们继续看下 webpack.config.js 配置代码如下：</p><p>首先引入文件如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 DllReferencePlugin</span></span><br><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllReferencePlugin'</span>);</span><br></pre></td></tr></table></figure><p>然后在插件中使用该插件，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 告诉webpack使用了哪些第三方库代码</span></span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// jquery 映射到json文件上去</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/jquery.manifest.json'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// echarts 映射到json文件上去</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/echarts.manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>DllReferencePlugin项的参数有如下：</strong></p><p><strong>context:</strong> manifest文件中请求的上下文。<br><strong>manifest:</strong> 编译时的一个用于加载的JSON的manifest的绝对路径。<br><strong>context:</strong> 请求到模块id的映射(默认值为 manifest.content)<br><strong>name:</strong> dll暴露的地方的名称(默认值为manifest.name)<br><strong>scope:</strong> dll中内容的前缀。<br><strong>sourceType:</strong> dll是如何暴露的libraryTarget。</p><p>webpack.config.js 所有代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="comment">// 提取css的插件</span></span><br><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除dist目录下的文件</span></span><br><span class="line"><span class="comment">// const ClearWebpackPlugin = require('clean-webpack-plugin');</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入打包html文件</span></span><br><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入 DllReferencePlugin</span></span><br><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">// 入口文件</span></span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./js/main.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    <span class="comment">// 将输出的文件都放在dist目录下</span></span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">// 使用正则去匹配</span></span><br><span class="line">        test: <span class="regexp">/\.styl$/</span>,</span><br><span class="line">        use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: &#123;</span><br><span class="line">            loader: <span class="string">'style-loader'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          use: [</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'css-loader'</span>,</span><br><span class="line">              options: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'postcss-loader'</span>,</span><br><span class="line">              options: &#123;</span><br><span class="line">                ident: <span class="string">'postcss'</span>,</span><br><span class="line">                plugins: [</span><br><span class="line">                  <span class="built_in">require</span>(<span class="string">'postcss-cssnext'</span>)(),</span><br><span class="line">                  <span class="built_in">require</span>(<span class="string">'cssnano'</span>)(),</span><br><span class="line">                  <span class="built_in">require</span>(<span class="string">'postcss-pxtorem'</span>)(&#123;</span><br><span class="line">                    rootValue: <span class="number">16</span>,</span><br><span class="line">                    unitPrecision: <span class="number">5</span>,</span><br><span class="line">                    propWhiteList: []</span><br><span class="line">                  &#125;),</span><br><span class="line">                  <span class="built_in">require</span>(<span class="string">'postcss-sprites'</span>)()</span><br><span class="line">                ]</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              loader: <span class="string">'stylus-loader'</span>,</span><br><span class="line">              options: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(png|jpg)$/</span>,</span><br><span class="line">        loader: <span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">          limit: <span class="number">10000</span>,</span><br><span class="line">          name: <span class="string">'[name].[ext]'</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        exclude: path.resolve(__dirname, <span class="string">'node_modules'</span>), <span class="comment">// 排除文件</span></span><br><span class="line">        loader: <span class="string">'babel-loader'</span></span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'*'</span>, <span class="string">'.js'</span>, <span class="string">'.json'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  devtool: <span class="string">'cheap-module-eval-source-map'</span>,</span><br><span class="line">  devServer: &#123;</span><br><span class="line">    <span class="comment">// contentBase: path.join(__dirname, "dist"),</span></span><br><span class="line">    port: <span class="number">8081</span>,</span><br><span class="line">    host: <span class="string">'0.0.0.0'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'X-foo'</span>: <span class="string">'112233'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// hot: true,</span></span><br><span class="line">    inline: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// open: true,</span></span><br><span class="line">    overlay: <span class="literal">true</span>,</span><br><span class="line">    stats: <span class="string">'errors-only'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// new ClearWebpackPlugin(['dist']),</span></span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">      template: <span class="string">'./index.html'</span> <span class="comment">// 模版文件</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> ExtractTextPlugin(&#123;</span><br><span class="line">      <span class="comment">// 从js文件中提取出来的 .css文件的名称</span></span><br><span class="line">      filename: <span class="string">`main.css`</span></span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="comment">// 告诉webpack使用了哪些第三方库代码</span></span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// jquery 映射到json文件上去</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/jquery.manifest.json'</span>)</span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// echarts 映射到json文件上去</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(<span class="string">'./dist/echarts.manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>执行构建：</strong></p><p>最后一步就是构建代码了，先生存第三方库文件，因此我们运行如下命令：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --config webpack.dll.config.js</span><br></pre></td></tr></table></figure><p>为了方便，我们在package.json中scripts加如下代码了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"dev"</span>: <span class="string">"webpack-dev-server --progress --colors --devtool cheap-module-eval-source-map --hot --inline"</span>,</span><br><span class="line">  <span class="string">"build"</span>: <span class="string">"webpack --progress --colors --devtool cheap-module-source-map"</span>,</span><br><span class="line">  <span class="string">"build:dll"</span>: <span class="string">"webpack --config webpack.dll.config.js"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>所以我们先运行 npm run build:dll 命令，运行完成后，会在dist目录下生存 echarts.dll.js, echarts.manifest.json,jquery.dll.js, jquery.manifest.json 文件。如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6taww8nspj30co07mjrx.jpg" alt="img"></p><p>再看下打包两个库执行的时间，如下所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tax00td9j30pu0cwgpm.jpg" alt="img"></p><p>xx.dll.js 文件代码大概如下这个样子，比如echarts.dll.js 代码为例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _dll_echarts = (<span class="function"><span class="keyword">function</span>(<span class="params">modules</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 此处省略 webpackBootstrap 函数代码</span></span><br><span class="line">&#125;([</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ID为0模块对应的代码</span></span><br><span class="line">  &#125;),</span><br><span class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">module, exports, __webpack_require__</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ID为1模块对应的代码</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="comment">// ....... 很多模块代码</span></span><br><span class="line">]));</span><br></pre></td></tr></table></figure><p>那么 echarts.manifest.json 生存的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"_dll_echarts"</span>,</span><br><span class="line">  <span class="string">"content"</span>: &#123;</span><br><span class="line">    <span class="string">"./node_modules/zrender/lib/core/util.js"</span>: &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">"meta"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./node_modules/echarts/lib/echarts.js"</span>: &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="string">"meta"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"./node_modules/echarts/lib/util/graphic.js"</span>: &#123;</span><br><span class="line">      <span class="string">"id"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="string">"meta"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>echarts.manifest.json 文件可以清楚的看到与其对应的dll.js文件中包含了哪些模块，以及每个模块的路径和ID。</p><p>如上打包完库文件后，我们需要 运行 npm run build命令打包项目中文件了，如下dist目录后的文件</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6taxtq9fyj30d80cqdgs.jpg" alt="img"></p><p>然后我们查看index.html代码如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"main.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span>12aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'test2'</span>&gt;</span>vvvvv<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到jquery文件没有自动加上，因此需要我们手动加上，加上后代码变成如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"main.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"test1"</span>&gt;</span>12aaa<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">'test2'</span>&gt;</span>vvvvv<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"jquery.dll.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"main.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>加上jquery.dll.js文件后，main.js入口文件的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">'../styles/main.styl'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>);</span><br><span class="line">$(<span class="string">'#app'</span>).html(<span class="string">'欢迎你来我的博客'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'这是main.js'</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">'./demo1.js'</span>);</span><br></pre></td></tr></table></figure><p>$(‘#app’) 就可以操作元素了。</p><p><a href="https://github.com/tugenhua0707/webpack-all-demo/tree/master/dllPlugin" target="_blank" rel="noopener">github上查看demo</a></p><p>##DllPlugin DllReferencePlugin使用在vue和vuex项目中</p><p> 首先vuex-demo代码可以查看github上的代码了。然后我们在没有使用 DllPlugin 插件时候，打包的速度如下，使用了十几秒：</p><p><a href="https://github.com/tugenhua0707/webpack-all-demo/tree/master/vuex-demo1" target="_blank" rel="noopener">github查看demo</a></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tayw5puzj30x40eadjj.jpg" alt="img"></p><p>首先我们看下我们的入口文件 src/business/examine/app.js，引入我们所安装的静态资源，结果为：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">'vue-router'</span>;</span><br><span class="line"><span class="keyword">import</span> VueResource <span class="keyword">from</span> <span class="string">'vue-resource'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./base/main'</span>;</span><br><span class="line"><span class="keyword">import</span> routerConfig <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主题样式</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'../../components/common/common.styl'</span>;</span><br><span class="line"></span><br><span class="line">Vue.config.devtools = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Router</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Resource</span></span><br><span class="line">Vue.use(VueResource);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 resource</span></span><br><span class="line">Vue.http.options.root = <span class="string">''</span>;</span><br><span class="line">Vue.http.options.emulateJSON = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = routerConfig(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(Vue.util.extend(&#123;</span><br><span class="line">  router,</span><br><span class="line">  store</span><br><span class="line">&#125;, App)).$mount(<span class="string">'#app'</span>);</span><br></pre></td></tr></table></figure><p>在store文件内用到了vuex，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> state <span class="keyword">from</span> <span class="string">'./state'</span>;</span><br><span class="line"><span class="keyword">import</span> mutations <span class="keyword">from</span> <span class="string">'./mutations'</span>;</span><br><span class="line"><span class="keyword">import</span> actions <span class="keyword">from</span> <span class="string">'./actions'</span>;</span><br><span class="line"></span><br><span class="line">Vue.use(Vuex);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state,</span><br><span class="line">  mutations,</span><br><span class="line">  actions</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如上代码我们把vue和vue-router,vue-resource，vuex一起打包的。如上只是用到一些vue常见的插件，还没有使用很多其他的插件，就耗时了十几秒的时间，如果插件更多的话，那么相对来说耗时更长，那么现在我们希望把 vue，vuex, vue-router, vue-resource这样的在 webpack.dll.config.js中进行打包，然后再使用webpack.config.js打包本项目中的文件代码；<br>还是和上面一样在项目中根目录下新建 webpack.dll.config.js，我把打包文件统一都放到build文件内，配置代码如下：</p><p>配置入口文件代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    <span class="comment">// 项目中用到该依赖库文件</span></span><br><span class="line">    vendor: [<span class="string">'vue/dist/vue.esm.js'</span>, <span class="string">'vue'</span>, <span class="string">'vuex'</span>, <span class="string">'vue-router'</span>, <span class="string">'vue-resource'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 使用插件 DllPlugin</span></span><br><span class="line">    <span class="keyword">new</span> DllPlugin(&#123;</span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">       该插件的name属性值需要和 output.library保存一致，该字段值，也就是输出的 manifest.json文件中name字段的值。</span></span><br><span class="line"><span class="comment">       比如在jquery.manifest文件中有 name: '_dll_jquery'</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      name: <span class="string">'_dll_[name]'</span>,</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* 生成manifest文件输出的位置和文件名称 */</span></span><br><span class="line">      path: path.resolve(__dirname, paths.dist, <span class="string">'[name].manifest.json'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>webpack.config.js 配置相关代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 DllReferencePlugin</span></span><br><span class="line"><span class="keyword">const</span> DllReferencePlugin = <span class="built_in">require</span>(<span class="string">'webpack/lib/DllReferencePlugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="comment">// 告诉webpack使用了哪些第三方库代码</span></span><br><span class="line">    <span class="keyword">new</span> DllReferencePlugin(&#123;</span><br><span class="line">      <span class="comment">// jquery 映射到json文件上去</span></span><br><span class="line">      manifest: <span class="built_in">require</span>(path.resolve(__dirname, paths.dist, <span class="string">'vendor.manifest.json'</span>))</span><br><span class="line">    &#125;),</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后运行打包 npm run build 后，打包的时间如下图所示：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tb028l6gj30v60ekaf3.jpg" alt="img"></p><p>可以看到没有使用 DllPlugin DllReferencePlugin 打包前，打包的时间需要12.5秒，使用了该插件后，仅仅需要4秒的时间，可见提高了8秒的打包时间。并且分了两个文件，所有相关的vue的依赖都放在了vendor.dll.js内，我们项目上相关的代码放在了bundle.js内，这样就可以减少一个js文件非常大的问题。但是在页面上需要引用 vendor.dll.js 文件了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;webpack-DllPlugin&quot;&gt;&lt;a href=&quot;#webpack-DllPlugin&quot; class=&quot;headerlink&quot; title=&quot;webpack DllPlugin&quot;&gt;&lt;/a&gt;webpack DllPlugin&lt;/h1&gt;&lt;h2 id=&quot;DllPl
      
    
    </summary>
    
      <category term="前端工具" scheme="http://yoursite.com/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Html标签默认属性样式及浏览器默认样式</title>
    <link href="http://yoursite.com/2020/03/14/Html%E6%A0%87%E7%AD%BE%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7%E6%A0%B7%E5%BC%8F%E5%8F%8A%E6%B5%8F%E8%A7%88%E5%99%A8%E9%BB%98%E8%AE%A4%E6%A0%B7%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/14/Html标签默认属性样式及浏览器默认样式/</id>
    <published>2020-03-14T06:20:32.000Z</published>
    <updated>2020-04-03T06:15:57.271Z</updated>
    
    <content type="html"><![CDATA[<h1 id="html标签默认属性样式及浏览器默认样式"><a href="#html标签默认属性样式及浏览器默认样式" class="headerlink" title="html标签默认属性样式及浏览器默认样式"></a>html标签默认属性样式及浏览器默认样式</h1><h2 id="具有默认样式的html标签"><a href="#具有默认样式的html标签" class="headerlink" title="具有默认样式的html标签"></a>具有默认样式的html标签</h2><table><thead><tr><th>html</th><th>address</th><th>blockquote</th></tr></thead><tbody><tr><td>body</td><td>dd</td><td>div</td></tr><tr><td>dl</td><td>dt</td><td>fieldset</td></tr><tr><td>form</td><td>frame</td><td>frameset</td></tr><tr><td>h1</td><td>h2</td><td>H3</td></tr><tr><td>h4</td><td>h5</td><td>h6</td></tr><tr><td>noframes</td><td>ol</td><td>p</td></tr><tr><td>ul</td><td>center</td><td>dir</td></tr><tr><td>hr</td><td>menu</td><td>pre</td></tr></tbody></table><p>以上列表元素默认状态下以块状显示，未显示的将以内联元素显示，该列表针对HTML4版本，部分元素在XHTML1中将废弃</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;<span class="attribute">display</span>: list-item &#125;`<span class="comment">/*默认以列表显示*/</span>`</span><br><span class="line"><span class="selector-tag">head</span> &#123;<span class="attribute">display</span>: none &#125;<span class="comment">/*默认不显示*/</span></span><br><span class="line"><span class="selector-tag">table</span> &#123;<span class="attribute">display</span>: table &#125;<span class="comment">/*默认为表格显示*/</span></span><br><span class="line"><span class="selector-tag">tr</span> &#123;<span class="attribute">display</span>: table-row &#125;<span class="comment">/*默认为表格行显示*/</span></span><br><span class="line"><span class="selector-tag">thead</span> &#123;<span class="attribute">display</span>: table-header-group &#125;<span class="comment">/*默认为表格头部分组显示*/</span></span><br><span class="line"><span class="selector-tag">tbody</span> &#123;<span class="attribute">display</span>: table-row-group &#125;<span class="comment">/*默认为表格行分组显示*/</span></span><br><span class="line"><span class="selector-tag">tfoot</span> &#123;<span class="attribute">display</span>: table-footer-group &#125;<span class="comment">/*默认为表格底部分组显示*/</span></span><br><span class="line"><span class="selector-tag">col</span> &#123;<span class="attribute">display</span>: table-column &#125;<span class="comment">/*默认为表格列显示*/</span></span><br><span class="line"><span class="selector-tag">colgroup</span> &#123;<span class="attribute">display</span>: table-column-group &#125;<span class="comment">/*默认为表格列分组显示*/</span></span><br><span class="line"><span class="selector-tag">td</span>, <span class="selector-tag">th</span> &#123; <span class="attribute">display</span>:table-cell; &#125;<span class="comment">/*默认为单元格显示*/</span></span><br><span class="line"><span class="selector-tag">caption</span> &#123;<span class="attribute">display</span>: table-caption &#125;<span class="comment">/*默认为表格标题显示*/</span></span><br><span class="line"><span class="selector-tag">th</span> &#123;<span class="attribute">font-weight</span>: bolder; <span class="attribute">text-align</span>: center &#125;<span class="comment">/*默认为表格标题显示，呈现加粗居中状态*/</span></span><br><span class="line"><span class="selector-tag">caption</span> &#123;<span class="attribute">text-align</span>: center &#125;<span class="comment">/*默认为表格标题显示，呈现居中状态*/</span></span><br><span class="line"><span class="selector-tag">body</span> &#123;<span class="attribute">margin</span>: <span class="number">8px</span>; <span class="attribute">line-height</span>: <span class="number">1.12</span> &#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">font-size</span>: <span class="number">2em</span>; <span class="attribute">margin</span>: .<span class="number">67em</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="selector-tag">h2</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.5em</span>; <span class="attribute">margin</span>: .<span class="number">75em</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="selector-tag">h3</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.17em</span>; <span class="attribute">margin</span>: .<span class="number">83em</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="selector-tag">h4</span>, <span class="selector-tag">p</span>,<span class="selector-tag">blockquote</span>, <span class="selector-tag">ul</span>, <span class="selector-tag">fieldset</span>, <span class="selector-tag">form</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">dl</span>, <span class="selector-tag">dir</span>, <span class="selector-tag">menu</span> &#123; <span class="attribute">margin</span>: <span class="number">1.12em</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="selector-tag">h5</span> &#123;<span class="attribute">font-size</span>: .<span class="number">83em</span>; <span class="attribute">margin</span>: <span class="number">1.5em</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="selector-tag">h6</span> &#123;<span class="attribute">font-size</span>: .<span class="number">75em</span>; <span class="attribute">margin</span>: <span class="number">1.67em</span> <span class="number">0</span> &#125;</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span>, <span class="selector-tag">b</span>,<span class="selector-tag">strong</span> &#123; <span class="attribute">font-weight</span>: bolder &#125;</span><br><span class="line"><span class="selector-tag">blockquote</span>&#123; <span class="attribute">margin-left</span>: <span class="number">40px</span>; <span class="attribute">margin-right</span>: <span class="number">40px</span> &#125;</span><br><span class="line"><span class="selector-tag">i</span>, <span class="selector-tag">cite</span>,<span class="selector-tag">em</span>,<span class="selector-tag">var</span>, <span class="selector-tag">address</span> &#123; <span class="attribute">font-style</span>: italic &#125;</span><br><span class="line"><span class="selector-tag">pre</span>, <span class="selector-tag">tt</span>,<span class="selector-tag">code</span>, <span class="selector-tag">kbd</span>, <span class="selector-tag">samp</span> &#123; <span class="attribute">font-family</span>: monospace &#125;</span><br><span class="line"><span class="selector-tag">pre</span> &#123;<span class="attribute">white-space</span>: pre &#125;</span><br><span class="line"><span class="selector-tag">button</span>,<span class="selector-tag">textarea</span>, <span class="selector-tag">input</span>, <span class="selector-tag">object</span>, <span class="selector-tag">select</span> &#123; <span class="attribute">display</span>:inline-block; &#125;</span><br><span class="line"><span class="selector-tag">big</span> &#123;<span class="attribute">font-size</span>: <span class="number">1.17em</span> &#125;</span><br><span class="line"><span class="selector-tag">small</span>,<span class="selector-tag">sub</span>, <span class="selector-tag">sup</span> &#123; <span class="attribute">font-size</span>: .<span class="number">83em</span> &#125;</span><br><span class="line"><span class="selector-tag">sub</span> &#123;<span class="attribute">vertical-align</span>: sub &#125;<span class="comment">/*定义sub元素默认为下标显示*/</span></span><br><span class="line"><span class="selector-tag">sup</span> &#123;<span class="attribute">vertical-align</span>: super &#125;<span class="comment">/*定义sub元素默认为上标显示*/</span></span><br><span class="line"><span class="selector-tag">table</span> &#123;<span class="attribute">border-spacing</span>: <span class="number">2px</span>; &#125;</span><br><span class="line"><span class="selector-tag">thead</span>,<span class="selector-tag">tbody</span>, <span class="selector-tag">tfoot</span> &#123; <span class="attribute">vertical-align</span>: middle &#125;<span class="comment">/*定义表头、主体表、表脚元素默认为垂直对齐*/</span></span><br><span class="line"><span class="selector-tag">td</span>, <span class="selector-tag">th</span> &#123;<span class="attribute">vertical-align</span>: inherit &#125;<span class="comment">/*定义单元格、列标题默认为垂直对齐默认为继承*/</span></span><br><span class="line"><span class="selector-tag">s</span>, <span class="selector-tag">strike</span>,<span class="selector-tag">del</span> &#123; <span class="attribute">text-decoration</span>: line-through &#125;<span class="comment">/*定义这些元素默认为删除线显示*/</span></span><br><span class="line"><span class="selector-tag">hr</span> &#123;<span class="attribute">border</span>: <span class="number">1px</span> inset &#125;<span class="comment">/*定义分割线默认为1px宽的3D凹边效果*/</span></span><br><span class="line"><span class="selector-tag">ol</span>, <span class="selector-tag">ul</span>,<span class="selector-tag">dir</span>, <span class="selector-tag">menu</span>, <span class="selector-tag">dd</span> &#123; <span class="attribute">margin-left</span>: <span class="number">40px</span> &#125;</span><br><span class="line"><span class="selector-tag">ol</span> &#123;<span class="attribute">list-style-type</span>: decimal &#125;</span><br><span class="line"><span class="selector-tag">ol</span> <span class="selector-tag">ul</span>, <span class="selector-tag">ulol</span>, <span class="selector-tag">ul</span> <span class="selector-tag">ul</span>, <span class="selector-tag">ol</span> <span class="selector-tag">ol</span> &#123; <span class="attribute">margin-top</span>: <span class="number">0</span>; <span class="attribute">margin-bottom</span>: <span class="number">0</span> &#125;</span><br><span class="line"><span class="selector-tag">u</span>, <span class="selector-tag">ins</span> &#123;<span class="attribute">text-decoration</span>: underline &#125;</span><br><span class="line"><span class="selector-tag">br</span><span class="selector-pseudo">:before</span>&#123; <span class="attribute">content</span>: <span class="string">""</span>A<span class="string">" &#125;/*定义换行元素的伪对象内容样式*/</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:before</span>,<span class="selector-pseudo">:after</span> &#123; <span class="attribute">white-space</span>: pre-line &#125;<span class="comment">/*定义伪对象空格字符的默认样式*/</span></span><br><span class="line"><span class="selector-tag">center</span> &#123;<span class="attribute">text-align</span>: center &#125;</span><br><span class="line"><span class="selector-tag">abbr</span>,<span class="selector-tag">acronym</span> &#123; <span class="attribute">font-variant</span>: small-caps; <span class="attribute">letter-spacing</span>: <span class="number">0.1em</span> &#125;</span><br><span class="line"><span class="selector-pseudo">:link</span>,<span class="selector-pseudo">:visited</span> &#123; <span class="attribute">text-decoration</span>: underline &#125;</span><br><span class="line"><span class="selector-pseudo">:focus</span> &#123;<span class="attribute">outline</span>: thin dotted invert &#125;</span><br><span class="line"><span class="comment">/* Beginbidirectionality settings (do not change) */</span></span><br><span class="line"><span class="selector-tag">BDO</span><span class="selector-attr">[DIR="ltr"]</span>&#123; <span class="attribute">direction</span>: ltr; <span class="attribute">unicode-bidi</span>: bidi-override &#125;<span class="comment">/*定义BDO元素当其属性为DIR="ltr"时的默认文本读写显示顺序*/</span></span><br><span class="line"><span class="selector-tag">BDO</span><span class="selector-attr">[DIR="rtl"]</span>&#123; <span class="attribute">direction</span>: rtl; <span class="attribute">unicode-bidi</span>: bidi-override &#125;<span class="comment">/*定义BDO元素当其属性为DIR="rtl"时的默认文本读写显示顺序*/</span></span><br><span class="line">*<span class="selector-attr">[DIR="ltr"]</span>&#123; <span class="attribute">direction</span>: ltr; <span class="attribute">unicode-bidi</span>: embed &#125;<span class="comment">/*定义任何元素当其属性为DIR="ltr"时的默认文本读写显示顺序*/</span></span><br><span class="line">*<span class="selector-attr">[DIR="rtl"]</span>&#123; <span class="attribute">direction</span>: rtl; <span class="attribute">unicode-bidi</span>: embed &#125;<span class="comment">/*定义任何元素当其属性为DIR="rtl"时的默认文本读写显示顺序*/</span></span><br><span class="line">@<span class="keyword">mediaprint</span> &#123; <span class="comment">/*定义标题和列表默认的打印样式*/</span></span><br><span class="line"><span class="selector-tag">h1</span> &#123;<span class="attribute">page-break-before</span>: always &#125;</span><br><span class="line"><span class="selector-tag">h1</span>, <span class="selector-tag">h2</span>,<span class="selector-tag">h3</span>, <span class="selector-tag">h4</span>, <span class="selector-tag">h5</span>, <span class="selector-tag">h6</span> &#123; <span class="attribute">page-break-after</span>: avoid &#125;</span><br><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">dl</span>&#123; <span class="attribute">page-break-before</span>: avoid &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="浏览器默认样式"><a href="#浏览器默认样式" class="headerlink" title="浏览器默认样式"></a><strong>浏览器默认样式</strong></h2><h3 id="页边距"><a href="#页边距" class="headerlink" title="页边距"></a>页边距</h3><ul><li>IE默认为10px，通过body的margin属性设置 </li><li>FF默认为8px，通过body的padding属性设置 </li></ul><p>要清除页边距一定要清除这两个属性值 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="段间距"><a href="#段间距" class="headerlink" title="段间距"></a>段间距</h3><ul><li>IE默认为19px，通过p的margin-top属性设置 </li><li>FF默认为1.12em，通过p的margin-bottom属性设 </li></ul><p>p默认为块状显示，要清除段间距，一般可以设置 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>:<span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin-bottom</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="标题样式"><a href="#标题样式" class="headerlink" title="标题样式"></a>标题样式</h3><p>h1~h6默认加粗显示：font-weight:bold;。<br>默认大小请参上表 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span>&#123;<span class="attribute">font-size</span>:xx-large;&#125;</span><br><span class="line"><span class="selector-tag">h2</span>&#123;<span class="attribute">font-size</span>:x-large;&#125;</span><br><span class="line"><span class="selector-tag">h3</span>&#123;<span class="attribute">font-size</span>:large;&#125;</span><br><span class="line"><span class="selector-tag">h4</span>&#123;<span class="attribute">font-size</span>:medium;&#125;</span><br><span class="line"><span class="selector-tag">h5</span>&#123;<span class="attribute">font-size</span>:small;&#125;</span><br><span class="line"><span class="selector-tag">h6</span>&#123;<span class="attribute">font-size</span>:x-small;&#125;</span><br></pre></td></tr></table></figure><p>各大浏览器默认字体大小为16px，即等于medium，h1~h6元素默认以块状显示字体显示为粗体，<br>要清除标题样式，一般可以设置 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">hx</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>:normal;</span><br><span class="line">  <span class="attribute">font-size</span>:value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="列表样式"><a href="#列表样式" class="headerlink" title="列表样式"></a>列表样式</h3><ul><li>IE默认为40px，通过ul、ol的margin属性设置 </li><li>FF默认为40px，通过ul、ol的padding属性设置 </li></ul><p>dl无缩进，但起内部的说明元素dd默认缩进40px，而名称元素dt没有缩进。<br>要清除列表样式，一般可以设置 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span>, <span class="selector-tag">ol</span>, <span class="selector-tag">dd</span>&#123;</span><br><span class="line">  <span class="attribute">list-style-type</span>:none;<span class="comment">/*清楚列表样式符*/</span></span><br><span class="line">  <span class="attribute">margin-left</span>:<span class="number">0</span>;<span class="comment">/*清楚IE左缩进*/</span></span><br><span class="line">  <span class="attribute">padding-left</span>:<span class="number">0</span>;<span class="comment">/*清楚非IE左缩进*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="元素居中"><a href="#元素居中" class="headerlink" title="元素居中"></a>元素居中</h3><ul><li>IE默认为text-align:center; </li><li>FF默认为margin-left:auto;margin-right:auto; </li></ul><h3 id="超链接样式"><a href="#超链接样式" class="headerlink" title="超链接样式"></a>超链接样式</h3><p>a 样式默认带有下划线，显示颜色为蓝色，被访问过的超链接变紫色，要清除链接样式，一般可以设置<br>代码如下:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>:none;</span><br><span class="line">  <span class="attribute">color</span>:<span class="number">#c</span>olorname;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="鼠标样式"><a href="#鼠标样式" class="headerlink" title="鼠标样式"></a>鼠标样式</h3><ul><li>IE默认为cursor:hand; </li><li>FF默认为cursor:pointer;。该声明在IE中也有效 </li></ul><h3 id="图片链接样式"><a href="#图片链接样式" class="headerlink" title="图片链接样式"></a>图片链接样式</h3><ul><li>IE默认为紫色2px的边框线 </li><li>FF默认为蓝色2px的边框线 </li></ul><p>要清除图片链接样式，一般可以设置</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;html标签默认属性样式及浏览器默认样式&quot;&gt;&lt;a href=&quot;#html标签默认属性样式及浏览器默认样式&quot; class=&quot;headerlink&quot; title=&quot;html标签默认属性样式及浏览器默认样式&quot;&gt;&lt;/a&gt;html标签默认属性样式及浏览器默认样式&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
      <category term="HTML" scheme="http://yoursite.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>CSS viewport</title>
    <link href="http://yoursite.com/2020/03/05/CSS%20viewport/"/>
    <id>http://yoursite.com/2020/03/05/CSS viewport/</id>
    <published>2020-03-05T07:20:55.000Z</published>
    <updated>2020-04-03T03:21:08.780Z</updated>
    
    <content type="html"><![CDATA[<p>#viewport</p><h2 id="页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl-no不生效时，用js怎么控制达到禁止缩放的效果？"><a href="#页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl-no不生效时，用js怎么控制达到禁止缩放的效果？" class="headerlink" title="页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl=no不生效时，用js怎么控制达到禁止缩放的效果？"></a>页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl=no不生效时，用js怎么控制达到禁止缩放的效果？</h2><h3 id="viewport-meta的背景"><a href="#viewport-meta的背景" class="headerlink" title="viewport meta的背景"></a>viewport meta的背景</h3><p>浏览器的 <a href="https://developer.mozilla.org/en-US/docs/Glossary/viewport" target="_blank" rel="noopener">viewport</a> 是可以看到Web内容的窗口区域，通常与渲染出的页面的大小不同，这种情况下，浏览器会提供滚动条以滚动访问所有内容。</p><p>窄屏幕设备（如移动设备）在一个虚拟窗口或视口中渲染页面，这个窗口或视口通常比屏幕宽；然后缩小渲染的结果，以便在一屏内显示所有内容。然后用户可以移动、缩放以查看页面的不同区域。例如，如果移动屏幕的宽度为640px，则可能会用980px的虚拟视口渲染页面，然后缩小页面以适应640px的窗口大小。</p><p>这样做是因为许多页面没有做移动端优化，在小窗口渲染时会乱掉（或看起来乱）。所以，这种虚拟视口是一种让未做移动端优化的网站在窄屏设备上看起来更好的办法。</p><p>但是，对于用媒体查询针对窄屏幕做了优化的页面，这种机制不大好 - 比如如果虚拟视口宽 980px，那么在 640px 或 480px 或更小宽度要起作用的媒体查询就不会触发了，浪费了这些响应式设计。</p><p>为了缓解这个问题，Apple 在 Safari iOS 中引入了“viewport meta 标签”，<strong>让Web开发人员控制视口的大小和比例。</strong>很多其他移动浏览器现在也支持此标签，但它不属于 Web 标准。</p><h3 id="viewport-meta-标签的概念"><a href="#viewport-meta-标签的概念" class="headerlink" title="viewport meta 标签的概念"></a>viewport meta 标签的概念</h3><p>移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图列出了一些设备上浏览器的默认viewport的宽度。</p><h3 id="css中的1px并不等于设备的1px"><a href="#css中的1px并不等于设备的1px" class="headerlink" title="css中的1px并不等于设备的1px"></a><strong>css中的1px并不等于设备的1px</strong></h3><p> 在css中我们一般使用px作为单位，在桌面浏览器中css的1个像素往往都是对应着电脑屏幕的1个物理像素，但在移动设备上，在早先的移动设备中，屏幕像素密度都比较低，如iphone3，它的分辨率为320x480，在iphone3上，一个css像素确实是等于一个屏幕物理像素的。后来随着技术的发展，移动设备的屏幕像素密度越来越高，从iphone4开始，苹果公司便推出了所谓的Retina屏，分辨率提高了一倍，变成640x960，但屏幕尺寸却没变化，这就意味着同样大小的屏幕上，像素却多了一倍，这时，一个css像素是等于两个物理像素的。其他品牌的移动设备也是这个道理。例如安卓设备根据屏幕像素密度可分为ldpi、mdpi、hdpi、xhdpi等不同的等级，分辨率也是五花八门，安卓设备上的一个css像素相当于多少个屏幕物理像素，也因设备的不同而不同，没有一个定论。</p><p> 还有一个因素也会引起css中px的变化，那就是用户缩放。例如，当用户把页面放大一倍，那么css中1px所代表的物理像素也会增加一倍；反之把页面缩小一倍，css中1px所代表的物理像素也会减少一倍。</p><p>window对象有一个devicePixelRatio属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 devicePixelRatio = 物理像素 / 独立像素。</p><p>例如，在Retina屏的iphone上，devicePixelRatio的值为2，也就是说1个css像素相当于2个物理像素。</p><h3 id="三个viewport"><a href="#三个viewport" class="headerlink" title="三个viewport"></a>三个viewport</h3><p>这些浏览器就决定默认情况下把viewport设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的viewport叫做 <strong>*layout viewport</strong>。<strong><em>*layout viewport</em></strong> 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个viewport来代表 浏览器可视区域的大小，ppk把这个viewport叫做 <strong>visual viewport</strong>。visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5puat7yj30dt0ai0t9.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5qah7plj30dw0ahjrw.jpg" alt="img"></p><p> 完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适；不只是文字，其他元素像图片什么的也是这个道理ppk把这个viewport叫做 <strong><em>ideal viewport</em></strong>，也就是第三个viewport——移动设备的理想viewport。</p><p> ideal viewport并没有一个固定的尺寸，不同的设备拥有有不同的ideal viewport。所有的iphone的ideal viewport宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在iphone中，css中的320px就代表iphone屏幕的宽度。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5rjwmr1j307i05wq2s.jpg" alt="img"><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6j5s6pthkj307p05w3yc.jpg" alt="img"></p><p>但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到<a href="http://viewportsizes.com/" target="_blank" rel="noopener">http://viewportsizes.com</a>去查看一下，里面收集了众多设备的理想宽度。</p><h3 id="利用meta标签对viewport进行控制"><a href="#利用meta标签对viewport进行控制" class="headerlink" title="利用meta标签对viewport进行控制"></a><strong>利用meta标签对viewport进行控制</strong></h3><p> 移动设备默认的viewport是layout viewport，也就是那个比屏幕要宽的viewport，但在进行移动设备网站的开发时，我们需要的是ideal viewport。</p><p>我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的head标签中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户手动缩放。</p><p>meta viewport 标签首先是由苹果公司在其safari浏览器中引入的，目的就是解决移动设备的viewport问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对meta viewport的支持，事实也证明这个东西还是非常有用的。</p><h4 id="meta-viewport-有6个属性-暂且把content中的那些东西称为一个个属性和值-，如下："><a href="#meta-viewport-有6个属性-暂且把content中的那些东西称为一个个属性和值-，如下：" class="headerlink" title="meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下："></a>meta viewport 有6个属性(暂且把content中的那些东西称为一个个属性和值)，如下：</h4><table><thead><tr><th>属性</th><th>作用</th></tr></thead><tbody><tr><td>width</td><td>设置<strong><em>layout viewport</em></strong>  的宽度，为一个正整数，或字符串”device-width”</td></tr><tr><td>initial-scale</td><td>设置页面的初始缩放值，为一个数字，可以带小数（缩放是相对于 ideal viewport来进行缩放的）</td></tr><tr><td>minimum-scale</td><td>允许用户的最小缩放值，为一个数字，可以带小数</td></tr><tr><td>maximum-scale</td><td>允许用户的最大缩放值，为一个数字，可以带小数</td></tr><tr><td>height</td><td>设置<strong><em>layout viewport</em></strong>  的高度，这个属性对我们并不重要，很少使用</td></tr><tr><td>user-scalable</td><td>是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许</td></tr></tbody></table><ul><li><p><code>width</code><strong>设为<code>device-width</code> 特殊值，代表缩放为 100% 时以 CSS 像素计量的屏幕宽度</strong>。（相应的也有<code>height</code>及<code>device-height</code>属性，可能对包含基于视口高度调整大小及位置的元素的页面有用。）</p><p>注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。</p></li><li><p>对于设置了初始或最大缩放的页面，width属性实际上变成了<strong>最小</strong>视口宽度。比如，如果你的布局需要至少500像素的宽度，那么你可以使用以下标记。当屏幕宽度大于500像素时，浏览器会扩展视口（而不是放大页面）来适应屏幕：</p></li><li><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=500, initial-scale=1"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当width=400，ideal viewport的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是ideal viewport的宽度。</p></li><li><p>在安卓中还支持  target-densitydpi  这个私有属性，它表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素</p><p>target-densitydpi：值可以为一个数值或 high-dpi 、 medium-dpi、 low-dpi、 device-dpi 这几个字符串中的一个</p><p>特别说明的是，当 target-densitydpi=device-dpi 时， css中的1px会等于物理像素中的1px。</p><p>因为这个属性只有安卓支持，并且安卓已经决定要废弃<del>target-densitydpi</del>  这个属性了，所以这个属性我们要避免进行使用  </p></li></ul><h3 id="关于缩放"><a href="#关于缩放" class="headerlink" title="关于缩放"></a>关于缩放</h3><p>缩放是相对于ideal viewport来缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，ideal viewport的宽度是320px，如果我们设置 initial-scale=2 ，此时viewport的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">visual viewport宽度 = ideal viewport宽度  / 当前缩放值</span><br><span class="line"></span><br><span class="line">当前缩放值 = ideal viewport宽度  / visual viewport宽度</span><br></pre></td></tr></table></figure><p>根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给layout viewpor设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算initial-scale这个值，以保证当前layout viewport的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。</p><p>当前缩放值 = ideal viewport宽度  / visual viewport宽度，我们可以得出：</p><p>​      当前缩放值 = 320 / 980</p><p>也就是当前的initial-scale默认值应该是 0.33这样子。当你指定了initial-scale的值后，这个默认值就不起作用了。</p><p><strong>在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。</strong></p><h3 id="js事件监听阻止用户缩放"><a href="#js事件监听阻止用户缩放" class="headerlink" title="js事件监听阻止用户缩放"></a>js事件监听阻止用户缩放</h3><p>移动端web缩放有两种：</p><p><strong>1.双击缩放；</strong></p><p><strong>2.双指手势缩放。</strong></p><ul><li>禁止双击缩放</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.οnlοad=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;         </span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(event.touches.length&gt;<span class="number">1</span>)&#123;</span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)  </span><br><span class="line">  <span class="keyword">var</span> lastTouchEnd=<span class="number">0</span>;  </span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;  </span><br><span class="line">    <span class="keyword">var</span> now=(<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();  </span><br><span class="line">    <span class="keyword">if</span>(now-lastTouchEnd&lt;=<span class="number">300</span>)&#123;  </span><br><span class="line">      event.preventDefault();  </span><br><span class="line">    &#125;  </span><br><span class="line">    lastTouchEnd=now;  </span><br><span class="line">  &#125;,<span class="literal">false</span>)  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>完美方案</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchstart'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">if</span>(event.touches.length&gt;<span class="number">1</span>)&#123;</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="actionscript">    <span class="keyword">var</span> lastTouchEnd=<span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'touchend'</span>,<span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> now=(<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime();</span></span><br><span class="line"><span class="vbscript">      <span class="keyword">if</span>(<span class="built_in">now</span>-lastTouchEnd&lt;=<span class="number">300</span>)&#123;</span></span><br><span class="line">        event.preventDefault();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="vbscript">      lastTouchEnd=<span class="built_in">now</span>;</span></span><br><span class="line"><span class="actionscript">    &#125;,<span class="literal">false</span>);</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//依然存在bug，双指同时放下放大禁止了，但一指先放下，另一指在放下滑动放大依然不管用</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.addEventListener(<span class="string">'gesturestart'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span></span><br><span class="line">      event.preventDefault();</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#viewport&lt;/p&gt;
&lt;h2 id=&quot;页面适配的标签viewport这个标签是什么作用？meta几个属性都是什么含义？user-scanl-no不生效时，用js怎么控制达到禁止缩放的效果？&quot;&gt;&lt;a href=&quot;#页面适配的标签viewport这个标签是什么作用？met
      
    
    </summary>
    
      <category term="CSS" scheme="http://yoursite.com/categories/CSS/"/>
    
    
      <category term="CSS" scheme="http://yoursite.com/tags/CSS/"/>
    
      <category term="viewport" scheme="http://yoursite.com/tags/viewport/"/>
    
  </entry>
  
  <entry>
    <title>Vue组件间的通信</title>
    <link href="http://yoursite.com/2020/02/26/Vue%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/"/>
    <id>http://yoursite.com/2020/02/26/Vue组件间的通信/</id>
    <published>2020-02-26T03:18:32.000Z</published>
    <updated>2020-04-03T03:50:33.254Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vue组件间的通信"><a href="#vue组件间的通信" class="headerlink" title="vue组件间的通信"></a>vue组件间的通信</h1><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tg3703qaj309t07ujr9.jpg" alt="img"></p><p>如上图所示，A 和 B、B 和 C、B 和 D 都是父子关系，C 和 D 是兄弟关系，A 和 C 是隔代关系（可能隔多代）。</p><h2 id="props-emit"><a href="#props-emit" class="headerlink" title="props/$emit"></a><code>props</code>/<code>$emit</code></h2><p>父组件A通过props的方式向子组件B传递，B to A 通过在 B 组件中 $emit, A 组件中 v-on 的方式实现。</p><h3 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1.父组件向子组件传值"></a>1.父组件向子组件传值</h3><p>接下来我们通过一个例子，说明父组件如何向子组件传递值：在子组件Users.vue中如何获取父组件App.vue中的数据 <code>users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//App.vue父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;users v-bind:users=&quot;users&quot;&gt;&lt;/users&gt;//前者自定义名称便于子组件调用，后者要传递数据名</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Users from &quot;./components/Users&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      users:[&quot;Henry&quot;,&quot;Bucky&quot;,&quot;Emily&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    &quot;users&quot;:Users</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//users子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;hello&quot;&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">      &lt;li v-for=&quot;user in users&quot;&gt;&#123;&#123;user&#125;&#125;&lt;/li&gt;//遍历传递过来的值，然后呈现到页面</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;HelloWorld&apos;,</span><br><span class="line">  props:&#123;</span><br><span class="line">    users:&#123;           //这个就是父组件中子标签自定义名字</span><br><span class="line">      type:Array,</span><br><span class="line">      required:true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>总结：父组件通过props向下传递数据给子组件。注：组件中的数据共有三种形式：data、props、computed</strong></p><h3 id="2-子组件向父组件传值（通过事件形式）"><a href="#2-子组件向父组件传值（通过事件形式）" class="headerlink" title="2.子组件向父组件传值（通过事件形式）"></a>2.子组件向父组件传值（通过事件形式）</h3><p>接下来我们通过一个例子，说明子组件如何向父组件传递值：当我们点击“Vue.js Demo”后，子组件向父组件传递值，文字由原来的“传递的是一个值”变成“子向父组件传值”，实现子组件向父组件值的传递。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tg6j35buj30yg046q33.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 子组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;header&gt;</span><br><span class="line">    &lt;h1 @click=&quot;changeTitle&quot;&gt;&#123;&#123;title&#125;&#125;&lt;/h1&gt;//绑定一个点击事件</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;app-header&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title:&quot;Vue.js Demo&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    changeTitle() &#123;</span><br><span class="line">      this.$emit(&quot;titleChanged&quot;,&quot;子向父组件传值&quot;);//自定义事件  传递值“子向父组件传值”</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;app-header v-on:titleChanged=&quot;updateTitle&quot; &gt;&lt;/app-header&gt;//与子组件titleChanged自定义事件保持一致</span><br><span class="line">   // updateTitle($event)接受传递过来的文字</span><br><span class="line">    &lt;h2&gt;&#123;&#123;title&#125;&#125;&lt;/h2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Header from &quot;./components/Header&quot;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;App&apos;,</span><br><span class="line">  data()&#123;</span><br><span class="line">    return&#123;</span><br><span class="line">      title:&quot;传递的是一个值&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods:&#123;</span><br><span class="line">    updateTitle(e)&#123;   //声明这个函数</span><br><span class="line">      this.title = e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">   &quot;app-header&quot;:Header,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>总结：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</strong></p><h2 id="emit-on"><a href="#emit-on" class="headerlink" title="$emit/$on"></a><code>$emit</code>/<code>$on</code></h2><p><strong>这种方法通过一个空的Vue实例作为中央事件总线（事件中心），用它来触发事件和监听事件,巧妙而轻量地实现了任何组件间的通信，包括父子、兄弟、跨级</strong>。当我们的项目比较大时，可以选择更好的状态管理解决方案vuex。</p><h3 id="1-具体实现方式："><a href="#1-具体实现方式：" class="headerlink" title="1.具体实现方式："></a>1.具体实现方式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Event=new Vue();</span><br><span class="line">Event.$emit(事件名,数据);</span><br><span class="line">Event.$on(事件名,data =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-举个例子"><a href="#2-举个例子" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><p>假设兄弟组件有三个，分别是A、B、C组件，C组件如何获取A或者B组件的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=&quot;itany&quot;&gt;</span><br><span class="line">&lt;my-a&gt;&lt;/my-a&gt;</span><br><span class="line">&lt;my-b&gt;&lt;/my-b&gt;</span><br><span class="line">&lt;my-c&gt;&lt;/my-c&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">&lt;template id=&quot;a&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;A组件：&#123;&#123;name&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;将数据发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=&quot;b&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;B组件：&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">    &lt;button @click=&quot;send&quot;&gt;将数组发送给C组件&lt;/button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template id=&quot;c&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h3&gt;C组件：&#123;&#123;name&#125;&#125;，&#123;&#123;age&#125;&#125;&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var Event = new Vue();//定义一个空的Vue实例</span><br><span class="line">var A = &#123;</span><br><span class="line">template: &apos;#a&apos;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: &apos;tom&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  send() &#123;</span><br><span class="line">    Event.$emit(&apos;data-a&apos;, this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var B = &#123;</span><br><span class="line">template: &apos;#b&apos;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    age: 20</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  send() &#123;</span><br><span class="line">    Event.$emit(&apos;data-b&apos;, this.age);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var C = &#123;</span><br><span class="line">template: &apos;#c&apos;,</span><br><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    name: &apos;&apos;,</span><br><span class="line">    age: &quot;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;//在模板编译完成后执行</span><br><span class="line"> Event.$on(&apos;data-a&apos;,name =&gt; &#123;</span><br><span class="line">     this.name = name;//箭头函数内部不会产生新的this，这边如果不用=&gt;,this指代Event</span><br><span class="line"> &#125;)</span><br><span class="line"> Event.$on(&apos;data-b&apos;,age =&gt; &#123;</span><br><span class="line">     this.age = age;</span><br><span class="line"> &#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">el: &apos;#itany&apos;,</span><br><span class="line">components: &#123;</span><br><span class="line">  &apos;my-a&apos;: A,</span><br><span class="line">  &apos;my-b&apos;: B,</span><br><span class="line">  &apos;my-c&apos;: C</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/e5ab7d4be1d7178cfa8f1da5f208ec786f277916/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d363637373530316461393030366564323f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/e5ab7d4be1d7178cfa8f1da5f208ec786f277916/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d363637373530316461393030366564323f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970" alt="image"></a><br><code>$on</code> 监听了自定义事件 data-a和data-b，因为有时不确定何时会触发事件，一般会在 mounted 或 created 钩子中来监听。</p><h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><p><a href="https://camo.githubusercontent.com/1cb690c2b97cfff1434956e5d66bab39673d84dc/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d653632626134343961306332653761633f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1cb690c2b97cfff1434956e5d66bab39673d84dc/687474703a2f2f75706c6f61642d696d616765732e6a69616e7368752e696f2f75706c6f61645f696d616765732f333137343730312d653632626134343961306332653761633f696d6167654d6f6772322f6175746f2d6f7269656e742f7374726970253743696d61676556696577322f322f772f31323430" alt="image"></a></p><h3 id="1-简要介绍Vuex原理"><a href="#1-简要介绍Vuex原理" class="headerlink" title="1.简要介绍Vuex原理"></a>1.简要介绍Vuex原理</h3><p>Vuex实现了一个单向数据流，在全局拥有一个State存放数据，当组件要更改State中的数据时，必须通过Mutation进行，Mutation同时提供了订阅者模式供外部插件调用获取State数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走Action，但Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。</p><h3 id="2-简要介绍各模块在流程中的功能："><a href="#2-简要介绍各模块在流程中的功能：" class="headerlink" title="2.简要介绍各模块在流程中的功能："></a>2.简要介绍各模块在流程中的功能：</h3><ul><li>Vue Components：Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li><li>dispatch：操作行为触发方法，是唯一能执行action的方法。</li><li>actions：<strong>操作行为处理模块,由组件中的$store.dispatch(‘action 名称’, data1)来触发。然后由commit()来触发mutation的调用 , 间接更新 state</strong>。负责处理Vue Components接收到的所有交互行为。包含同步/异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li><li>commit：状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li><li>mutations：<strong>状态改变操作方法，由actions中的commit(‘mutation 名称’)来触发</strong>。是Vuex修改state的唯一推荐方法。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li><li>state：页面状态管理容器对象。集中存储Vue components中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li><li>getters：state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li></ul><h3 id="3-Vuex与localStorage"><a href="#3-Vuex与localStorage" class="headerlink" title="3.Vuex与localStorage"></a>3.Vuex与localStorage</h3><p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，<strong>具体做法应该在vuex里数据改变的时候把数据拷贝一份保存到localStorage里面，刷新之后，如果localStorage里有保存的数据，取出来再替换store里的state。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> defaultCity = <span class="string">"上海"</span></span><br><span class="line"><span class="keyword">try</span> &#123;   <span class="comment">// 用户关闭了本地存储功能，此时在外层加个try...catch</span></span><br><span class="line">  <span class="keyword">if</span> (!defaultCity)&#123;</span><br><span class="line">    defaultCity = <span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">'defaultCity'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    city: defaultCity</span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    changeCity(state, city) &#123;</span><br><span class="line">      state.city = city</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.localStorage.setItem(<span class="string">'defaultCity'</span>, <span class="built_in">JSON</span>.stringify(state.city));</span><br><span class="line">      <span class="comment">// 数据改变的时候把数据拷贝一份保存到localStorage里面</span></span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里需要注意的是：由于vuex里，我们保存的状态，都是数组，而localStorage只支持字符串，所以需要用JSON转换：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.stringify(state.subscribeList);   <span class="comment">// array -&gt; string</span></span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">window</span>.localStorage.getItem(<span class="string">"subscribeList"</span>));    <span class="comment">// string -&gt; array</span></span><br></pre></td></tr></table></figure><p>##<code>$attrs</code>/<code>$listeners</code></p><p>多级组件嵌套需要传递数据时，通常使用的方法是通过vuex。但如果仅仅是传递数据，而不做中间处理，使用 vuex 处理，未免有点大材小用。为此Vue2.4 版本提供了另一种方法—-<code>$attrs</code>/<code>$listeners</code></p><ul><li><code>$attrs</code>：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 (class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 (class 和 style 除外)，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li><code>$listeners</code>：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</li></ul><p>接下来我们看个跨级通信的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">// index.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h2&gt;浪里行舟&lt;/h2&gt;</span><br><span class="line">    &lt;child-com1</span><br><span class="line">      :foo=&quot;foo&quot;</span><br><span class="line">      :boo=&quot;boo&quot;</span><br><span class="line">      :coo=&quot;coo&quot;</span><br><span class="line">      :doo=&quot;doo&quot;</span><br><span class="line">      title=&quot;前端工匠&quot;</span><br><span class="line">    &gt;&lt;/child-com1&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom1 = () =&gt; import(&quot;./childCom1.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123; childCom1 &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      foo: &quot;Javascript&quot;,</span><br><span class="line">      boo: &quot;Html&quot;,</span><br><span class="line">      coo: &quot;CSS&quot;,</span><br><span class="line">      doo: &quot;Vue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// childCom1.vue</span><br><span class="line">&lt;template class=&quot;border&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;foo: &#123;&#123; foo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom1的$attrs: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com2 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com2&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom2 = () =&gt; import(&quot;./childCom2.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom2</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性</span><br><span class="line">  props: &#123;</span><br><span class="line">    foo: String // foo作为props属性绑定</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;boo&quot;: &quot;Html&quot;, &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// childCom2.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;boo: &#123;&#123; boo &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;childCom2: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">    &lt;child-com3 v-bind=&quot;$attrs&quot;&gt;&lt;/child-com3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">const childCom3 = () =&gt; import(&quot;./childCom3.vue&quot;);</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    childCom3</span><br><span class="line">  &#125;,</span><br><span class="line">  inheritAttrs: false,</span><br><span class="line">  props: &#123;</span><br><span class="line">    boo: String</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    console.log(this.$attrs); // &#123; &quot;coo&quot;: &quot;CSS&quot;, &quot;doo&quot;: &quot;Vue&quot;, &quot;title&quot;: &quot;前端工匠&quot; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">// childCom3.vue</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;border&quot;&gt;</span><br><span class="line">    &lt;p&gt;childCom3: &#123;&#123; $attrs &#125;&#125;&lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    coo: String,</span><br><span class="line">    title: String</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tgffgg8oj30ft06bglo.jpg" alt="img"></p><p>如上图所示<code>$attrs</code>表示没有继承数据的对象，格式为{属性名：属性值}。Vue2.4提供了<code>$attrs</code> , <code>$listeners</code> 来传递数据与事件，跨级组件之间的通讯变得更简单。</p><p>简单来说：<code>$attrs</code>与<code>$listeners</code> 是两个对象，<code>$attrs</code> 里存放的是父组件中绑定的非 Props 属性，<code>$listeners</code>里存放的是父组件中绑定的非原生事件。</p><p>##provide/inject</p><h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h3><p>Vue2.2.0新增API,这对选项需要一起使用，<strong>以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效</strong>。一言而蔽之：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量。<br><strong>provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系</strong>。</p><h3 id="2-举个例子-1"><a href="#2-举个例子-1" class="headerlink" title="2.举个例子"></a>2.举个例子</h3><p>假设有两个组件： A.vue 和 B.vue，B 是 A 的子组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  provide: &#123;</span><br><span class="line">    name: <span class="string">'浪里行舟'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// B.vue</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  inject: [<span class="string">'name'</span>],</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);  <span class="comment">// 浪里行舟</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，在 A.vue 里，我们设置了一个 <strong>provide: name</strong>，值为 浪里行舟，它的作用就是将 <strong>name</strong> 这个变量提供给它的所有子组件。而在 B.vue 中，通过 <code>inject</code> 注入了从 A 组件中提供的 <strong>name</strong> 变量，那么在组件 B 中，就可以直接通过 <strong>this.name</strong> 访问这个变量了，它的值也是 浪里行舟。这就是 provide / inject API 最核心的用法。</p><p>需要注意的是：<strong>provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的</strong>—-vue官方文档<br>所以，上面 A.vue 的 name 如果改变了，B.vue 的 this.name 是不会改变的，仍然是 浪里行舟。</p><h3 id="3-provide与inject-怎么实现数据响应式"><a href="#3-provide与inject-怎么实现数据响应式" class="headerlink" title="3.provide与inject 怎么实现数据响应式"></a>3.provide与inject 怎么实现数据响应式</h3><p>一般来说，有两种办法：</p><ul><li>provide祖先组件的实例，然后在子孙组件中注入依赖，这样就可以在子孙组件中直接修改祖先组件的实例的属性，不过这种方法有个缺点就是这个实例上挂载很多没有必要的东西比如props，methods</li><li>使用2.6最新API Vue.observable 优化响应式 provide(推荐)</li></ul><p>我们来看个例子：孙组件D、E和F获取A组件传递过来的color值，并能实现数据响应式变化，即A组件的color变化后，组件D、E、F会跟着变（核心代码如下：）</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g6tgjlms01j30eo09owes.jpg" alt="img"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">// A 组件 </span><br><span class="line">&lt;div&gt;</span><br><span class="line">      &lt;h1&gt;A 组件&lt;/h1&gt;</span><br><span class="line">      &lt;button @click=&quot;() =&gt; changeColor()&quot;&gt;改变color&lt;/button&gt;</span><br><span class="line">      &lt;ChildrenB /&gt;</span><br><span class="line">      &lt;ChildrenC /&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line">......</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      color: &quot;blue&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  // provide() &#123;</span><br><span class="line">  //   return &#123;</span><br><span class="line">  //     theme: &#123;</span><br><span class="line">  //       color: this.color //这种方式绑定的数据并不是可响应的</span><br><span class="line">  //     &#125; // 即A组件的color变化后，组件D、E、F不会跟着变</span><br><span class="line">  //   &#125;;</span><br><span class="line">  // &#125;,</span><br><span class="line">  provide() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      theme: this//方法一：提供祖先组件的实例</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    changeColor(color) &#123;</span><br><span class="line">      if (color) &#123;</span><br><span class="line">        this.color = color;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.color = this.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // 方法二:使用2.6最新API Vue.observable 优化响应式 provide</span><br><span class="line">  // provide() &#123;</span><br><span class="line">  //   this.theme = Vue.observable(&#123;</span><br><span class="line">  //     color: &quot;blue&quot;</span><br><span class="line">  //   &#125;);</span><br><span class="line">  //   return &#123;</span><br><span class="line">  //     theme: this.theme</span><br><span class="line">  //   &#125;;</span><br><span class="line">  // &#125;,</span><br><span class="line">  // methods: &#123;</span><br><span class="line">  //   changeColor(color) &#123;</span><br><span class="line">  //     if (color) &#123;</span><br><span class="line">  //       this.theme.color = color;</span><br><span class="line">  //     &#125; else &#123;</span><br><span class="line">  //       this.theme.color = this.theme.color === &quot;blue&quot; ? &quot;red&quot; : &quot;blue&quot;;</span><br><span class="line">  //     &#125;</span><br><span class="line">  //   &#125;</span><br><span class="line">  // &#125;</span><br><span class="line">// F 组件 </span><br><span class="line">&lt;template functional&gt;</span><br><span class="line">  &lt;div class=&quot;border2&quot;&gt;</span><br><span class="line">    &lt;h3 :style=&quot;&#123; color: injections.theme.color &#125;&quot;&gt;F 组件&lt;/h3&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  inject: &#123;</span><br><span class="line">    theme: &#123;</span><br><span class="line">      //函数式组件取值不一样</span><br><span class="line">      default: () =&gt; (&#123;&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>虽说provide 和 inject 主要为高阶插件/组件库提供用例，但如果你能在业务中熟练运用，可以达到事半功倍的效果！</p><h2 id="parent-children与-ref"><a href="#parent-children与-ref" class="headerlink" title="$parent / $children与 ref"></a><code>$parent</code> / <code>$children</code>与 <code>ref</code></h2><ul><li><code>ref</code>：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li><code>$parent</code> / <code>$children</code>：访问父 / 子实例</li></ul><p>需要注意的是：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。我们先来看个用 <code>ref</code>来访问组件的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// component-a 子组件</span><br><span class="line">export default &#123;</span><br><span class="line">  data () &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      title: &apos;Vue.js&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sayHello () &#123;</span><br><span class="line">      window.alert(&apos;Hello&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;component-a ref=&quot;comA&quot;&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      const comA = this.$refs.comA;</span><br><span class="line">      console.log(comA.title);  // Vue.js</span><br><span class="line">      comA.sayHello();  // 弹窗</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>不过，<strong>这两种方法的弊端是，无法在跨级或兄弟间通信</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// parent.vue</span><br><span class="line">&lt;component-a&gt;&lt;/component-a&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br><span class="line">&lt;component-b&gt;&lt;/component-b&gt;</span><br></pre></td></tr></table></figure><p>我们想在 component-a 中，访问到引用它的页面中（这里就是 parent.vue）的两个 component-b 组件，那这种情况下，就得配置额外的插件或工具了，比如 Vuex 和 Bus 的解决方案。</p><p>##总结</p><p>常见使用场景可以分为三类：</p><ul><li>父子通信：<br>父向子传递数据是通过 props，子向父是通过 events（<code>$emit</code>）；通过父链 / 子链也可以通信（<code>$parent</code> / <code>$children</code>）；ref 也可以访问组件实例；provide / inject API；<code>$attrs/$listeners</code></li><li>兄弟通信：<br>Bus；Vuex</li><li>跨级通信：<br>Bus；Vuex；provide / inject API、<code>$attrs/$listeners</code></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vue组件间的通信&quot;&gt;&lt;a href=&quot;#vue组件间的通信&quot; class=&quot;headerlink&quot; title=&quot;vue组件间的通信&quot;&gt;&lt;/a&gt;vue组件间的通信&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/00
      
    
    </summary>
    
      <category term="VUE" scheme="http://yoursite.com/categories/VUE/"/>
    
    
      <category term="VUE" scheme="http://yoursite.com/tags/VUE/"/>
    
  </entry>
  
</feed>
