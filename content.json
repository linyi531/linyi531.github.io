{"meta":{"title":"01不是包子脸","subtitle":"小01的程序猿成长之路","description":null,"author":"Linyi Li","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-06-20T16:00:00.000Z","updated":"2019-11-10T14:37:39.042Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于 01我是『01』。一个不承认自己是包子脸的小仙女～一个努力成长的技术小菜鸟。🙈喜欢千玺，喜欢刷剧看综艺，喜欢夏天穿小裙子、开着空调窝在被子里吃西瓜。🍉喜欢旅行，喜欢猫猫狗狗，喜欢拍照记录生活，喜欢身边有一群志同道合的好朋友。👯‍♀️喜欢李煊。❤️ 关于博客这个博客，想记录一路走来的点点滴滴。有关于大神的见解搬运，有自己总结的小小心得。希望看博客的你，也能找到自己想要的问题答案。🗝 关于现在或未来希望我和你，我们，都能有自己的一技之长，能在社会上的某个方面成为独当一面的佼佼者。🎉2019 的小心愿：见千玺、拥抱爱的人。😘 关于社交 : 01 不是包子脸啊 : linyi531 : linyi531"},{"title":"Categories","date":"2018-06-20T16:00:00.000Z","updated":"2019-09-21T10:49:32.277Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-20T16:00:00.000Z","updated":"2019-09-21T10:49:32.277Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Vue计算属性(computed)和侦听属性(watch)","slug":"Vue计算属性(computed)和侦听属性(watch)","date":"2019-12-29T01:52:21.000Z","updated":"2019-12-29T07:18:55.892Z","comments":true,"path":"2019/12/29/Vue计算属性(computed)和侦听属性(watch)/","link":"","permalink":"http://yoursite.com/2019/12/29/Vue计算属性(computed)和侦听属性(watch)/","excerpt":"","text":"Vue计算属性(computed)和侦听属性(watch)计算属性介绍计算属性是自动监听依赖值的变化，从而动态返回内容，监听是一个过程，在监听的值变化时，可以触发一个回调，并做一些事情。它有以下几个特点： 数据可以进行逻辑处理，减少模板中计算逻辑。 对计算属性中的数据进行监视 依赖固定的数据类型（响应式数据） 计算属性由两部分组成：get和set，分别用来获取计算属性和设置计算属性。默认只有get，如果需要set，要自己添加。另外set设置属性，并不是直接修改计算属性，而是修改它的依赖。 123456789101112131415computed: &#123; fullName: &#123; // getter get: function () &#123; return this.firstName + ' ' + this.lastName &#125;, // setter set: function (newValue) &#123; //this.fullName = newValue 这种写法会报错 var names = newValue.split(' ') this.firstName = names[0]//对它的依赖进行赋值 this.lastName = names[names.length - 1] &#125; &#125;&#125; 计算属性 vs 普通属性可以像绑定普通属性一样在模板中绑定计算属性，在定义上有区别：计算属性的属性值必须是一个函数。 1234567891011data:&#123; //普通属性 msg:'浪里行舟',&#125;,computed:&#123; //计算属性 msg2:function()&#123; //该函数必须有返回值，用来获取属性，称为get函数 return '浪里行舟'; &#125;, reverseMsg:function()&#123; //可以包含逻辑处理操作，同时reverseMsg依赖于msg,一旦msg发生变化，reverseMsg也会跟着变化 return this.msg.split(' ').reverse().join(' '); &#125; 计算属性 vs 方法两者最主要的区别：computed 是可以缓存的，methods 不能缓存； 只要相关依赖没有改变，多次访问计算属性得到的值是之前缓存的计算结果，不会多次执行。网上有种说法就是方法可以传参，而计算属性不能，其实并不准确，计算属性可以通过闭包来实现传参： 123456789:data=\"closure(item, itemName, blablaParams)\"computed: &#123; closure () &#123; return function (a, b, c) &#123; /** do something */ return data &#125; &#125;&#125; 侦听属性Vue 提供了一种更通用的方式来观察和响应 Vue 实例上的数据变动：侦听属性watch。watch中可以执行任何逻辑，如函数节流，Ajax异步获取数据，甚至操作 DOM（不建议）。 常规用法12345678910111213141516171819202122232425262728293031323334353637383940&lt;template&gt; &lt;div class=&quot;attr&quot;&gt; &lt;h1&gt;watch属性&lt;/h1&gt; &lt;h2&gt;&#123;&#123; $data &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;() =&gt; (a += 1)&quot;&gt;修改a的值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; a: 1, b: &#123; c: 2, d: 3 &#125;, e: &#123; f: &#123; g: 4 &#125; &#125;, h: [] &#125;; &#125;, watch: &#123; a: function(val, oldVal) &#123; this.b.c += 1; &#125;, &quot;b.c&quot;: function(val, oldVal) &#123; this.b.d += 1; &#125;, &quot;b.d&quot;: function(val, oldVal) &#123; this.e.f.g += 1; &#125;, e: &#123; handler: function(val, oldVal) &#123; this.h.push(&quot;浪里行舟&quot;); &#125;, deep: true //用于监听e对象内部值的变化 &#125; &#125;&#125;;&lt;/script&gt; 使用 watch 的深度遍历和立即调用功能使用 watch 来监听数据变化的时候除了常用到 handler 回调，其实其还有两个参数，便是： deep 设置为 true 用于监听对象内部值的变化 immediate 设置为 true 将立即以表达式的当前值触发回调 1234567891011121314151617181920212223&lt;template&gt; &lt;button @click=&quot;obj.a = 2&quot;&gt;修改&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; obj: &#123; a: 1, &#125; &#125; &#125;, watch: &#123; obj: &#123; handler: function(newVal, oldVal) &#123; console.log(newVal); &#125;, deep: true, immediate: true &#125; &#125;&#125;&lt;/script&gt; 以上代码我们修改了 obj 对象中 a 属性的值，我们可以触发其 watch 中的 handler 回调输出新的对象，而如果不加 deep: true，我们只能监听 obj 的改变，并不会触发回调。同时我们也添加了 immediate: true 配置，其会立即以 obj 的当前值触发回调。 computed和watch两者之间对比 从上面流程图中，我们可以看出它们之间的区别： watch：监测的是属性值， 只要属性值发生变化，其都会触发执行回调函数来执行一系列操作。 computed：监测的是依赖值，依赖值不变的情况下其会直接读取缓存进行复用，变化的情况下才会重新计算。 除此之外，有点很重要的区别是：计算属性不能执行异步任务，计算属性必须同步执行。也就是说计算属性不能向服务器请求或者执行异步任务。如果遇到异步任务，就交给侦听属性。watch也可以检测computed属性。 计算属性适合用在模板渲染中，某个值是依赖了其它的响应式对象甚至是计算属性计算而来；而侦听属性适用于观测某个值的变化去完成一段复杂的业务逻辑。 computed能做的，watch都能做，反之则不行 能用computed的尽量用computed","categories":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/categories/VUE/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"深入浅出Node.js学习笔记（二）","slug":"深入浅出Node.js学习笔记（二）","date":"2019-12-19T09:25:43.000Z","updated":"2019-12-29T07:15:07.580Z","comments":true,"path":"2019/12/19/深入浅出Node.js学习笔记（二）/","link":"","permalink":"http://yoursite.com/2019/12/19/深入浅出Node.js学习笔记（二）/","excerpt":"","text":"深入浅出Node.js学习笔记（二）第四章 异步编程函数式编程高阶函数高阶函数是可以把函数作为参数，或是将函数作为返回值的函数 12345function foo(x) &#123; return function () &#123; return x; &#125;;&#125; 后续传递风格(Continuation Passing Style)的结果接收 方式，而非单一的返回值形式。后续传递风格的程序编写将函数的业务重点从返回值转移到了回调函数中。 例子ECMAScript5中提供的一些数组方法(sort()、forEach()、 map()、reduce()、reduceRight()、filter()、every()、some())十分典型 偏函数用法偏函数用法是指创建一个调用另外一个部分——参数或变量已经预置的函数——的函数的用法 1234567var toString = Object.prototype.toString;var isString = function (obj) &#123; return toString.call(obj) == '[object String]';&#125;;var isFunction = function (obj) &#123; return toString.call(obj) == '[object Function]'; &#125;; 我们需要重复去定义一些相似的函数，如果有更多的isXXX()，就会出现更多的冗余代码. 1234567var isType = function (type) &#123; return function (obj) &#123; return toString.call(obj) == '[object ' + type + ']'; &#125;;&#125;;var isString = isType('String');var isFunction = isType('Function'); 这 种通过指定部分参数来产生一个新的定制函数的形式就是偏函数 异步编程的优势与难点优势最大的特性：基于事件驱动的非阻塞I/O模型 非阻塞I/O可以使CPU与I/O并不相互依赖等待，让资源得到更好的利用 并行带来的想象空间更大，延展而开的是分布式和云。并行使得各个单点之间能够更有效地组织起来 难点难点1:异常处理异步I/O的实现主要包含两个阶段:提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常在第一个阶段提交请求后立即返回，因为异常并不一定发生在这个阶段，try/catch的功效在此处不会发挥任何作用。 123var async = function (callback) &#123; process.nextTick(callback);&#125;; 12345try &#123; async(callback); &#125; catch (e) &#123; // TODO&#125; 调用async()方法后，callback被存放起来，直到下一个事件循环(Tick)才会取出来执行。尝试对异步方法进行try/catch操作只能捕获当次事件循环内的异常，对callback执行时抛出的异常将无能为力。 Node在处理异常上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有异常抛出： 123async(function (err, results) &#123; // TODO&#125;); 自行编写的异步方法上，需要去遵循这样一些原则: 原则一:必须执行调用者传入的回调函数; 原则二:正确传递回异常供调用者判断。 难点2:函数嵌套过深难点3:阻塞代码没有sleep()这样的线程沉睡功能 setInterval()和setTimeout()并不能阻塞后续代码的持续执行 难点4:多线程编程对于服务器端而言，如果服务器是多核CPU，单个Node进程实质上是没有充分利用多核CPU的。 Node借鉴了这个模式，child_process是其基础API，cluster模块是更深层次的应用。借助Web Workers的模式，开发人员要更多地去面临跨线程的编程，这对于以往的JavaScript编程经验是较少考虑的。 难点5:异步转同步Node中试图同步式编程，但并不能得到原生支持，需要借助库或者编译等手段来实现 异步编程解决方案事件发布/订阅模式事件监听器模式是一种广泛用于异步编程的模式，是回调函数的事件化，又称发布/订阅模式 123456// 订阅emitter.on(\"event1\", function (message) &#123; console.log(message); &#125;);// 发布emitter.emit('event1', \"I am message!\"); 事件发布/订阅模式可以实现一个事件与多 个回调函数的关联，这些回调函数又称为事件侦听器。通过emit()发布事件后，消息会立即传递给当前事件的所有侦听器执行。侦听器可以很灵活地添加和删除，使得事件和具体处理逻辑之间可以很轻松地关联和解耦。 Node对事件发布/订阅的机制做了一些额外的处理，这大多是基于健壮性而考虑的: 如果对一个事件添加了超过10个侦听器，将会得到一条警告。这一处设计与Node自身单线程运行有关，设计者认为侦听器太多可能导致内存泄漏，所以存在这样一条警告。调用emitter.setMaxListeners(0);可以将这个限制去掉。另一方面，由于事件发布会引起一系列侦听器执行，如果事件相关的侦听器过多，可能存在过多占用CPU的情景。 为了处理异常，EventEmitter对象对error事件进行了特殊对待。如果运行期间的错误触发了error事件，EventEmitter会检查是否有对error事件添加过侦听器。如果添加了，这个错误将会交由该侦听器处理，否则这个错误将会作为异常抛出。如果外部没有捕获这个异常，将会引起线程退出。一个健壮的EventEmitter实例应该对error事件做处理。 1. 继承events模块12345var events = require('events');function Stream() &#123; events.EventEmitter.call(this);&#125;util.inherits(Stream, events.EventEmitter); Node在util模块中封装了继承的方法，所以此处可以很便利地调用。开发者可以通过这样的方式轻松继承EventEmitter类，利用事件机制解决业务问题。在Node提供的核心模块中，有近半数都继承自EventEmitter。 2. 利用事件队列解决雪崩问题雪崩问题，就是在高访问量、大并发量的情况下缓存失效的情景，此时大量的请求同时涌入数据库中，数据库无法同时承受如此大的查询请求，进而往前影响到网站整体的响应速度 123456789101112var proxy = new events.EventEmitter();var status = \"ready\";var select = function (callback) &#123; proxy.once(\"selected\", callback); if (status === \"ready\") &#123; status = \"pending\"; db.select(\"SQL\", function (results) &#123; proxy.emit(\"selected\", results); status = \"ready\"; &#125;); &#125; &#125;; 利用了once()方法，将所有请求的回调都压入事件队列中，利用其执行一次就会将监视器移除的特点，保证每一个回调只会被执行一次。对于相同的SQL语句，保证在同一个查询开始到结束的过程中永远只有一次。 3. 多异步之间的协作方案由于多个异步场景中回调函数的执行并不能保证顺序，且回调函数之间互相没有任何交集，所以需要借助一个第三方函数和第三方变量来处理异步协作的结果。通常，我们把这个用于检测次数的变量叫做哨兵变量 4. EventProxy的原理EventProxy来自于Backbone的事件模块，Backbone的事件模块是Model、View模块的基础功能，在前端有广泛的使用。它在每个非all事件触发时都会触发一次all事件 1234567891011121314151617181920212223// Trigger an event, firing all bound callbacks. Callbacks are passed the // same arguments as `trigger` is, apart from the event name.// Listening for `\"all\"` passes the true event name as the first argument trigger : function(eventName) &#123; var list, calls, ev, callback, args; var both = 2; if (!(calls = this._callbacks)) return this; while (both--) &#123; ev = both ? eventName : 'all'; if (list = calls[ev]) &#123; for (var i = 0, l = list.length; i &lt; l; i++) &#123; if (!(callback = list[i])) &#123; list.splice(i, 1); i--; l--; &#125; else &#123; args = both ? Array.prototype.slice.call(arguments, 1) : arguments; callback[0].apply(callback[1] || this, args); &#125; &#125; &#125; &#125; return this; &#125; EventProxy则是将all当做一个事件流的拦截层，在其中注入一些业务来处理单一事件无法解决的异步处理问题。类似的扩展方法还有all()、tail()、after()、not()和any()等。 5. EventProxy的异常处理1234567891011121314exports.getContent = function (callback) &#123; var ep = new EventProxy(); ep.all('tpl', 'data', function (tpl, data) &#123; // 成功回调 callback(null, &#123; template: tpl, data: data &#125;);&#125;); //绑定错误处理函数 ep.fail(callback); fs.readFile('template.tpl', 'utf-8', ep.done('tpl')); db.get('some sql', ep.done('data')); &#125;; EventProxy提供了fail()和done()这两个实例方法来优化异常处理，使得开发者将精力关注在业务部分，而不是在异常捕获上。 fail()方法的实现1ep.fail(callback); 等价于： 123ep.fail(function (err) &#123; callback(err);&#125;); 又等价于: 123456ep.bind('error', function (err) &#123; // 卸载掉所有处理函数 ep.unbind(); // 异常回调 callback(err); &#125;); done()方法的实现1ep.done('tpl'); 等价于: 1234567function (err, content) &#123; if (err) &#123; // 一旦发生异常，一律交给error事件处理函数处理 return ep.emit('error', err); &#125; ep.emit('tpl', content); &#125; Promise/Deferred模式先执行异步调用，延迟传递处理的方式 1234$.get('/api') .success(onSuccess) .error(onError) .complete(onComplete); 这使得即使不调用success()、error()等方法，Ajax也会执行，这样的调用方式比预先传入回调让人觉得舒适一些。 在原始的API中，一个事件只能处理一个回调，而通过Deferred对象，可以对事件加入任意的业务处理逻辑。 123$.get('/api') .success(onSuccess1) .success(onSuccess2); CommonJS草案目前已经抽象出了Promises/A、 Promises/B、Promises/D这样典型的异步Promise/Deferred模型，这使得异步操作可以以一种优雅的方式出现。 Promises/A Promise操作只会处在3种状态的一种:未完成态、完成态和失败态。 Promise的状态只会出现从未完成态向完成态或失败态转化，不能逆反。完成态和失败态不能互相转化。 Promise的状态一旦转化，将不能被更改。 Promise对象的then()一个Promise对象只要具备then()方法即可 接受完成态、错误态的回调方法。在操作完成或出现错误时，将会调用对应方法。 可选地支持progress事件回调作为第三个方法。 then()方法只接受function对象，其余对象将被忽略。 then()方法继续返回Promise对象，以实现链式调用。 Deferred，延迟对象触发执行这些回调函数的地方，实现这些功能的对象通常被称为Deferred，即延迟对象 Promise和Deferred的差别Deferred主要是用于内部， 用于维护异步模型的状态;Promise则作用于外部，通过then()方法暴露给外部以添加自定义逻辑。 Promise中的多异步协作通过all()方法抽象多个异步操作。只有所有异步操作成功，这个异步操作才算成功， 一旦其中一个异步操作失败，整个异步操作就失败。 Promise的进阶知识 支持序列执行的Promise 1234567891011promise() .then(obj.api1) .then(obj.api2) .then(obj.api3) .then(obj.api4) .then(function (value4) &#123; // Do something with value4 &#125;, function (error) &#123; // Handle any error from step1 through step4 &#125;) .done(); 改造一下代码以实现链式调用 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364var Deferred = function () &#123; this.promise = new Promise();&#125;;// 完成态Deferred.prototype.resolve = function (obj) &#123; var promise = this.promise; var handler; while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.fulfilled) &#123; var ret = handler.fulfilled(obj); if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue; this.promise = ret; return; &#125; &#125; &#125; &#125;;// 失败态Deferred.prototype.reject = function (err) &#123; var promise = this.promise; var handler; while ((handler = promise.queue.shift())) &#123; if (handler &amp;&amp; handler.error) &#123; var ret = handler.error(err); if (ret &amp;&amp; ret.isPromise) &#123; ret.queue = promise.queue; this.promise = ret; return; &#125; &#125; &#125;&#125;; // 生成回调函数 Deferred.prototype.callback = function () &#123; var that = this; return function (err, file) &#123; if (err) &#123; return that.reject(err); &#125; that.resolve(file); &#125;;&#125;;var Promise = function () &#123; // 队列用于存储待执行的回调函数 this.queue = []; this.isPromise = true;&#125;;Promise.prototype.then = function (fulfilledHandler, errorHandler, progressHandler) &#123; var handler = &#123;&#125;; if (typeof fulfilledHandler === 'function') &#123; handler.fulfilled = fulfilledHandler; &#125; if (typeof errorHandler === 'function') &#123; handler.error = errorHandler; &#125; this.queue.push(handler); return this;&#125;; 读取第二个文件是依 赖于第一个文件中的内容的 123456789101112131415var readFile1 = function (file, encoding) &#123; var deferred = new Deferred(); fs.readFile(file, encoding, deferred.callback()); return deferred.promise;&#125;;var readFile2 = function (file, encoding) &#123; var deferred = new Deferred(); fs.readFile(file, encoding, deferred.callback()); return deferred.promise;&#125;;readFile1('file1.txt', 'utf8').then(function (file1) &#123; return readFile2(file1.trim(), 'utf8');&#125;).then(function (file2) &#123; console.log(file2);&#125;); 要让Promise支持链式执行，主要通过以下两个步骤。 (1) 将所有的回调都存到队列中。 (2) Promise完成时，逐个执行回调，一旦检测到返回了新的Promise对象，停止执行，然后将当前Deferred对象的promise引用改变为新的Promise对象，并将队列中余下的回调转交给它。 将API Promise化 可以 批量将方法Promise化 12345678910// smooth(fs.readFile);var smooth = function (method) &#123; return function () &#123; var deferred = new Deferred(); var args = Array.prototype.slice.call(arguments, 0); args.push(deferred.callback()); method.apply(null, args); return deferred.promise; &#125;; &#125;; 于是前面的两次文件读取的构造可以简化为: 1var readFile = smooth(fs.readFile); 于是代码锐减到： 12345var readFile = smooth(fs.readFile); readFile('file1.txt', 'utf8').then(function (file1) &#123; return readFile(file1.trim(), 'utf8'); &#125;).then(function (file2) &#123; // file2 =&gt; I am file2 console.log(file2); &#125;); 流程控制库1. 尾触发与Next需要手工调用才能持续执行后续调用的 中间件机制使得在处理网络请求时，可以像面向切面编程一样进行过滤、验证、日志等功能， 而不与具体业务逻辑产生关联，以致产生耦合 尽管中间件这种尾触发模式并不要求每个中间方法都是异步的，但是如果每 个步骤都采用异步来完成，实际上只是串行化的处理，没办法通过并行的异步调用来提升业务的 处理效率。流式处理可以将一些串行的逻辑扁平化，但是并行逻辑处理还是需要搭配事件或者 Promise完成的，这样业务在纵向和横向都能够各自清晰。 在Connect中，尾触发十分适合处理网络请求的场景。将复杂的处理逻辑拆解为简洁、单一 的处理单元，逐层次地处理请求对象和响应对象。 2. async异步的串行执行12345678910async.series([ function (callback) &#123; fs.readFile('file1.txt', 'utf-8', callback); &#125;, function (callback) &#123; fs.readFile('file2.txt', 'utf-8', callback); &#125;], function (err, results) &#123; // results =&gt; [file1.txt, file2.txt] &#125;); 这段代码等价于: 1234567891011fs.readFile('file1.txt', 'utf-8', function (err, content) &#123; if (err) &#123; return callback(err); &#125; fs.readFile('file2.txt ', 'utf-8', function (err, data) &#123; if (err) &#123; return callback(err); &#125; callback(null, [content, data]); &#125;);&#125;); series()方法中传入的函数callback()并非由使用者指定。事实上，此处的回调函数由async通过高阶函数的方式注入，这里隐含了特殊的逻 辑。每个callback()执行时会将结果保存起来，然后执行下一个调用，直到结束所有调用。最终的回调函数执行时，队列里的异步调用保存的结果以数组的方式传入。这里的异常处理规则是一 旦出现异常，就结束所有调用，并将异常传递给最终回调函数的第一个参数。 异步的并行执行当我们需要通过并行来提升性能时，async提供了parallel()方法，用以并行执行一些异步操作。 12345678910async.parallel([ function (callback) &#123; fs.readFile('file1.txt', 'utf-8', callback); &#125;, function (callback) &#123; fs.readFile('file2.txt', 'utf-8', callback); &#125;], function (err, results) &#123; // results =&gt; [file1.txt, file2.txt] &#125;); 上面这段代码等价于下面的代码: 123456789101112131415161718192021222324252627282930var counter = 2;var results = [];var done = function (index, value) &#123; results[index] = value; counter--; if (counter === 0) &#123; callback(null, results); &#125;&#125;;// 只传递第一个异常var hasErr = false;var fail = function (err) &#123; if (!hasErr) &#123; hasErr = true; callback(err); &#125; &#125;;fs.readFile('file1.txt', 'utf-8', function (err, content) &#123; if (err) &#123; return fail(err); &#125; done(0, content); &#125;);fs.readFile('file2.txt', 'utf-8', function (err, data) &#123; if (err) &#123; return fail(err); &#125; done(1, data); &#125;); 通过async编写的代码既没有深度的嵌套，也没有复杂的状态判断，它的诀窍依然来 自于注入的回调函数 parallel()方法对于异常的判断依然是一旦某个异步调用产生了异常，就 会将异常作为第一个参数传入给最终的回调函数。只有所有异步调用都正常完成时，才会将结果 以数组的方式传入。 异步调用的依赖处理series()适合无依赖的异步串行执行，但当前一个的结果是后一个调用的输入时，series()方法就无法满足需求了 async提供了waterfall()方法来满足 123456789101112131415161718192021async.waterfall([ function (callback) &#123; fs.readFile('file1.txt', 'utf-8', function (err, content) &#123; callback(err, content); &#125;); &#125;, function (arg1, callback) &#123; // arg1 =&gt; file2.txt fs.readFile(arg1, 'utf-8', function (err, content) &#123; callback(err, content); &#125;); &#125;, function(arg1, callback)&#123; // arg1 =&gt; file3.txt fs.readFile(arg1, 'utf-8', function (err, content) &#123; callback(err, content); &#125;); &#125;], function (err, result) &#123; // result =&gt; file4.txt &#125;); 自动依赖处理 auto()方法能根据依赖关系自动分析，以最佳的顺序执行业务 1async.auto(deps); 3. Step1Step(task1, task2, task3); Step接受任意数量的任务，所有的任务都将会串行依次执行。 1234567891011Step( function readFile1() &#123; fs.readFile('file1.txt', 'utf-8', this); &#125;, function readFile2(err, content) &#123; fs.readFile('file2.txt', 'utf-8', this); &#125;, function done(err, content) &#123; console.log(content); &#125;); Step用到了this关键字。事实上，它是Step内部的一个next()方法，将异步调用的结果传递给下一个任务作为参 数，并调用执行。 并行任务执行 this具有一个parallel()方法，它告诉Step，需要等所有任务完成时才进行下一个任务 1234567891011Step( function readFile1() &#123; fs.readFile('file1.txt', 'utf-8', this.parallel()); fs.readFile('file2.txt', 'utf-8', this.parallel()); &#125;, function done(err, content1, content2) &#123; // content1 =&gt; file1 // content2 =&gt; file2 console.log(arguments); &#125; ); 使用parallel()的时候需要小心的是，如果异步方法的结果传回的是多个参数，Step将只会取前两个参数 Step的parallel()方法的原理是每次执行时将内部的计数器加1，然后返回一个回调函数，这个回调函数在异步调用结束时才执行。当回调函数执行时，将计数器减1。当计数器为0的时候， 告知Step所有异步调用结束了，Step会执行下一个方法。 Step与async相同的是异常处理，一旦有一个异常产生，这个异常会作为下一个方法的第一个 参数传入 结果分组 12345678910111213141516171819Step( function readDir() &#123; fs.readdir(__dirname, this); &#125;, function readFiles(err, results) &#123; if (err) throw err; // Create a new group var group = this.group(); results.forEach(function (filename) &#123; if (/\\.js$/.test(filename)) &#123; fs.readFile(__dirname + \"/\" + filename, 'utf8', group()); &#125; &#125;); &#125;, function showAll(err, files) &#123; if (err) throw err; console.dir(files); &#125;); 我们注意到有两次group()的调用。第一次调用是告知Step要并行执行，第二次调用的结果将会生成一个回调函数，而回调函数接受的返回值将会按组存储。 parallel()传递给下一个任务的 结果是如下形式: 1function (err, result1, result2, ...); group()传递的结果是: 1function (err, results); 这个函数返回的数据保存在数组中。 4. wind 异步任务定义 12eval(Wind.compile(\"async\", function() &#123;&#125;));Wind.Async.sleep(20); Wind.compile()会将普通的函数进行编译，然后交给eval()执行。 eval(Wind.compile(“async”, function () {}));定义了异步任务。Wind.Async.sleep();内置了对setTimeout()的封装。 除了通过eval(Wind.compile(“async”, function () {}));定义任务外，正式的任务创建方法为Task.create()。 $await()与任务模型 1$await() 事实上，它并不是一个方法，也不存在于上下文中，只是一个等待的占位符，告之编译器这里需要等待。 $await()接受的参数是一个任务对象，表示等待任务结束后才会执行后续操作。每一个异步 操作都可以转化为一个任务，wind正是基于任务模型实现的。 wind提供了whenAll()来处理并发，通过$await关键字将等待配置的所有任务完成后才向下继续执行。 1234567891011var parallel = eval(Wind.compile(\"async\", function () &#123; var result = $await(Task.whenAll(&#123; file1: readFileAsync('file1.txt', 'utf-8'), file2: readFileAsync('file2.txt', 'utf-8') &#125;)); console.log(result.file1); console.log(result.file2); &#125;));parallel().start();//得到输出:file1 file2 异步方法转换辅助函数 这种近同步编程的体验需要我们额外 或者提前完成的事情是:将异步方法任务化。 wind提供了两个 方法来辅助转换: Wind.Async.Binding.fromCallback 用于转换这类无异常的异步调用为wind中的任务 Wind.Async.Binding.fromStandard 用于转换这类带异常的异步调用到wind中的任务。 异步并发控制同步I/O因为每个I/O都是彼此阻塞的，在循环体 中，总是一个接着一个调用，不会出现耗用文件描述符太多的情况，同时性能也是低下的;对于 异步I/O，虽然并发容易实现，但是由于太容易实现，依然需要控制。换言之，尽管是要压榨底 层系统的性能，但还是需要给予一定的过载保护，以防止过犹不及。 bagpipe的解决方案 通过一个队列来控制并发量。 如果当前活跃(指调用发起但未执行回调)的异步调用量小于限定值，从队列中取出执行。 如果活跃调用达到限定值，调用暂时存放在队列中。 每个异步调用结束时，从队列中取出新的异步调用执行 用户传入的回调函数被真正执行前，被封装替换过。这个封装的回调函数内部的逻辑将活跃 值的计数器减1后，主动调用next()执行后续等待的异步调用。 bagpipe类似于打开了一道窗口，允许异步调用并行进行，但是严格限定上限。仅仅在调用 push()时分开传递，并不对原有API有任何侵入。 拒绝模式1234// 设定最大并发数为10var bagpipe = new Bagpipe(10, &#123; refuse: true &#125;); 在拒绝模式下，如果等待的调用队列也满了之后，新来的调用就直接返给它一个队列太忙的 拒绝异常。 超时控制造成队列拥塞的主要原因是异步调用耗时太久，调用产生的速度远远高于执行的速度。为了防止某些异步调用使用了太多的时间，我们需要设置一个时间基线，将那些执行时间太久的异步调用 清理出活跃队列，让排队中的异步调用尽快执行。否则在拒绝模式下，会有太多的调用因为某个执 行得慢，导致得到拒绝异常。 超时控制是为异步调用设置一个时间阈值，如果异步调用 没有在规定时间内完成，我们先执行用户传入的回调函数，让用户得到一个超时异常，以尽早返 回。然后让下一个等待队列中的调用执行。 1234// 设定最大并发数为10var bagpipe = new Bagpipe(10, &#123; timeout: 3000 &#125;); async的解决方案async也提供了一个方法用于处理异步调用的限制:parallelLimit() 12345678910async.parallelLimit([ function (callback) &#123; fs.readFile('file1.txt', 'utf-8', callback); &#125;, function (callback) &#123; fs.readFile('file2.txt', 'utf-8', callback); &#125;], 1, function (err, results) &#123; // TODO &#125;); parallelLimit()与parallel()类似，但多了一个用于限制并发数量的参数，使得任务只能同 时并发一定数量，而不是无限制并发。 parallelLimit()方法的缺陷在于无法动态地增加并行任务。async提供了queue()方法 来满足该需求. 1234567891011var q = async.queue(function (file, callback) &#123; fs.readFile(file, 'utf-8', callback);&#125;,2);q.drain=function()&#123; // 完成了队列中的所有任务 &#125;;fs.readdirSync('.').forEach(function (file) &#123; q.push(file, function (err, data) &#123; // TODO &#125;);&#125;); 尽管queue()实现了动态添加并行任务，但是相比parallelLimit()，由于queue()接收的参数是固定的，它丢失了parallelLimit()的多样性 第五章 内存控制V8 的垃圾回收机制与内存限制V8 的内存限制在Node中通过JavaScript 使用内存时就会发现只能使用部分内存(64位系统下约为1.4 GB，32位系统下约为0.7 GB)。在 这样的限制下，将会导致Node无法直接操作大内存对象。 造成这个问题的主要原因在于Node基于V8构建，所以在Node中使用的JavaScript对象基本上 都是通过V8自己的方式来进行分配和管理的。V8的这套内存管理机制在浏览器的应用场景下使 用起来绰绰有余，足以胜任前端页面中的所有需求。但在Node中，这却限制了开发者随心所欲使 用大内存的想法。 V8 的对象分配内存使用量的查看在V8中，所有的JavaScript对象都是通过堆来进行分配的。Node提供了V8中内存使用量的查 看方式，执行下面的代码，将得到输出的内存信息: 123456$ node&gt; process.memoryUsage(); &#123; rss: 14958592, heapTotal: 7195904, heapUsed: 2821496 &#125; heapTotal和heapUsed是V8的堆内存使用情况，前者是已申请到的堆内存，后者是当前使用的量。 当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲 内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过V8的限制为止。 V8限制堆大小的原因以1.5 GB的垃圾回收堆内存为例，V8做一次小的垃圾回收需要50毫秒以上，做一 次非增量式的垃圾回收甚至要1秒以上。这是垃圾回收中引起JavaScript线程暂停执行的时间，在 这样的时间花销下，应用的性能和响应能力都会直线下降。这样的情况不仅仅后端服务无法接受， 前端浏览器也无法接受。因此，在当时的考虑下直接限制堆内存是一个好的选择。 调整内存限制的大小123node --max-old-space-size=1700 test.js // 单位为MB // 或者node --max-new-space-size=1024 test.js // 单位为KB V8 的垃圾回收机制V8主要的垃圾回收算法V8的垃圾回收策略主要基于分代式垃圾回收机制 V8的内存分代 在V8中，主要将内存分为新生代和老生代两代。新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。 V8堆的整体大小就是新生代所用内存空间加上老生代的内存空间。前面我们提及的 –max-old-space-size命令行参数可以用于设置老生代内存空间的最大值，–max-new-space-size 命令行参数则用于设置新生代内存空间的大小的。比较遗憾的是，这两个最大值需要在启动时就 指定。这意味着V8使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值 时，就会引起进程出错。 对于新生代内存，它由两个reserved_semispace_size_所构成.按机器位数不同，reserved_semispace_size_在64位系统和32位系统上分别为16 MB和8 MB。所以新生 代内存的最大值在64位系统和32位系统上分别为32 MB和16 MB。 默认情况下，V8堆内存的最大值在64位系统上为1464 MB，32位系统上则为732 MB。 这个数值可以解释为何在64位系统下只能使用约1.4 GB内存和在32位系统下只能使用约0.7 GB 内存。 Scavenge算法 新生代中的对象主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法。 Cheney算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间称为semispace。在这两个semispace空间中，只有一个处于使用中，另一个处于闲置状态。处 于使用状态的semispace空间称为From空间，处于闲置状态的空间称为To空间。当我们分配对象 时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这 些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空 间和To空间的角色发生对换。简而言之，在垃圾回收的过程中，就是通过将存活对象在两个 semispace空间之间进行复制。 Scavenge的缺点是只能使用堆内存中的一半，这是由划分空间和复制机制所决定的。但 Scavenge由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以它在时 间效率上有优异的表现。 当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代中移动到老生代中 的过程称为晋升。 在分代式垃圾回收的前提下，From空间中的存活对 象在复制到To空间之前需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中， 也就是完成对象晋升。 对象晋升的条件主要有两个，一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。当要从From空间复制一个对象到To空间时，如果 To空间已经使用了超过25%，则这个对象直接晋升到老生代空间中 （设置25%这个限制值的原因是当这次Scavenge回收完成后，这个To空间将变成From空间，接 下来的内存分配将在这个空间中进行。如果占比过高，会影响后续的内存分配。） Mark-Sweep &amp; Mark-Compact Mark-Sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段中，只清除没有被标记的对象。Scavenge中只复制活着的对象，而Mark-Sweep只清理死亡对象。 Mark-Sweep最大的问题是在进行一次标记清除回收后，内存空间会出现不连续的状态。这种 内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有 的碎片空间都无法完成此次分配，就会提前触发垃圾回收，而这次回收是不必要的。 在整理的 过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。 V8主要使用Mark-Sweep，在空间不足以对从新 生代中晋升过来的对象进行分配时才使用Mark-Compact。 Incremental Marking 为了避免出现JavaScript应用逻辑与垃圾回收器看到的不一致的情况，垃圾回收的3种基本算法都需要将应用逻辑暂停下来，待执行完垃圾回收后再恢复执行应用逻辑，这种行为被称为“全 停顿”(stop-the-world)。 为了降低全堆垃圾回收带来的停顿时间，V8先从标记阶段入手，将原本要一口气停顿完成 的动作改为增量标记(incremental marking)，也就是拆分为许多小“步进”，每做完一“步进” 就让JavaScript应用逻辑执行一小会儿，垃圾回收与应用逻辑交替执行直到标记阶段完成。 V8在经过增量标记的改进后，垃圾回收的最大停顿时间可以减少到原本的1/6左右。 V8后续还引入了延迟清理(lazy sweeping)与增量式整理(incremental compaction)，让清 理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低 每次停顿的时间。 查看垃圾回收日志查看垃圾回收日志的方式主要是在启动时添加–trace_gc参数。在进行垃圾回收时，将会从 标准输出中打印垃圾回收的日志信息。通过分析垃圾回收日志，可以了解垃圾回收的运行状况，找出垃圾回收的哪些阶段比较耗时， 触发的原因是什么。 通过在Node启动时使用–prof参数，可以得到V8执行时的性能分析数据，其中包含了垃圾 回收执行时占用的时间。 （V8提供了linux-tick-processor工具用于统计日志信息。该工具可以从Node源码的 deps/v8/tools目录下找到，Windows下的对应命令文件为windows-tick-processor.bat。将该目录添 加到环境变量PATH中，即可直接调用） 高效使用内存作用域1. 标识符查找标识符，可以理解为变量名。 2. 作用域链JavaScript在执行时会去查找该变量定义在哪里。它最先查找的是当前作用域，如果在当前作 用域中无法找到该变量的声明，将会向上级的作用域里查找，直到查到为止。这样的查找方式使得作 用域像一个链条。由于标识符的查找方向是向上的，所以变量只能向外访问，而不能向内访问。 3. 变量的主动释放 如果变量是全局变量(不通过var声明或定义在global变量上)，由于全局作用域需要直到 进程退出才能释放，此时将导致引用的对象常驻内存(常驻在老生代中)。如果需要释放常驻内 存的对象，可以通过delete操作来删除引用关系。或者将变量重新赋值，让旧的对象脱离引用关系。在接下来的老生代内存清除和整理的过程中，会被回收释放。 在非全局作用域中，想主动释放变量引用的对象，也可以通过这样的方式。 虽然 delete操作和重新赋值具有相同的效果，但是在V8中通过delete删除对象的属性有可能干扰V8 的优化，所以通过赋值方式解除引用更好。 闭包实现外部作用域访问内部作用域中变量的方法叫做闭包(closure) 这得益 于高阶函数的特性:函数可以作为参数或者返回值。 一旦有变量引用这个中间函数，这个中间函数将不会释放，同时也会使原始的作用域不会得到释放，作用域 中产生的内存占用也不会得到释放。除非不再有引用，才会逐步释放。 内存指标os模块中的 totalmem()和freemem()方法也可以查看内存使用情况 查看内存使用情况1. 查看进程的内存占用调用process.memoryUsage()可以看到Node进程的内存占用情况 123456$ node&gt; process.memoryUsage() &#123; rss: 13852672, heapTotal: 6131200, heapUsed: 2757120 &#125; rss是resident set size的缩写，即进程的常驻内存部分。进程的内存总共有几部分，一部分是 rss，其余部分在交换区(swap)或者文件系统(filesystem)中。 除了rss外，heapTotal和heapUsed对应的是V8的堆内存信息。heapTotal是堆中总共申请的内 存量，heapUsed表示目前堆中使用中的内存量。这3个值的单位都是字节。 2. 查看系统的内存占用os模块中的totalmem()和freemem()这两个方法用于查看操作系统的内存使用情况，它们分别返回系统的总内存和闲置内存，以字节为单位。 123456$ node&gt; os.totalmem() 8589934592&gt; os.freemem() 4527833088&gt; 堆外内存堆中的内存用量总是小于进程的常驻内存用 量，这意味着Node中的内存使用并非都是通过V8进行分配的。我们将那些不是通过V8分配的内存称为堆外内存。 Buffer对象不同于其他对象，它不经过V8的内存分配机制，所以也不 会有堆内存的大小限制。 利用堆外内存可以突破内存限制的问题。 Node的内存构成主要由通过V8进行分配的部分和Node自行分配的 部分。受V8的垃圾回收限制的主要是V8的堆内存。 内存泄漏造成内存泄漏的原因： 缓存。 队列消费不及时。 作用域未释放。 慎将内存当做缓存 在Node中，缓存并非物美价廉。一旦一个对象被当做缓存来使用，那就意味着它将会常 驻在老生代中。缓存中存储的键越多，长期存活的对象也就越多，这将导致垃圾回收在进行扫描 10 和整理时，对这些对象做无用功 JavaScript开发者通常喜欢用对象的键值对来缓存东西，但这与严格意义上 的缓存又有着区别，严格意义的缓存有着完善的过期策略，而普通对象的键值对并没有。 1. 缓存限制策略为了解决缓存中的对象永远无法释放的问题，需要加入一种策略来限制缓存的无限增长。 模块机制：为了加速模块的引入，所有模块都会通 过编译执行，然后被缓存起来。由于通过exports导出的函数，可以访问文件模块中的私有变量， 这样每个文件模块在编译执行后形成的作用域因为模块缓存的原因，不会被释放。 2. 缓存的解决方案进 程之间无法共享内存。如果在进程内使用缓存，这些缓存不可避免地有重复，对物理内存的使用 是一种浪费。 采用进程外的缓存，进程自身不存储状态。外 部的缓存软件有着良好的缓存过期淘汰策略以及自有的内存管理，不影响Node进程的性能。 在Node中主要可以解决以下两个问题。 (1) 将缓存转移到外部，减少常驻内存的对象的数量，让垃圾回收更高效。 (2) 进程之间可以共享缓存。 市面上较好的缓存有Redis和Memcached 关注队列状态队列在消费者-生产者模型中经常充当中间产物。一旦消费速度低于生产速度， 将会形成堆积。 深度的解决方案应该是监控队列的长度，一旦堆积，应当通过监控系统产生报警并通知相关 人员。另一个解决方案是任意异步调用都应该包含超时机制，一旦在限定的时间内未完成响应， 通过回调函数传递超时异常，使得任意异步调用的回调都具备可控的响应时间，给消费速度一个 下限值。 内存泄漏排查常见的定位Node应用的内存泄漏的工具： v8-profiler。由Danny Coates提供，它可以用于对V8堆内存抓取快照和对CPU进行分析，但该项目已经有3年没有维护了。 node-heapdump。这是Node核心贡献者之一Ben Noordhuis编写的模块，它允许对V8堆内存抓取快照，用于事后分析。 node-mtrace。由Jimb Esser提供，它使用了GCC的mtrace工具来分析堆的使用。 dtrace。在Joyent的SmartOS系统上，有完善的dtrace工具用来分析内存泄漏。 node-memwatch。来自Mozilla的Lloyd Hilaiel贡献的模块，采用WTFPL许可发布。 node-heapdump先构造如下一份包含内存泄 漏的代码示例，并将其存为server.js文件： 12345678910var leakArray = [];var leak = function () &#123; leakArray.push(\"leak\" + Math.random()); &#125;;http.createServer(function (req, res) &#123; leak(); res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World\\n'); &#125;).listen(1337); console.log('Server running at http://127.0.0.1:1337/'); 在上面这段代码中，每次访问服务进程都将引起leakArray数组中的元素增加，而且得不到回收。我们可以用curl工具输入http://127.0.0.1:1337/命令来模拟用户访问。 安装node-heapdump1$ npm install heapdump 安装node-heapdump后，在代码的第一行添加如下代码将其引入: 1var heapdump = require(&apos;heapdump&apos;); 引入node-heapdump后，就可以启动服务进程，并接受客户端的请求。访问多次之后， leakArray中就会具备大量的元素。这个时候我们通过向服务进程发送SIGUSR2信号，让 10 node-heapdump抓拍一份堆内存的快照。发送信号的命令如下: 1$ kill -USR2 &lt;pid&gt; 这份抓取的快照将会在文件目录下以heapdump-..heapsnapshot的格式存放。这是一份较大的JSON文件，需要通过Chrome的开发者工具打开查看。 可以看到有大量的leak字符串存在，这些字符串就是一直未能得到回收的数据。 通过在开发者工具的面板中查看内存分布，我们可以找到泄漏的数据，然后根据这些信息找到造 成泄漏的代码。 node-memwatch12345678910111213141516171819var memwatch = require('memwatch'); memwatch.on('leak', function (info) &#123; console.log('leak:'); console.log(info); &#125;);memwatch.on('stats', function (stats) &#123; console.log('stats:') console.log(stats);&#125;);var http = require('http');var leakArray = [];var leak = function () &#123; leakArray.push(\"leak\" + Math.random()); &#125;;http.createServer(function (req, res) &#123; leak(); res.writeHead(200, &#123;'Content-Type': 'text/plain'&#125;); res.end('Hello World\\n'); &#125;).listen(1337);console.log('Server running at http://127.0.0.1:1337/'); 1. stats事件在进程中使用node-memwatch之后，每次进行全堆垃圾回收时，将会触发一次stats事件，这 4 个事件将会传递内存的统计信息。 num_full_gc和num_inc_gc比较直观地反应了垃圾回收的情况 2. leak事件如果经过连续5次垃圾回收后，内存仍然没有被释放，这意味着有内存泄漏的产生，node-memwatch会出发一个leak事件。 这个数据能显示5次垃圾回收的过程中内存增长了多少。 3. 堆内存比较最终得到的leak事件的信息只能告知我们应用中存在内存泄漏，具体问题产生在何处还需要从V8的堆内存上定位。node-memwatch提供了抓取快照和比较快照的功能，它能够比较堆上对象 的名称和分配数量，从而找出导致内存泄漏的元凶。 1234567891011121314var memwatch = require('memwatch');var leakArray = [];var leak = function () &#123; leakArray.push(\"leak\" + Math.random());&#125;;// Take first snapshotvar hd = new memwatch.HeapDiff();for (var i = 0; i &lt; 10000; i++) &#123; leak();&#125;// Take the second snapshot and compute the diff var diff = hd.end(); console.log(JSON.stringify(diff, null, 2)); 执行上面这段代码，得到的输出结果如下所示: 1234567891011121314151617181920212223242526272829303132333435363738394041424344$ node diff.js &#123; \"before\": &#123; \"nodes\": 11719, \"time\": \"2013-10-07T06:32:07.000Z\", \"size_bytes\": 1493304, \"size\": \"1.42 mb\" &#125;, \"after\": &#123; \"nodes\": 31618, \"time\": \"2013-10-07T06:32:07.000Z\", \"size_bytes\": 2684864, \"size\": \"2.56 mb\" &#125;, \"change\": &#123; \"size_bytes\": 1191560, \"size\": \"1.14 mb\", \"freed_nodes\": 129, \"allocated_nodes\": 20028, \"details\": [ &#123; \"what\": \"Array\", \"size_bytes\": 323720, \"size\": \"316.13 kb\", \"+\": 15, \"-\": 65 &#125;, &#123; \"what\": \"Code\", \"size_bytes\": -10944, \"size\": \"-10.69 kb\", \"+\": 8, \"-\": 28 &#125;, &#123; \"what\": \"String\", \"size_bytes\": 879424, \"size\": \"858.81 kb\", \"+\": 20001, \"-\": 1 &#125; ] &#125;&#125; change节点下的freed_nodes和allocated_nodes，它们记录了 释放的节点数量和分配的节点数量。这里由于有内存泄漏，分配的节点数量远远多余释放的节点 数量。在details下可以看到具体每种类型的分配和释放数量。 加号和减号分别表示分配和释放的字符串对象数量。 大内存应用Node提供了stream模块用于处理大文件 stream模块是Node的原生模块，直接引用即可。stream继承自EventEmitter，具备基本的自 定义事件功能，同时抽象出标准的事件和方法。它分可读和可写两种。Node中的大多数模块都有 stream的应用，比如fs的createReadStream()和createWriteStream()方法可以分别用于创建文件 的可读流和可写流，process模块中的stdin和stdout则分别是可读流和可写流的示例。 第六章 理解BufferBuffer 结构Buffer是一个像Array的对象，但它主要用于操作字节。 模块结构Buffer是一个典型的JavaScript与C++结合的模块，它将性能相关部分用C++实现，将非性能相关的部分用JavaScript实现 Node在进程启动时就已经加载了它，并将其放在全局对象(global) 上。所以在使用Buffer时，无须通过require()即可直接使用 Buffer 对象Buffer对象类似于数组，它的元素为16进制的两位数，即0到255的数值。 1234var str = \"深入浅出node.js\";var buf = new Buffer(str, 'utf-8');console.log(buf);// =&gt; &lt;Buffer e6 b7 b1 e5 85 a5 e6 b5 85 e5 87 ba 6e 6f 64 65 2e 6a 73&gt; 不同编码的字符串占用的元素个数各不相同，上面代码中的中文字在 UTF-8编码下占用3个元素，字母和半角标点符号占用1个元素。 Buffer可以访问length属性得到长度，也可以通过下标访问元素，在构造对象时也与Array相似。 123var buf = new Buffer(100); console.log(buf.length); // =&gt; 100console.log(buf[10]);//会得到一个比较奇怪的结果，它的元素值是一个0到255的随机值。 如果给元素赋值不是0到255的整数而是小数时会怎样呢? 123456buf[20] = -100;console.log(buf[20]); // 156 buf[21] = 300; console.log(buf[21]); // 44 buf[22] = 3.1415; console.log(buf[22]); // 3 给元素的赋值如果小于0，就将该值逐次加256，直到得到一个0到255之间的整数。如果得到 的数值大于255，就逐次减256，直到得到0~255区间内的数值。如果是小数，舍弃小数部分，只 保留整数部分。 Buffer 内存分配Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的。因 为处理大量的字节数据不能采用需要一点内存就向操作系统申请一点内存的方式，这可能造成大 量的内存申请的系统调用，对操作系统有一定压力。为此Node在内存的使用上应用的是在C++ 层面申请内存、在JavaScript中分配内存的策略。 Node采用了slab分配机制，slab是一种动态内存管理机制。slab就是一块申请好的固定大小的内存区域。slab具有如下3种状态。 full:完全分配状态。 partial:部分分配状态。 empty:没有被分配状态。 1new Buffer(size); Node以8 KB为界限来区分Buffer是大对象还是小对象。8 KB的值也就是每个slab的大小值，在JavaScript层面，以它作为单位单元进行内存的分配。 1. 分配小Buffer对象如果指定Buffer的大小少于8 KB，Node会按照小对象的方式进行分配。Buffer的分配过程中主要使用一个局部变量pool作为中间处理对象，处于分配状态的slab单元都指向它 12345var pool;function allocPool() &#123; pool = new SlowBuffer(Buffer.poolSize); pool.used = 0;&#125; slab处于empty状态。 1new Buffer(1024); 这次构造将会去检查pool对象，如果pool没有被创建，将会创建一个新的slab单元指向它: 1if (!pool || pool.length - pool.used &lt; this.length) allocPool(); 同时当前Buffer对象的parent属性指向该slab，并记录下是从这个slab的哪个位置(offset) 开始使用的，slab对象自身也记录被使用了多少字节 1234this.parent = pool;this.offset = pool.used;pool.used += this.length;if (pool.used &amp; 7) pool.used = (pool.used + 8) &amp; ~7; 这时候的slab状态为partial。 当再次创建一个Buffer对象时，构造过程中将会判断这个slab的剩余空间是否足够。如果足 够，使用剩余空间，并更新slab的分配状态。如果slab剩余的空间不够，将会构造新的slab，原slab中剩余的空间会造成浪费。 由于同一个slab可能分配给多个Buffer对象使用，只有这些小Buffer对 象在作用域释放并都可以回收时，slab的8 KB空间才会被回收。尽管创建了1个字节的Buffer对象， 但是如果不释放它，实际可能是8 KB的内存没有释放。 2. 分配大Buffer对象如果需要超过8 KB的Buffer对象，将会直接分配一个SlowBuffer对象作为slab单元，这个slab 单元将会被这个大Buffer对象独占。 12// Big buffer, just alloc onethis.parent = new SlowBuffer(this.length); this.offset = 0; Buffer 的转换Buffer对象可以与字符串之间相互转换。目前支持的字符串编码类型有如下这几种。 ASCII UTF-8 UTF-16LE/UCS-2 Base64 Binary Hex 字符串转Buffer字符串转Buffer对象主要是通过构造函数完成的 1new Buffer(str, [encoding]); 通过构造函数转换的Buffer对象，存储的只能是一种编码类型。encoding参数不传递时，默认按UTF-8编码进行转码和存储。 一个Buffer对象可以存储不同编码类型的字符串转码的值，调用write()方法可以实现该目的 1buf.write(string, [offset], [length], [encoding]) 由于可以不断写入内容到Buffer对象中，并且每次写入可以指定编码，所以Buffer对象中可 以存在多种编码转化后的内容。需要小心的是，每种编码所用的字节长度不同，将Buffer反转回 字符串时需要谨慎处理。 Buffer 转字符串Buffer对象的toString()可以将Buffer对象转换为字符串 1buf.toString([encoding], [start], [end]) 可以设置encoding(默认为UTF-8)、start、end这3个参数实现整体或局部的转换。如果Buffer对象由多种编码写入，就需要在局部指定不同的编码，才能转换回正常的编码。 Buffer 不支持的编码类型Buffer提供了一个isEncoding()函数来判断编码是否支持转换 1Buffer.isEncoding(encoding) 将编码类型作为参数传入上面的函数，如果支持转换返回值为true，否则为false。 Buffer 的拼接Buffer在使用场景中，通常是以一段一段的方式传输。 乱码是如何产生的12345678var fs = require('fs');var rs = fs.createReadStream('test.md');var data = '';rs.on(\"data\", function (chunk)&#123; data += chunk; &#125;);rs.on(\"end\", function () &#123; console.log(data);&#125;); data += chunk;这句代码里隐藏了toString()操作，等价于data = data.toString() + chunk.toString(); 1var rs = fs.createReadStream('test.md', &#123;highWaterMark: 11&#125;); 搭配该代码的测试数据为李白的《静夜思》。执行该程序，将会得到以下输出: 1床前明���光，疑���地上霜;举头���明月，���头思故乡。 产生这个输出结果的原因在于文件可读流在读取时会逐个读取Buffer。这首诗的原始Buffer应存储为: 1&lt;Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c 88 e5 85 89 ef bc 8c e7 96 91 e6 98 af e5 9c b0 e4 b8 8a e9 9c 9c ef bc 9b e4 b8 be e5 a4 b4 e6 9c 9b e6 98 8e e6 9c 88 ...&gt; 由于我们限定了Buffer对象的长度为11，因此只读流需要读取7次才能完成完整的读取，结果 是以下几个Buffer对象依次输出: 123&lt;Buffer e5 ba 8a e5 89 8d e6 98 8e e6 9c&gt; &lt;Buffer 88 e5 85 89 ef bc 8c e7 96 91 e6&gt; ... buf.toString()方法默认以UTF-8为编码，中文字在UTF-8下占3个字节。所以第 一个Buffer对象在输出时，只能显示3个字符，Buffer中剩下的2个字节(e6 9c)将会以乱码的形 式显示。第二个Buffer对象的第一个字节也不能形成文字，只能显示乱码。于是形成一些文字无 法正常显示的问题。 在这个示例中我们构造了11这个限制，但是对于任意长度的Buffer而言，宽字节字符串都有 可能存在被截断的情况，只不过Buffer的长度越大出现的概率越低而已，但该问题依然不可忽视。 setEncoding()与 string_decoder()可读流还有一个设置编码的方法setEncoding()，该方法的作用是让data事件中传递的不再是一个Buffer对象，而是编码后的字符串。 1readable.setEncoding(encoding) 12var rs = fs.createReadStream('test.md', &#123; highWaterMark: 11&#125;);rs.setEncoding('utf8'); 重新执行程序，得到输出: 床前明月光，疑是地上霜;举头望明月，低头思故乡。 设置编码并未改变按 段读取的基本方式。在调用setEncoding()时，可读流对象在内部设置了一个decoder对象。每次data事 件都通过该decoder对象进行Buffer到字符串的解码，然后传递给调用者。置编码后，data 不再收到原始的Buffer对象。 decoder对象来自于string_decoder 模块StringDecoder的实例对象。StringDecoder在得到编码后，知道宽字节字符串在UTF-8编码下是 以3个字节的方式存储的，所以第一次write()时，只输出前9个字节转码形成的字符，“月”字的 前两个字节被保留在StringDecoder实例内部。第二次write()时，会将这2个剩余字节和后续11 个字节组合在一起，再次用3的整数倍字节进行转码。于是乱码问题通过这种中间形式被解决了。 string_decoder目前只能处理UTF-8、Base64和 UCS-2/UTF-16LE这3种编码。 正确拼接Buffer1234567891011var chunks = [];var size = 0;res.on('data', function (chunk) &#123; chunks.push(chunk); size += chunk.length;&#125;)res.on('end', function()&#123; var buf = Buffer.concat(chunks, size); var str = iconv.decode(buf, 'utf8'); console.log(str);&#125;) 正确的拼接方式是用一个数组来存储接收到的所有Buffer片段并记录下所有片段的总长度， 然后调用Buffer.concat()方法生成一个合并的Buffer对象。Buffer.concat()方法封装了从小 Buffer对象向大Buffer对象的复制过程，实现十分细腻 12345678910111213141516171819202122232425Buffer.concat = function(list, length) &#123; if (!Array.isArray(list)) &#123; throw new Error('Usage: Buffer.concat(list, [length])'); &#125; if (list.length === 0) &#123; return new Buffer(0); &#125; else if (list.length === 1) &#123; return list[0]; &#125; if (typeof length !== 'number') &#123; length = 0; for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i]; length += buf.length; &#125; &#125; var buffer = new Buffer(length); var pos = 0; for (var i = 0; i &lt; list.length; i++) &#123; var buf = list[i]; buf.copy(buffer, pos); pos += buf.length; &#125; return buffer; &#125;; Buffer 与性能一旦在网络中传输，都需要转换为Buffer，以进行二进制数据传输。 通过预先转换静态内容为Buffer对象，可以有效地减少CPU的重复使用，节省服务器资源。 在Node构建的Web应用中，可以选择将页面中的动态内容和静态内容分离，静态内容部分可以通 过预先转换为Buffer的方式，使性能得到提升。由于文件自身是二进制数据，所以在不需要改变 内容的场景下，尽量只读取Buffer，然后直接传输，不做额外的转换，避免损耗。 文件读取在文件的读取时，有一个highWaterMark设置对性能的影响至关重要。 在fs.createReadStream(path, opts)时，我们可以传入一些参数 1234567&#123; flags: 'r', encoding: null, fd: null, mode: 0666, highWaterMark: 64 * 1024&#125; 还可以传递start和end来指定读取文件的位置范围 1&#123;start: 90, end: 99&#125; fs.createReadStream()的工作方式是在内存中准备一段Buffer，然后在fs.read()读取时逐步 从磁盘中将字节复制到Buffer中。完成一次读取时，则从这个Buffer中通过slice()方法取出部分 数据作为一个小Buffer对象，再通过data事件传递给调用方。如果Buffer用完，则重新分配一个; 如果还有剩余，则继续使用。 分配一个新的Buffer对象的操作: 12345var pool;function allocNewPool(poolSize) &#123; pool = new Buffer(poolSize); pool.used = 0;&#125; 在理想的状况下，每次读取的长度就是用户指定的highWaterMark。但是有可能读到了文件结尾，或者文件本身就没有指定的highWaterMark那么大，这个预先指定的Buffer对象将会有部分 剩余，不过好在这里的内存可以分配给下次读取时使用。pool是常驻内存的，只有当pool单元剩 余数量小于128(kMinPoolSpace)字节时，才会重新分配一个新的Buffer对象。 highWaterMark的大小对性能有两个影响的点 highWaterMark设置对Buffer内存的分配和使用有一定影响。 highWaterMark设置过小，可能导致系统调用次数过多。 文件流读取基于Buffer分配，Buffer则基于SlowBuffer分配 由于fs.createReadStream()内部采用fs.read()实现，将会引起对磁盘的系统调用，对于大 文件而言，highWaterMark的大小决定会触发系统调用和data事件的次数。 读取一个相同的大文件时，highWaterMark值的大小与读取速 度的关系:该值越大，读取速度越快。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"深入浅出Node.js学习笔记（一）","slug":"深入浅出Node.js学习笔记（一）","date":"2019-12-13T07:04:52.000Z","updated":"2019-12-29T07:11:37.454Z","comments":true,"path":"2019/12/13/深入浅出Node.js学习笔记（一）/","link":"","permalink":"http://yoursite.com/2019/12/13/深入浅出Node.js学习笔记（一）/","excerpt":"","text":"深入浅出Node.js学习笔记（一）高并发、高性能 第一章 Node简介 高性能、符合事件驱动、没有历史包袱这3个主要原因，JavaScript成为了Node的实现语言。 Node发展为一个强制不共享任何资源的 单线程、单进程系统，包含十分适宜网络的库，为构建大型分布式应用程序提供基础设施，其目 标也是成为一个构建快速、可伸缩的网络应用平台。它自身非常简单，通过通信协议来组织许多 Node，非常容易通过扩展来达成构建大型网络应用的目的。每一个Node进程都构成这个网络应 用中的一个节点，这是它名字所含意义的真谛。 它们都是基于事件驱动的异步架构，浏览器通过事件驱动来服务界面上的交互，Node通过事件驱 动来服务I/O Node的特点异步I/O 在Node中，绝大多数的操作都以异步的方式进行调用。 在Node中，我们可 以从语言层面很自然地进行并行I/O操作。每个调用之间无须等待之前的I/O调用结束。 事件与回调函数 事件的编程方式具有轻量级、松耦合、只关注事务点等优势，但是在多个异步任务的场景下， 事件与事件之间各自独立，如何协作是一个问题。 回调函数无处不在。回调函数是最好的接受异步调用返回数据的方式 单线程Node保持了JavaScript在浏览器中单线程的特点。 在Node中，JavaScript与其余线程是无 法共享任何状态的。（单线程的最大好处是不用像多线程编程那样处处在意状态的同步问题，这里 没有死锁的存在，也没有线程上下文交换所带来的性能上的开销。） 单线程的弱点： 无法利用多核CPU 错误会引起整个应用退出，应用的健壮性值得考验 大量计算占用CPU导致无法继续调用异步I/O 在Node中，长时间的CPU占用也会导致后续的异步I/O发不出调用，已完成的异步I/O的 回调函数也会得不到及时执行。解决单线程中大计算量的问题——child_process 子进程的出现，意味着Node可以从容地应对单线程在健壮性和无法利用多核CPU方面的问 题。通过将计算分发到各个子进程，可以将大量计算分解掉，然后再通过进程之间的事件消息来 传递结果，这可以很好地保持应用模型的简单和低依赖。通过Master-Worker的管理方式，也可以 很好地管理各个工作进程，以达到更高的健壮性。 跨平台 它在操作系统与Node上层模块 系统之间构建了一层平台层架构，即libuv。（libuv已经成为许多系统实现跨平台的基础组件） Node 的应用场景I/O 密集型Node擅长I/O密集型的应用场景。Node面向网络且擅长并行I/O，能够有效 地组织起更多的硬件资源，从而提供更多好的服务。 I/O密集的优势主要在于Node利用事件循环的处理能力，而不是启动每一个线程为每一个请 求服务，资源占用极少。 CPU密集型CPU密集型应用给Node 带来的挑战主要是:由于JavaScript单线程的原因，如果有长时间运行的计算(比如大循环)，将 会导致CPU时间片不能释放，使得后续I/O无法发起。但是适当调整和分解大型运算任务为多个 小任务，使得运算能够适时释放，不阻塞I/O调用的发起，这样既可同时享受到并行异步I/O的好 处，又能充分利用CPU。 Node可以通过编写C/C++扩展的方式更高效地利用CPU，将一些V8不能做到性能极致的地方通过C/C++来实现。由上面的测试结果可以看到，通过C/C++扩展的方式实现斐波那契数列计算，速度比Java还快。 如果单线程的Node不能满足需求，甚至用了C/C++扩展后还觉得不够，那么通过子进程的方式，将一部分Node进程当做常驻服务进程用于计算，然后利用进程间的消息来传递结果，将计算与I/O分离，这样还能充分利用多CPU。 CPU密集不可怕，如何合理调度是诀窍。 分布式应用Node高效利用并行I/O的过程，也是高效使用数 据库的过程 第二章 模块机制CommonJSJavaScript缺陷 没有模块系统 标准库较少 没有标准接口 缺乏包管理系统 CommonJS规范的提出，主要是为了弥补当前JavaScript没有标准的缺陷 CommonJS 的模块规范 模块引用 1var math = require('math'); 模块定义 上下文提供了 exports对象用于导出当前模块的方法或者变量，并且它是唯一导出的出口。 在模块中，还存在 一个module对象，它代表模块自身，而exports是module的属性。 在Node中，一个文件就是一个 模块，将方法挂载在exports对象上作为属性即可定义导出的方式。 1234567891011// math.jsexports.add = function () &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum; &#125;; 模块标识 模块标识其实就是传递给require()方法的参数，它必须是符合小驼峰命名的字符串，或者 以.、..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。 它的意义在于将类聚的方法和变量等限定在私有的 作用域中，同时支持引入和导出功能以顺畅地连接上下游依赖。 Node 的模块实现在Node中引入模块，需要经历如下3个步骤。 路径分析 文件定位 编译执行 在Node中，模块分为两类:一类是Node提供的模块，称为核心模块;另一类是用户编写的模块，称为文件模块。 核心模块部分在Node源代码的编译过程中，编译进了二进制执行文件。在Node进程启动 时，部分核心模块就被直接加载进内存中，所以这部分核心模块引入时，文件定位和编 译执行这两个步骤可以省略掉，并且在路径分析中优先判断，所以它的加载速度是最 快的。 文件模块则是在运行时动态加载，需要完整的路径分析、文件定位、编译执行过程，速 度比核心模块慢。 优先从缓存加载Node对引入过的模块都会进行缓存，以减少二次引入时的开销。Node缓存的事编译和执行之后的对象。 不论是核心模块还是文件模块，require()方法对相同模块的二次加载都一律采用缓存优先的 方式，这是第一优先级的。不同之处在于核心模块的缓存检查先于文件模块的缓存检查。 路径分析和文件定位模块路径模块路径是Node在定位文件模块的具体文件时制定的查找策略，具体表现为一个路径组成的数组。 模块路径的生成规则： 当前文件目录下的node_modules目录。 父目录下的node_modules目录。 父目录的父目录下的node_modules目录。 沿路径向上逐级递归，直到根目录下的node_modules目录。 模块标识符分析模块标识符在Node中主要分为以下几类。 核心模块，如http、fs、path等。 .或..开始的相对路径文件模块。 以/开始的绝对路径文件模块。 非路径形式的文件模块，如自定义的connect模块。 核心模块 核心模块的优先级仅次于缓存加载，它在Node的源代码编译过程中已经编译为二进制代码， 其加载过程最快。 （如果加载一个与核心模块标识符相同的自定义模块，不会成功。如果自己编写了一个http用户模块，想要加载成功，必须选择不同的标识符或换用路径方式） 路径形式的文件模块 在分析文件模块时，require()方法会将路径转为真实路径，并以真实路径作为索引，将编译执行后的结果存放到缓存中，以使二 次加载时更快。 （文件模块指明了确切的文件位置，在查找中会节约时间，加载速度慢于核心模块） 自定义模块 它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。 在加载的过程中，Node 会逐个尝试模块路径中的路径，直到找到目标文件为止。可以看出，当前文件的路径越深，模块查找耗时会越多，这是自定义模块的加载速度是最慢的原因。 文件定位 文件扩展名分析： require()在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。CommonJS模块规范也允许在标识符中不包含文件扩展名，这种情况下，Node会按.js、.json、.node的次序补 足扩展名，依次尝试。 在尝试的过程中，需要调用fs模块同步阻塞式地判断文件是否存在。因为Node是单线程的， 所以这里是一个会引起性能问题的地方。 （如果是.node和.json文件，在传递给require() 的标识符中带上扩展名，会加快一点速度。同步配合缓存，可以大幅度缓解Node 单线程中阻塞式调用的缺陷。） 目录分析和包 在分析标识符的过程中，require()通过分析文件扩展名之后，可能没有查找到对应文件，但却得到一个目录，这在引入自定义模块和逐个模块路径进行查找时经常会出现，此时Node会将目录当做一个包来处理。 Node在当前目录下 查找package.json(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象， 从中取出main属性指定的文件名进行定位。如果文件名缺少扩展名，将会进入扩展名分析的步骤。 而如果main属性指定的文件名错误，或者压根没有package.json文件，Node会将index当做默 认文件名，然后依次查找index.js、index.json、index.node。 如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查 找。 如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败的异常。 模块编译在Node中，每个文件模块都是一个对象 定位到具体的文件后，Node会新建一个模块对 象，然后根据路径载入并编译。对于不同的文件扩展名，其载入方法有所不同 .js文件。通过fs模块同步读取文件后编译执行。 .node文件。这是用C/C++编写的扩展文件，通过dlopen()方法加载最后编译生成的文件。 .json文件。通过fs模块同步读取文件后，用JSON.parse()解析返回结果。 其余扩展名文件。它们都被当做.js文件载入。 每一个编译成功的模块都会将其文件路径作为索引缓存在Module._cache对象上，以提高二 次引入的性能。 在确定文件的扩展名之后，Node将调用具体的编译方式来将文件执行后返回给调用者。 JavaScript模块的编译在编译的过程中，Node对获取的JavaScript文件内容进行了头尾包装。 在头部添加 了(function (exports, require, module, __filename, __dirname) {\\n，在尾部添加了\\n});。 123456(function (exports, require, module, __filename, __dirname) &#123; var math = require('math'); exports.area = function (radius) &#123; return Math.PI * radius * radius; &#125;; &#125;); 这样每个模块文件之间都进行了作用域隔离。 包装之后的代码会通过vm原生模块的runInThisContext()方法执行(类似eval，只是具有明确上下文，不污染全局)，返回一个具体的 function对象。 将当前模块对象的exports属性、require()方法、module(模块对象自身)， 以及在文件定位中得到的完整文件路径和文件目录作为参数传递给这个function()执行。 exports对象是通过形参的方式传入的，直接赋值形参会改变形参的引用，但并不能改变作用域外的值。(如果要达到require引入一个类的效果，请赋值给module.exports对象。) C/C++模块的编译Node调用process.dlopen()方法进行加载和执行。在Node的架构下，dlopen()方法在Windows 和*nix平台下分别有不同的实现，通过libuv兼容层进行了封装。 它是编写C/C++模块之后编译生成的，所以这 里只有加载和执行的过程。在执行的过程中，模块的exports对象与.node模块产生联系，然后返 回给调用者。 优势：执行效率 劣势：编写门槛高 JSON文件的编译Node利用fs模块同步读取JSON文件的内容之 后，调用JSON.parse()方法得到对象，然后将它赋给模块对象的exports，以供外部调用。 （定义了一个JSON文件作为配置，那就 不必调用fs模块去异步读取和解析，直接调用require()引入即可） 核心模块核心模块C/C++文件存放在Node项目的src目录下， JavaScript文件存放在lib目录下。 JavaScript 核心模块的编译过程转存为C/C++代码Node采用了V8附带的js2c.py工具，将所有内置的JavaScript代码(src/node.js和lib/*.js)转换 成C++里的数组，生成node_natives.h头文件 JavaScript代码以字符串的形式存储在node命名空间中，是不可直接执行的。 在启动Node进程时，JavaScript代码直接加载进内存中。在加载的过程中，JavaScript核心模块经 历标识符分析后直接定位到内存中，比普通的文件模块从磁盘中一处一处查找要快很多。 编译JavaScript核心模块lib目录下的所有模块文件也没有定义require、module、exports这些变量。在引入JavaScript 核心模块的过程中，也经历了头尾包装的过程，然后才执行和导出了exports对象。与文件模块有区别的地方在于:获取源代码的方式(核心模块是从内存中加载的)以及缓存执行结果的位置。 源文件通过process.binding(‘natives’)取出， 编译成功的模块缓存到NativeModule._cache对象上，文件模块则缓存到Module._cache对象上 C/C++核心模块的编译过程C++模块主内完成核心，JavaScript 主外实现封装的模式是Node能够提高性能的常见方式。 由纯C/C++编写的部分统一称为内建模块，因为它们通常不被用户直接调 用。 内建模块Node提供了get_builtin_module()方法从node_module_list 数组中取出这些模块 内建模块的优势在于： 它们本身由C/C++编写，性能上优于脚本语言 在进行文件编译时，它们被编译进二进制文件。一旦Node开始执行，它们被直接加载进内存中，无须再 次做标识符定位、文件定位、编译等过程，直接就可执行。 在Node的所有模块类型中，存在着如图2-4所示的一种依赖层级关系，即文件模块可能会依 赖核心模块，核心模块可能会依赖内建模块。 加载内建模块： 在加载内建模块时，先创建一个exports空对象 然后调用get_builtin_module()方法取 出内建模块对象，通过执行register_func()填充exports对象 最后将exports对象按模块名缓存，并返回给调用方完成导出。 核心模块的引入流程 编写核心模块 编写头文件 编写C/C++文件 C/C++扩展模块C/C++扩展模块属于文件模块中的一类。 为了实现跨平台，dlopen()方法在内部实现时区 分了平台，分别用的是加载.so和.dll的方式。（一个平台下的.node文件在另一个平台下是无法加载执行的，必须重新用各 自平台下的编译器编译为正确的.node文件。） require()在引入.node文件的过程中： 调用uv_dlopen()方法去打开动态链接库 调用uv_dlsym()方法找到动态链接库中通过NODE_MODULE宏定义的方法地址 这 两个过程都是通过libuv库进行封装的:在*nix平台下实际上调用的是dlfcn.h头文件中定义的 dlopen()和dlsym()两个方法;在Windows平台则是通过LoadLibraryExW()和GetProcAddress()这两 个方法实现的，它们分别加载.so和.dll文件(实际为.node文件)。 模块调用栈 C/C++内建模块属于最底层的模块，它属于核心模块，主要提供API给JavaScript核心模块和 第三方JavaScript文件模块调用。 JavaScript核心模块主要扮演的职责有两类: 一类是作为C/C++内建模块的封装层和桥接层， 供文件模块调用; 一类是纯粹的功能模块 文件模块通常由第三方编写，包括普通JavaScript模块和C/C++扩展模块，主要调用方向为普通JavaScript模块调用扩展模块。 包与NPM 由包结构和包描述文件两个部分组成，前者用于组织包中的各种文件，后者则用于描述包的相关信息，以供外部读取分析。 包结构包实际上是一个存档文件，即一个目录直接打包为.zip或tar.gz格式的文件，安装后解压还原为目录。 完全符合CommonJS规范的包目录应该包含如下这些文件： package.json:包描述文件。 bin:用于存放可执行二进制文件的目录。 lib:用于存放JavaScript代码的目录。 doc:用于存放文档的目录。 test:用于存放单元测试用例的代码。 包描述文件与NPM包描述文件用于表达非代码相关的信息，它是一个JSON格式的文件——package.json，位于 包的根目录下，是包的重要组成部分。 必需字段： name。包名。规范定义它需要由小写的字母和数字组成，可以包含.、_和-，但不允许出现空格。包名必须是唯一的，以免对外公布时产生重名冲突的误解。除此之外，NPM还建议不要在包名中附带上node或js来重复标识它是JavaScript或Node模块。 description。包简介。 version。版本号。一个语义化的版本号，该版本号十分重要，常常用于一些版本控制的场合。 keywords。关键词数组，NPM中主要用来做分类搜索。一个好的关键词数组有利于用户快速找到你编写的包。 maintainers。包维护者列表。每个维护者由name、email和web这3个属性组成。NPM通过该属性进行权限认证。 contributors。贡献者列表。列表中的第一个贡献应当是包的作者本人。它的格式与维护者列表相同。 bugs。一个可以反馈bug的网页地址或邮件地址。 licenses。当前包所使用的许可证列表，表示这个包可以在哪些许可证下使用。 repositories。托管源代码的位置列表，表明可以通过哪些方式和地址访问包的源代码。 dependencies。使用当前包所需要依赖的包列表。这个属性十分重要，NPM会通过这个属性帮助自动加载依赖的包。 可选字段： homepage。当前包的网站地址。 os。操作系统支持列表。这些操作系统的取值包括aix、freebsd、linux、macos、solaris、vxworks、windows。如果设置了列表为空，则不对操作系统做任何假设。 cpu。CPU架构的支持列表，有效的架构名称有arm、mips、ppc、sparc、x86和x86_64。同os一样，如果列表为空，则不对CPU架构做任何假设。 engine。支持的JavaScript引擎列表，有效的引擎取值包括ejs、flusspferd、gpsee、jsc、spidermonkey、narwhal、node和v8。 builtin。标志当前包是否是内建在底层系统的标准组件。 directories。包目录说明。 implements。实现规范的列表。标志当前包实现了CommonJS的哪些规范。 scripts。脚本说明对象。它主要被包管理器用来安装、编译、测试和卸载包。 在包描述文件的规范中，NPM实际需要的字段主要有name、version、description、keywords、 repositories、author、bin、main、scripts、engines、dependencies、devDependencies。 author。包作者。 bin。一些包作者希望包可以作为命令行工具使用。配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径中，之后可以在命令行中直接执行。前面的node-gyp即是这样安装的。通过-g命令安装的模块包称为全局模式。 main。模块引入方法require()在引入包时，会优先检查这个字段，并将其作为包中其余 模块的入口。如果不存在这个字段，require()方法会查找包目录下的index.js、index.node、index.json文件作为默认入口。 devDependencies。一些模块只在开发时需要依赖。配置这个属性，可以提示包的后续开发者安装依赖包。 前后端共用模块AMD 规范AMD规范是CommonJS模块规范的一个延伸 1define(id?, dependencies?, factory); 它的模块id和依赖是可选的，与Node模块相似的地方在于factory的内容就是实际代码的内容。 123456define(function() &#123; var exports = &#123;&#125;; exports.sayHello = function() &#123; alert('Hello from module: ' + module.id); &#125;; return exports; &#125;); 不同之处在于AMD模块需要用define来明确定义一个模块，而在Node实现中是隐式包装的， 它们的目的是进行作用域隔离，仅在需要的时候被引入，避免掉过去那种通过全局变量或者全局 命名空间的方式，以免变量污染和不小心被修改。另一个区别则是内容需要通过返回的方式实现 导出。 CMD 规范与AMD规范的主要区别在于定义模块和依赖引入的部分。 AMD需要在声明模块的时候指定所有的依赖，通过形参传递依赖到模块内容中。 在依赖部分，CMD支持动态引入。 第三章 异步I/O为什么要异步I/O用户体验 前端通过异步可以消除掉UI阻塞的现象。但是前端获取资源的速度也取决于后端的响应速度。采用异步方式，第一个资源的获取并不会阻塞第二个资源。 随着网站或应用不断膨胀，数据将会分布到多台服务器上，分布式将会是常态。分布也意味着M与N的值（M/N分别为两个请求消耗的时间）会线性增长，这也会放大异步和同步在性能方面的差异。 只有后端能够快速响应资源，才能让前端的体验变好。 资源分配利用单线程，远离多线程死锁、状态同步等问题;利用异 步I/O，让单线程远离阻塞，以更好地使用CPU。 Node提供了类似前端浏览器中Web Workers的子 进程，该子进程可以通过工作进程高效地利用CPU和I/O 异步I/O实现现状异步I/O与非阻塞I/O异步/同步和阻塞/非阻塞实际上是两回事 操作系统内核对于I/O只有两种方式:阻塞与非阻塞。 阻塞：在调用阻塞I/O时，应用程序需要等待 I/O完成才返回结果 特点：调用之后一定要等到系统内核层面完成所有操作后，调用才结束。 阻塞I/O造成CPU等待I/O，浪费等待时间，CPU的处理能力不能得到充分利用 非阻塞：非阻塞I/O跟阻塞I/O的差别为调用之后会立即返回 非阻塞I/O返回之后，CPU的时间片可以用来处理其他事务，此时的性能提升是明显的。 问题：由于完整的I/O并没有完成，立即返回的并不是业务层期望的 数据，而仅仅是当前调用的状态。为了获取完整的数据，应用程序需要重复调用I/O操作来确认 是否完成。这种重复调用判断操作是否完成的技术叫做轮询。 轮询技术： read。它是最原始、性能最低的一种，通过重复调用来检查I/O的状态来完成完整数据的读取。在得到最终数据前，CPU一直耗用在等待上。 select。它是在read的基础上改进的一种方案，通过对文件描述符上的事件状态来进行判断。 select轮询具有一个较弱的限制，那就是由于它采用一个1024长度的数组来存储状态， 所以它最多可以同时检查1024个文件描述符。 poll。该方案较select有所改进，采用链表的方式避免数组长度的限制，其次它能避免不需要的检查。但是当文件描述符较多的时候，它的性能还是十分低下的。 epoll。该方案是Linux下效率最高的I/O事件通知机制，在进入轮询的时候如果没有检查到 I/O事件，将会进行休眠，直到事件发生将它唤醒。它是真实利用了事件通知、执行回调 的方式，而不是遍历查询，所以不会浪费CPU，执行效率较高 kqueue。该方案的实现方式与epoll类似，不过它仅在FreeBSD系统下存在。 现实的异步I/O通过让部分线程进行阻塞I/O或者非阻塞I/O加 轮询技术来完成数据获取，让一个线程进行计算处理，通过线程之间的通信将I/O得到的数据进 行传递，这就轻松实现了异步I/O ibeio 实质上依然是采用线程池与阻塞I/O模拟异步I/O IOCP：调用异步方法，等待I/O完成之后的通知，执行回调，用户无须考虑轮询。但是它的 内部其实仍然是线程池原理，不同之处在于这些线程池由系统内核接手管理。 Node是单线程的，这里的单线程仅仅只是 JavaScript执行在单线程中罢了。在Node中，无论是*nix还是Windows平台，内部完成I/O任务的 另有线程池。 Node 的异步 I/O事件循环、观察者、请求对象、I/O线程池这四者共同构成了Node异步I/O模型的基本要素。 Windows下主要通过IOCP来向系统内核发送I/O调用和从内核获取已完成的I/O操作，配以事 件循环，以此完成异步I/O的过程。在Linux下通过epoll实现这个过程，FreeBSD下通过kqueue实 现，Solaris下通过Event ports实现。不同的是线程池在Windows下由内核(IOCP)直接提供，*nix 系列下由libuv自行实现。 事件循环Node自身的执行模型——事件循环 每执行一次循环体的过程我 们称为Tick。每个Tick的过程就是查看是否有事件待处理，如果有，就取出事件及其相关的回调 函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不再有事件处理，就退出进程。 观察者每个事件循环中有一个或者多个观察者，而判断是否有事件要处理的过程就是向这些观察者询问 是否有要处理的事件。 观察者将事件进行分类。在Node中，事件主要来源于网络请求、文件I/O等，这些事件对应的 观察者有文件I/O观察者、网络I/O观察者等。 在Windows下，这个循环基于IOCP创建，而在*nix下则基于多线程创建。 请求对象从JavaScript发起调用到内核执行完I/O操作的 过渡过程中，存在一种中间产物，它叫做请求对象。 1234fs.open = function(path, flags, mode, callback) &#123; // ... binding.open(pathModule._makeLong(path), stringToFlags(flags),mode,callback); &#125;; 从JavaScript调用Node的核心模块，核心模块调用C++内建模块，内建模块通过libuv进行系统调用 这里libuv作为封装层，有两个平台的实现，实质上是调 用了uv_fs_open()方法。在uv_fs_open()的调用过程中，我们创建了一个FSReqWrap请求对象 回调函数则 被设置在这个对象的oncomplete_sym属性上 1req_wrap-&gt;object_-&gt;Set(oncomplete_sym, callback); 对象包装完毕后，在Windows下，则调用QueueUserWorkItem()方法将这个FSReqWrap对象推入线程池中等待执行 QueueUserWorkItem()方法接受3个参数:第一个参数是将要执行的方法的引用，这里引用的是uv_fs_thread_proc，第二个参数是uv_fs_thread_proc方法运行时所需要的参数;第三个参数是 执行的标志。 当线程池中有可用线程时，我们会调用uv_fs_thread_proc()方法。uv_fs_thread_ proc()方法会根据传入参数的类型调用相应的底层函数 至此，JavaScript调用立即返回，由JavaScript层面发起的异步调用的第一阶段就此结束。 JavaScript线程可以继续执行当前任务的后续操作。当前的I/O操作在线程池中等待执行，不管它 是否阻塞I/O，都不会影响到JavaScript线程的后续执行，如此就达到了异步的目的。 请求对象是异步I/O过程中的重要中间产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及I/O操作完毕后的回调处理 执行回调 线程池中的I/O操作调用完毕之后，会将获取的结果储存在req-&gt;result属性上，然后调用 PostQueuedCompletionStatus()通知IOCP，告知当前对象操作已经完成 1PostQueuedCompletionStatus((loop)-&gt;iocp, 0, 0, &amp;((req)-&gt;overlapped)) PostQueuedCompletionStatus()方法的作用是向IOCP提交执行状态，并将线程归还线程池。通过PostQueuedCompletionStatus()方法提交的状态，可以通过GetQueuedCompletionStatus()提取。 在每次Tick的执行中，它会调用 IOCP相关的GetQueuedCompletionStatus()方法检查线程池中是否有执行完的请求，如果存在，会将请求对象加入到I/O观察者的队列中，然后将其当做事件处理。 I/O观察者回调函数的行为就是取出请求对象的result属性作为参数，取出oncomplete_sym属性作为方法，然后调用执行，以此达到调用JavaScript中传入的回调函数的目的 非I/O的异步APII/O无关的异步API:setTimeout()、setInterval()、 setImmediate()和process.nextTick() 定时器setTimeout()和setInterval() 它们的实现原理与异步I/O比较类似，只是不需要I/O线程池的参与。 调用setTimeout()或者 setInterval()创建的定时器会被插入到定时器观察者内部的一个红黑树中。每次Tick执行时，会 从该红黑树中迭代取出定时器对象，检查是否超过定时时间，如果超过，就形成一个事件，它的 回调函数将立即执行。 process.nextTick()123456789101112131415process.nextTick = function(callback) &#123; // on the way out, don't bother. // it won't get fired anyway if (process._exiting) return; if (tickDepth &gt;= process.maxTickDepth) maxTickWarn(); var tock = &#123; callback: callback &#125;; if (process.domain) tock.domain = process.domain; nextTickQueue.push(tock); if (nextTickQueue.length) &#123; process._needTickCallback(); &#125;&#125;; 每次调用process.nextTick()方法，只会将回调函数放入队列中，在下一轮Tick时取出执行。 定时器中采用红黑树的操作时间复杂度为O(lg(n))，nextTick()的时间复杂度为O(1)。相较之下，process.nextTick()更高效。 setImmediate()1234567process.nextTick(function () &#123; console.log('nextTick延迟执行');&#125;);setImmediate(function () &#123; console.log('setImmediate延迟执行'); &#125;);console.log('正常执行'); 其执行结果如下: 123正常执行 nextTick延迟执行 setImmediate延迟执行 process.nextTick()中的回调函数执行的优先级要高于setImmediate()。 原因在于事件循环对观察者的检查是有先后顺序的，process.nextTick()属于idle观察者， setImmediate()属于check观察者。在每一个轮循环检查中，idle观察者先于I/O观察者，I/O观察者先于check观察者。 process.nextTick()的回调函数保存在一个数组中，setImmediate()的结果 则是保存在链表中 在行为上，process.nextTick()在每轮循环中会将数组中的回调函数全部执行完，而setImmediate()在每轮循环中执行链表中的一个回调函数。 之所以这样设计，是为了保证每轮循环能够较快地执行结束，防止CPU占用过多而阻塞后续I/O 调用的情况。 事件驱动与高性能服务器事件驱动的实质： 通过主循环加事件触发的方式来运行程序。 几种经典的服务器模型，对比优缺点 同步式。对于同步式的服务，一次只能处理一个请求，并且其余请求都处于等待状态。 每进程/每请求。为每个请求启动一个进程，这样可以处理多个请求，但是它不具备扩展性，因为系统资源只有那么多。 每线程/每请求。为每个请求启动一个线程来处理。尽管线程比进程要轻量，但是由于每个线程都占用一定内存，当大并发请求到来时，内存将会很快用光，导致服务器缓慢。 高性能：Node通过事件驱动的方式处理请求，无须为 每一个请求创建额外的对应线程，可以省掉创建线程和销毁线程的开销，同时操作系统在调度任 务时因为线程较少，上下文切换的代价很低。这使得服务器能够有条不紊地处理请求，即使在大量连接的情况下，也不受线程上下文切换开销的影响，这是Node高性能的一个原因。","categories":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/categories/Node-js/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"http://yoursite.com/tags/Node-js/"}]},{"title":"scrollWidth,clientWidth,offsetWidth的区别","slug":"scrollWidth,clientWidth,offsetWidth的区别","date":"2019-12-07T14:01:34.000Z","updated":"2019-12-29T07:11:43.885Z","comments":true,"path":"2019/12/07/scrollWidth,clientWidth,offsetWidth的区别/","link":"","permalink":"http://yoursite.com/2019/12/07/scrollWidth,clientWidth,offsetWidth的区别/","excerpt":"","text":"scrollWidth,clientWidth,offsetWidth的区别总体说明元素对象： offsetLeft、offsetTop属性：获取元素相对于文档左上角的坐标位置。 scrollWidth：对象的实际内容的宽度，不包括边线宽度，会随对象中内容超过可视区后而变大。 scrollWidth=元素的width+padding clientWidth：对象内容的可视区的宽度，不包括滚动条等边线，会随对象显示大小的变化而改变。 clientWidth=元素的width+padding offsetWidth：对象整体的实际宽度，包括滚动条等边线，会随对象显示大小的变化而改变。 offsetWidth=元素的width+padding+border ###window对象： innerWidth：窗口中文档显示区域的宽度，不包括菜单栏、工具栏等部分。该属性可读可写。浏览器窗口的内部宽度（对于IE9+、Chrome、Firefox、Opera 以及 Safari） pageXOffset：整数只读属性，表示文档向右滚动过的像素数。IE不支持该属性，使用body元素的scrollLeft属性替代。 ##情况一 元素内无内容或者内容不超过可视区，滚动不出现或不可用的情况下。 scrollWidth=clientWidth，两者皆为内容可视区的宽度。 offsetWidth为元素的实际宽度。 ##情况二 元素的内容超过可视区，滚动条出现和可用的情况下。 scrollWidth&gt;clientWidth。 scrollWidth为实际内容的宽度。 clientWidth是内容可视区的宽度。 offsetWidth是元素的实际宽度。 针对文档(document)的各个height、width、top、left的说明 针对网页中一个div的各个属性值的说明","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"循环中的异步操作问题小结","slug":"JS事件机制 copy","date":"2019-11-26T05:29:24.000Z","updated":"2019-11-26T05:36:52.906Z","comments":true,"path":"2019/11/26/JS事件机制 copy/","link":"","permalink":"http://yoursite.com/2019/11/26/JS事件机制 copy/","excerpt":"","text":"循环中的异步操作问题小结循环的异步操作主要有两个问题： 如何确保循环的所有异步操作完成之后执行某个其他操作 循环中的下一步操作依赖于前一步的操作，如何解决 不需等待结果要处理这个问题，我们可以把这个匿名函数定义为异步的： 123456async function processArray(array)&#123; array.forEach(async (item)=&gt;&#123; await delayedLog(item) &#125;) console.log('Done!')&#125; 但是这样的话 forEach 方法就相当于异步的了，不会等待遍历完所有的 item 将会输出： 1234Done!123 如果你不需要等待这个循环完成，这样就已经可以了。但是大部分情况我们还是需要等待这个循环完成才进行之后的操作。 如何确保循环的所有异步操作完成之后执行某个其他操作方法一：设置一个flag，在每个异步操作中对flag进行检测123456789let flag = 0;for(let i = 0; i &lt; len; i++) &#123; flag++; Database.save_method().exec().then((data) =&gt; &#123; if(flag === len) &#123; // your code &#125; &#125;)&#125; 方法二：将所有的循环放在一个promise中，使用then处理123456789 new Promise(function(resolve)&#123; resolve() &#125;).then(()=&gt; &#123; for(let i = 0; i &lt; len; i++) &#123; Database.save_method().exec() &#125;&#125;).then(() =&gt; &#123; // your code&#125;) 方法三：串行遍历要等待所有的结果返回，我们还是要回到老式的 for 循环写法： 123456async function processArray(array)&#123; for(const item of array)&#123; await delayedLog(item) &#125; console.log('Done!')&#125; 最后的结果符合我们的预期： 1234123Done! 方法四：并行遍历 123456async function processArray(array)&#123; //map array to promise const promises=array.map(delayedLog) await Promise.all(promises) console.log('Done!')&#125; （注意：对于特别大的数组不建议使用这种写法，太多的并行任务会加重 CPU 和内存的负荷） 循环中的下一步操作依赖于前一步的操作，如何解决方法一：使用递归，在异步操作完成之后调用下一次异步操作123456function loop(i)&#123; i++; Database.save_method().exec().then(() =&gt; &#123; loop(i) &#125;)&#125; 方法二：使用async和await（串行遍历）12345async function loop() &#123; for(let i = 0; i &lt; len; i++) &#123; await Database.save_method().exec(); &#125;&#125; 如何优雅地写js异步循环循环的方式假设我们有个数组，包含 5 个数字：let times = [100, 150, 200, 250, 300]；还有一个异步的睡觉方法：sleep(time, cb)。 123456789101112import Promise from 'bluebird';// 当没有 cb 时，返回一个 Promise 对象export default function sleep(time, cb) &#123; if (cb) &#123; setTimeout(cb, time); &#125; else &#123; return new Promise(resolve =&gt; &#123; setTimeout(resolve, time); &#125;); &#125;&#125;; 现在要去循环睡这几个数字，问你有哪些睡法？🤔 为了方便交流，我就给这几个睡法起个名字： All in：你如果赶时间又不担心消耗过度，你可以一次性都睡了； One by one：你想细水长流，你可以一个一个睡； With concurrency：你害羞地低下头，说一次能不能睡两个。 作为一段有节操的代码，肯定要告诉其他人你睡完了，也就是必须有全部完成的回调，否则我们接下来的交流会毫无意义。 本文目的是和大家探讨如何写出优雅的异步循环代码，并不是去实现这些循环控制的逻辑；而保持代码优雅，个人以为最好的办法是使用较新的语言特性，其次是使用优秀的开源项目，最后才是自己撸。下面会使用 Async、Promise(bluebird) 和 ES7 中的 async/await 对比下实现这几种循环的区别。 All in 这种方式效率是最高的，耗时取决于循环中最慢的那个异步方法。对资源的消耗也是最大的，如果大量循环请求后端服务，很有可能造成瞬时拥堵的情况。 如果自己实现，这也是最简单的场景，加一个完成计数器，每个异步方法完就给这个完成计数器加 1，然后检查完成数是不是等于数组长度，一旦相等就表示所有的异步方法执行完毕，通知全部完成的回调。 使用 async.each：1234567891011121314import &#123; each &#125; from 'async'; import sleep from './sleep';let times = [100, 150, 200, 250, 300];console.log('sleep start'); console.time('async all in'); each(times, sleep, (err) =&gt; &#123; console.timeEnd('async all in'); console.log('sleep complete');&#125;);// sleep start// async all in: 304.627ms// sleep complete 使用 Promise.all：1234567891011121314import Promise from 'bluebird'; import sleep from './sleep';let times = [100, 150, 200, 250, 300];console.log('sleep start'); console.time('promise all in'); Promise.all(times.map(time =&gt; sleep(time))).then(() =&gt; &#123; console.timeEnd('promise all in'); console.log('sleep complete');&#125;);// sleep start// promise all in: 305.509ms// sleep complete 使用ES7 async/await：1234567891011121314import sleep from './sleep';let times = [100, 150, 200, 250, 300];(async function() &#123; console.log('sleep start'); console.time('es7 all in'); for await (let i of times.map(time =&gt; sleep(time))) &#123;&#125; console.timeEnd('es7 all in'); console.log('sleep complete');&#125;());// sleep start// es7 all in: 305.986ms// sleep complete One by one 这种方式效率最低，有点类似于同步语言中的循环，一个接着一个执行，耗时自然也就是所有异步方法耗时的总和。对资源的消耗最小。 这个实现起来也比较简单，把数组看做一个队列，每次从队列shift出一个代入异步方法执行，执行完成就开始递归调用这个过程，当队列长度为空就表示所有的异步方法执行完毕，结束递归，通知全部完成的回调。 使用 async.eachSeries：1234567891011121314import &#123; eachSeries &#125; from 'async'; import sleep from './sleep';let times = [100, 150, 200, 250, 300];console.log('sleep start'); console.time('async one by one'); eachSeries(times, sleep, (err) =&gt; &#123; console.timeEnd('async one by one'); console.log('sleep complete');&#125;);// sleep start// async one by one: 1020.078ms// sleep complete 使用 Promise.reduce：12345678910111213141516import Promise from 'bluebird'; import sleep from './sleep';let times = [100, 150, 200, 250, 300];console.log('sleep start'); console.time('promise one by one'); Promise.reduce(times, (last, curr) =&gt; &#123; return sleep(curr);&#125;, 0).then(() =&gt; &#123; console.timeEnd('promise one by one'); console.log('sleep complete');&#125;);// sleep start// promise one by one: 1023.014ms// sleep complete 使用ES7 async/await：12345678910111213141516import sleep from './sleep';let times = [100, 150, 200, 250, 300];(async function() &#123; console.log('sleep start'); console.time('es7 one by one'); for (let time of times) &#123; await sleep(time); &#125; console.timeEnd('es7 one by one'); console.log('sleep complete');&#125;());// sleep start// es7 one by one: 1025.513ms// sleep complete With concurrency这种方式稍微复杂些，但也是最灵活的方式，可以随心控制并发数。效率和耗时取决于魔法数字 concurrency，当 concurrency 大于或等于数组长度时，它就等同于 All in 方式；当 concurrency 为 1 时，它就等同于 One by one 方式。所以耗时和对资源的消耗都会介于以上两种方式之间。 With concurrency 本身在实现上也会有不同的方式，分别是预分组和任务池。 预分组 顾名思义，就是提前将数组内容按 concurrency 分好组，组内是以 All in 方式执行，组之间则是以 One by one 的方式执行。 就以上文的例子，假如 concurrency 为 2，times 预先分组成：[[100, 150], [200, 250], [300]]，这样耗时会是 700（150 + 250 + 300）。 这个实现方式可以有效地控制并发数，优点就是简单，缺点是并不能达到效率最大化。 任务池 任务池的方式就是设置一个容量为 concurrency 的池子，比如容量为 2，初始化放入两个任务，每当有任务完成，就继续往池子添加新的任务，直到所有任务都完成。上文的例子执行过程大致如下： time = 0; pool = [100, 150]：放入 100 和 150 time = 100; pool = [150, 200]：100 结束，放入 200 time = 150; pool = [200, 250]：150 结束，放入 250 time = 300; pool = [250, 300]：200 结束，放入 300 time = 400; pool = [300]：250 结束，没有更多任务 time = 600; pool = []：300 结束，循环完毕 得出来的耗时是 600，比预分组的方式效率更高，而且同样能有效控制并发个数。async 和 bluebird 也有相关的方法供直接使用。 使用 async.eachLimit：1234567891011121314import &#123; eachLimit &#125; from 'async'; import sleep from './sleep';let times = [100, 150, 200, 250, 300];console.log('sleep start'); console.time('async with concurrency'); eachLimit(times, 2, sleep, (err) =&gt; &#123; console.timeEnd('async with concurrency'); console.log('sleep complete');&#125;);// sleep start// async with concurrency: 611.498ms// sleep complete 使用 Promise.map（bluebird 特有 api）：123456789101112131415161718import Promise from 'bluebird'; import sleep from './sleep';let times = [100, 150, 200, 250, 300];console.log('sleep start'); console.time('promise one by one'); Promise.map(times, (time) =&gt; &#123; return sleep(time);&#125;, &#123; concurrency: 2&#125;).then(() =&gt; &#123; console.timeEnd('promise one by one'); console.log('sleep complete');&#125;);// sleep start// promise with concurrency: 616.601ms// sleep complete 使用ES7 async/await： pool 方法来自davetemplin/async-parallel 12345678910111213141516171819202122232425262728293031323334353637383940414243444546import sleep from './sleep';let times = [100, 150, 200, 250, 300];(async function() &#123; console.log('sleep start'); console.time('es7 with concurrency'); await pool(2, async () =&gt; &#123; await sleep(times.shift()); return times.length &gt; 0; &#125;); console.timeEnd('es7 with concurrency'); console.log('sleep complete');&#125;());async function pool(size, task) &#123; var active = 0; var done = false; var errors = []; return new Promise((resolve, reject) =&gt; &#123; next(); function next() &#123; while (active &lt; size &amp;&amp; !done) &#123; active += 1; task() .then(more =&gt; &#123; if (--active === 0 &amp;&amp; (done || !more)) errors.length === 0 ? resolve() : reject(errors); else if (more) next(); else done = true; &#125;) .catch(err =&gt; &#123; errors.push(err); done = true; if (--active === 0) reject(errors); &#125;); &#125; &#125; &#125;);&#125;// sleep start// es7 with concurrency: 612.197ms// sleep complete 总结好了，到这应该可以给这三种循环方式打下分了： 循环方式 效率 消耗 灵活度 复杂度 All in 高 高 低 低 One by one 低 低 低 低 With concurrency 中 中 高 高 乍一看 With concurrency 是完胜，其实并没有。All in 和 One by one 虽然灵活度低，但是应用的场景还是非常广泛的。要求效率优先就使用 All in；如果有下一次循环依赖上一次循环结果的场景，就必须使用 One by One。 再说下上面 async、bluebird、ES7 对这三种循环方式的实现。需求一直在变，async 需要修改的代码非常少，甚至只要改下方法名就可以，方法定义简单优雅，这可能也是 async 易上手的原因；bluebird 在 Promise 标准基础上添加的方法非常实用，如：map、join…，以至于我几乎是没有使用过原生 Promise 😂；ES7 新增的 async/await 语法特性确实减轻了编写异步代码的痛苦，同时还增强了代码的可读性。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"伪类和伪元素","slug":"伪类和伪元素","date":"2019-11-16T11:40:32.000Z","updated":"2019-11-16T11:49:57.412Z","comments":true,"path":"2019/11/16/伪类和伪元素/","link":"","permalink":"http://yoursite.com/2019/11/16/伪类和伪元素/","excerpt":"","text":"伪类和伪元素css引入伪类和伪元素概念是为了格式化文档树以外的信息。也就是说，伪类和伪元素是用来修饰不在文档树中的部分。 伪类用于当已有元素处于的某个状态时，为其添加对应的样式，这个状态是根据用户行为而动态变化的。比如说，当用户悬停在指定的元素时，我们可以通过:hover来描述这个元素的状态。虽然它和普通的css类相似，可以为已有的元素添加样式，但是它只有处于dom树无法描述的状态下才能为元素添加样式，所以将其称为伪类。 伪元素用于创建一些不在文档树中的元素，并为其添加样式。比如说，我们可以通过:before来在一个元素前增加一些文本，并为这些文本添加样式。虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。 伪类的效果可以通过添加一个实际的类来达到，而伪元素的效果则需要通过添加一个实际的元素才能达到，这也是为什么他们一个称为伪类，一个称为伪元素的原因。 伪类和伪元素的根本区别在于：它们是否创造了新的元素,, 这个新创造的元素就叫 “伪无素” 。 ##伪类 伪类前面是一个冒号，E:first-child会对现有的元素进行筛选 :link:选择未访问的链接 :visited:选择已访问的链接 :hover:选择鼠标指针浮动在其上的元素 :active:选择活动的链接 :focus:选择获取焦点的输入字段 :not():一个否定伪类，用于匹配不符合参数选择器的元素。 :first-child:匹配元素的第一个子元素。 :last-child:匹配元素的最后一个子元素。 :first-of-type:匹配属于其父元素的首个特定类型的子元素的每个元素。 :last-of-type:匹配属于其父元素的最后一个特定类型的子元素的每个元素。 :nth-child::nth-child根据元素的位置匹配一个或者多个元素，它接受一个 an+b 形式的参数，an+b 匹配到的元素 :nth-last-child::nth-last-child 与:nth-child相似，不同之处在于它是从最后一个子元素开始计数的。 :nth-of-type::nth-of-type 与 nth-child相似，不同之处在于它是只匹配特定类型的元素。 :nth-last-type::nth-last-of-type 与 nth-of-type相似，不同之处在于它是从最后一个子元素开始计数的。 :only-child :当元素是其父元素中唯一一个特定类型的子元素时，:only-child匹配该元素。 :target :当URL带有锚名称，指向文档内某个具体的元素时，:target匹配该元素。 :checked::checked匹配被选中的 input 元素，这个 input 元素包括 radio 和 checkbox。 :default: 匹配默认选中的元素 :disabled: 匹配禁用的表单元素。 :empty :匹配没有子元素的元素 :enabled: 匹配没有设置 disabled 属性的表单元素。 :in-range: 匹配在指定区域内元素。 :out-of-range: 与:in-range相反，它匹配不在指定区域内的元素。 :indeterminate:indeterminate 的英文意思是“ 不确定的”。当某组中的单选框或复选框还没有选取状态时，:indeterminate 匹配该组中所有的单选框或复选框。 :valid :匹配条件验证正确的表单元素。 :invalid: 与:valid 相反，匹配条件验证错误的表单元素。 :optional:匹配是具有 optional 属性的表单元素。当表单元素没有设置为 required 时，即为 optional 属性。 :required: 与:optional相反匹配设置了 required 属性的表单元素。 :read-only: 匹配设置了只读属性的元素，表单元素可以通过设置“readonly” 属性来定义元素只读。 :read-write: 匹配处于编辑状态的元素。input，textarea 和设置了 contenteditable 的 HTML 元素获取焦点时即处于编辑状态。 :scope: 匹配处于 style 作用域下的元素。当 style 没有设置 scope 属性时，style 内的样式会对整个 html 起作用。 :dir:匹配指定阅读方向的元素，当 HTML 元素中设置了 dir 属性时该伪类才能生效。现时支持的阅读方向有两种：ltr（从左往右）和 rtl（从右往左）。目前，只有火狐浏览器支持:dir 伪类，并在火狐浏览器中使用时需要添加前缀 ( -moz-dir() )。 :lang:匹配设置了特定语言的元素，设置特定语言可以通过为了 HTML 元素设置 lang=”” 属性，设置 meta 元素的 charset=”” 属性，或者是在 http 头部上设置语言属性。 实际上，lang=”” 属性不只可以在 html 标签上设置，也可以在其他的元素上设置。 :root:匹配文档的根元素。一般的 html 文件的根元素是 html 元素，而 SVG 或 XML 文件的根元素则可能是其他元素。 :fullscreen: 匹配处于全屏模式下的元素。全屏模式不是通过按 F11 来打开的全屏模式，而是通过 Javascript 的 Fullscreen API 来打开的，不同的浏览器有不同的 Fullscreen API。目前，:fullscreen 需要添加前缀才能使用。 ##伪元素 伪元素前面是两个冒号，E::first-line会创造出不存在的新元素，由于css对单冒号的伪元素也支持，所以这样很容易让新学者混淆。但实际上现在css3已经明确规定了伪类单冒号，伪元素双冒号的规则。 ::before/:before在被选元素前插入内容。需要使用 content 属性来指定要插入的内容。被插入的内容实际上不在文档树中。 ::after/:after 在被元素后插入内容，其用法和特性与:before相似。 对于伪元素 :before 和 :after 而言，属性 content 是必须设置的，我们知道属性的值可以为字符串，也可以有其它形式，比如指向一张图片的 URL: content: url(&#39;img/icon.png&#39;) ::first-letter/:first-letter 匹配元素中文本的首字母。被修饰的首字母不在文档树中 ::first-line/:first-line 匹配元素中第一行的文本。这个伪元素只能用在块元素中，不能用在内联元素中。 ::selection 匹配用户被用户选中或者处于高亮状态的部分。在火狐浏览器使用时需要添加-moz前缀。该伪元素只支持双冒号的形式。 ::placeholder 匹配占位符的文本，只有元素设置了placeholder属性时，该伪元素才能生效。 伪元素不是CSS的标准，它的实现可能在将来会有所改变，所以要决定使用时必须谨慎。在一些浏览器中（IE10和Firefox18及其以下版本）会使用单冒号的形式。 ::backdrop 用于改变全屏模式下的背景颜色，全屏模式的默认颜色为黑色。该伪元素只支持双冒号的形式 注意： 配合伪类使用 伪元素 :before 还可以配合伪类使用，这里举经常与 :before 配合使用的伪类 :hover 为例： 12.before:hover:before&#123;content:'you before'; color:red;&#125;&lt;div class=\"before\"&gt; me&lt;/div&gt; 配合取值函数 attr() 使用 12345a::before&#123;content: attr(title)&#125;&lt;a href=\"https://blog.ihoey.com\" title=\"梦魇小栈\"&gt;&lt;/a&gt;效果&lt;a href=\"https://blog.ihoey.com\" title=\"梦魇小栈\"&gt;梦魇小栈&lt;/a&gt;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"伪元素","slug":"伪元素","permalink":"http://yoursite.com/tags/伪元素/"},{"name":"伪类","slug":"伪类","permalink":"http://yoursite.com/tags/伪类/"}]},{"title":"sass&less对比","slug":"sass&less对比","date":"2019-11-11T06:09:00.000Z","updated":"2019-11-10T15:36:08.788Z","comments":true,"path":"2019/11/11/sass&less对比/","link":"","permalink":"http://yoursite.com/2019/11/11/sass&less对比/","excerpt":"","text":"sass&amp;less##为什么要使用 CSS 预处理器？ 作为前端开发人员，大家都知道，Js 中可以自定义变量，而 CSS 仅仅是一个标记语言，不是编程语言，因此不可以自定义变量，不可以引用等等。 CSS 有具体以下几个缺点： 语法不够强大，比如无法嵌套书写，导致模块化开发中需要书写很多重复的选择器； 没有变量和合理的样式复用机制，使得逻辑上相关的属性值必须以字面量的形式重复输出，导致难以维护。 这就导致了我们在工作中无端增加了许多工作量。而使用 CSS 预处理器，提供 CSS 缺失的样式层复用机制、减少冗余代码，提高样式代码的可维护性。大大提高了我们的开发效率。 但是，CSS 预处理器也不是万金油，CSS 的好处在于简便、随时随地被使用和调试。预编译 CSS 步骤的加入，让我们开发工作流中多了一个环节，调试也变得更麻烦了。更大的问题在于，预编译很容易造成后代选择器的滥用。 所以我们在实际项目中衡量预编译方案时，还是得想想，比起带来的额外维护开销，CSS 预处理器有没有解决更大的麻烦。 主要区别：首先 sass 和 less 都是 css 的预编译处理语言，他们引入了 mixins，参数，嵌套规则，运算，颜色，名字空间，作用域，JavaScript 赋值等 加快了 css 开发效率,当然这两者都可以配合 gulp 和 grunt 等前端构建工具使用 sass 和 less主要区别:在于实现方式 less 是基于 JavaScript 的在客户端处理 所以安装的时候用 npm，sass 是基于 ruby 所以在服务器处理。 SASS 介绍Sass 是 Ruby 开发者为前端开发提供的处理 CSS 的工具。它为 CSS 提供更动态的设定方式，允许编译、变量、函数……总之，使 CSS 更动态，也更像一门真正的可编程语言。 Sass 是基于 Ruby 开发的，所以开发环境首先需要安装 Ruby。 浏览器中无法编译 Sass，所以要先编译好 css 文件，再交给浏览器。Sass不能在浏览器环境中直接运行。 ##Less 介绍 Less 是晚些产生的语言，基于 JS 进行开发，在 Node 中进行编译。所以使用时不需要安装其他语言，不过要记得先导入 less 文件，然后导入 less.js。提供 CDN 地址在这里： 12&lt;script src=\"https://cdn.bootcss.com/less.js/3.0.4/less.js\"&gt;&lt;/script&gt;&lt;script src=\"https://cdn.bootcss.com/less.js/3.0.4/less.min.js\"&gt;&lt;/script&gt; 当然 Less 也提供服务器端的编译功能。 Stylus 介绍Stylus相对前两者较新，可以看官方文档介绍的功能。 1.来自 NodeJS 社区，所以和 NodeJS 走得很近，与 JavaScript 联系非常紧密。还有专门 JavaScript API：learnboost.github.io/stylus/docs… 2.支持 Ruby 之类等等框架 3.更多更强大的支持和功能 以 stylus 的角度来说,stylus 更加注重对 javascript( learnboost.github.io/stylus/docs… ) 的利用。 当用户觉得写 stylus 函数遇到了过于复杂或者无法测试，stylus 语法不支持等需求时， 也可以直接用 js 来实现这个函数并且在 stylus 中调用。 其次从编译器源码上来看：stylus 应该比 less.js 更有条理， 感觉如果未来社区添加功能的话，stylus 的源码添加起功能来会更简单，同样，目前 stylus 的功能也更复杂。 stylus 和 sass 另一个区别在于 sass 本身会建议，以下划线(_) 打头的文件在静态资源打包的时候不会被编译成 .css 文件【只是作为一种 import 存在】。而 stylus 没有这方面的规范。 同时写过 stylus 和 sass， 就语法简洁来看， stylus 在这方面占了很大的便宜。 三者对比 变量 Sass: $varLess: @var两种语言都会有作用域的问题。一个变量只能在它被定义的代码块中使用。重复定义的变量会报错。 Stylus 对变量名没有任何限定，你可以是 $ 开始，也可以是任意的字符，而且与变量值之间可以用冒号、空格隔开，需要注意的是 Stylus (0.22.4) 将会编译 @ 开始的变量，但其对应的值并不会赋予该变量，换句话说，在 Stylus 的变量名不要用 @ 开头。 运算赋值： 只要保持单位统一或可相互转换，就可以进行运算，包括颜色在内：Sass: 12345678910111213p &#123; cursor: e + -resize;&#125;// 编译为// p &#123;// cursor: e-resize;// &#125;body &#123; margin: (14px/2); top: 50px + 100px; right: $var * 10%;&#125; Less: 12345678910111213@base: 5%;@filler: @base * 2;@other: @base + @filler;color: #888 / 4;background-color: @base-color + #111;height: 100% / 2 + @filler;@var: 1px + 5;width: (@var + 5) * 2;border: (@width * 2) solid black; 嵌套 Sass 和 Less 均允许元素嵌套。如果父子选择器均用逗号分开，那么编译时会按结合律拆开编译。Sass 和 Less 指代上层元素均使用&amp;符号。 继承 Sass 中，写好的选择器进行集成，需要@extend关键字。（sytlus 与 sass 相同）Less 中，直接写入即可：.be-extend-class; Mixin Sass 中，需要进行 Mixin 操作的选择器需要@mixin关键字，选择器后可以传入变量和默认值。 1@mixin left($value: 10px) padding: $value; 使用时使用@include关键字，并可以更新变量： 1@include left @include left(20px); Less 中 Mixin 和继承感觉更相似，选择器在书写时就留好了变量，直接继承或更新变量即可： 123456.be-extend-class(@width: 10px) &#123; padding: @width;&#125;// 使用.be-extend-class;.be-extend-class(20px); sass：在 sass 定义 Mixins 和 less、stylus 有所不同，在声明 Mixins 时需要使用“@mixin”,然后后面紧跟 Mixins 的名，他也可以定义参数，同时可以给这个参数设置一个默认值，但参数名是使用“$”符号开始，而且和参数值之间需要使用冒号（：）分开。另外在 sass 中调用 Mixins 需要使用“@include”，然后在其后紧跟你要调用的 Mixins 名。 less：less 中声明 Mixins 和 CSS 定义样式非常类似，可以将 Mixins 看成是一个选择器，当然 Mixins 也可以设置参数，并给参数设置默认值。不过设置参数的变量名是使用“@”开始，同样参数和默认参数值之间需要使用冒号（：）分开。 stylus：stylus 和前两者也略有不同，他可以不使用任何符号，就是直接定义 Mixins 名，然后在定义参数和默认值之间用等号（=）来连接。 注释 两种语言相同：多行注释格式可保留，单行注释格式会在编译时被删除。 12/* 会被保留的注释格式 */// 不保存的注释格式 颜色运算： CSS 预处理器提供一系列颜色函数帮助生成主题系列颜色：Sass： 1234lighten(#cc3, 10%) // #d6d65cdarken(#cc3, 10%) // #a3a329grayscale(#cc3) // #808080 灰度complement(#cc3) // #33c Less： 1234567891011121314lighten(@color, 10%); // return a color which is 10% *lighter* than @colordarken(@color, 10%); // return a color which is 10% *darker* than @colorsaturate(@color, 10%); // return a color 10% *more* saturated than @colordesaturate(@color, 10%); // return a color 10% *less* saturated than @colorfadein(@color, 10%); // return a color 10% *less* transparent than @colorfadeout(@color, 10%); // return a color 10% *more* transparent than @colorfade(@color, 50%); // return @color with 50% transparencyspin(@color, 10); // return a color with a 10 degree larger in hue than @colorspin(@color, -10); // return a color with a 10 degree smaller hue than @colormix(@color1, @color2); // return a mix of @color1 and @color2 stylus： 1234lighten(color, 10%); /* 返回的颜色在'color'基础上变亮10% */darken(color, 10%); /* 返回的颜色在'color'基础上变暗10% */saturate(color, 10%); /* 返回的颜色在'color'基础上饱和度增加10% */desaturate(color, 10%); /* 返回的颜色在'color'基础上饱和度降低10% */ 插入文件 两种语言相同，使用@import 关键字引入。注意后缀名，可以直接导入 css 文件。后缀名为 css 的文件不会被预处理器处理。 1234@import \"path/filename.scss\";@import \"lib.less\";@import \"lib.css\"; ==高级语法：== SASS在 Sass 中，需要用 Sass 自己的一套语言编程： 条件 if-else 12345@if lightness($color) &gt; 30% &#123; background-color: #000;&#125; @else &#123; background-color: #fff;&#125; 循环 for: 12345@for $i from 1 to 10 &#123; .border-#&#123;$i&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125; while: 1234567$i: 6;@while $i &gt; 0 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125; $i: $i - 2;&#125; each: 12345@each $member in a, b, c, d &#123; .#&#123;$member&#125; &#123; background-image: url(\"/image/#&#123;$member&#125;.jpg\"); &#125;&#125; 自定义函数 需要@function、@return关键字。 1234567@function double($n) &#123; @return $n * 2;&#125;#sidebar &#123; width: double(5px);&#125; LessLess 是使用 JS 作为编译环境的，所以它支持 JS 语法。 字符串插值 12@base-url: \"http://assets.fnord.com\";background-image: url(\"@&#123;base-url&#125;/images/bg.png\"); 用反引号使用 JS 语法： 1@var: ` \"hello\" .toUpperCase() + \"!\" `; 直接访问 JS 环境 1@height: `document.body.clientHeight`;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"SASS","slug":"SASS","permalink":"http://yoursite.com/tags/SASS/"},{"name":"LESS","slug":"LESS","permalink":"http://yoursite.com/tags/LESS/"}]},{"title":"oh-my-zsh git 命令缩写","slug":"oh-my-zsh git 命令缩写","date":"2019-11-05T13:08:23.000Z","updated":"2019-11-10T14:37:39.026Z","comments":true,"path":"2019/11/05/oh-my-zsh git 命令缩写/","link":"","permalink":"http://yoursite.com/2019/11/05/oh-my-zsh git 命令缩写/","excerpt":"","text":"#oh-my-zsh git 命令缩写 喜欢用 git 命令行，平时能少打几个字还是会节省不少时间的。 常用123456789101112131415161718alias ga='git add'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gcam='git commit -a -m'alias gcb='git checkout -b'alias gco='git checkout'alias gcp='git cherry-pick'alias gd='git diff'alias gfo='git fetch origin'alias ggpush='git push origin $(git_current_branch)'alias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'alias glgp='git log --stat -p'alias gm='git merge'alias gp='git push'alias gst='git status'alias gsta='git stash save'alias gstp='git stash pop' 全部参考：https://github.com/robbyrussell/oh-my-zsh/blob/master/plugins/git/git.plugin.zsh 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201alias g='git'alias ga='git add'alias gaa='git add --all'alias gapa='git add --patch'alias gau='git add --update'alias gb='git branch'alias gba='git branch -a'alias gbd='git branch -d'alias gbda='git branch --no-color --merged | command grep -vE \"^(\\*|\\s*(master|develop|dev)\\s*$)\" | command xargs -n 1 git branch -d'alias gbl='git blame -b -w'alias gbnm='git branch --no-merged'alias gbr='git branch --remote'alias gbs='git bisect'alias gbsb='git bisect bad'alias gbsg='git bisect good'alias gbsr='git bisect reset'alias gbss='git bisect start'alias gc='git commit -v'alias gc!='git commit -v --amend'alias gcn!='git commit -v --no-edit --amend'alias gca='git commit -v -a'alias gca!='git commit -v -a --amend'alias gcan!='git commit -v -a --no-edit --amend'alias gcans!='git commit -v -a -s --no-edit --amend'alias gcam='git commit -a -m'alias gcsm='git commit -s -m'alias gcb='git checkout -b'alias gcf='git config --list'alias gcl='git clone --recursive'alias gclean='git clean -fd'alias gpristine='git reset --hard &amp;&amp; git clean -dfx'alias gcm='git checkout master'alias gcd='git checkout develop'alias gcmsg='git commit -m'alias gco='git checkout'alias gcount='git shortlog -sn'compdef _git gcountalias gcp='git cherry-pick'alias gcpa='git cherry-pick --abort'alias gcpc='git cherry-pick --continue'alias gcs='git commit -S'alias gd='git diff'alias gdca='git diff --cached'alias gdct='git describe --tags `git rev-list --tags --max-count=1`'alias gdt='git diff-tree --no-commit-id --name-only -r'alias gdw='git diff --word-diff'gdv() &#123; git diff -w \"$@\" | view - &#125;compdef _git gdv=git-diffalias gf='git fetch'alias gfa='git fetch --all --prune'alias gfo='git fetch origin'function gfg() &#123; git ls-files | grep $@ &#125;compdef _grep gfgalias gg='git gui citool'alias gga='git gui citool --amend'ggf() &#123; [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push --force origin \"$&#123;b:=$1&#125;\"&#125;compdef _git ggf=git-checkoutggl() &#123; if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git pull origin \"$&#123;*&#125;\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull origin \"$&#123;b:=$1&#125;\" fi&#125;compdef _git ggl=git-checkoutggp() &#123; if [[ \"$#\" != 0 ]] &amp;&amp; [[ \"$#\" != 1 ]]; then git push origin \"$&#123;*&#125;\" else [[ \"$#\" == 0 ]] &amp;&amp; local b=\"$(git_current_branch)\" git push origin \"$&#123;b:=$1&#125;\" fi&#125;compdef _git ggp=git-checkoutggpnp() &#123; if [[ \"$#\" == 0 ]]; then ggl &amp;&amp; ggp else ggl \"$&#123;*&#125;\" &amp;&amp; ggp \"$&#123;*&#125;\" fi&#125;compdef _git ggpnp=git-checkoutggu() &#123; [[ \"$#\" != 1 ]] &amp;&amp; local b=\"$(git_current_branch)\" git pull --rebase origin \"$&#123;b:=$1&#125;\"&#125;compdef _git ggu=git-checkoutalias ggpur='ggu'compdef _git ggpur=git-checkoutalias ggpull='git pull origin $(git_current_branch)'compdef _git ggpull=git-checkoutalias ggpush='git push origin $(git_current_branch)'compdef _git ggpush=git-checkoutalias ggsup='git branch --set-upstream-to=origin/$(git_current_branch)'alias gpsup='git push --set-upstream origin $(git_current_branch)'alias ghh='git help'alias gignore='git update-index --assume-unchanged'alias gignored='git ls-files -v | grep \"^[[:lower:]]\"'alias git-svn-dcommit-push='git svn dcommit &amp;&amp; git push github master:svntrunk'compdef _git git-svn-dcommit-push=gitalias gk='\\gitk --all --branches'compdef _git gk='gitk'alias gke='\\gitk --all $(git log -g --pretty=%h)'compdef _git gke='gitk'alias gl='git pull'alias glg='git log --stat'alias glgp='git log --stat -p'alias glgg='git log --graph'alias glgga='git log --graph --decorate --all'alias glgm='git log --graph --max-count=10'alias glo='git log --oneline --decorate'alias glol=\"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit\"alias glola=\"git log --graph --pretty='%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit --all\"alias glog='git log --oneline --decorate --graph'alias gloga='git log --oneline --decorate --graph --all'alias glp=\"_git_log_prettily\"compdef _git glp=git-logalias gm='git merge'alias gmom='git merge origin/master'alias gmt='git mergetool --no-prompt'alias gmtvim='git mergetool --no-prompt --tool=vimdiff'alias gmum='git merge upstream/master'alias gp='git push'alias gpd='git push --dry-run'alias gpoat='git push origin --all &amp;&amp; git push origin --tags'compdef _git gpoat=git-pushalias gpu='git push upstream'alias gpv='git push -v'alias gr='git remote'alias gra='git remote add'alias grb='git rebase'alias grba='git rebase --abort'alias grbc='git rebase --continue'alias grbi='git rebase -i'alias grbm='git rebase master'alias grbs='git rebase --skip'alias grh='git reset HEAD'alias grhh='git reset HEAD --hard'alias grmv='git remote rename'alias grrm='git remote remove'alias grset='git remote set-url'alias grt='cd $(git rev-parse --show-toplevel || echo \".\")'alias gru='git reset --'alias grup='git remote update'alias grv='git remote -v'alias gsb='git status -sb'alias gsd='git svn dcommit'alias gsi='git submodule init'alias gsps='git show --pretty=short --show-signature'alias gsr='git svn rebase'alias gss='git status -s'alias gst='git status'alias gsta='git stash save'alias gstaa='git stash apply'alias gstc='git stash clear'alias gstd='git stash drop'alias gstl='git stash list'alias gstp='git stash pop'alias gsts='git stash show --text'alias gsu='git submodule update'alias gts='git tag -s'alias gtv='git tag | sort -V'alias gunignore='git update-index --no-assume-unchanged'alias gunwip='git log -n 1 | grep -q -c \"\\-\\-wip\\-\\-\" &amp;&amp; git reset HEAD~1'alias gup='git pull --rebase'alias gupv='git pull --rebase -v'alias glum='git pull upstream master'alias gwch='git whatchanged -p --abbrev-commit --pretty=medium'alias gwip='git add -A; git rm $(git ls-files --deleted) 2&gt; /dev/null; git commit --no-verify -m \"--wip-- [skip ci]\"'","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Object.prototype.toString方法的原理","slug":"Object.prototype.toString方法的原理","date":"2019-10-28T04:33:37.000Z","updated":"2019-11-10T14:37:39.020Z","comments":true,"path":"2019/10/28/Object.prototype.toString方法的原理/","link":"","permalink":"http://yoursite.com/2019/10/28/Object.prototype.toString方法的原理/","excerpt":"","text":"Object.prototype.toString 方法的原理ECMAScript 3Object.prototype.toString 方法的规范在toString方法被调用时,会执行下面的操作步骤: 获取 this 对象的[[Class]]属性的值. 计算出三个字符串“[object “,第一步的操作结果 Result(1), 以及 “]”连接后的新字符串. 返回第二步的操作结果 Result(2). [[Class]][[Class]]是一个内部属性,所有的对象(原生对象和宿主对象)都拥有该属性.在规范中,[[Class]]是这么定义的 内部属性 描述 [[Class]] 一个字符串值,表明了该对象的类型. 然后给了一段解释: 所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是任意值,甚至可以是内置对象使用过的[[Class]]属性的值.[[Class]]属性的值可以用来判断一个原生对象属于哪种内置类型.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值 也就是说,把 Object.prototype.toString 方法返回的字符串,去掉前面固定的“[object “和后面固定的“]”,就是内部属性[[class]]的值,也就达到了判断对象类型的目的。 [[Class]]的值在 ES3 中,规范文档并没有总结出[[class]]内部属性一共有几种,不过我们可以自己统计一下,原生对象的[[class]]内部属性的值一共有 10 种.分别是:&quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Error&quot;, &quot;Function&quot;, &quot;Math&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;, &quot;String&quot;. ECMAScript 5Object.prototype.toString 方法的规范在toString方法被调用时,会执行下面的操作步骤: 如果this的值为undefined,则返回&quot;[object Undefined]&quot;. 如果this的值为null,则返回&quot;[object Null]&quot;. 让O成为调用 ToObject(this)的结果. 让class成为O的内部属性[[Class]]的值. 返回三个字符串“[object “, class, 以及 “]”连接后的新字符串. 可以看出,ES5 比 ES3 多了 1,2,3 步.第 1,2 步属于新规则,比较特殊,因为”Undefined&quot;和”Null&quot;并不属于[[class]]属性的值,需要注意的是,这里和严格模式无关(大部分函数在严格模式下,this 的值才会保持 undefined 或 null,非严格模式下会自动成为全局对象).第 3 步并不算是新规则,因为在 ES3 的引擎中,也都会在这一步将三种原始值类型转换成对应的包装对象,只是规范中没写出来. [[Class]]ES5 中,[[Class]]属性的解释更加详细: 所有内置对象的[[Class]]属性的值是由本规范定义的.所有宿主对象的[[Class]]属性的值可以是除了”Arguments”, “Array”, “Boolean”, “Date”, “Error”, “Function”, “JSON”, “Math”, “Number”, “Object”, “RegExp”, “String”之外的的任何字符串.[[Class]]内部属性是引擎内部用来判断一个对象属于哪种类型的值的.需要注意的是,除了通过Object.prototype.toString方法之外,本规范没有提供任何其他方式来让程序访问该属性的值 对比 ES3 第一个差别就是[[class]]内部属性的值多了两种,成了 12 种 一种是 arguments 对象的[[class]]成了”Arguments”,而不是以前的”Object” 多个了全局对象 JSON,它的[[class]]值为”JSON”. 第二个差别就是,宿主对象的[[class]]内部属性的值,不能和这 12 种值冲突（不过在支持 ES3 的浏览器中,貌似也没有发现哪些宿主对象故意使用那 10 个值） ECMAScript 6[[class]]内部属性没有了,取而代之的是另外一个内部属性[[NativeBrand]].[[NativeBrand]]属性是这么定义的: 内部属性 属性值 描述 [[NativeBrand]] 枚举 NativeBrand 的一个成员. 该属性的值对应一个标志值(tag value),可以用来区分原生对象的类型. [[NativeBrand]]属性（internal slot）[[NativeBrand]]内部属性用来识别某个原生对象是否为符合本规范的某一种特定类型的对象.[[NativeBrand]]内部属性的值为下面这些枚举类型的值中的一个:NativeFunction, NativeArray, StringWrapper, BooleanWrapper, NumberWrapper, NativeMath, NativeDate, NativeRegExp, NativeError, NativeJSON, NativeArguments, NativePrivateName.[[NativeBrand]]内部属性仅用来区分区分特定类型的 ECMAScript 原生对象.只有在表 10 中明确指出的对象类型才有[[NativeBrand]]内部属性. 属性值 对应类型 NativeFunction Function objects NativeArray Array objects StringWrapper String objects BooleanWrapper Boolean objects NumberWrapper Number objects NativeMath The Math object NativeDate Date objects NativeRegExp RegExp objects NativeError Error objects NativeJSON The JSON object NativeArguments Arguments objects NativePrivateName Private Name objects 可见,和[[class]]不同的是,并不是每个对象都拥有[[NativeBrand]]. Object.prototype.toString 方法的规范:在toString方法被调用时,会执行下面的操作步骤: 如果this的值为undefined,则返回&quot;[object Undefined]&quot;. 如果this的值为null,则返回&quot;[object Null]&quot;. 让O成为调用 ToObject(this)的结果. 如果O有[[NativeBrand]]内部属性,让tag成为表 29 中对应的值. 否则 让hasTag成为调用O的[[HasProperty]]内部方法后的结果,参数为@@toStringTag. 如果hasTag为false,则让tag为&quot;Object&quot;. 否则, 让tag成为调用O的[[Get]]内部方法后的结果,参数为@@toStringTag. 如果tag是一个 abrupt completion,则让tag成为 NormalCompletion(&quot;???&quot;). 让tag成为tag.[[value]]. 如果 Type(tag)不是字符串,则让tag 成为&quot;???&quot;. 如果tag的值为&quot;Arguments&quot;, &quot;Array&quot;, &quot;Boolean&quot;, &quot;Date&quot;, &quot;Error&quot;, &quot;Function&quot;, &quot;JSON&quot;, &quot;Math&quot;, &quot;Number&quot;, &quot;Object&quot;, &quot;RegExp&quot;,或者&quot;String&quot;中的任一个,则让tag成为字符串&quot;~&quot;和tag当前的值连接后的结果. 返回三个字符串”[object “, tag, and “]”连接后的新字符串. ES6 里的新类型 Map,SetES6 里的新类型 Map,Set 等,都没有在表 29 中.它们在执行 toString 方法的时候返回的是什么? 12console.log(Object.prototype.toString.call(Map())); //\"[object Map]\"console.log(Object.prototype.toString.call(Set())); //\"[object Set]\" Map.prototype.@@toStringTag @@toStringTag 属性的初始值为字符串“Map”.","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"函数式编程","slug":"函数式编程","date":"2019-10-21T03:15:12.000Z","updated":"2019-11-10T14:37:39.029Z","comments":true,"path":"2019/10/21/函数式编程/","link":"","permalink":"http://yoursite.com/2019/10/21/函数式编程/","excerpt":"","text":"函数式编程什么是函数式编程定义：函数式编程是一种编程范式，主要是利用函数把运算过程封装起来，通过组合各种函数来计算结果。函数式编程意味着你可以在更短的时间内编写具有更少错误的代码。 举个简单的例子，假设我们要把字符串 functional programming is great 变成每个单词首字母大写，我们可以这样实现： 12345var string = \"functional programming is great\";var result = string .split(\" \") .map(v =&gt; v.slice(0, 1).toUpperCase() + v.slice(1)) .join(\" \"); 上面的例子先用 split 把字符串转换数组，然后再通过 map 把各元素的首字母转换成大写，最后通过 join 把数组转换成字符串。 整个过程就是 join(map(split(str))),体现了函数式编程的核心思想： 通过函数对数据进行转换。 特点：由此我们可以得到，函数式编程有两个基本特点： 通过函数来对数据进行转换 通过串联多个函数来求结果 对比声明式与命令式 命令式：我们通过编写一条又一条指令去让计算机执行一些动作，这其中一般都会涉及到很多繁杂的细节。命令式代码中频繁使用语句,来完成某个行为。比如 for、if、switch、throw 等这些语句。 声明式：我们通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合、一些值和操作符，用来计算出结果值。 12345678//命令式var CEOs = [];for (var i = 0; i &lt; companies.length; i++) &#123; CEOs.push(companies[i].CEO);&#125;//声明式var CEOs = companies.map(c =&gt; c.CEO); 从上面的例子中，我们可以看到声明式的写法是一个表达式，无需关心如何进行计数器迭代，返回的数组如何收集，它指明的是做什么，而不是怎么做。函数式编程的一个明显的好处就是这种声明式的代码，对于无副作用的纯函数，我们完全可以不考虑函数内部是如何实现的，专注于编写业务代码。 常见特性无副作用指调用函数时不会修改外部状态，即一个函数调用 n 次后依然返回同样的结果。 12345678910111213var a = 1;// 含有副作用，它修改了外部变量 a// 多次调用结果不一样function test1() &#123; a++; return a;&#125;// 无副作用，没有修改外部状态// 多次调用结果一样function test2(a) &#123; return a + 1;&#125; 透明引用指一个函数只会用到传递给它的变量以及自己内部创建的变量，不会使用到其他变量。 12345678910var a = 1;var b = 2;// 函数内部使用的变量并不属于它的作用域function test1() &#123; return a + b;&#125;// 函数内部使用的变量是显式传递进去的function test2(a, b) &#123; return a + b;&#125; 不可变变量指的是一个变量一旦创建后，就不能再进行修改，任何修改都会生成一个新的变量。使用不可变变量最大的好处是线程安全。多个线程可以同时访问同一个不可变变量，让并行变得更容易实现。 由于 JavaScript 原生不支持不可变变量，需要通过第三方库来实现。 (如 Immutable.js，Mori 等等) 1234var obj = Immutable(&#123; a: 1 &#125;);var obj2 = obj.set(\"a\", 2);console.log(obj); // Immutable(&#123; a: 1 &#125;)console.log(obj2); // Immutable(&#123; a: 2 &#125;) 函数是一等公民我们常说函数是 JavaScript 的”第一等公民”，指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。下文将要介绍的闭包、高阶函数、函数柯里化和函数组合都是围绕这一特性的应用 常见的函数式编程模型1.闭包（Closure）如果一个函数引用了自由变量，那么该函数就是一个闭包。何谓自由变量？自由变量是指不属于该函数作用域的变量(所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么用，通常情况下我们说的闭包是指函数内部的函数)。 闭包的形成条件： 存在内、外两层函数 内层函数对外层函数的局部变量进行了引用 闭包的用途:可以定义一些作用域局限的持久化变量，这些变量可以用来做缓存或者计算的中间量等。 1234567891011121314151617// 简单的缓存工具// 匿名函数创造了一个闭包const cache = (function() &#123; const store = &#123;&#125;; return &#123; get(key) &#123; return store[key]; &#125;, set(key, val) &#123; store[key] = val; &#125; &#125;;&#125;)();console.log(cache); //&#123;get: ƒ, set: ƒ&#125;cache.set(\"a\", 1);cache.get(\"a\"); // 1 上面例子是一个简单的缓存工具的实现，匿名函数创造了一个闭包，使得 store 对象 ，一直可以被引用，不会被回收。 闭包的弊端:持久化变量不会被正常释放，持续占用内存空间，很容易造成内存浪费，所以一般需要一些额外手动的清理机制。 2.高阶函数函数式编程倾向于复用一组通用的函数功能来处理数据，它通过使用高阶函数来实现。高阶函数指的是一个函数以函数为参数，或以函数为返回值，或者既以函数为参数又以函数为返回值。 高阶函数经常用于： 抽象或隔离行为、作用，异步控制流程作为回调函数，promises，monads 等 创建可以泛用于各种数据类型的功能 部分应用于函数参数（偏函数应用）或创建一个柯里化的函数，用于复用或函数复合。 接受一个函数列表并返回一些由这个列表中的函数组成的复合函数。 JavaScript 语言是原生支持高阶函数的, 例如 Array.prototype.map，Array.prototype.filter 和 Array.prototype.reduce 是 JavaScript 中内置的一些高阶函数，使用高阶函数会让我们的代码更清晰简洁。 mapmap() 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。map 不会改变原数组。 假设我们有一个包含名称和种类属性的对象数组，我们想要这个数组中所有名称属性放在一个新数组中，如何实现呢？ 12345678910111213141516171819202122232425// 不使用高阶函数var animals = [ &#123; name: \"Fluffykins\", species: \"rabbit\" &#125;, &#123; name: \"Caro\", species: \"dog\" &#125;, &#123; name: \"Hamilton\", species: \"dog\" &#125;, &#123; name: \"Harold\", species: \"fish\" &#125;, &#123; name: \"Ursula\", species: \"cat\" &#125;, &#123; name: \"Jimmy\", species: \"fish\" &#125;];var names = [];for (let i = 0; i &lt; animals.length; i++) &#123; names.push(animals[i].name);&#125;console.log(names); //[\"Fluffykins\", \"Caro\", \"Hamilton\", \"Harold\", \"Ursula\", \"Jimmy\"]// 使用高阶函数var animals = [ &#123; name: \"Fluffykins\", species: \"rabbit\" &#125;, &#123; name: \"Caro\", species: \"dog\" &#125;, &#123; name: \"Hamilton\", species: \"dog\" &#125;, &#123; name: \"Harold\", species: \"fish\" &#125;, &#123; name: \"Ursula\", species: \"cat\" &#125;, &#123; name: \"Jimmy\", species: \"fish\" &#125;];var names = animals.map(x =&gt; x.name);console.log(names); //[\"Fluffykins\", \"Caro\", \"Hamilton\", \"Harold\", \"Ursula\", \"Jimmy\"] filterfilter() 方法会创建一个新数组，其中包含所有通过回调函数测试的元素。filter 为数组中的每个元素调用一次 callback 函数， callback 函数返回 true 表示该元素通过测试，保留该元素，false 则不保留。filter 不会改变原数组，它返回过滤后的新数组。 假设我们有一个包含名称和种类属性的对象数组。 我们想要创建一个只包含狗（species: “dog”）的数组。如何实现呢？ 1234567891011121314151617181920212223242526// 不使用高阶函数var animals = [ &#123; name: \"Fluffykins\", species: \"rabbit\" &#125;, &#123; name: \"Caro\", species: \"dog\" &#125;, &#123; name: \"Hamilton\", species: \"dog\" &#125;, &#123; name: \"Harold\", species: \"fish\" &#125;, &#123; name: \"Ursula\", species: \"cat\" &#125;, &#123; name: \"Jimmy\", species: \"fish\" &#125;];var dogs = [];for (var i = 0; i &lt; animals.length; i++) &#123; if (animals[i].species === \"dog\") dogs.push(animals[i]);&#125;console.log(dogs);// 使用高阶函数var animals = [ &#123; name: \"Fluffykins\", species: \"rabbit\" &#125;, &#123; name: \"Caro\", species: \"dog\" &#125;, &#123; name: \"Hamilton\", species: \"dog\" &#125;, &#123; name: \"Harold\", species: \"fish\" &#125;, &#123; name: \"Ursula\", species: \"cat\" &#125;, &#123; name: \"Jimmy\", species: \"fish\" &#125;];var dogs = animals.filter(x =&gt; x.species === \"dog\");console.log(dogs); // &#123;name: \"Caro\", species: \"dog\"&#125;// &#123; name: \"Hamilton\", species: \"dog\" &#125; reducereduce 方法对调用数组的每个元素执行回调函数，最后生成一个单一的值并返回。 reduce 方法接受两个参数：1）reducer 函数（回调），2）一个可选的 initialValue。 假设我们要对一个数组的求和： 1234567891011121314// 不使用高阶函数const arr = [5, 7, 1, 8, 4];let sum = 0;for (let i = 0; i &lt; arr.length; i++) &#123; sum = sum + arr[i];&#125;console.log(sum); //25// 使用高阶函数const arr = [5, 7, 1, 8, 4];const sum = arr.reduce( (accumulator, currentValue) =&gt; accumulator + currentValue, 0);console.log(sum); //25 我们可以通过下图，形象生动展示三者的区别： 3.函数柯里化柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候，再一次性把所有传入的参数进行求值。 12345678910111213// 普通函数function add(x, y) &#123; return x + y;&#125;add(1, 2); // 3// 函数柯里化var add = function(x) &#123; return function(y) &#123; return x + y; &#125;;&#125;;var increment = add(1);increment(2); // 3 这里我们定义了一个 add 函数，它接受一个参数并返回一个新的函数。调用 add 之后，返回的函数就通过闭包的方式记住了 add 的第一个参数。那么，我们如何来实现一个简易的柯里化函数呢？ 123456789101112131415161718192021function curryIt(fn) &#123; // 参数fn函数的参数个数 var n = fn.length; var args = []; return function(arg) &#123; args.push(arg); if (args.length &lt; n) &#123; return arguments.callee; // 返回这个函数的引用 &#125; else &#123; return fn.apply(this, args); &#125; &#125;;&#125;function add(a, b, c) &#123; return [a, b, c];&#125;var c = curryIt(add);var c1 = c(1);var c2 = c1(2);var c3 = c2(3);console.log(c3); //[1, 2, 3] 由此我们可以看出，柯里化是一种“预加载”函数的方法，通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的“缓存”，是一种非常高效的编写函数的方法！ 4.函数组合 (Composition)前面提到过，函数式编程的一个特点是通过串联函数来求值。然而，随着串联函数数量的增多，代码的可读性就会不断下降。函数组合就是用来解决这个问题的方法。假设有一个 compose 函数，它可以接受多个函数作为参数，然后返回一个新的函数。当我们为这个新函数传递参数时，该参数就会「流」过其中的函数，最后返回结果。 123456789101112131415//两个函数的组合var compose = function(f, g) &#123; return function(x) &#123; return f(g(x)); &#125;;&#125;;//或者var compose = (f, g) =&gt; x =&gt; f(g(x));var add1 = x =&gt; x + 1;var mul5 = x =&gt; x * 5;compose( mul5, add1)(2); // =&gt;15","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"IP","slug":"IP","date":"2019-10-13T07:41:22.000Z","updated":"2019-11-10T14:37:39.018Z","comments":true,"path":"2019/10/13/IP/","link":"","permalink":"http://yoursite.com/2019/10/13/IP/","excerpt":"","text":"IPIP（IPv4、IPv6）相当于 OSI 参考模型中的第 3 层——网络层。网络层的主要作用是“实现终端节点之间的通信”。这种终端节点之间的通信也叫“点对点通信”。 网络的下一层——数据链路层的主要作用是在互连同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端节点之间的数据包传输。 IP 大致分为三大作用模块，它们是 IP 寻址、路由（最终节点为止的转发）以及 IP 分包与组包。 TCP/IP 基础互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。 每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。 网络中传输的数据包由两部分组成：一部分是协议所要用到的首部，另一部分是上一层传过来的数据。首部的结构由协议的具体规范详细定义。在数据包的首部，明确标明了协议应该如何读取数据。反过来说，看到首部，也就能够了解该协议必要的信息以及所要处理的数据。包首部就像协议的脸。 数据处理流程 应用程序处理首先应用程序会进行编码处理，这些编码相当于 OSI 的表示层功能；编码转化后，邮件不一定马上被发送出去，这种何时建立通信连接何时发送数据的管理功能，相当于 OSI 的会话层功能。 TCP 模块的处理TCP 根据应用的指示，负责建立连接、发送数据以及断开连接。TCP 提供将应用层发来的数据顺利发送至对端的可靠传输。为了实现这一功能，需要在应用层数据的前端附加一个 TCP 首部。 IP 模块的处理IP 将 TCP 传过来的 TCP 首部和 TCP 数据合起来当做自己的数据，并在 TCP 首部的前端加上自己的 IP 首部。IP 包生成后，参考路由控制表决定接受此 IP 包的路由或主机。 网络接口（以太网驱动）的处理从 IP 传过来的 IP 包对于以太网来说就是数据。给这些数据附加上以太网首部并进行发送处理，生成的以太网数据包将通过物理层传输给接收端。 网络接口（以太网驱动）的处理主机收到以太网包后，首先从以太网包首部找到 MAC 地址判断是否为发送给自己的包，若不是则丢弃数据。如果是发送给自己的包，则从以太网包首部中的类型确定数据类型，再传给相应的模块，如 IP、ARP 等。这里的例子则是 IP 。 IP 模块的处理IP 模块接收到 数据后也做类似的处理。从包首部中判断此 IP 地址是否与自己的 IP 地址匹配，如果匹配则根据首部的协议类型将数据发送给对应的模块，如 TCP、UDP。这里的例子则是 TCP。另外吗，对于有路由器的情况，接收端地址往往不是自己的地址，此时，需要借助路由控制表，在调查应该送往的主机或路由器之后再进行转发数据。 TCP 模块的处理在 TCP 模块中，首先会计算一下校验和，判断数据是否被破坏。然后检查是否在按照序号接收数据。最后检查端口号，确定具体的应用程序。数据被完整地接收以后，会传给由端口号识别的应用程序。 应用程序的处理接收端应用程序会直接接收发送端发送的数据。通过解析数据，展示相应的内容。 IP 服务的主要特点IP 协议为上层协议提供无状态、无连接、不可靠的服务。 无状态 无状态是指 IP 通信双方不同步传输数据的状态信息，所有 IP 数据报的发送、传输、接受都是相互独立、没有上下文关系的。这种服务优点在于简单、高效。最大的缺点是无法处理乱序和重复的 IP 数据报，确保 IP 数据报完整的工作只能交给上层协议来完成。 无连接 无连接是指 IP 通信双方都不长久地维持对方的任何信息。上层协议每次发送数据的时候，都需要明确指出对方的 IP 地址。 不可靠 不可靠是指 IP 协议不能保证 IP 数据报准确到达接收端，它指承诺尽最大努力交付。IP 模块一旦检测到数据报发送失败，就通知上层协议，而不会试图重传。 IP 地址IP 地址概述 在计算机通信中，为了识别通信对端，必须要有一个类似于地址的识别码进行标识。在数据链路中的 MAC 地址正是用来标识同一个链路中不同计算机的一种识别码。 作为网络层的 IP ,也有这种地址信息，一般叫做 IP 地址。IP 地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此，在 TCP/IP 通信中所有主机或路由器必须设定自己的 IP 地址。 不论一台主机与哪种数据链路连接，其 IP 地址的形式都保持不变。 IP 地址（IPv4 地址）由 32 位正整数来表示。IP 地址在计算机内部以二进制方式被处理。然而，由于我们并不习惯于采用二进制方式，我们将 32 位的 IP 地址以每 8 位为一组，分成 4 组，每组以 “.” 隔开，再将每组数转换成十进制数。如下： 2^8 2^8 2^8 2^8 10101100 00010100 00000001 00000001 （2 进制） 172. 20. 1. 1 （10 进制） IP 地址由网络和主机两部分标识组成 如下图，网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不相重复。而相同段内相连的主机必须有相同的网络地址。IP 地址的“主机标识”则不允许在同一个网段内重复出现。由此，可以通过设置网络地址和主机地址，在相互连接的整个网络中保证每台主机的 IP 地址都不会相互重叠。即 IP 地址具有了唯一性。 如下图，IP 包被转发到途中某个路由器时，正是利用目标 IP 地址的网络标识进行路由。因为即使不看主机标识，只要一见到网络标识就能判断出是否为该网段内的主机。 IP 地址的分类IP 地址分为四个级别，分别为 A 类、B 类、C 类、D 类。它根据 IP 地址中从第 1 位到第 4 位的比特列对其网络标识和主机标识进行区分。 A 类 IP 地址是首位以 “0” 开头的地址。从第 1 位到第 8 位是它的网络标识。用十进制表示的话，0.0.0.0~127.0.0.0 是 A 类的网络地址。A 类地址的后 24 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 16,777,214 个。 B 类 IP 地址是前两位 “10” 的地址。从第 1 位到第 16 位是它的网络标识。用十进制表示的话，128.0.0.0~191.255.0.0 是 B 类的网络地址。B 类地址的后 16 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 65,534 个。 C 类 IP 地址是前三位为 “110” 的地址。从第 1 位到第 24 位是它的网络标识。用十进制表示的话，192.0.0.0~223.255.255.0 是 C 类的网络地址。C 类地址的后 8 位相当于主机标识。因此，一个网段内可容纳的主机地址上限为 254 个。 D 类 IP 地址是前四位为 “1110” 的地址。从第 1 位到第 32 位是它的网络标识。用十进制表示的话，224.0.0.0~239.255.255.255 是 D 类的网络地址。D 类地址没有主机标识，常用于多播。 在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。 广播地址 广播地址用于在同一个链路中相互连接的主机之间发送数据包。将 IP 地址中的主机地址部分全部设置为 1，就成了广播地址。 广播分为本地广播和直接广播两种。在本网络内的广播叫做本地广播；在不同网络之间的广播叫做直接广播。 IP 多播 多播用于将包发送给特定组内的所有主机。由于其直接使用 IP 地址，因此也不存在可靠传输。 相比于广播，多播既可以穿透路由器，又可以实现只给那些必要的组发送数据包。请看下图： 多播使用 D 类地址。因此，如果从首位开始到第 4 位是 “1110”，就可以认为是多播地址。而剩下的 28 位可以成为多播的组编号。 此外， 对于多播，所有的主机（路由器以外的主机和终端主机）必须属于 224.0.0.1 的组，所有的路由器必须属于 224.0.0.2 的组。 子网掩码 现在一个 IP 地址的网络标识和主机标识已不再受限于该地址的类别，而是由一个叫做“子网掩码”的识别码通过子网网络地址细分出比 A 类、B 类、C 类更小粒度的网络。这种方式实际上就是将原来 A 类、B 类、C 类等分类中的主机地址部分用作子网地址，可以将原网络分为多个物理网络的一种机制。 子网掩码用二进制方式表示的话，也是一个 32 位的数字。它对应 IP 地址网络标识部分的位全部为 “1”，对应 IP 地址主机标识的部分则全部为 “0”。由此，一个 IP 地址可以不再受限于自己的类别，而是可以用这样的子网掩码自由地定位自己的网络标识长度。当然，子网掩码必须是 IP 地址的首位开始连续的 “1”。 对于子网掩码，目前有两种表示方式。第一种是，将 IP 地址与子网掩码的地址分别用两行来表示。以 172.20.100.52 的前 26 位是网络地址的情况为例，如下： IP 地址 172. 20. 100. 52 子网掩码 255. 255. 255. 192 网络地址 172. 20. 100. 0 子网掩码 255. 255. 255. 192 广播地址 172. 20. 100. 63 子网掩码 255. 255. 255. 192 第二种表示方式是，在每个 IP 地址后面追加网络地址的位数用 “/ ” 隔开，如下： IP 地址 172. 20. 100. 52 / 26 网络地址 172. 20. 100. 0 / 26 广播地址 172. 20. 100. 63 / 26 另外，在第二种方式下记述网络地址时可以省略后面的 “0” 。例如：172.20.0.0/26 跟 172.20/26 其实是一个意思。 路由 发送数据包时所使用的地址是网络层的地址，即 IP 地址。然而仅仅有 IP 地址还不足以实现将数据包发送到对端目标地址，在数据发送过程中还需要类似于“指明路由器或主机”的信息，以便真正发往目标地址。保存这种信息的就是路由控制表。 该路由控制表的形成方式有两种：一种是管理员手动设置，另一种是路由器与其他路由器相互交换信息时自动刷新。前者也叫做静态路由控制，而后者叫做动态路由控制。 IP 协议始终认为路由表是正确的。然后，IP 本身并没有定义制作路由控制表的协议。即 IP 没有制作路由控制表的机制。该表示由一个叫做“路由协议”的协议制作而成。 IP 地址与路由控制 IP 地址的网络地址部分用于进行路由控制。 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。 在发送 IP 包时，首先要确定 IP 包首部中的目标地址，再从路由控制表中找到与该地址具有相同网络地址的记录，根据该记录将 IP 包转发给相应的下一个路由器。如果路由控制表中存在多条相同网络地址的记录，就选择一个最为吻合的网络地址。 路由匹配路由匹配顺序：1） 直接匹配，查找路由表中是否由与目标 IP 地址完全匹配的主机 IP 地址，找到则匹配成功，没有的话转 2；2）查找是否有与目标 IP 地址具有相同网络 ID 的 IP 地址，找到则匹配成功，没有的话转 3；3）查看是否有默认网关，有则转发给它，没有的话，路由查找失败，由 ICMP 返回错误信息。 路由更新通过 route 命令或其他工具可以手工修改路由表，是静态路由更新方式。对于大型路由器，它们通常通过 BGP、RIP、OSPF 等协议进行动态路由更新。 IP 分包与组包 每种数据链路的最大传输单元（MTU）都不尽相同，因为每个不同类型的数据链路的使用目的不同。使用目的不同，可承载的 MTU 也就不同。 任何一台主机都有必要对 IP 分片进行相应的处理。分片往往在网络上遇到比较大的报文无法一下子发送出去时才会进行处理。 经过分片之后的 IP 数据报在被重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。 路径 MTU 发现 分片机制也有它的不足。如路由器的处理负荷加重之类。因此，只要允许，是不希望由路由器进行 IP 数据包的分片处理的。 为了应对分片机制的不足，“路径 MTU 发现” 技术应运而生。路径 MTU 指的是，从发送端主机到接收端主机之间不需要分片是最大 MTU 的大小。即路径中存在的所有数据链路中最小的 MTU 。 进行路径 MTU 发现，就可以避免在中途的路由器上进行分片处理，也可以在 TCP 中发送更大的包。 IPv4IPv4 头部 头部长度 标识该 IP 头部有多少个 32 位 bit 字（4 字节），由于 4 位最大描述 15，所以 IP 头部最大长度为 60 字节。 8 为服务位 包括 3 位优先权位，4 为 TOS 字段和 1 位保留字段。4 为 TOS 字段分别表示：最小延时，最大吞吐量、最高可靠性和最小费用。其中最多能选择一位置 1，应用程序根据实际需要来设置服务类型。 16 位标识 唯一标识主机发送的每一个数据报。其初始值由系统随机生成；每发一个数据报就加 1。每个分片中具有相同的标识值。 分片偏移 有 3 位用于标识偏移，第一位保留，第二位 DF 字段（禁止分片标识），第三位 MF 字段（更多分片标识，最后一个分片为 0，其他分片置 1）。13 位偏移是勇敢将实际值左移三位得到的，因此要求数据部分的长度是 8 的倍数。 8 位协议 标识上层协议，1 是 ICMP，6 是 TCP，17 是 UDP。 16 位头部校验和 IP 模块接受数据后，首先对数据报头部做 CRC 校验，确保 IP 头部在传输过程中无损坏后，再分析其头部具体信息。 IPv6IPv6（IP version 6）是为了根本解决 IPv4 地址耗尽的问题而被标准化的网际协议。IPv4 的地址长度为 4 个 8 位字节，即 32 比特。而 IPv6 的地址长度则是原来的 4 倍，即 128 比特，一般写成 8 个 16 位字节。 IPv6 协议并不是 IPv4 的简单扩展，而是完全独立的协议。从以太网帧封装的数据类型来看，前者类型是 0X86dd，后者是 0x8600，是完全不同的类型。 IPv6 解决了网络地址不足的问题，其头部增加了多播和流的功能，引入了自动配置功能，还增加了网络安全的功能。 IPv6 头部固定部分 流标签 是 IPv6 新增加的字段，用于对某些连接的服务质量有特殊要求的通信，比如音频或者视频等实时数据传递。 下一个包头 指出紧跟 IPv6 固定头部后的包头类型，如拓展头，或者某个上层协议头（ICMP，TCP，UDP），它类似 IPv4 中的协议字段，且相同的取值具有相同的含义。 IPv6 的特点 IP 得知的扩大与路由控制表的聚合。 性能提升。包首部长度采用固定的值（40 字节），不再采用首部检验码。简化首部结构，减轻路由器负担。路由器不再做分片处理。 支持即插即用功能。即使没有 DHCP 服务器也可以实现自动分配 IP 地址。 采用认证与加密功能。应对伪造 IP 地址的网络安全功能以及防止线路窃听的功能。 多播、Mobile IP 成为扩展功能。 IPv6 中 IP 地址的标记方法 一般人们将 128 比特 IP 地址以每 16 比特为一组，每组用冒号（“：”）隔开进行标记。 而且如果出现连续的 0 时还可以将这些 0 省略，并用两个冒号（“：：”）隔开。但是，一个 IP 地址中只允许出现一次两个连续的冒号。 IPv6 地址的结构 IPv6 类似 IPv4，也是通过 IP 地址的前几位标识 IP 地址的种类。 在互联网通信中，使用一种全局的单播地址。它是互联网中唯一的一个地址，不需要正式分配 IP 地址。 未定义 0000 … 0000（128 比特） ：：/ 128 环回地址 0000 … 0001（128 比特） ：：1 / 128 唯一本地地址 1111 110 FC00：/ 7 链路本地单播地址 1111 1110 10 FE80：：/ 10 多播地址 1111 1111 FF00：：/ 8 全局单播地址 （其他） 全局单播地址 全局单播地址是指世界上唯一的一个地址。它是互联网通信以及各个域内部通信中最为常用的一个 IPv6 地址。 格式如下图所示，现在 IPv6 的网络中所使用的格式为，n = 48，m = 16 以及 128 - n - m = 64。即前 64 比特为网络标识，后 64 比特为主机标识。 链路本地单播地址链路本地单播地址是指在同一个数据链路内唯一的地址。它用于不经过路由器，在同一个链路中的通信。通常接口 ID 保存 64 比特版的 MAC 地址。 唯一本地地址 唯一本地地址是不进行互联网通信时所用的地址。 唯一本地地址虽然不会与互联网连接，但是也会尽可能地随机生成一个唯一的全局 ID。 L 通常被置为 1 全局 ID 的值随机决定 子网 ID 是指该域子网地址 接口 ID 即为接口的 ID IPv6 分段处理 IPv6 的分片处理只在作为起点的发送端主机上进行，路由器不参与分片。 IPv6 中最小 MTU 为 1280 字节，因此，在嵌入式系统中对于那些有一定系统资源限制的设备来说，不需要进行“路径 MTU 发现”，而是在发送 IP 包时直接以 1280 字节为单位分片送出。 IP 首部（暂略）IP 协议相关技术IP 旨在让最终目标主机收到数据包，但是在这一过程中仅仅有 IP 是无法实现通信的。必须还有能够解析主机名称和 MAC 地址的功能，以及数据包在发送过程中异常情况处理的功能。 DNS 我们平常在访问某个网站时不适用 IP 地址，而是用一串由罗马字和点号组成的字符串。而一般用户在使用 TCP/IP 进行通信时也不使用 IP 地址。能够这样做是因为有了 DNS （Domain Name System）功能的支持。DNS 可以将那串字符串自动转换为具体的 IP 地址。 这种 DNS 不仅适用于 IPv4，还适用于 IPv6。 ARP 只要确定了 IP 地址，就可以向这个目标地址发送 IP 数据报。然而，在底层数据链路层，进行实际通信时却有必要了解每个 IP 地址所对应的 MAC 地址。 ARP 是一种解决地址问题的协议。以目标 IP 地址为线索，用来定位下一个应该接收数据分包的网络设备对应的 MAC 地址。不过 ARP 只适用于 IPv4，不能用于 IPv6。IPv6 中可以用 ICMPv6 替代 ARP 发送邻居探索消息。 RARP 是将 ARP 反过来，从 MAC 地址定位 IP 地址的一种协议。 ICMP ICMP 的主要功能包括，确认 IP 包是否成功送达目标地址，通知在发送过程当中 IP 包被废弃的具体原因，改善网络设置等。 IPv4 中 ICMP 仅作为一个辅助作用支持 IPv4。也就是说，在 IPv4 时期，即使没有 ICMP，仍然可以实现 IP 通信。然而，在 IPv6 中，ICMP 的作用被扩大，如果没有 ICMPv6，IPv6 就无法进行正常通信。 DHCP 如果逐一为每一台主机设置 IP 地址会是非常繁琐的事情。特别是在移动使用笔记本电脑、只能终端以及平板电脑等设备时，每移动到一个新的地方，都要重新设置 IP 地址。 于是，为了实现自动设置 IP 地址、统一管理 IP 地址分配，就产生了 DHCP（Dynamic Host Configuration Protocol）协议。有了 DHCP，计算机只要连接到网络，就可以进行 TCP/IP 通信。也就是说，DHCP 让即插即用变得可能。 DHCP 不仅在 IPv4 中，在 IPv6 中也可以使用。 NAT NAT（Network Address Translator）是用于在本地网络中使用私有地址，在连接互联网时转而使用全局 IP 地址的技术。 除转换 IP 地址外，还出现了可以转换 TCP、UDP 端口号的 NAPT（Network Address Ports Translator）技术，由此可以实现用一个全局 IP 地址与多个主机的通信。 NAT（NAPT）实际上是为正在面临地址枯竭的 IPv4 而开发的技术。不过，在 IPv6 中为了提高网络安全也在使用 NAT，在 IPv4 和 IPv6 之间的相互通信当中常常使用 NAT-PT。 IP 隧道 如上图的网络环境中，网络 A 与网络 B 之间无法直接进行通信，为了让它们之间正常通信，这时必须得采用 IP 隧道的功能。 IP 隧道可以将那些从网络 A 发过来的 IPv6 的包统合为一个数据，再为之追加一个 IPv4 的首部以后转发给网络 C。 一般情况下，紧接着 IP 首部的是 TCP 或 UDP 的首部。然而，现在的应用当中“ IP 首部的后面还是 IP 首部”或者“ IP 首部的后面是 IPv6 的首部”等情况与日俱增。这种在网络层的首部后面追加网络层首部的通信方法就叫做“ IP 隧道”。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"Http/1.0的Keep-Alive和Http/2.0的多路复用对比","slug":"Http1.0的Keep-Alive和Http2.0的多路复用对比 copy","date":"2019-10-04T08:14:38.000Z","updated":"2019-11-10T14:37:39.018Z","comments":true,"path":"2019/10/04/Http1.0的Keep-Alive和Http2.0的多路复用对比 copy/","link":"","permalink":"http://yoursite.com/2019/10/04/Http1.0的Keep-Alive和Http2.0的多路复用对比 copy/","excerpt":"","text":"Http/1.0 的 Keep-Alive 和 Http/2.0 的多路复用对比Http/1.0 的 Keep-Alive在没有Keep-Alive前，我们与服务器请求数据的流程是这样： 浏览器请求//static.mtime.cn/a.js–&gt;解析域名–&gt;HTTP 连接–&gt;服务器处理文件–&gt;返回数据–&gt;浏览器解析、渲染文件 浏览器请求//static.mtime.cn/b.js–&gt;解析域名–&gt;HTTP 连接–&gt;服务器处理文件–&gt;返回数据–&gt;浏览器解析、渲染文件 … 这样循环下去，直至全部文件下载完成。 这个流程最大的问题就是：每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，而且逻辑上是非必需的，因为不间断的请求数据，第一次建立连接是正常的，以后就占用这个通道，下载其他文件，这样效率多高啊！你猜对了，这就是Keep-Alive。 Keep-Alive解决的问题Keep-Alive解决的核心问题：一定时间内，同一域名多次请求数据，只建立一次 HTTP 请求，其他请求可复用每一次建立的连接通道，以达到提高请求效率的问题。这里面所说的一定时间是可以配置的，不管你用的是Apache还是nginx。 HTTP1.1还是存在效率问题如上面所说，在HTTP1.1中是默认开启了Keep-Alive，他解决了多次连接的问题，但是依然有两个效率上的问题： 第一个：串行的文件传输。当请求 a 文件时，b 文件只能等待，等待 a 连接到服务器、服务器处理文件、服务器返回文件，这三个步骤。我们假设这三步用时都是 1 秒，那么 a 文件用时为 3 秒，b 文件传输完成用时为 6 秒，依此类推。（注：此项计算有一个前提条件，就是浏览器和服务器是单通道传输） 第二个：连接数过多。我们假设Apache设置了最大并发数为 300，因为浏览器限制，浏览器发起的最大请求数为 6，也就是服务器能承载的最高并发为 50，当第 51 个人访问时，就需要等待前面某个请求处理完成。 HTTP/2 的多路复用HTTP/2 的多路复用就是为了解决上述的两个性能问题，我们来看一下，他是如何解决的。 解决第一个：在HTTP1.1的协议中，我们传输的request和response都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输，比如需要传输：hello world，只能从h到d一个一个的传输，不能并行传输，因为接收端并不知道这些字符的顺序，所以并行传输在HTTP1.1是不能实现的。 HTTP/2引入二进制数据帧和流的概念，其中帧对数据进行顺序标识，如下图所示，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是流所做的事情。 解决第二个问题：HTTP/2对同一域名下所有请求都是基于流，也就是说同一域名不管访问多少文件，也只建立一路连接。同样Apache的最大连接数为 300，因为有了这个新特性，最大的并发就可以提升到 300，比原来提升了 6 倍！ 多路复用和 keep alive 区别？ 1）线头阻塞（Head-of-Line Blocking），HTTP1.X 虽然可以采用 keep alive 来解决复用 TCP 的问题，但是还是无法解决请求阻塞问题。 2）所谓请求阻塞意思就是一条 TCP 的 connection 在同一时间只能允许一个请求经过，这样假如后续请求想要复用这个链接就必须等到前一个完成才行，正如上图左边表示的。 3）之所以有这个问题就是因为 HTTP1.x 需要每条请求都是可是识别，按顺序发送，否则 server 就无法判断该相应哪个具体的请求。 4）HTTP2 采用多路复用是指，在同一个域名下，开启一个 TCP 的 connection，每个请求以 stream 的方式传输，每个 stream 有唯一标识，connection 一旦建立，后续的请求都可以复用这个 connection 并且可以同时发送，server 端可以根据 stream 的唯一标识来相应对应的请求。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"CSS 清除浮动","slug":"CSS 清除浮动","date":"2019-09-29T07:26:33.000Z","updated":"2019-11-10T14:37:39.013Z","comments":true,"path":"2019/09/29/CSS 清除浮动/","link":"","permalink":"http://yoursite.com/2019/09/29/CSS 清除浮动/","excerpt":"","text":"CSS 清除浮动 浮动是什么？W3school 中给出的浮动定义为浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框脱离文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。 浮动的特点浮动的特点，可以用八个字总结：脱标、贴边、字围和收缩。 为了更好说明，请看下图：当框 1 向左浮动时，它脱离文档流（脱标）并且向左移动（贴边），直到它的左边缘碰到包含框的左边缘。因为它不再处于文档流中，所以它不占据空间，实际上覆盖住了框 2，使框 2 从视图中消失。如果框 2 中有文字，就会围着框 1 排开（字围）。 如果把所有三个框都向左浮动，那么框 1 向左浮动直到碰到包含框，另外两个框向左浮动直到碰到前一个浮动框。下面着重讲解下第四个特点–收缩 一个浮动的内联元素（比如 span img 标签）不需要设置 display：block 就可以设置宽度。 12345678910111213&lt;head&gt; &lt;style&gt; div &#123; float: left; background-color: greenyellow; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt; 这是一段文字 &lt;/div&gt;&lt;/body&gt; 得到以下的效果： 我们都知道 div 标签是块级元素，会独占一行，然而上面的例子中将 div 设置为左浮后，其宽度不再是占满一行，而是收紧为内部元素的宽度，这就是浮动第四个特征的含义。 浮动的缺点先看下面这段代码： 123456789101112131415161718192021222324252627282930313233&lt;head&gt; &lt;style&gt; .parent &#123; border: solid 5px; width: 300px; &#125; .child:nth-child(1) &#123; height: 100px; width: 100px; background-color: yellow; float: left; &#125; .child:nth-child(2) &#123; height: 100px; width: 100px; background-color: red; float: left; &#125; .child:nth-child(3) &#123; height: 100px; width: 100px; background-color: greenyellow; float: left; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;div class=\"child\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 我们想让父容器包裹着三个浮动元素，然而事与愿违，得到却是这样的结果：这就是浮动带来副作用—-父容器高度塌陷，于是清理浮动就显着至关重要。 清理浮动清除浮动不是不用浮动，是清除浮动产生的父容器高度塌陷。 套路 1：给浮动元素的父元素添加高度（扩展性不好）如果一个元素要浮动，那么它的父元素一定要有高度。高度的盒子，才能关住浮动。可以通过直接给父元素设置 height，实际应用中我们不大可能给所有的盒子加高度，不仅麻烦，并且不能适应页面的快速变化；另外一种，父容器的高度可以通过内容撑开（比如 img 图片），实际当中此方法用的比较多。 套路 2：clear:both;在最后一个子元素后新添加一个冗余元素，然后将其设置 clear:both,这样就可以清除浮动。这里强调一点，即在父级元素末尾添加的元素必须是一个块级元素，否则无法撑起父级元素高度。 1234&lt;div id=\"wrap\"&gt; &lt;div id=\"inner\"&gt;&lt;/div&gt; &lt;div style=\"clear: both;\"&gt;&lt;/div&gt;&lt;/div&gt; 123456789#wrap &#123; border: 1px solid;&#125;#inner &#123; float: left; width: 200px; height: 200px; background: pink;&#125; 套路 3：伪元素清除浮动上面那种办法固然可以清除浮动，但是我们不想在页面中添加这些没有意义的冗余元素，此时如何清除浮动吗？结合 :after 伪元素和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。 123&lt;div id=\"wrap\" class=\"clearfix\"&gt; &lt;div id=\"inner\"&gt;&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122#wrap &#123; border: 1px solid;&#125;#inner &#123; float: left; width: 200px; height: 200px; background: pink;&#125;/*开启haslayout*/.clearfix &#123; *zoom: 1;&#125;/*ie6 7不支持伪元素*/.clearfix:after &#123; content: \"\"; display: block; clear: both; height: 0; line-height: 0; visibility: hidden; //允许浏览器渲染它，但是不显示出来&#125; 给浮动元素的父容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素，实现元素末尾添加一个看不见的块元素来清理浮动。这是通用的清理浮动方案，推荐使用 套路 4：给父元素使用 overflow:hidden;这种方案让父容器形成了 BFC（块级格式上下文），而 BFC 可以包含浮动，通常用来解决浮动父元素高度坍塌的问题。 BFC 的触发方式 我们可以给父元素添加以下属性来触发 BFC： float 为 left | right overflow 为 hidden | auto | scorll display 为 table-cell | table-caption | inline-block position 为 absolute | fixed 这里可以给父元素设置 overflow:auto，但是为了兼容 IE 最好使用 overflow:hidden。 但这种办法有个缺陷：如果有内容出了盒子，用这种方法就会把多的部分裁切掉，所以这时候不能使用。 BFC 的主要特征: BFC 容器是一个隔离的容器，和其他元素互不干扰；所以我们可以用触发两个元素的 BFC 来解决垂直边距折叠问题。 BFC 不会重叠浮动元素 BFC 可以包含浮动,这可以清除浮动。 套路 5：br 标签清浮动br 标签存在一个属性：clear。这个属性就是能够清除浮动的利器，在 br 标签中设置属性 clear，并赋值 all。即能清除掉浮动。 1234&lt;div id=\"wrap\"&gt; &lt;div id=\"inner\"&gt;&lt;/div&gt; &lt;br clear=\"all\" /&gt;&lt;/div&gt; 123456789#wrap &#123; border: 1px solid;&#125;#inner &#123; float: left; width: 200px; height: 200px; background: pink;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"清除浮动","slug":"清除浮动","permalink":"http://yoursite.com/tags/清除浮动/"}]},{"title":"git merge和git rebase的区别","slug":"git merge和git rebase的区别","date":"2019-09-21T14:53:17.000Z","updated":"2019-09-21T14:54:12.854Z","comments":true,"path":"2019/09/21/git merge和git rebase的区别/","link":"","permalink":"http://yoursite.com/2019/09/21/git merge和git rebase的区别/","excerpt":"","text":"git merge和git rebase的区别git rebase 和 git merge 一样都是用于从一个分支获取并且合并到当前分支，但是他们采取不同的工作方式。 为了将master 上新的提交合并到你的feature分支上，你有两种选择：merging or rebase merge执行以下命令： 12git checkout featuregit merge master 或 1git merge master feature 那么此时在feature上git 自动会产生一个新的commit(merge commit) git merge 有如下特点： 只处理一次冲突，如果合并的时候遇到冲突，仅需要修改后重新commit 引入了一次合并的历史记录，合并后的所有 commit 会按照提交时间从旧到新排列 所有的过程信息更多，可能会提高之后查找问题的难度 优点：记录了真实的commit情况，包括每个分支的详情 缺点：因为每次merge会自动产生一个merge commit，所以在使用一些git 的GUI tools，特别是commit比较频繁时，看到分支很杂乱。 rebase与 git merge 一致，git rebase 的目的也是将一个分支的更改并入到另外一个分支中去。 12git checkout featuregit rebase master 本质是变基 变基 变基 变基是什么? 找公共祖先 rebase 特点： 改变当前分支从 master上拉出分支的位置 没有多余的合并历史的记录，会合并之前的commit历史，且合并后的 commit顺序不一定按照 commit的提交时间排列 可能会多次解决同一个地方的冲突（有 squash来解决） 更清爽一些，master分支上每个 commit点都是相对独立完整的功能单元 优点：得到更简洁的项目历史，去掉了merge commit 缺点：如果合并出现代码问题不容易定位，因为rewrite了history 合并时遇到冲突：合并时如果出现冲突需要按照如下步骤解决 修改冲突部分 git add git rebase --continue （如果第三步无效可以执行 git rebase --skip） 不要在git add 之后习惯性的执行 git commit命令 git rebase 的交互模式打开变基的交互模式只需要传入一个参数 -i 即可，同时还需要指定对哪些提交进行处理 1git rebase -i HEAD~4 上述命令指定了对当前分支的最近四次提交进行操作。下面我们使用上面这行命令将 feature 分支的提交合并。 中间红框内有一些命令，可以用来处理某次提交的 总结 如果你想要一个干净的，没有merge commit的线性历史树，或者当发现自己修改某个功能时，频繁进行了git commit提交时，发现其实过多的提交信息没有必要时，那么你应该选择git rebase 当需要保留详细的合并信息的时候建议使用git merge，特别是需要将分支合并进入master分支时，并且想要避免重写commit history的风险，你应该选择使用git merge","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"浏览器同域名请求的最大并发数限制","slug":"浏览器同域名请求的最大并发数限制","date":"2019-09-14T15:14:44.000Z","updated":"2019-11-10T14:37:39.038Z","comments":true,"path":"2019/09/14/浏览器同域名请求的最大并发数限制/","link":"","permalink":"http://yoursite.com/2019/09/14/浏览器同域名请求的最大并发数限制/","excerpt":"","text":"浏览器同域名请求的最大并发数限制当我们在浏览网页的时候，对浏览速度有一个重要的影响因素，就是浏览器的并发数量。并发数量简单通俗的讲就是，当浏览器网页的时候同时工作的进行数量。 如果同时只有 2 个并发连接数数量，那网页打开的时候只能依赖于这 2 条线程，前面如果有打开慢的内容，就会直接影响到后面的内容打开。但是如果同时有更多的并发连接数，这样就会大大的提高网页加载速度。但是浏览器的并发连接数也并非越大越好。 HTTP 客户端一般对同一个服务器的并发连接个数都是有限制的。实际上，浏览器确实使用并行连接，但它们将并行连接的总数限制为少量（通常为四个）。服务器可以自由地关闭来自特定客户端的过多连接。 主流浏览器最大并发连接数一些主流浏览器对 HTTP 1.1 和 HTTP 1.0 的最大并发连接数目，可以参考如下表格： 浏览器 HTTP / 1.1 HTTP / 1.0 IE 11 6 6 IE 10 6 6 IE 9 10 10 IE 8 6 6 IE 6,7 2 4 火狐 6 6 Safari 3,4 4 4 Chrome 4+ 6 6 歌剧 9.63,10.00alpha 4 4 Opera 10.51+ 8 ？ iPhone 2 4 ？ iPhone 3 6 ？ iPhone 4 4 ？ iphone 5 6 ？ Android2-4 4 ？ Firefox 浏览器的最大并发连接数在 Firefox 中的地址栏输入“about：config 中”，然后搜索并修改如下两个配置项目即可： network.http.max-persistent-connections-per-server:6连接同一个服务器允许的最大持久连接数，默认为 6，可以不用更改。 network.http.max-persistent-connections-per-proxy:8每个代理服务器允许的最大持久连接数,公司用户使用代理服务器，但是外面的客户一般不使用代理，火狐推荐的每台代理服务器设置为：&lt;= 10。 Firefox3.6 和 IE8 的几乎完全一样： 最大并发 HTTP 连接数为 6 个（可在 about:config 中修改）。 javascript 文件不会阻塞其他资源的加载，多个 javascript 文件可以一起加载。 会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。 Firefox4 beta12 不知是因为设计理念上的不同，还是因为 beta 版未照顾到这一块，Firefox4 反而退化了，和 Firefox3.6 的区别主要体现在对资源类型的处理上，Firefox4 不再严格地优先下载 script 和 link 标签定义的外部资源，而是按照 HTML 结构中出现的顺序来进行加载。 IE 浏览器的最大并发连接数用“注册表编辑器”命令打开注册表编辑器，找到： [HKEY_CURRRENT_USER \\ Software \\ Microsoft \\ Windows \\ CurrentVersion \\ Internet Settings]，可以看到MaxConnectionsPerServer和MaxConnectionsPer1_0Server这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置） 对于 IE 9 [HKEY_CURRRENT_USER \\ Software \\ Policies \\ Microsoft \\ Internet Exploer \\ Main \\ FeatureControl，可以看到FEATURE_MAXCONNECTIONSPER1_0SERVER和FEATURE_MAXCONNECTIONSPERSERVER这两个键（分别是针对 HTTP 1.1 和 HTTP 1.0 的设置） IE8 和 IE6 完全不同的瀑布图，其特点有： 最大并发 HTTP 连接数为 6 个。 javascript 文件已经不会阻塞其他资源的加载，甚至多个 javascript 文件可以一起加载，并且会保证执行的顺序。 会分析 HTML 结构，优先下载 script 和 link 标签定义的外部资源。 chrome 浏览器的最大并发连接数Chrome8 Chrome 自带的工具不能很清楚地表示各请求的开始时间，所以使用了 Fiddler 的瀑布图，从图上可以看出，Chrome 也是比较特立独行的一位，其特点有： 最大并发 HTTP 连接数为 6。 head 部分的资源会单独下载，且阻塞 body 中的其他资源的加载。 会优先加载 script 和 link 标签定义的资源。 opera 浏览器的最大并发连接数Opera11 先报怨一下，Dragonfly 不怎么好用来着……Opera 的资源加载也比较有特色，而且很难看出规律，只能大致总结一下： Opera 的最大并发 HTTP 连接数默认为 16，可在 opera:config - Performance - Max Connections Server 查看和修改。 javascript 文件的加载会阻塞其他 script 和 link 标签定义的外部资源的加载，如图中的 2.js。但不会阻塞图片等其他资源的加载，如图中的 3.js。 会一定程度上对资源的优先级进行优化，但由于 javascript 文件要阻止后续部分资源的加载，又为了充分利用最大 HTTP 连接数，因此不能严格先加载所有的 script 和 link 标签定义的资源，导致瀑布图上各类型资源有相互穿插，难寻规律。 HTTP 连接请求与线程HTTP 连接是复杂，有状态的对象，所以它必须被妥善管理。一个 HTTP 连接请求在同一时间只能被一个线程访问。 HttpClient 使用一个叫做的 Http 连接管理器的特殊实体类来管理的 Http 连接。Http 连接管理器在新建的 HTTP 连接时，作为工厂类；管理持久的 http 连接的生命周期；同步持久连接（确保线程安全，即一个 HTTP 连接同一时间只能被一个线程访问）。 如果一个的 Http 连接被释放或者被它的消费者明确表示要关闭，那么底层的连接就会和它的代理进行分离，并且该连接会被交还给连接管理器。这是，即使服务消费者仍然持有代理的引用，它也不能再执行 I / O 操作，或者更改的 Http 连接的状态。 连接池管理器连接池管理器是个复杂的类，它管理着连接池，可以同时为很多线程提供 HTTP 连接请求。当请求一个新的连接时，如果连接池有有可用的持久连接，连接管理器就会使用其中的一个，而不是再创建一个新的连接。 当使用了请求连接池管理器后，HttpClient 的就可以同时执行多个线程的请求了。 连接池管理器会根据它的配置来分配请求连接。如果连接池中的所有连接都被占用了，那么后续的请求就会被阻塞，直到有连接被释放回连接池中。 线程池的原理线程池的原理很简单，类似于操作系统中的缓冲区的概念，它的流程如下： 线程池在还没有任务到来之前，创建一定数量的线程，放入空闲队列中。这些线程都是处于睡眠状态，即均为启动，不消耗 CPU，而只是占用较小的内存空间。当客户端有一个新请求时，就会唤醒线程池中的某一个睡眠线程，让它来处理客户端的这个请求，当处理完这个请求后，线程又处于睡眠状态。 线程池能节约大量的的系统资源，使得更多的 CPU 时间和内存用来处理实际的商业应用，而不是频繁的线程创建与销毁 每个线程需要大约 1MB 内存，线程开的越多，消耗的内存也就越大。 在什么情况下使用线程池： 单个任务处理的时间比较短 将需处理的任务的数量大 数据库连接池数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池（简单说：在一个“池”里放了好多半成品的数据库联接对象），由应用程序动态地对池中的连接进行申请，使用和释放。对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数。连接池技术尽可能多地重用了消耗内存地资源，大大节省了内存，提高了服务器地服务效率，能够支持更多的客户服务。通过使用连接池，将大大提高程序运行效率，同时，我们可以通过其自身的管理机制来监视数据库连接的数量，使用情况等。 1）最小连接数是连接池一直保持的数据库连接，所以如果应用程序对数据库连接的使用量不大，将会有大量的数据库连接资源被浪费;2）最大连接数是连接池能申请的最大连接数，如果数据库连接请求超过此数，后面的数据库连接请求将被加入到等待队列中，这会影响之后的数据库操作。 数据库连接是一种关键的有限的昂贵的资源，这一点在多用户的网页应用程序中体现得尤为突出。一个数据库连接对象均对应一个物理数据库连接，每次操作都打开一个物理连接，使用完都关闭连接，这样造成系统的性能低下。 WebSphere Application Server 性能http://websphere.sys-con.com/node/46514/print 构建服务器应用程序的一个过于简单的模型是：每当一个请求到达就创建一个新的服务对象，然后在新的服务对象中为服务请求，但当有大量请求并发访问时，服务器不断的创建和销毁对象的开销很大。 在面向对象的编程中，创建和销毁对象是很浪费资源的，因为创建一个对象要获取内存资源或者其它更多资源。在 Java 的中更是如此，虚拟机试图跟踪每一个对象，以便能够在对象销毁后进行垃圾回收。所以，提高程序效率的一个手段就是尽可能减少创建和销毁对象的次数。利用已有的对象来服务就是“池化资源”技术产生的原因。 HTTP 侦听器HTTP 侦听器负责在 HTTP 服务器级别创建线程。这里发生的大多数处理是静态页面服务，或 HTTP post / GET 传递命令到后端。这是必须考虑的第一级线程配置。 Web 容器Web 容器负责在应用程序服务器级别创建线程池。此级别的大多数处理包括 servlet，JSP，EJB，动态页面创建和后端传递处理。Web 容器是必须配置的第二级线程池配置。 ORB 容器 ORB 容器负责在对象级创建线程池。这里发生的大部分处理包括处理基于非 Web 的客户端。ORB 容器是必须配置的线程池配置的第三级。 数据源数据源级负责创建从数据库或“传统”系统访问的连接线程。这些线程是必须解决的第四级配置 WAS 线程池数与 IHS server假定一个浏览器的并发连接请求数为 10，通常同一时间内会有多个用户并发访问网站。又考虑到，一个 Http 连接请求在同一时间只能被一个线程访问。所以，IHS 服务器的 httpd.conf 里的 maxclients（允许建立的总线程数）要能够处理峰值时刻的浏览器连接请求才行。同时，考虑不是所有的连接请求都会到 was server，有的连接只是为了在 web 服务器上取静态资源，所以，was 上的线程池数目（Thread pools ：50 ）会远小于 IHS server 上的 maxclients 值譬如 400）。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"前端优化","slug":"前端优化","date":"2019-09-08T15:48:15.000Z","updated":"2019-11-10T14:37:39.031Z","comments":true,"path":"2019/09/08/前端优化/","link":"","permalink":"http://yoursite.com/2019/09/08/前端优化/","excerpt":"","text":"前端优化前端性能衡量指标 白屏时间 该时间点表示浏览器开始绘制页面，在此之前页面都是白屏，也称为开始渲染时间 首屏时间 该时间点表示用户看到第一屏页面的时间 用户可交互时间 也叫 DOM Ready,该时间点表示 DOM 解析完成，资源还没有完成，这个时候用户与页面可以交互了 完全加载时间 该时间点是 window.onload 时间触发的时间，表示原始文档和所用引用的内容已经加载完成，用户最明显的感觉就是浏览器 tab 上 loading 状态结束 首字节时间（TTFB） 第一字节响应时间（TTFB）=发送请求到 WEB 服务器的时间+WEB 服务器处理请求并生成响应花费的时间+WEB 服务器生成响应到浏览器花费的时间 DNS 解析时间 TCP 连接时间 HTTP 请求时间 HTTP 响应时间 优化原则雅虎 14 条优化原则： 尽可能的减少 HTTP 的请求数 content 使用 CDN（Content Delivery Network） server 添加 Expires 头(或者 Cache-control ) server Gzip 组件 server 将 CSS 样式放在页面的上方 css 将脚本移动到底部（包括内联的） javascript 避免使用 CSS 中的 Expressions css 将 JavaScript 和 CSS 独立成外部文件 javascript css 减少 DNS 查询 content 压缩 JavaScript 和 CSS (包括内联的) javascript css 避免重定向 server 移除重复的脚本 javascript 配置实体标签（ETags） css 使 AJAX 缓存 优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域，字体图标，雪碧图片等 请求带宽 开启服务器 GZip，精简 JavaScript，移除重复脚本，图像优化（包括图片大小 kb） 缓存利用 使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AjaX 可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免 CSS 表达式，避免重定向 网络相关DNS 预解析DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。 1&lt;link rel=\"dns-prefetch\" href=\"//yuchengkai.cn\" /&gt; 利用缓存缓存对于前端性能优化来说是个很重要的点，良好的缓存策略可以降低资源的重复加载提高网页的整体加载速度。 通常浏览器缓存策略分为两种：强缓存和协商缓存 选择合适的缓存策略对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。 使用 HTTP / 2.0因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建立和断开，消耗了好几个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积大的文件会需要更多的时间。 在 HTTP / 2.0 中引入了多路复用，能够让多个请求使用同一个 TCP 链接，极大的加快了网页的加载速度。并且还支持 Header 压缩，进一步的减少了请求的数据大小。 预加载&amp;懒加载预加载在开发中，可能会遇到这样的情况。有些资源不需要马上用到，但是希望尽早获取，这时候就可以使用预加载。 预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件，可以使用以下代码开启预加载 1&lt;link rel=\"preload\" href=\"http://example.com\" /&gt; 预加载可以一定程度上降低首屏的加载时间，因为可以将一些不影响首屏但重要的文件延后加载，唯一缺点就是兼容性不好。 预渲染可以通过预渲染将下载的文件预先在后台渲染，可以使用以下代码开启预渲染 1&lt;link rel=\"prerender\" href=\"http://example.com\" /&gt; 预渲染虽然可以提高页面的加载速度，但是要确保该页面百分百会被用户在之后打开，否则就白白浪费资源去渲染。 懒执行懒执行就是将某些逻辑延迟到使用时再计算。该技术可以用于首屏优化，对于某些耗时逻辑并不需要在首屏就使用的，就可以使用懒执行。懒执行需要唤醒，一般可以通过定时器或者事件的调用来唤醒。 懒加载懒加载就是将不关键的资源延后加载。 懒加载的原理就是只加载自定义区域（通常是可视区域，但也可以是即将进入可视区域）内需要加载的东西。对于图片来说，先设置图片标签的 src 属性为一张占位图，将真实的图片资源放入一个自定义属性中，当进入自定义区域时，就将自定义属性替换为 src 属性，这样图片就会去下载资源，实现了图片懒加载。 懒加载不仅可以用于图片，也可以使用在别的资源上。比如进入可视区域才开始播放视频等等。 文件优化图片优化图片大小计算在实际项目中，一张图片可能并不需要使用那么多颜色去显示，我们可以通过减少每个像素的调色板来相应缩小图片的大小。 了解了如何计算图片大小的知识，那么对于如何优化图片，想必大家已经有 2 个思路了： 减少像素点 减少每个像素点能够显示的颜色 图片加载优化 不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。 对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。 小图使用 base64 格式 将多个图标文件整合到一张图片中（雪碧图） 选择正确的图片格式： 对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好 小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替 照片使用 JPEG 其他文件优化 CSS 文件放在 head 中 服务端开启文件压缩功能 将 script 标签放在 body 底部，因为 JS 文件执行会阻塞渲染。当然也可以把 script 标签放在任意位置然后加上 defer ，表示该文件会并行下载，但是会放到 HTML 解析完成后顺序执行。对于没有任何依赖的 JS 文件可以加上 async ，表示加载和渲染后续文档元素的过程将和 JS 文件的加载与执行并行无序进行。 执行 JS 代码过长会卡住渲染，对于需要很多时间计算的代码可以考虑使用 Webworker。Webworker 可以让我们另开一个线程执行脚本而不影响渲染。 CDN CDN 的全称是 Content Delivery Network，即内容分发网络。CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。—— 科学百科 CDN 存在的意义为了不让网络拥塞成为互联网发展的障碍。 CDN 的优势 CDN 节点解决了跨运营商和跨地域访问的问题，访问延时大大降低； 大部分请求在 CDN 边缘节点完成，CDN 起到了分流作用，减轻了源站的负载； 降低“广播风暴”的影响，提高网络访问的稳定性；节省骨干网带宽，减少带宽需求量。 CDN 的核心点 缓存：将从根服务器请求来的资源按要求缓存。 回源：当有用户访问某个资源的时候，如果被解析到的那个 CDN 节点没有缓存响应的内容，或者是缓存已经到期，就会回源站去获取。没有人访问，CDN 节点不会主动去源站请求资源。 关键技术 内容发布：它借助于建立索引、缓存、流分裂、组播（Multicast）等技术，将内容发布或投递到距离用户最近的远程服务点（POP）处； 内容路由：它是整体性的网络负载均衡技术，通过内容路由器中的重定向（DNS）机制，在多个远程 POP 上均衡用户的请求，以使用户请求得到最近内容源的响应； 内容交换：它根据内容的可用性、服务器的可用性以及用户的背景，在 POP 的缓存服务器上，利用应用层交换、流分裂、重定向（ICP、WCCP）等技术，智能地平衡负载流量； 性能管理：它通过内部和外部监控系统，获取网络部件的状况信息，测量内容发布的端到端性能（如包丢失、延时、平均带宽、启动时间、帧速率等），保证网络处于最佳的运行状态。 CDN &amp; 静态资源静态资源本身具有访问频率高、承接流量大的特点，因此静态资源加载速度始终是前端性能的一个非常关键的指标。CDN 是静态资源提速的重要手段。 静态资源尽量使用 CDN 加载，由于浏览器对于单个域名有并发请求上限，可以考虑使用多个 CDN 域名。对于 CDN 加载静态资源需要注意 CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie。 其他优化使用 Webpack 优化项目 对于 Webpack4，打包项目使用 production 模式，这样会自动开启代码压缩 使用 ES6 模块来开启 tree shaking，这个技术可以移除没有使用的代码 优化图片，对于小图可以使用 base64 的方式写入文件中 按照路由拆分代码，实现按需加载 给打包出来的文件名添加哈希，实现浏览器缓存文件 监控对于代码运行错误，通常的办法是使用 window.onerror 拦截报错。该方法能拦截到大部分的详细报错信息，但是也有例外 对于跨域的代码运行错误会显示 Script error. 对于这种情况我们需要给 script 标签添加 crossorigin 属性 对于某些浏览器可能不会显示调用栈信息，这种情况可以通过 arguments.callee.caller 来做栈递归 对于异步代码来说，可以使用 catch 的方式捕获错误。比如 Promise 可以直接使用 catch 函数，async await 可以使用 try catch 但是要注意线上运行的代码都是压缩过的，需要在打包时生成 sourceMap 文件便于 debug。 对于捕获的错误需要上传给服务器，通常可以通过 img 标签的 src 发起一个请求。 如何优化第二次加载速度？（增量加载）前端性能优化三部曲(加载篇) 移动 H5 首屏秒开优化方案探讨 降低请求量：合并资源，减少 HTTP 请求数，minify / gzip 压缩，webP，lazyLoad。 加快请求速度：预解析 DNS，减少域名数，并行加载，CDN 分发。 缓存：HTTP 协议缓存请求，离线缓存 manifest，离线数据缓存 localStorage。 渲染：JS/CSS 优化，加载顺序，服务端渲染，pipeline。 其中对首屏启动速度影响最大的就是网络请求，所以优化的重点就是缓存 增量式更新”的解决方案，简单地说就是在版本更新的时候不需要重新加载资源，只需要加载一段很小的 diff 信息，然后合并到当前资源上，类似 git merge 的效果。 增量加载的一种思路： 1、用户端使用 LocalStorage 或者其它储存方案，存储一份原始代码+时间戳： 1234&#123; timeStamp: &quot;20161026xxxxxx&quot;, data: &quot;aaabbbccc&quot;&#125; 2、每次加载资源的时候向服务器发送这个时间戳； 3、服务器从接受到时间戳中识别出客户端的版本，和最新的版本做一次 diff，返回两者的 diff 信息： 123diff(\"aaabbbccc\", \"aaagggccc\");// 假设我们的diff信息这样表示：// [3, \"-3\", \"+ggg\", 3] 4、客户端接收到这个 diff 信息之后，把本地资源和时间戳更新到最新，实现一次增量更新： 12mergeDiff(\"aaabbbccc\", [3, \"-3\", \"+ggg\", 3]);//=&gt; \"aaagggccc\" 面试题（如何渲染几万条数据并不卡住界）这道题考察了如何在不卡住页面的情况下渲染数据，也就是说不能一次性将几万条都渲染出来，而应该一次渲染部分 DOM，那么就可以通过 requestAnimationFrame 来每 16 ms 刷新一次。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"UTF-8\" /&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\" /&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; 控件 &lt;/ul&gt; &lt;script&gt; setTimeout(() =&gt; &#123; // 插入十万条数据 const total = 100000; // 一次插入 20 条，如果觉得性能不好就减少 const once = 20; // 渲染数据总共需要几次 const loopCount = total / once; let countOfRender = 0; let ul = document.querySelector(\"ul\"); function add() &#123; // 优化性能，插入不会造成回流 const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; once; i++) &#123; const li = document.createElement(\"li\"); li.innerText = Math.floor(Math.random() * total); fragment.appendChild(li); &#125; ul.appendChild(fragment); countOfRender += 1; loop(); &#125; function loop() &#123; if (countOfRender &lt; loopCount) &#123; window.requestAnimationFrame(add); &#125; &#125; loop(); &#125;, 0); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 拓展知识之 Gzip基本介绍gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome,firefox,IE 等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持 gzip。 gzip 压缩比率在 3 到 10 倍左右，可以大大节省服务器的网络带宽。而在实际应用中，并不是对所有文件进行压缩，通常只是压缩静态文件。 gzip 工作原理： 浏览器请求 url，并在 request header 中设置属性 accept-encoding:gzip。表明浏览器支持 gzip。 服务器收到浏览器发送的请求之后，判断浏览器是否支持 gzip，如果支持 gzip，则向浏览器传送压缩过的内容，不支持则向浏览器发送未经压缩的内容。一般情况下，浏览器和服务器都支持 gzip，response headers 返回包含 content-encoding:gzip。 浏览器接收到服务器的响应之后判断内容是否被压缩，如果被压缩则解压缩显示页面内容。 Nginx 中开启 gzip如果服务端接口使用 nodejs 和 express，那么开启 nginx 非常简单。启用 compress() 中间件即可并在 nginx.conf 中添加 gzip 配置项即可，express.compress() gzip 压缩中间件，通过 filter 函数设置需要压缩的文件类型。压缩算法为 gzip/deflate。这个中间件应该放置在所有的中间件最前面以保证所有的返回都是被压缩的。如果使用 java 开发，需要配置 filter。 添加完参数后，运行 nginx –t 检查一下语法，若语法检测通过，则开始访问 url 检测 gzip 是否添加成功。 gzip on：开启 gzip。 gzip_comp_level：gzip 压缩比。 gzip_min_length：允许被压缩的页面最小字节数。 gzip_types：匹配 MIME 类型进行压缩，text/html 默认被压缩。 检测 gzip 是否开启如果没有现成的项目代码，这里提供一个比较简单的检测方式。首先在本地安装 nginx，在 nginx 默认目录下面添加了两个静态文件 bootstrap.css、bootstrap.js。 OS X 系统的默认路径为：/usr/local/Cellar/nginx/1.10.2_1/html，Windows 系统直接复制文件到文件夹下面。 拷贝文件指令可参考：cp -r bootstrap.js /usr/local/Cellar/nginx/1.10.2_1/html，在 nginx 的默认成功跳转页面 index.html 引入这两个静态文件。index.html 页面内容如图所示。 做好这一切的准备工作之后，浏览器输入http://localhost:8080/。出现如图所示页面表明 nginx 启动成功。 nginx 启动成功界面。 此时打开 Chrome 控制台，可以看到 network 信息，response headers 中返回了 content-encoding:gzip，表明 gzip 开启成功。 gzip 未开启前 network 信息如图所示： 开启后返回 network 信息如图所示： url 请求的 headers 报文如图所示： 对比以上三图可以看出 gzip 压缩效率非常高，且经过压缩后静态文件大小不到原来的五分之一。这里值得一提的是静态资源文件越大，gzip 的压缩效率越高。所以对于静态资源量非常大的网站，开启 gzip 可节省大量流量，而同时 gzip 的应用远不止提高 web 性能,Android，IOS 底层网络请求同样可用。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"性能优化","slug":"性能优化","permalink":"http://yoursite.com/tags/性能优化/"}]},{"title":"CSS的position属性","slug":"CSS的position属性","date":"2019-08-31T13:48:53.000Z","updated":"2019-11-10T14:37:39.015Z","comments":true,"path":"2019/08/31/CSS的position属性/","link":"","permalink":"http://yoursite.com/2019/08/31/CSS的position属性/","excerpt":"","text":"CSS 的 position 属性static默认值。该关键字指定元素使用正常的布局行为，即元素在文档常规流中当前的布局位置。此时 top, right, bottom, left 和 z-index属性无效。 relative定位类型相对定位元素，相对定位的元素是在文档中的正常位置偏移给定的值，但是不影响其他元素的偏移。 定位方式生成相对定位的元素，相对于其正常位置进行定位。该关键字下，元素先放置在未添加定位时的位置，再在不改变页面布局的前提下调整元素位置（因此会在此元素未添加定位时所在位置留下空白，”left:20” 会向元素的 LEFT 位置添加 20 像素。）。position:relative 对 table-group, table-row,table-column,table-cell,table-caption 元素无效。 1234&lt;div class=\"box\" id=\"one\"&gt;One&lt;/div&gt;&lt;div class=\"box\" id=\"two\"&gt;Two&lt;/div&gt;&lt;div class=\"box\" id=\"three\"&gt;Three&lt;/div&gt;&lt;div class=\"box\" id=\"four\"&gt;Four&lt;/div&gt; 1234567891011121314.box &#123; display: inline-block; width: 100px; height: 100px; background: red; color: white;&#125;#two &#123; position: relative; top: 20px; left: 20px; background: blue;&#125; absolute定位类型绝对定位元素，相对定位的元素并未脱离文档流，而绝对定位的元素则脱离了文档流。在布置文档流中其它元素时，绝对定位元素不占据空间。绝对定位元素相对于最近的非 static 祖先元素定位。当这样的祖先元素不存在时，则相对于 ICB（inital container block, 初始包含块）。 定位方式生成绝对定位的元素，不为元素预留空间，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。绝对定位的元素可以设置外边距（margins），且不会与其他边距合并。 1234&lt;div class=\"box\" id=\"one\"&gt;One&lt;/div&gt;&lt;div class=\"box\" id=\"two\"&gt;Two&lt;/div&gt;&lt;div class=\"box\" id=\"three\"&gt;Three&lt;/div&gt;&lt;div class=\"box\" id=\"four\"&gt;Four&lt;/div&gt; 123456789101112131415.box &#123; display: inline-block; background: red; width: 100px; height: 100px; float: left; margin: 20px; color: white;&#125;#three &#123; position: absolute; top: 20px; left: 20px;&#125; fixed定位类型绝对定位元素，固定定位与绝对定位相似，但元素的包含块为 viewport 视口。该定位方式常用于创建在滚动屏幕时仍固定在相同位置的元素。 定位方式生成绝对定位的元素，不为元素预留空间，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。fixed 属性会创建新的层叠上下文。 当元素祖先的 transform 属性非 none 时，容器由视口改为该祖先。 sticky定位类型粘性定位元素，粘性定位可以被认为是相对定位和固定定位的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。 定位方式盒位置根据正常流计算(这称为正常流动中的位置)，然后相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位。在所有情况下（即便被定位元素为 table 时），该元素定位均不对后续元素造成影响。当元素 B 被粘性定位时，后续元素的位置仍按照 B 未定位时的位置来确定。position: sticky对 table 元素的效果与 position: relative相同。 1234#one &#123; position: sticky; top: 10px;&#125; 在 viewport 视口滚动到元素 top 距离小于 10px 之前，元素为相对定位。之后，元素将固定在与顶部距离 10px 的位置，直到 viewport 视口回滚到阈值以下。 粘性定位常用于定位字母列表的头部元素。标示 B 部分开始的头部元素在滚动 A 部分时，始终处于 A 的下方。而在开始滚动 B 部分时，B 的头部会固定在屏幕顶部，直到所有 B 的项均完成滚动后，才被 C 的头部替代。 例子123456789101112131415161718192021222324252627282930&lt;div&gt; &lt;dl&gt; &lt;dt&gt;A&lt;/dt&gt; &lt;dd&gt;Andrew W.K.&lt;/dd&gt; &lt;dd&gt;Apparat&lt;/dd&gt; &lt;dd&gt;Arcade Fire&lt;/dd&gt; &lt;dd&gt;At The Drive-In&lt;/dd&gt; &lt;dd&gt;Aziz Ansari&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;C&lt;/dt&gt; &lt;dd&gt;Chromeo&lt;/dd&gt; &lt;dd&gt;Common&lt;/dd&gt; &lt;dd&gt;Converge&lt;/dd&gt; &lt;dd&gt;Crystal Castles&lt;/dd&gt; &lt;dd&gt;Cursive&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;E&lt;/dt&gt; &lt;dd&gt;Explosions In The Sky&lt;/dd&gt; &lt;/dl&gt; &lt;dl&gt; &lt;dt&gt;T&lt;/dt&gt; &lt;dd&gt;Ted Leo &amp; The Pharmacists&lt;/dd&gt; &lt;dd&gt;T-Pain&lt;/dd&gt; &lt;dd&gt;Thrice&lt;/dd&gt; &lt;dd&gt;TV On The Radio&lt;/dd&gt; &lt;dd&gt;Two Gallants&lt;/dd&gt; &lt;/dl&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132* &#123; box-sizing: border-box;&#125;dl &#123; margin: 0; padding: 24px 0 0 0;&#125;dt &#123; background: #b8c1c8; border-bottom: 1px solid #989ea4; border-top: 1px solid #717d85; color: #fff; font: bold 18px/21px Helvetica, Arial, sans-serif; margin: 0; padding: 2px 0 0 12px; position: -webkit-sticky; position: sticky; top: -1px;&#125;dd &#123; font: bold 20px/45px Helvetica, Arial, sans-serif; margin: 0; padding: 0 0 0 12px; white-space: nowrap;&#125;dd + dd &#123; border-top: 1px solid #ccc;&#125; 生效规则position:sticky 的生效是有一定的限制的，总结如下： 须指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 并且 top 和 bottom 同时设置时，top 生效的优先级高，left 和 right 同时设置时，left 的优先级高。 设定为 position:sticky 元素的任意父节点的 overflow 属性必须是 visible，否则 position:sticky 不会生效。这里需要解释一下： 如果 position:sticky 元素的任意父节点定位设置为 overflow:hidden，则父容器无法进行滚动，所以 position:sticky 元素也不会有滚动然后固定的情况。 如果 position:sticky 元素的任意父节点定位设置为 position:relative | absolute | fixed，则元素相对父元素进行定位，而不会相对 viewprot 定位。 达到设定的阀值。这个还算好理解，也就是设定了 position:sticky 的元素表现为 relative 还是 fixed 是根据元素是否达到设定了的阈值决定的。 特性 同一个父容器中的 sticky 元素，如果定位值相等，则会重叠；如果属于不同父元素，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果。 initialinitial 关键字用于设置 CSS 属性为它的默认值，可作用于任何 CSS 样式。（IE 不支持该关键字） inherit：规定应该从父元素继承 position 属性的值。 每一个 CSS 属性都有一个特性就是，这个属性必然是默认继承的 (inherited: Yes) 或者是默认不继承的 (inherited: no)其中之一，我们可以在 MDN 上通过这个索引查找，判断一个属性的是否继承特性。 可继承属性 所有元素可继承：visibility 和 cursor 内联元素可继承：letter-spacing、word-spacing、white-space、line-height、color、font、 font-family、font-size、font-style、font-variant、font-weight、text- decoration、text-transform、direction 块状元素可继承：text-indent 和 text-align 列表元素可继承：list-style、list-style-type、list-style-position、list-style-image 表格元素可继承：border-collapse unsetunset 关键字我们可以简单理解为不设置。其实，它是关键字 initial 和 inherit 的组合。 什么意思呢？也就是当我们给一个 CSS 属性设置了 unset 的话： 如果该属性是默认继承属性，该值等同于 inherit 如果该属性是非继承属性，该值等同于 initial 例子1234567&lt;div class=\"father\"&gt; &lt;div class=\"children\"&gt;子级元素一&lt;/div&gt; &lt;div class=\"children unset\"&gt;子级元素二&lt;/div&gt;&lt;/div&gt;.father &#123; color: red; border: 1px solid black; &#125; .children &#123; color: green;border: 1px solid blue; &#125; .unset &#123; color: unset; border: unset; &#125; 由于 color 是可继承样式，设置了 color: unset 的元素，最终表现为了父级的颜色 red。 由于 border 是不可继承样式，设置了 border: unset 的元素，最终表现为 border: initial ，也就是默认 border 样式，无边框。 revertrevert 未列入规范","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"position","slug":"position","permalink":"http://yoursite.com/tags/position/"}]},{"title":"ES6 装饰器","slug":"ES6 装饰器","date":"2019-08-18T14:47:55.000Z","updated":"2019-11-10T14:37:39.018Z","comments":true,"path":"2019/08/18/ES6 装饰器/","link":"","permalink":"http://yoursite.com/2019/08/18/ES6 装饰器/","excerpt":"ES6 装饰器装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。","text":"ES6 装饰器装饰器（Decorator）是一种与类（class）相关的语法，用来注释或修改类和类方法。装饰器是一种函数，写成@ + 函数名。它可以放在类和类方法的定义前面。 123456789@frozenclass Foo &#123; @configurable(false) @enumerable(true) method() &#123;&#125; @throttle(500) expensiveMethod() &#123;&#125;&#125; 上面代码一共使用了四个装饰器，一个用在类本身，另外三个用在类方法。它们不仅增加了代码的可读性，清晰地表达了意图，而且提供一种方便的手段，增加或修改类的功能。 Proxy 的核心作用是控制外界对被代理者内部的访问，Decorator 的核心作用是增强被装饰者的功能。著作权归作者所有。 类的装饰装饰器可以用来装饰整个类。 为类添加静态属性12345678910@testableclass MyTestableClass &#123; // ...&#125;function testable(target) &#123; target.isTestable = true;&#125;MyTestableClass.isTestable; // true 上面代码中，@testable就是一个装饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。testable函数的参数target是MyTestableClass类本身。 基本上，装饰器的行为就是下面这样。 1234567@decoratorclass A &#123;&#125;// 等同于class A &#123;&#125;A = decorator(A) || A; 也就是说，装饰器是一个对类进行处理的函数。装饰器函数的第一个参数，就是所要装饰的目标类。 如果觉得一个参数不够用，可以在装饰器外面再封装一层函数。 12345678910111213function testable(isTestable) &#123; return function(target) &#123; target.isTestable = isTestable; &#125;;&#125;@testable(true)class MyTestableClass &#123;&#125;MyTestableClass.isTestable; // true@testable(false)class MyClass &#123;&#125;MyClass.isTestable; // false 上面代码中，装饰器testable可以接受参数，这就等于可以修改装饰器的行为。 注意，装饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，装饰器能在编译阶段运行代码。也就是说，装饰器本质就是编译时执行的函数。 为类添加实例属性如果想添加实例属性，可以通过目标类的prototype对象操作。 123456789function testable(target) &#123; target.prototype.isTestable = true;&#125;@testableclass MyTestableClass &#123;&#125;let obj = new MyTestableClass();obj.isTestable; // true 上面代码中，装饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。 下面是另外一个例子。 123456789101112131415161718192021// mixins.jsexport function mixins(...list) &#123; return function(target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125;// main.jsimport &#123; mixins &#125; from \"./mixins\";const Foo = &#123; foo() &#123; console.log(\"foo\"); &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo(); // 'foo' 上面代码通过装饰器mixins，把Foo对象的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。 方法的装饰装饰器修改属性的描述对象装饰器不仅可以装饰类，还可以装饰类的属性。 123456class Person &#123; @readonly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;`; &#125;&#125; 上面代码中，装饰器readonly用来装饰“类”的name方法。 装饰器函数readonly一共可以接受三个参数。 123456789101112131415function readonly(target, name, descriptor) &#123; // descriptor对象原来的值如下 // &#123; // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // &#125;; descriptor.writable = false; return descriptor;&#125;readonly(Person.prototype, \"name\", descriptor);// 类似于Object.defineProperty(Person.prototype, \"name\", descriptor); 装饰器第一个参数是类的原型对象，上例是Person.prototype，装饰器的本意是要“装饰”类的实例，但是这个时候实例还没生成，所以只能去装饰原型（这不同于类的装饰，那种情况时target参数指的是类本身）；第二个参数是所要装饰的属性名，第三个参数是该属性的描述对象。 另外，上面代码说明，装饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。 下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。 1234567891011class Person &#123; @nonenumerable get kidCount() &#123; return this.children.length; &#125;&#125;function nonenumerable(target, name, descriptor) &#123; descriptor.enumerable = false; return descriptor;&#125; 下面的@log装饰器，可以起到输出日志的作用。 12345678910111213141516171819202122class Math &#123; @log add(a, b) &#123; return a + b; &#125;&#125;function log(target, name, descriptor) &#123; var oldValue = descriptor.value; descriptor.value = function() &#123; console.log(`Calling $&#123;name&#125; with`, arguments); return oldValue.apply(this, arguments); &#125;; return descriptor;&#125;const math = new Math();// passed parameters should get logged nowmath.add(2, 4); 上面代码中，@log装饰器的作用就是在执行原始的操作之前，执行一次console.log，从而达到输出日志的目的。 装饰器的注释作用12345678@testableclass Person &#123; @readonly @nonenumerable name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;`; &#125;&#125; 从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。 下面是使用 Decorator 写法的组件，看上去一目了然。 1234567891011121314151617@Component(&#123; tag: \"my-component\", styleUrl: \"my-component.scss\"&#125;)export class MyComponent &#123; @Prop() first: string; @Prop() last: string; @State() isVisible: boolean = true; render() &#123; return ( &lt;p&gt; Hello, my name is &#123;this.first&#125; &#123;this.last&#125; &lt;/p&gt; ); &#125;&#125; 多个装饰器如果同一个方法有多个装饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。 1234567891011121314function dec(id) &#123; console.log(\"evaluated\", id); return (target, property, descriptor) =&gt; console.log(\"executed\", id);&#125;class Example &#123; @dec(1) @dec(2) method() &#123;&#125;&#125;// evaluated 1// evaluated 2// executed 2// executed 1 上面代码中，外层装饰器@dec(1)先进入，但是内层装饰器@dec(2)先执行。 装饰器可用作类型检查除了注释，装饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是 JavaScript 代码静态分析的重要工具。 为什么装饰器不能用于函数函数提升，类没有提升装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。 123456789var counter = 0;var add = function () &#123; counter++;&#125;;@addfunction foo() &#123;&#125; 上面的代码，意图是执行后counter等于 1，但是实际上结果是counter等于 0。因为函数提升，使得实际执行的代码是下面这样。 123456789101112@addfunction foo() &#123;&#125;var counter;var add;counter = 0;add = function () &#123; counter++;&#125;; 下面是另一个例子。 12345var readOnly = require(\"some-decorator\");@readOnlyfunction foo() &#123;&#125; 上面代码也有问题，因为实际执行是下面这样。 1234567var readOnly;@readOnlyfunction foo() &#123;&#125;readOnly = require(\"some-decorator\"); 总之，由于存在函数提升，使得装饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。 函数一定要用装饰器另一方面，如果一定要装饰函数，可以采用高阶函数的形式直接执行。 1234567891011121314function doSomething(name) &#123; console.log(\"Hello, \" + name);&#125;function loggingDecorator(wrapped) &#123; return function() &#123; console.log(\"Starting\"); const result = wrapped.apply(this, arguments); console.log(\"Finished\"); return result; &#125;;&#125;const wrapped = loggingDecorator(doSomething); 常见装饰器core-decorators.js是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。 1. @autobindautobind装饰器使得方法中的this对象，绑定原始对象。 1234567891011121314import &#123; autobind &#125; from \"core-decorators\";class Person &#123; @autobind getPerson() &#123; return this; &#125;&#125;let person = new Person();let getPerson = person.getPerson;getPerson() === person;// true 2. @readonlyreadonly装饰器使得属性或方法不可写。 12345678910import &#123; readonly &#125; from \"core-decorators\";class Meal &#123; @readonly entree = \"steak\";&#125;var dinner = new Meal();dinner.entree = \"salmon\";// Cannot assign to read only property 'entree' of [object Object] 3. @overrideoverride装饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。 123456789101112131415161718192021import &#123; override &#125; from \"core-decorators\";class Parent &#123; speak(first, second) &#123;&#125;&#125;class Child extends Parent &#123; @override speak() &#123;&#125; // SyntaxError: Child#speak() does not properly override Parent#speak(first, second)&#125;// orclass Child extends Parent &#123; @override speaks() &#123;&#125; // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain. // // Did you mean \"speak\"?&#125; 4. @deprecate (别名@deprecated)deprecate或deprecated装饰器在控制台显示一条警告，表示该方法将废除。 12345678910111213141516171819202122232425262728import &#123; deprecate &#125; from \"core-decorators\";class Person &#123; @deprecate facepalm() &#123;&#125; @deprecate(\"We stopped facepalming\") facepalmHard() &#123;&#125; @deprecate(\"We stopped facepalming\", &#123; url: \"http://knowyourmeme.com/memes/facepalm\" &#125;) facepalmHarder() &#123;&#125;&#125;let person = new Person();person.facepalm();// DEPRECATION Person#facepalm: This function will be removed in future versions.person.facepalmHard();// DEPRECATION Person#facepalmHard: We stopped facepalmingperson.facepalmHarder();// DEPRECATION Person#facepalmHarder: We stopped facepalming//// See http://knowyourmeme.com/memes/facepalm for more details.// 5. @suppressWarningssuppressWarnings装饰器抑制deprecated装饰器导致的console.warn()调用。但是，异步代码发出的调用除外。 12345678910111213141516import &#123; suppressWarnings &#125; from \"core-decorators\";class Person &#123; @deprecated facepalm() &#123;&#125; @suppressWarnings facepalmWithoutWarning() &#123; this.facepalm(); &#125;&#125;let person = new Person();person.facepalmWithoutWarning();// no warning is logged 使用装饰器实现自动发布事件我们可以使用装饰器，使得对象的方法被调用时，自动发出一个事件。 1234567891011121314151617181920const postal = require(\"postal/lib/postal.lodash\");export default function publish(topic, channel) &#123; const channelName = channel || \"/\"; const msgChannel = postal.channel(channelName); msgChannel.subscribe(topic, v =&gt; &#123; console.log(\"频道: \", channelName); console.log(\"事件: \", topic); console.log(\"数据: \", v); &#125;); return function(target, name, descriptor) &#123; const fn = descriptor.value; descriptor.value = function() &#123; let value = fn.apply(this, arguments); msgChannel.publish(topic, value); &#125;; &#125;;&#125; 上面代码定义了一个名为publish的装饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是Postal.js。 它的用法如下。 123456789101112131415161718// index.jsimport publish from \"./publish\";class FooComponent &#123; @publish(\"foo.some.message\", \"component\") someMethod() &#123; return &#123; my: \"data\" &#125;; &#125; @publish(\"foo.some.other\") anotherMethod() &#123; // ... &#125;&#125;let foo = new FooComponent();foo.someMethod();foo.anotherMethod(); 以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。 12345678$ bash-node index.js频道: component事件: foo.some.message数据: &#123; my: 'data' &#125;频道: /事件: foo.some.other数据: undefined Mixin在装饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。 请看下面的例子。 123456789101112const Foo = &#123; foo() &#123; console.log(\"foo\"); &#125;&#125;;class MyClass &#123;&#125;Object.assign(MyClass.prototype, Foo);let obj = new MyClass();obj.foo(); // 'foo' 上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。 下面，我们部署一个通用脚本mixins.js，将 Mixin 写成一个装饰器。 12345export function mixins(...list) &#123; return function(target) &#123; Object.assign(target.prototype, ...list); &#125;;&#125; 然后，就可以使用上面这个装饰器，为类“混入”各种方法。 12345678910111213import &#123; mixins &#125; from \"./mixins\";const Foo = &#123; foo() &#123; console.log(\"foo\"); &#125;&#125;;@mixins(Foo)class MyClass &#123;&#125;let obj = new MyClass();obj.foo(); // \"foo\" 通过mixins这个装饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。 不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现 Mixin。 123class MyClass extends MyBaseClass &#123; /* ... */&#125; 上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面“混入”一个foo方法，一个办法是在MyClass和MyBaseClass之间插入一个混入类，这个类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass再继承这个类。 123456let MyMixin = superclass =&gt; class extends superclass &#123; foo() &#123; console.log(\"foo from MyMixin\"); &#125; &#125;; 上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。 接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。 123456class MyClass extends MyMixin(MyBaseClass) &#123; /* ... */&#125;let c = new MyClass();c.foo(); // \"foo from MyMixin\" 如果需要“混入”多个方法，就生成多个混入类。 123class MyClass extends Mixin1(Mixin2(MyBaseClass)) &#123; /* ... */&#125; 这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法。 12345678910111213141516171819202122232425262728let Mixin1 = superclass =&gt; class extends superclass &#123; foo() &#123; console.log(\"foo from Mixin1\"); if (super.foo) super.foo(); &#125; &#125;;let Mixin2 = superclass =&gt; class extends superclass &#123; foo() &#123; console.log(\"foo from Mixin2\"); if (super.foo) super.foo(); &#125; &#125;;class S &#123; foo() &#123; console.log(\"foo from S\"); &#125;&#125;class C extends Mixin1(Mixin2(S)) &#123; foo() &#123; console.log(\"foo from C\"); super.foo(); &#125;&#125; 上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。 12345new C().foo();// foo from C// foo from Mixin1// foo from Mixin2// foo from S TraitTrait 也是一种装饰器，效果与 Mixin 类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。 下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits装饰器，不仅可以接受对象，还可以接受 ES6 类作为参数。 1234567891011121314151617181920import &#123; traits &#125; from \"traits-decorator\";class TFoo &#123; foo() &#123; console.log(\"foo\"); &#125;&#125;const TBar = &#123; bar() &#123; console.log(\"bar\"); &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123;&#125;let obj = new MyClass();obj.foo(); // fooobj.bar(); // bar 上面代码中，通过traits装饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。 Trait 不允许“混入”同名方法。 1234567891011121314151617181920212223import &#123; traits &#125; from \"traits-decorator\";class TFoo &#123; foo() &#123; console.log(\"foo\"); &#125;&#125;const TBar = &#123; bar() &#123; console.log(\"bar\"); &#125;, foo() &#123; console.log(\"foo\"); &#125;&#125;;@traits(TFoo, TBar)class MyClass &#123;&#125;// 报错// throw new Error('Method named: ' + methodName + ' is defined twice.');// ^// Error: Method named: foo is defined twice. 上面代码中，TFoo和TBar都有foo方法，结果traits装饰器报错。 一种解决方法是排除TBar的foo方法。 1234567891011121314151617181920212223import &#123; traits, excludes &#125; from \"traits-decorator\";class TFoo &#123; foo() &#123; console.log(\"foo\"); &#125;&#125;const TBar = &#123; bar() &#123; console.log(\"bar\"); &#125;, foo() &#123; console.log(\"foo\"); &#125;&#125;;@traits(TFoo, TBar::excludes(\"foo\"))class MyClass &#123;&#125;let obj = new MyClass();obj.foo(); // fooobj.bar(); // bar 上面代码使用绑定运算符（::）在TBar上排除foo方法，混入时就不会报错了。 另一种方法是为TBar的foo方法起一个别名。 123456789101112131415161718192021222324import &#123; traits, alias &#125; from \"traits-decorator\";class TFoo &#123; foo() &#123; console.log(\"foo\"); &#125;&#125;const TBar = &#123; bar() &#123; console.log(\"bar\"); &#125;, foo() &#123; console.log(\"foo\"); &#125;&#125;;@traits(TFoo, TBar::alias(&#123; foo: \"aliasFoo\" &#125;))class MyClass &#123;&#125;let obj = new MyClass();obj.foo(); // fooobj.aliasFoo(); // fooobj.bar(); // bar 上面代码为TBar的foo方法起了别名aliasFoo，于是MyClass也可以混入TBar的foo方法了。 alias和excludes方法，可以结合起来使用。 12@traits(TExample::excludes(\"foo\", \"bar\")::alias(&#123; baz: \"exampleBaz\" &#125;))class MyClass &#123;&#125; 上面代码排除了TExample的foo方法和bar方法，为baz方法起了别名exampleBaz。 as方法则为上面的代码提供了另一种写法。 1234@traits( TExample::as(&#123; excludes: [\"foo\", \"bar\"], alias: &#123; baz: \"exampleBaz\" &#125; &#125;))class MyClass &#123;&#125;","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"QUIC","slug":"QUIC","date":"2019-08-15T17:52:20.000Z","updated":"2019-11-10T14:37:39.022Z","comments":true,"path":"2019/08/16/QUIC/","link":"","permalink":"http://yoursite.com/2019/08/16/QUIC/","excerpt":"QUICQUIC 概述Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。 QUIC 协议内置了 TLS 栈，实现了自己的传输加密层，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：","text":"QUICQUIC 概述Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。 QUIC 协议内置了 TLS 栈，实现了自己的传输加密层，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的： 从图上可以看出，QUIC 底层通过 UDP 协议替代了 TCP，上层只需要一层用于和远程服务器交互的 HTTP/2 API。这是因为 QUIC 协议已经包含了多路复用和连接管理，HTTP API 只需要完成 HTTP 协议的解析即可。 QUIC 优势 减少了 TCP 三次握手及 TLS 握手时间。 改进的拥塞控制。 避免队头阻塞的多路复用。 连接迁移。 前向冗余纠错。（目前默认的冗余量是 10%，既每发送 10 个数据包，其冗余数据就可以重新构建一个丢失的数据包） 为什么需要 QUIC 协议历史悠久导致中间设备僵化。 TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口（80、443）及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。 依赖于操作系统的实现导致协议本身僵化。 TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。 建立连接的握手延迟大。 不管是 HTTP1.0/1.1 还是 HTTPS，HTTP2，都使用了 TCP 进行传输。HTTPS 和 HTTP2 还需要使用 TLS 协议来进行安全传输。这就出现了两个握手延迟： TCP 三次握手导致的 TCP 连接建立的延迟。 TLS 完全握手需要至少 2 个 RTT 才能建立，简化握手需要 1 个 RTT 的握手延迟。 对于很多短连接场景，这样的握手延迟影响很大，且无法消除。 队头阻塞。 队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。 另外 TLS 协议层面也有一个队头阻塞，因为 TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。 QUIC 协议选择了 UDP，因为 UDP 本身没有连接的概念，不需要三次握手，优化了连接建立的握手延迟，同时在应用程序层面实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性，只需要用户端和服务端的应用程序支持 QUIC 协议，完全避开了操作系统和中间设备的限制。 QUIC 详解1. QUIC 核心特性连接建立延时低0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。 传输层 0RTT 就能建立连接。 加密层 0RTT 就能建立加密连接。 比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption[14]，也需要至少 2 个 RTT。 而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket[13] 要高很多。 2. 改进的拥塞控制TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。 QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。 从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点： 可插拔 什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面： 应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。 即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。 应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。 STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。 单调递增的 Packet Number TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。 QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。 ​ 图 2 Tcp 重传歧义性 如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。 如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。 由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。 ​ 图 3 Quic 重传没有歧义性 如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。 但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 Stream Offset 的概念。 即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。但是 Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。如错误! 未找到引用源。所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。 假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。 ​ 图 4 Stream Offset 保证有序性 不允许 Reneging 什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。 Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据。 QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰。 更多的 Ack 块 TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。 由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 [25]，所以留给 Sack 选项的只有 30 个字节。 每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。 但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。 Ack Delay 时间 Tcp 的 Timestamp 选项存在一个问题，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。 这样就会导致 RTT 计算误差。如下图： 可以认为 TCP 的 RTT 计算： 而 Quic 计算如下： 当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式 [9]。 3.基于 stream 和 connecton 级别的流量控制QUIC 的流量控制类似 HTTP2，即在 Connection 和 Stream 级别提供了两种流量控制。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。 Stream 可以认为就是一条 HTTP 请求。 Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。 QUIC 实现流量控制的原理比较简单： 通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。 通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。 QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。 但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。 ​ 图 5 Quic Flow Control 针对 Stream： 针对 Connection： 同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。 最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。 4.没有队头阻塞的多路复用QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。 QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。 这也就在很大程度上缓解甚至消除了队头阻塞的影响。 多路复用是 HTTP2 最强大的特性，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞，如下图示： ​ 图 6 HTTP2 队头阻塞 HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。 不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞 [12]。 ​ 图 7 TLS 队头阻塞 Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。 那 QUIC 多路复用为什么能避免上述问题呢？ QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。 Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。（QUIC 协议直接通过底层使用 UDP 协议天然的避免了该问题。由于 UDP 协议没有严格的顺序，当一个数据包遇到问题需要重传时，只会影响该数据包对应的资源，其他独立的资源（如其他 css、js 文件）不会受到影响） ​ 图 8 QUIC 多路复用时没有队头阻塞的问题 当然，并不是所有的 QUIC 数据都不会受到队头阻塞的影响，比如 QUIC 当前也是使用 Hpack 压缩算法 [10]，由于算法的限制，丢失一个头部数据时，可能遇到队头阻塞。 总体来说，QUIC 在传输大量数据时，比如视频，受到队头阻塞的影响很小。 5.加密认证的报文TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。 但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。 这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。 如下图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。 6.连接迁移一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。 比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。 又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。 针对 TCP 的连接变化，MPTCP 其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。 所以从 TCP 连接的角度来讲，这个问题是无解的。 那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。 由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。 7.其他亮点此外，QUIC 还能实现前向冗余纠错，在重要的包比如握手消息发生丢失时，能够根据冗余信息还原出握手消息。 QUIC 还能实现证书压缩，减少证书传输量，针对包头进行验证等。 QUIC 协议实践Chrome 浏览器从 2014 年开始已经实验性的支持了 QUIC 协议。可以通过在 Chrome 浏览器中输入chrome://net-internals/#quic查看是否已经支持 QUIC 协议。如果还未支持，可以在chrome://flags/#enable-quic中进行开启。 开始 Chrome 浏览器对 QUIC 协议的支持之后，可以在chrome://net-internals/#quic中查看到当前浏览器的 QUIC 一些连接。当然目前只有 Google 服务才支持 QUIC 协议（如 YouTube、 Google.com）。 1. 关于防火墙通常系统管理员会关注防火墙的 TCP 规则，而忽略 UDP 规则。如果要在防火墙之后使用 QUIC 协议，除了传统 web 服务需要开放的80/TCP、443/TCP之外，针对 QUIC 还需要开放443/UDP的访问。 2.服务端使用 QUIC 协议目前支持 QUIC 协议的 web 服务只有 0.9 版本以后的Caddy。其他常用 web 服务如 nginx、apache 等都未开始支持。curl 表达了对 QUIC 协议支持的兴趣。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"TCP","slug":"TCP","date":"2019-08-11T13:15:33.000Z","updated":"2019-11-10T14:37:39.023Z","comments":true,"path":"2019/08/11/TCP/","link":"","permalink":"http://yoursite.com/2019/08/11/TCP/","excerpt":"TCP TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment） IP 在第三层——Network 层（在第三层上的数据叫 Packet） ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame） 我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。","text":"TCP TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment） IP 在第三层——Network 层（在第三层上的数据叫 Packet） ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame） 我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。 TCP 头格式 你需要注意这么几点： TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。 一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。 注意上图中的四个非常重要的东西： Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。 Acknowledgement Number就是 ACK——用于确认收到，用来解决不丢包的问题。 Window 又叫 Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。 TCP Flag ，也就是包的类型，主要是用于操控 TCP 的状态机的。 TCP 状态机其实，网络上的传输是没有连接的，包括 TCP 也是一样的。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。 “TCP 协议的状态机”和 “TCP 建链接”、“TCP 断链接”、“传数据” 的对照图 很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？ 对于建链接的 3 次握手，主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number）——所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。 对于 4 次挥手，其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）： 数据传输中的 Sequence Number下图是从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 Statistics -&gt;Flow Graph… ） 你可以看到，SeqNum 的增加是和传输的字节数相关的。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。 注意：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为 0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum——相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了 TCP 重传机制TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。 注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。 超时重传机制一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4——意味着 3 和 4 都收到了。 但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。 对此有两种选择： 一种是仅重传 timeout 的包。也就是第 3 份数据。 另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。 这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的） 快速重传机制于是，TCP 引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。Fast Retransmit 的好处是不用等 timeout 了再重传。 比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack=2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下： Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2 呢还是重传#2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2)是谁传回来的？也许发送端发了 20 份数据，是#6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。 SACK 方法另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图： 这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过tcp_sack参数打开这个功能（Linux 2.4 后默认打开）。 这里还需要注意一个问题——接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。 注意：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。 Duplicate SACK – 重复收到数据的问题Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。RFC-2883 里有详细描述和示例。下面举几个例子（来源于RFC-2883） D-SACK 使用了 SACK 的第一个段来做标志， 如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK 如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK 示例一：ACK 丢包下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个 SACK=3000-3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。 123456Transmitted Received ACK SentSegment Segment (Including SACK Blocks)3000-3499 3000-3499 3500 (ACK dropped)3500-3999 3500-3999 4000 (ACK dropped)3000-3499 3000-3499 4000, SACK=3000-3500 --------- 示例二，网络延误下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK=1000-1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK——标识收到了重复的包。 这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。 12345678910Transmitted Received ACK SentSegment Segment (Including SACK Blocks)500-999 500-999 10001000-1499 (delayed)1500-1999 1500-1999 1000, SACK=1500-20002000-2499 2000-2499 1000, SACK=1500-25002500-2999 2500-2999 1000, SACK=1500-30001000-1499 1000-1499 3000 1000-1499 3000, SACK=1000-1500 --------- 可见，引入了 D-SACK，有这么几个好处： 1）可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。 2）是不是自己的 timeout 太小了，导致重传。 3）网络上出现了先发的包后到的情况（又称 reordering） 4）网络上是不是把我的数据包给复制了。 知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控。 Linux 下的 tcp_dsack 参数用于开启这个功能（Linux 2.4 后默认打开） TCP 的 RTT 算法从前面的 TCP 重传机制我们知道 Timeout 的设置对于重传非常重要。 设长了，重发就慢，丢了老半天才重发，没有效率，性能差； 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP 引入了 RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置 Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下 t0，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。 经典算法RFC793 中定义的经典算法是这样的： 1）首先，先采样 RTT，记下最近好几次的 RTT 值。 2）然后做平滑计算 SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 Exponential weighted moving average，中文叫：加权移动平均） SRTT = ( α * SRTT ) + ((1- α) * RTT) 3）开始计算 RTO。公式如下： RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ] 其中： UBOUND 是最大的 timeout 时间，上限值 LBOUND 是最小的 timeout 时间，下限值 β 值一般在 1.3 到 2.0 之间。 Karn / Partridge 算法但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和 ack 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？ 这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示： 情况（a）是 ack 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。 情况（b）是 ack 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。 所以 1987 年的时候，搞了一个叫Karn / Partridge Algorithm，这个算法的最大特点是——忽略重传，不把重传的 RTT 做采样（你看，你不需要去解决不存在的问题）。 但是，这样一来，又会引发一个大 BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的 RTO 很小），于是，因为重转的不算，所以，RTO 就不会被更新，这是一个灾难。 于是 Karn 算法用了一个取巧的方式——只要一发生重传，就对现有的 RTO 值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的 RTT 也不靠谱。 Jacobson / Karels 算法前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果 RTT 有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988 年，又有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看RFC6289）。这个算法引入了最新的 RTT 的采样和平滑过的 SRTT 的差距做因子来计算。 公式如下：（其中的 DevRTT 是 Deviation RTT 的意思） SRTT = S**RTT** + α (**RTT** – S**RTT**) —— 计算平滑 RTT DevRTT = (1-β**)***DevRTT + β***(|**RTT-SRTT**|)** ——计算平滑 RTT 和真实的差距（加权移动平均） RTO= µ * SRTT + ∂ *DevRTT —— 神一样的公式 （其中：在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的 TCP 协议中（Linux 的源代码在：tcp_rtt_estimator）。 TCP 滑动窗口需要说明一下，如果你不了解 TCP 的滑动窗口这个事，你等于不了解 TCP 协议。我们都知道，TCP 必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP 引入了一些技术和设计来做网络流控，Sliding Window 是其中一个技术。 前面我们说过，TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下 TCP 缓冲区的一些数据结构： 上图中，我们可以看到： 接收端 LastByteRead 指向了 TCP 缓冲区中读到的位置，NextByteExpected 指向的地方是收到的连续包的最后一个位置，LastByteRcved 指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。 发送端的 LastByteAcked 指向了被接收端 Ack 过的位置（表示成功发送确认），LastByteSent 表示发出去了，但还没有收到成功确认的 Ack，LastByteWritten 指向的是上层应用正在写的地方。 于是： 接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1; 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。 下面我们来看一下发送方的滑动窗口示意图： 上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口） #1 已收到 ack 确认的数据。 #2 发还没收到 ack 的。 #3 在窗口中还没有发出的（接收方还有空间）。 #4 窗口以外的数据（接收方没空间） 下面是个滑动后的示意图（收到 36 的 ack，并发出了 46-51 的字节）： 下面我们来看一个接受端控制发送端的图示： Zero Window上图，我们可以看到一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的 TCP Sliding Window 给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？ 解决这个问题，TCP 使用了 Zero Window Probe 技术，缩写为 ZWP，也就是说，发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。 注意：只要有等待的地方都可能出现 DDoS 攻击，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下Wikipedia 的 SockStress 词条） 另外，Wireshark 中，你可以使用 tcp.analysis.zero_window 来过滤包，然后使用右键菜单里的 follow TCP stream，你可以看到 ZeroWindowProbe 及 ZeroWindowProbeAck 的包。 Silly Window SyndromeSilly Window Syndrome 翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。 要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。 另外，你需要知道网络上有个 MTU，对于以太网来说，MTU 是 1500 字节，除去 TCP+IP 头的 40 个字节，真正的数据传输可以有 1460，这就是所谓的 MSS（Max Segment Size）注意，TCP 的 RFC 定义这个 MSS 的默认值是 536，这是因为 RFC 791里说了任何一个 IP 设备都得最少接收 576 尺寸的大小（实际上来说 576 是拨号的网络的 MTU，而 576 减去 IP 头的 20 个字节就是 536）。 如果你的网络包可以塞满 MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。（大于 MTU 的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个 MTU 就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。 所以，Silly Windows Syndrome 这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人。 要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。 如果这个问题是由 Receiver 端引起的，那么就会使用 David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。 如果这个问题是由 Sender 端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。 另外，Nagle 算法默认是打开的，所以，对于一些需要小包场景的程序——比如像 telnet 或 ssh 这样的交互性比较强的程序，你需要关闭这个算法。你可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭） 1setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char*)&amp;value,sizeof(int)); 另外，网上有些文章说 TCP_CORK 的 socket option 是也关闭 Nagle 算法，这不对。TCP_CORK 其实是更新激进的 Nagle 算汉，完全禁止小包发送，而 Nagle 算法没有禁止小包发送，只是禁止了大量的小包发送。最好不要两个选项都设置。 TCP 的拥塞处理 – Congestion Handling上面我们知道了，TCP 通过 Sliding Window 来做流控（Flow Control），但是 TCP 觉得这还不够，因为 Sliding Window 需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP 的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型 4 层以上的事，TCP 的还应该更聪明地知道整个网络上的事。 具体一点，我们知道 TCP 通过一个 timer 采样了 RTT 并计算 RTO，但是，如果网络上的延时突然增加，那么，TCP 对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的 TCP 连接都这么行事，那么马上就会形成“网络风暴”，TCP 这个协议就会拖垮整个网络。这是一个灾难。 所以，TCP 不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此 TCP 的设计理念是：TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。 拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注: 1988 年，TCP-Tahoe 提出了 1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传 1990 年，TCP Reno 在 Tahoe 的基础上增加了 4）快速恢复 慢热启动算法 – Slow Start首先，我们来看一下 TCP 的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。 慢启动的算法如下(cwnd 全称 Congestion Window)： 1）连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。 2）每当收到一个 ACK，cwnd++; 呈线性上升 3）每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升 4）还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”（后面会说这个算法） 所以，我们可以看到，如果网速很快的话，ACK 也会返回得快，RTT 也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。 一篇 Google 的论文《An Argument for Increasing TCP’s Initial Congestion Window》Linux 3.0 后采用了这篇论文的建议——把 cwnd 初始化成了 10 个 MSS。而 Linux 3.0 以前，比如 2.6，Linux 采用了RFC3390，cwnd 是跟 MSS 的值来变的，如果 MSS&lt; 1095，则 cwnd = 4；如果 MSS&gt;2190，则 cwnd=2；其它情况下，则是 3。 拥塞避免算法 – Congestion Avoidance前面说过，还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”。一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下： 1）收到一个 ACK 时，cwnd = cwnd + 1/cwnd 2）当每过一个 RTT 时，cwnd = cwnd + 1 这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。 拥塞状态时的算法前面我们说过，当丢包的时候，会有两种情况： 1）等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。 sshthresh = cwnd /2 cwnd 重置为 1 进入慢启动过程 2）Fast Retransmit 算法，也就是在收到 3 个 duplicate ACK 时就开启重传，而不用等到 RTO 超时。 TCP Tahoe 的实现和 RTO 超时一样。 TCP Reno 的实现是： cwnd = cwnd /2 sshthresh = cwnd 进入快速恢复算法——Fast Recovery 上面我们可以看到 RTO 超时后，sshthresh 会变成 cwnd 的一半，这意味着，如果 cwnd&lt;=sshthresh 时出现的丢包，那么 TCP 的 sshthresh 就会减了一半，然后等 cwnd 又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP 是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。 快速恢复算法 – Fast RecoveryTCP Reno这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有 3 个 Duplicated Acks 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。 注意，正如前面所说，进入 Fast Recovery 之前，cwnd 和 sshthresh 已被更新： cwnd = cwnd /2 sshthresh = cwnd 然后，真正的 Fast Recovery 算法如下： cwnd = sshthresh + 3 * MSS （3 的意思是确认有 3 个数据包被收到了） 重传 Duplicated ACKs 指定的数据包 如果再收到 duplicated Acks，那么 cwnd = cwnd +1 如果收到了新的 Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。 如果你仔细思考一下上面的这个算法，你就会知道，上面这个算法也有问题，那就是——它依赖于 3 个重复的 Acks。注意，3 个重复的 Acks 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成 TCP 的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。 通常来说，正如我们前面所说的，SACK 或 D-SACK 的方法可以让 Fast Recovery 或 Sender 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持 SACK（SACK 需要两端都支持），所以，需要一个没有 SACK 的解决方案。而通过 SACK 进行拥塞控制的算法是 FACK（后面会讲） TCP New Reno于是，1995 年，TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有 SACK 的支持下改进 Fast Recovery 算法的—— 当 sender 这边收到了 3 个 Duplicated Acks，进入 Fast Retransimit 模式，开发重传重复 Acks 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 Ack 会把整个已经被 sender 传输出去的数据 ack 回来。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。 一旦 Sender 这边发现了 Partial ACK 出现，那么，sender 就可以推理出来有多个包被丢了，于是乎继续重传 sliding window 里未被 ack 的第一个包。直到再也收不到了 Partial Ack，才真正结束 Fast Recovery 这个过程 我们可以看到，这个“Fast Recovery 的变更”是一个非常激进的玩法，他同时延长了 Fast Retransmit 和 Fast Recovery 的过程。 算法示意图下面我们来看一个简单的图示以同时看一下上面的各种算法的样子： FACK 算法FACK 全称 Forward Acknowledgment 算法，论文地址在这里（PDF）Forward Acknowledgement: Refining TCP Congestion Control 这个算法是其于 SACK 的，前面我们说过 SACK 是使用了 TCP 扩展字段 Ack 了有哪些数据收到，哪些数据没有收到，他比 Fast Retransmit 的 3 个 duplicated acks 好处在于，前者只知道有包丢了，不知道是一个还是多个，而 SACK 可以准确的知道有哪些包丢了。 所以，SACK 可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK 用来做重传过程中的拥塞流控。 这个算法会把 SACK 中最大的 Sequence Number 保存在snd.fack这个变量中，snd.fack 的更新由 ack 带秋，如果网络一切安好则和 snd.una 一样（snd.una 就是还没有收到 ack 的地方，也就是前面 sliding window 里的 category #2 的第一个地方） 然后定义一个awnd = snd.nxt – snd.fack（snd.nxt 指向发送端 sliding window 中正在要被发送的地方——前面 sliding windows 图示的 category#3 第一个位置），这样 awnd 的意思就是在网络上的数据。（所谓 awnd 意为：actual quantity of data outstanding in the network） 如果需要重传数据，那么，awnd = snd.nxt – snd.fack + retran_data，也就是说，awnd 是传出去的数据 + 重传的数据。 然后触发 Fast Recovery 的条件是： ( ( snd.fack – snd.una ) &gt; (3*MSS) ) || (dupacks == 3) ) 。这样一来，就不需要等到 3 个 duplicated acks 才重传，而是只要 sack 中的最大的一个数据和 ack 的数据比较长了（3 个 MSS），那就触发重传。在整个重传过程中 cwnd 不变。直到当第一次丢包的 snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd 线性上涨。 我们可以看到如果没有 FACK 在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的 window 的大小，而需要几个 RTT 的时间才会完成恢复，而 FACK 会比较激进地来干这事。 但是，FACK 如果在一个网络包会被 reordering 的网络里会有很大的问题。 其它拥塞控制算法简介TCP Vegas 拥塞控制算法这个算法 1994 年被提出，它主要对 TCP Reno 做了些修改。这个算法通过对 RTT 的非常重的监控来计算一个基准 RTT。然后通过这个基准 RTT 来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加 cwnd 的大小。如果这个计算出来的 RTT 大于了 Timeout 后，那么，不等 ack 超时就直接重传。（Vegas 的核心思想是用 RTT 的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》这篇论文给了 Vegas 和 New Reno 的对比： 关于这个算法实现，你可以参看 Linux 源码：/net/ipv4/tcp_vegas.h， /net/ipv4/tcp_vegas.c HSTCP(High Speed TCP) 算法这个算法来自RFC 3649（Wikipedia 词条）。其对最基础的算法进行了更改，他使得 Congestion Window 涨得快，减得慢。其中： 拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd 丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd 注：α(cwnd)和 β(cwnd)都是函数，如果你要让他们和标准的 TCP 一样，那么让 α(cwnd)=1，β(cwnd)=0.5 就可以了。 对于 α(cwnd)和 β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看 Linux 源码：/net/ipv4/tcp_highspeed.c TCP BIC 算法2004 年，产内出 BIC 算法。现在你还可以查得到相关的新闻《Google：美科学家研发 BIC-TCP 协议 速度是 DSL 六千倍》 BIC 全称Binary Increase Congestion control，在 Linux 2.6.8 中是默认拥塞控制算法。BIC 的发明者发这么多的拥塞控制算法都在努力找一个合适的 cwnd – Congestion Window，而且 BIC-TCP 的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以 BIC 这个算法主要用的是 Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看 Linux 源码：/net/ipv4/tcp_bic.c TCP WestWood 算法westwood 采用和 Reno 相同的慢启动算法、拥塞避免算法。westwood 的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个 RTT 时间，会测量一次带宽，测量带宽的公式很简单，就是这段 RTT 内成功被 ack 了多少字节。因为，这个带宽和用 RTT 计算 RTO 一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送 X 个字节，而 RTT 是一个数据发出去后确认需要的时候，所以，X _ RTT 应该是我们缓冲区大小。所以，在这个算法中，ssthresh 的值就是 est_BD _ min-RTT(最小的 RTT 值)，如果丢包是 Duplicated ACKs 引起的，那么如果 cwnd &gt; ssthresh，则 cwin = ssthresh。如果是 RTO 引起的，cwnd = 1，进入慢启动。 关于这个算法实现，你可以参看 Linux 源码： /net/ipv4/tcp_westwood.c 四次挥手优化——三次挥手123456789#三次挥手 -- 客户端发起断开连接请求 客户端序列号为 3495051432#fin seq = 349505143200:05:30.157325 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [F.], seq 3495051432, ack 485492629, win 115, options [nop,nop,TS val 1695781058 ecr 629900122], length 0#三次挥手 -- 服务器端发起断开连接请求#ack = 3495051432 + 1 = 3495051433 注意 因为服务器端也没有东西要发送了，所以也要关闭连接，因此同时发送了fin信号，seq = 48549262900:05:30.157562 IP VM_0_6_centos.webcache &gt; 221.122.42.100.58706: Flags [F.], seq 485492629, ack 3495051433, win 235, options [nop,nop,TS val 629900162 ecr 1695781058], length 0#三次挥手 -- 客户端应答#ack = 485492629 + 1 = 48549263000:05:30.196710 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [.], ack 485492630, win 115, options [nop,nop,TS val 1695781097 ecr 629900162], length 0 这是因为关闭连接有两种方式，当一方关闭连接，另外一方没有数据发送时，马上关闭连接，也就将第二步的 ack 与第三步的 fin 合并为一步了","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"TCP/IP","slug":"TCP-IP","permalink":"http://yoursite.com/tags/TCP-IP/"}]},{"title":"Promise","slug":"promise","date":"2019-08-05T11:44:02.000Z","updated":"2019-11-10T14:37:39.027Z","comments":true,"path":"2019/08/05/promise/","link":"","permalink":"http://yoursite.com/2019/08/05/promise/","excerpt":"promise创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）方法一： 创建一个用 Promise 把 XHR 处理包装起来的名为 getURL 的函数。","text":"promise创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）方法一： 创建一个用 Promise 把 XHR 处理包装起来的名为 getURL 的函数。 1234567891011121314151617181920212223242526function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;// 运行示例var URL = \"http://httpbin.org/get\";getURL(URL) .then(function onFulfilled(value) &#123; console.log(value); &#125;) .catch(function onRejected(error) &#123; console.error(error); &#125;); 方法二： 12345678910111213141516171819202122232425function ajaxPromise(url, data, callback) &#123; return new Promise(function(resolve, reject) &#123; $.ajax(&#123; url: url, type: data == null ? \"GET\" : \"POST\", dataType: \"json\", data: data == null ? \"\" : JSON.stringify(data), async: true, contentType: \"application/json\", success: function(res) &#123; callback(res); resolve(); &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; if (XMLHttpRequest.status == \"401\") &#123; window.parent.location = \"/enterprise/enterprise_login.html\"; self.location = \"/enterprise/enterprise_login.html\"; &#125; else &#123; alert(XMLHttpRequest.responseText); &#125; reject(); &#125; &#125;); &#125;);&#125; 调用 1234567891011ajaxPromise('/prefix/entity1/action1',null, function(res)&#123; //do something on response&#125;).then( ajaxPromise('/prefix/entity2/action2', someData, function(res)&#123; //do something on response &#125;).then( initVue() ;).then( //do something else) promise 的实现和原理（用 js）promise 实现原理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210// 判断变量否为functionconst isFunction = variable =&gt; typeof variable === \"function\";// 定义Promise的三种状态常量const PENDING = \"PENDING\";const FULFILLED = \"FULFILLED\";const REJECTED = \"REJECTED\";class MyPromise &#123; constructor(handle) &#123; if (!isFunction(handle)) &#123; throw new Error(\"MyPromise must accept a function as a parameter\"); &#125; // 添加状态 this._status = PENDING; // 添加状态 this._value = undefined; // 添加成功回调函数队列 this._fulfilledQueues = []; // 添加失败回调函数队列 this._rejectedQueues = []; // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 添加resovle时执行的函数 _resolve(val) &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( value =&gt; &#123; this._value = value; this._status = FULFILLED; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; this._status = REJECTED; runRejected(err); &#125; ); &#125; else &#123; this._value = val; this._status = FULFILLED; runFulfilled(val); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); &#125; // 添加reject时执行的函数 _reject(err) &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); &#125; // 添加then方法 then(onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; let res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 let rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; let res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125; // 添加catch方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // 添加静态resolve方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; // 添加静态reject方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 添加静态all方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; /** * 返回值的集合 */ let values = []; let count = 0; for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125; ); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125; ); &#125; &#125;); &#125; finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125;&#125; promise.race 和超时处理函数 timeoutPromise(比较对象promise, ms) 接收两个参数，第一个是需要使用超时机制的 promise 对象，第二个参数是超时时间，它返回一个由 Promise.race 创建的相互竞争的 promise 对象。 1234567891011function delayPromise(ms) &#123; return new Promise(function(resolve) &#123; setTimeout(resolve, ms); &#125;);&#125;function timeoutPromise(promise, ms) &#123; var timeout = delayPromise(ms).then(function() &#123; throw new Error(\"Operation timed out after \" + ms + \" ms\"); &#125;); return Promise.race([promise, timeout]);&#125; 例子： 1234567891011121314151617181920212223242526function delayPromise(ms) &#123; return new Promise(function(resolve) &#123; setTimeout(resolve, ms); &#125;);&#125;function timeoutPromise(promise, ms) &#123; var timeout = delayPromise(ms).then(function() &#123; throw new Error(\"Operation timed out after \" + ms + \" ms\"); &#125;); return Promise.race([promise, timeout]);&#125;// 运行示例var taskPromise = new Promise(function(resolve) &#123; // 随便一些什么处理 var delay = Math.random() * 2000; setTimeout(function() &#123; resolve(delay + \"ms\"); &#125;, delay);&#125;);timeoutPromise(taskPromise, 1000) .then(function(value) &#123; console.log(\"taskPromise在规定时间内结束 : \" + value); &#125;) .catch(function(error) &#123; console.log(\"发生超时\", error); &#125;); 虽然在发生超时的时候抛出了异常，但是这样的话我们就不能区分这个异常到底是普通的错误还是超时错误了。 为了能区分这个 Error 对象的类型，我们再来定义一个Error 对象的子类 TimeoutError。 定制 Error 对象 1234567891011121314151617//TimeoutError.jsfunction copyOwnFrom(target, source) &#123; Object.getOwnPropertyNames(source).forEach(function(propName) &#123; Object.defineProperty( target, propName, Object.getOwnPropertyDescriptor(source, propName) ); &#125;); return target;&#125;function TimeoutError() &#123; var superInstance = Error.apply(null, arguments); copyOwnFrom(this, superInstance);&#125;TimeoutError.prototype = Object.create(Error.prototype);TimeoutError.prototype.constructor = TimeoutError; 我们定义了 TimeoutError 类和构造函数，这个类继承了 Error 的 prototype。 它的使用方法和普通的 Error 对象一样，使用 throw 语句即可，如下所示。 1234567var promise = new Promise(function() &#123; throw TimeoutError(\"timeout\");&#125;);promise.catch(function(error) &#123; console.log(error instanceof TimeoutError); // true&#125;); 应用 取消 XHR 操作本身的话并不难，只需要调用 XMLHttpRequest 对象的 abort() 方法就可以了。 为了能在外部调用 abort() 方法，我们先对之前本节出现的 getURL 进行简单的扩展，cancelableXHR 方法除了返回一个包装了 XHR 的 promise 对象之外，还返回了一个用于取消该 XHR 请求的abort方法。 大体的流程就像下面这样。 通过 cancelableXHR 方法取得包装了 XHR 的 promise 对象和取消该 XHR 请求的方法 在 timeoutPromise 方法中通过 Promise.race 让 XHR 的包装 promise 和超时用 promise 进行竞争。 XHR 在超时前返回结果的话 和正常的 promise 一样，通过 then 返回请求结果 发生超时的时候 抛出 throw TimeoutError 异常并被 catch catch 的错误对象如果是 TimeoutError 类型的话，则调用 abort 方法取消 XHR 请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function copyOwnFrom(target, source) &#123; Object.getOwnPropertyNames(source).forEach(function(propName) &#123; Object.defineProperty( target, propName, Object.getOwnPropertyDescriptor(source, propName) ); &#125;); return target;&#125;function TimeoutError() &#123; var superInstance = Error.apply(null, arguments); copyOwnFrom(this, superInstance);&#125;TimeoutError.prototype = Object.create(Error.prototype);TimeoutError.prototype.constructor = TimeoutError;function delayPromise(ms) &#123; return new Promise(function(resolve) &#123; setTimeout(resolve, ms); &#125;);&#125;function timeoutPromise(promise, ms) &#123; var timeout = delayPromise(ms).then(function() &#123; return Promise.reject( new TimeoutError(\"Operation timed out after \" + ms + \" ms\") ); &#125;); return Promise.race([promise, timeout]);&#125;function cancelableXHR(URL) &#123; var req = new XMLHttpRequest(); var promise = new Promise(function(resolve, reject) &#123; req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.onabort = function() &#123; reject(new Error(\"abort this request\")); &#125;; req.send(); &#125;); var abort = function() &#123; // 如果request还没有结束的话就执行abort // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest if (req.readyState !== XMLHttpRequest.UNSENT) &#123; req.abort(); &#125; &#125;; return &#123; promise: promise, abort: abort &#125;;&#125;var object = cancelableXHR(\"http://httpbin.org/get\");// maintimeoutPromise(object.promise, 1000) .then(function(contents) &#123; console.log(\"Contents\", contents); &#125;) .catch(function(error) &#123; if (error instanceof TimeoutError) &#123; object.abort(); return console.log(error); &#125; console.log(\"XHR Error :\", error); &#125;); promise.all 和顺序处理 在 重复使用多个 then 的方法 中的实现方法如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; // [] 用来保存初始化的值 var pushValue = recordValue.bind(null, []); return request .comment() .then(pushValue) .then(request.people) .then(pushValue);&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); 使用这种写法的话那么随着 request 中元素数量的增加，我们也需要不断增加对 then 方法的调用 将处理内容统一放到数组里，再配合 for 循环进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; // [] 用来保存初始化值 var pushValue = recordValue.bind(null, []); // 返回promise对象的函数的数组 var tasks = [request.comment, request.people]; var promise = Promise.resolve(); // 开始的地方 for (var i = 0; i &lt; tasks.length; i++) &#123; var task = tasks[i]; promise = promise.then(task).then(pushValue); &#125; return promise;&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); promise = promise.then(task).then(pushValue); 的代码就是通过不断对 promise 进行处理，不断的覆盖 promise 变量的值，以达到对 promise 对象的累积处理效果。 但是这种方法需要 promise 这个临时变量，从代码质量上来说显得不那么简洁。 Promise chain 和 reduce 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; var pushValue = recordValue.bind(null, []); var tasks = [request.comment, request.people]; return tasks.reduce(function(promise, task) &#123; return promise.then(task).then(pushValue); &#125;, Promise.resolve());&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); Array.prototype.reduce 的第二个参数用来设置盛放计算结果的初始值。在这个例子中， Promise.resolve() 会赋值给 promise，此时的 task 为 request.comment 。 在 reduce 中第一个参数中被 return 的值，则会被赋值为下次循环时的 promise 。也就是说，通过返回由 then 创建的新的 promise 对象，就实现了和 for 循环类似的 Promise chain 了。 使用 reduce 和 for 循环不同的地方是 reduce 不再需要临时变量 promise 了，因此也不用编写 promise = promise.then(task).then(pushValue); 这样冗长的代码了，这是非常大的进步。 定义进行顺序处理的函数 12345678910function sequenceTasks(tasks) &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; var pushValue = recordValue.bind(null, []); return tasks.reduce(function(promise, task) &#123; return promise.then(task).then(pushValue); &#125;, Promise.resolve());&#125; 需要注意的一点是，和 Promise.all 等不同，这个函数接收的参数是一个函数的数组。为什么传给这个函数的不是一个 promise 对象的数组呢？这是因为 promise 对象创建的时候，XHR 已经开始执行了，因此再对这些 promise 对象进行顺序处理的话就不能正常工作了。 重写上例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function sequenceTasks(tasks) &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; var pushValue = recordValue.bind(null, []); return tasks.reduce(function(promise, task) &#123; return promise.then(task).then(pushValue); &#125;, Promise.resolve());&#125;function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; return sequenceTasks([request.comment, request.people]);&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); 如何实现 Promise.all ?12345678910111213141516171819202122232425262728Promise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; //promises[i] 可能是普通值 Promise.resolve(promises[i]).then( data =&gt; &#123; processValue(i, data); &#125;, err =&gt; &#123; reject(err); return; &#125; ); &#125; &#125; &#125;);&#125;; 如何实现 Promise.finally ?不管成功还是失败，都会走到 finally 中,并且 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then. 1234567891011121314Promise.prototype.finally = function(callback) &#123; return this.then( value =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, err =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;); &#125; );&#125;; 常见问题 输出结果：success 解题思路：Promise 状态一旦改变，无法在发生变更。 1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"success\"); reject(\"error\"); &#125;, 1000);&#125;);promise.then( res =&gt; &#123; console.log(res); &#125;, err =&gt; &#123; console.log(err); &#125;); 输出结果：1 解题思路：Promise 的 then 方法的参数期望是函数，传入非函数则会发生值穿透。 1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log); 结果是：3 4 6 8 7 5 2 1 优先级关系如下：process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate 123456789101112131415161718setImmediate(function() &#123; console.log(1);&#125;, 0);setTimeout(function() &#123; console.log(2);&#125;, 0);new Promise(function(resolve) &#123; console.log(3); resolve(); console.log(4);&#125;).then(function() &#123; console.log(5);&#125;);console.log(6);process.nextTick(function() &#123; console.log(7);&#125;);console.log(8); V8 实现中，两个队列各包含不同的任务： macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver 实现一个简单的 Promise 1234567891011121314151617181920212223242526272829303132333435function Promise(fn) &#123; var status = \"pending\"; function successNotify() &#123; status = \"fulfilled\"; //状态变为fulfilled toDoThen.apply(undefined, arguments); //执行回调 &#125; function failNotify() &#123; status = \"rejected\"; //状态变为rejected toDoThen.apply(undefined, arguments); //执行回调 &#125; function toDoThen() &#123; setTimeout(() =&gt; &#123; // 保证回调是异步执行的 if (status === \"fulfilled\") &#123; for (let i = 0; i &lt; successArray.length; i++) &#123; successArray[i].apply(undefined, arguments); //执行then里面的回掉函数 &#125; &#125; else if (status === \"rejected\") &#123; for (let i = 0; i &lt; failArray.length; i++) &#123; failArray[i].apply(undefined, arguments); //执行then里面的回掉函数 &#125; &#125; &#125;); &#125; var successArray = []; var failArray = []; fn.call(undefined, successNotify, failNotify); return &#123; then: function(successFn, failFn) &#123; successArray.push(successFn); failArray.push(failFn); return undefined; // 此处应该返回一个Promise &#125; &#125;;&#125; 解题思路：Promise 中的 resolve 和 reject 用于改变 Promise 的状态和传参，then 中的参数必须是作为回调执行的函数。因此，当 Promise 改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JS引擎执行机制","slug":"JS引擎执行机制","date":"2019-07-30T05:13:29.000Z","updated":"2019-11-10T14:37:39.019Z","comments":true,"path":"2019/07/30/JS引擎执行机制/","link":"","permalink":"http://yoursite.com/2019/07/30/JS引擎执行机制/","excerpt":"JS 引擎执行机制(1) JS 是单线程语言 (2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop","text":"JS 引擎执行机制(1) JS 是单线程语言 (2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop JS 为什么是单线程的? 为什么需要异步? 单线程又是如何实现异步的呢? JS 最初被设计用在浏览器中,那么想象一下,如果浏览器中的 JS 是多线程的。 场景描述: 那么现在有 2 个线程,process1 process2,由于是多线程的 JS,所以他们对同一个 dom,同时进行操作。process1 删除了该 dom,而 process2 编辑了该 dom,同时下达 2 个矛盾的命令,浏览器究竟该如何执行呢? JS 为什么需要异步? 如果 JS 中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验 JS 单线程又是如何实现异步的呢? 是通过的事件循环(event loop),理解了 event loop 机制,就理解了 JS 的执行机制 JS 中的 event loopevent loop（1）JS 里的一种分类方式,就是将任务分为: 同步任务和异步任务 JS 的执行机制是： 首先判断 JS 是同步还是异步,同步就进入主线程,异步就进入 event table 异步任务在 event table 中注册函数,当满足触发条件后,被推入 event queue 同步任务进入主线程后一直执行,直到主线程空闲时,才会去 event queue 中查看是否有可执行的异步任务,如果有就推入主线程中 event loop（2）准确的划分方式是: macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval micro-task(微任务)：Promise.then，process.nextTick JS 的执行机制是： 执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里 当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完 重复以上 2 步骤,结合 event loop(1) event loop(2) ,就是更为准确的 JS 执行机制了。 理解 JavaScript 的 async/awaitasync 和 await 在干什么先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 async 函数返回的是一个 Promise 对象。 如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。 await 等待的是一个表达式。 这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。 await 等到了要等的，然后呢？ await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 await 等待的表达式详解await 等的是右侧「表达式」的结果 await 是从右向左执行的 12345678910async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;async1();console.log(\"script start\"); 先执行 async2 后，发现有 await 关键字，于是让出线程，阻塞代码 右侧表达式的结果: 如果不是 promise , await 会阻塞后面的代码，先执行 async 外面的同步代码，同步代码执行完，再回到 async 内部，把这个非 promise 的东西，作为 await 表达式的结果 如果它等到的是一个 promise 对象，await 也会暂停 async 后面的代码，先执行 async 外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。 async/await 的优势在于处理 then 链单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。 Async/await 代码清晰很多，几乎跟同步代码一样。 Promise 方案的死穴—— 链式调用参数传递太麻烦 async/await 和 promise 的执行顺序例子1234567891011121314151617181920async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;console.log(\"script start\");setTimeout(function() &#123; console.log(\"setTimeout\");&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(\"promise1\"); resolve();&#125;).then(function() &#123; console.log(\"promise2\");&#125;);console.log(\"script end\"); 12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout 宏任务和微任务的慨念，在我脑海中宏任务和为微任务如图所示 也就是「宏任务」、「微任务」都是队列。 一段代码执行时，会先执行宏任务中的同步代码， 如果执行中遇到 setTimeout 之类宏任务，那么就把这个 setTimeout 内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。 如果执行中遇到 promise.then()之类的微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行所有的微任务 1、2、3 例子分析执行顺序直接打印同步代码 console.log(‘script start’)12// 首先是2个函数声明，虽然有async关键字，但不是调用我们就不看。然后首先是打印同步代码console.log(\"script start\"); 将 setTimeout 放入宏任务队列默认所包裹的代码，其实可以理解为是第一个宏任务，所以这里是宏任务 2 调用 async1，打印 同步代码 console.log( ‘async1 start’ )我们说过看到带有 async 关键字的函数，不用害怕，它的仅仅是把 return 值包装成了 promise，其他并没有什么不同的地方。所以就很普通的打印 console.log( ‘async1 start’ ) 分析一下 await async2()前文提过 await，1.它先计算出右侧的结果，2.然后看到 await 后，中断 async 函数 先得到 await 右侧表达式的结果。执行 async2()，打印同步代码 console.log(‘async2’), 并且 return Promise.resolve(undefined) await 后，中断 async 函数，先执行 async 外的同步代码 目前就直接打印 console.log(‘async2’) 被阻塞后，要执行 async 之外的代码执行 new Promise()，Promise 构造函数是直接调用的同步代码，所以 console.log( ‘promise1’ ) 代码运行到 promise.then()代码运行到 promise.then()，发现这个是微任务，所以暂时不打印，只是推入当前宏任务的微任务队列中。 注意：这里只是把 promise2 推入微任务队列，并没有执行。微任务会在当前宏任务的同步代码执行完毕，才会依次执行 打印同步代码 console.log(‘script end’)执行完这个同步代码后，「async 外的代码」终于走了一遍 下面该回到 await 表达式那里，执行 await Promise.resolve(undefined)了 回到 async 内部，执行 await Promise.resolve(undefined)这部分可能不太好理解，我尽量表达我的想法。 对于 await Promise.resolve(undefined) 如何理解呢？ 根据 MDN 原话我们知道 如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。 在我们这个例子中，就是 Promise.resolve(undefined)正常处理完成，并返回其处理结果。那么 await async2()就算是执行结束了。 目前这个 promise 的状态是 fulfilled，等其处理结果返回就可以执行 await 下面的代码了。 那何时能拿到处理结果呢？ 回忆平时我们用 promise，调用 resolve 后，何时能拿到处理结果？是不是需要在 then 的第一个参数里，才能拿到结果。 （调用 resolve 时，会把 then 的参数推入微任务队列，等主线程空闲时，再调用它） 所以这里的 await Promise.resolve() 就类似于 1Promise.resolve(undefined).then(undefined =&gt; &#123;&#125;); 把 then 的第一个回调参数 (undefined) =&gt; {} 推入微任务队列。 then 执行完，才是 await async2()执行结束。 await async2()执行结束，才能继续执行后面的代码 如图 此时当前宏任务 1 都执行完了，要处理微任务队列里的代码。微任务队列，先进选出的原则， 执行微任务 1，打印 promise2 执行微任务 2，没什么内容.. 但是微任务 2 执行后，await async2()语句结束，后面的代码不再被阻塞，所以打印 console.log(‘async1 end’) 宏任务 1 执行完成后,执行宏任务 2宏任务 2 的执行比较简单，就是打印 console.log(‘setTimeout’)","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS事件机制","slug":"JS事件机制","date":"2019-07-24T07:22:00.000Z","updated":"2019-11-10T14:37:39.019Z","comments":true,"path":"2019/07/24/JS事件机制/","link":"","permalink":"http://yoursite.com/2019/07/24/JS事件机制/","excerpt":"JS 事件机制js 里一般的阻止事件默认行为怎么做？event.preventDefault()可以取消默认事件 event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。","text":"JS 事件机制js 里一般的阻止事件默认行为怎么做？event.preventDefault()可以取消默认事件 event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。 1234567891011function cancelHandler(event) &#123; var event = event || window.event; //兼容IE //取消事件相关的默认行为 if (event.preventDefault) //标准技术 event.preventDefault(); if (event.returnValue) //兼容IE9之前的IE event.returnValue = false; return false; //用于处理使用对象属性注册的处理程序&#125; 冒泡的机制是什么？下面代码输出顺序是什么？（2-&gt;button-&gt;1） 触发顺序：button-&gt;1-&gt;2 12345678910111213141516171819202122232425&lt;div&gt;&lt;button&gt;aaa&lt;/button&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"1\"); &#125;, false ); document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"2\"); &#125;, false ); document.getElementById(\"button\").addEventListener( \"click\", function() &#123; console.log(\"button\"); &#125;, false );&lt;/script&gt; 触发顺序：2-&gt;button-&gt;1 12345678910111213141516171819202122232425&lt;div&gt;&lt;button&gt;aaa&lt;/button&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"1\"); &#125;, false ); document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"2\"); &#125;, true ); document.getElementById(\"button\").addEventListener( \"click\", function() &#123; console.log(\"button\"); &#125;, false );&lt;/script&gt; 触发顺序：2-&gt;button-&gt;1 12345678910111213141516171819202122232425&lt;div&gt;&lt;button&gt;aaa&lt;/button&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"1\"); &#125;, false ); document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"2\"); &#125;, true ); document.getElementById(\"button\").addEventListener( \"click\", function() &#123; console.log(\"button\"); &#125;, true );&lt;/script&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"JS静态作用域","slug":"JS静态作用域","date":"2019-07-11T03:01:34.000Z","updated":"2019-11-10T14:37:39.020Z","comments":true,"path":"2019/07/11/JS静态作用域/","link":"","permalink":"http://yoursite.com/2019/07/11/JS静态作用域/","excerpt":"JS 静态作用域js 的作用域和别的编程语言的作用域有什么区别作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。","text":"JS 静态作用域js 的作用域和别的编程语言的作用域有什么区别作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设 JavaScript 采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设 JavaScript 采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。 最后，让我们看一个《JavaScript 权威指南》中的例子： 123456789101112131415161718var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f();&#125;checkscope();var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为 JavaScript 采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript 权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 bash 就是动态作用域","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"https中间人攻击及防御","slug":"https中间人攻击及防御","date":"2019-07-03T06:51:26.000Z","updated":"2019-11-10T14:37:39.023Z","comments":true,"path":"2019/07/03/https中间人攻击及防御/","link":"","permalink":"http://yoursite.com/2019/07/03/https中间人攻击及防御/","excerpt":"https 中间人攻击及防御HTTPS 也不是绝对安全的，在 HTTPS 握手的过程中，如果实施不当，还是会存在漏洞，很容被中间人攻击； 什么是中间人攻击中间人攻击（Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。","text":"https 中间人攻击及防御HTTPS 也不是绝对安全的，在 HTTPS 握手的过程中，如果实施不当，还是会存在漏洞，很容被中间人攻击； 什么是中间人攻击中间人攻击（Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。 如何进行中间人攻击的呢？攻击一：SSLSniff攻击者在网关截获 SSL 会话，替换服务器公钥证书，将公钥PKey换成自己的公钥PKey，欺骗客户端。客户端使用PKey加密信息并发送会话，中间人用私钥Skey解密客户端返回会话，从而劫持会话。同时，中间人用PKey加密明文会话并返回服务器 过程如下： Attacker截获了客户端的say hello，可以把publicKey_attacker返回给客户端，取得客户端的信任，至此Attacker与客户端建立了安全连接。 Attacker冒充客户端向服务器发送say hello，至此Attacker与服务器建立了安全连接。 这种攻击会存在一个问题会被感知到，就是Attacker的证书是伪造的不受信任的证书，所以客户端可以确认是否需要真的连接该服务器，不过如果有内鬼的话，伪造的受信任的证书的话，就当我啥也没说； 攻击二：SSLStrip这种攻击相对于攻击一复杂一点，但是也更加厉害，几乎可以在客户端无感知的情况下实施攻击，并且不需要伪造证书；简单来说就是这样：Attacker在客户端与服务器建立连接时，在Attacker与服务器之间形成 HTTPS 连接，而在客户端与Attacker之间形成HTTP连接，即将 SSL 层从原 HTTPS 连接中“剥离”。这样，既避免了在客户端验证证书时难以避免的弹框问题，又能够劫持 HTTP 明文数据，并同时保证客户端HTTP数据的传输，达到欺骗服务器与客户端的效果。 过程如下： 用户在浏览器地址栏中输入网址时，多数会采用直接输入网址的方式，而忽略了传输所采用的协议。例如，在登录 gmail 过程中，大多数用户会直接在地址栏中输入www.gmail.com，向Google服务器发送一个 HTTP 连接请求，而不是输入https：//www.gmail.com， 向服务器发送一个HTTPS连接请求。因此，用户通常接触到 HTTPS 的方式有两种：一种是 Web 上的连接，比如当用户在 gmail 上输入用户名和密码后，点击的登录键，将用户的用户名和密码以HTTPS的形式POST到服务器。另一种是通过 HTTP 的 302 状态。 当客户端向 gmail 提出 HTTP 连接请求时，gmail 服务器会返回一个REDIRECT网址，https：//www.google.com/accounts/ServiceLogin?service=mail...，用户端在接收到这个 URL 后，将页面重定位到该网页，并请求 HTTPS 连接。 从另外一个角度讲，用户通常是通过HTTP向服务器发起HTTPS连接的。而HTTP本身是以明文的形式对外传送，并不能保证数据的安全。因此，可以考虑通过对 HTTP 进行劫持，来实现对 HTTPS 劫持的目的。 客户端向服务器发起HTTP连接请求； 中间人 MITM 监听客户端与服务器的HTTP数据； 服务器返回给客户端的 HTTP 数据包被在客户端与服务器之间的中间人截获。中间人解析原 HTTP 数据包，将其中&lt;a href=”https：//...”&gt;替换成&lt;a href=”http//...”&gt;，将 Location： https：//... 替换成Location：http://..，同时记录下所修改的 URL，并保存； 中间人将修改后的HTTP数据发送给客户端； 客户端向服务器发起HTTP连接请求； 中间人计算机解析客户端的HTTP连接请求，并与保存文件相比较。当发现存在有已修改过的HTTP URL时，将其替换成原HTTPS URL，并发送给服务器； 与服务器保持HTTPS连接，回到步骤 3； 与客户端保持HTTP连接，回到步骤 4。 效果就是： 服务器认为 HTTPS 是安全的。对于客户端而言，由于中间人 MITM 与客户端 Client 之间是 HTTP 连接，因此并不会对证书进行认证； HSTS:为了解决这个问题，IETF（互联网工程任务小组）引入了一个策略，叫做 HSTS (HTTP Strict Transport Security, HTTP 严格传输安全)。HSTS 的作用是强制客户端与服务端建立安全的 HTTPS 连接，而非不安全的 HTTP 连接。如果一个站点启用了 HSTS 策略，那么客户端在第一次与该站点建立连接之后，在未来的一段时间内（由一个 HTTP 头部控制，这个头部为：Strict-Transport-Security），客户端与该站点的所有连接都会直接使用 HTTPS，即使客户端访问的是 HTTP，也会直接在客户端重定向到 HTTPS 连接。 假设 https://example.com 的响应头部含有 Strict-Transport-Security: max-age=31536000; includeSubDomains，这意味着： 在未来的 1 年时间里（即 31536000 秒中），只要浏览器向 example.com 或者其子域名发送请求，必须采用 HTTPS 来发起连接。即使用户在地址栏里写的是 http://example.com，那也直接重写为 https://example.com 并直接发起 HTTPS 连接。 在接下去的一年中，如果服务器提供的 HTTPS 证书无效（不论是域名对不上还是自签名还是不在有效期内），用户都无法访问该站点。 如果站点没有启用 HSTS，用户可以忽略证书无效的警告，继续建立连接，而如果站点启用了 HSTS，那么用户即使想冒风险，浏览器也不会继续访问。 HSTS 可以很大程度上防止 SSLTrip 攻击，不过这样还是有个问题，那就是要启用 HSTS，浏览器至少要和服务器建立一次 HTTPS 连接，如果中间人一直阻止浏览器与服务器建立 HTTPS 连接，那么 HSTS 就失效了。解决这个问题有个办法，那就是将 HSTS 站点列表内置到浏览器中，这样只要浏览器离线判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。 如何防御中间人攻击？中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在 SSL 握手的过程中缺乏相互认证而造成的漏洞 防御中间人攻击的方案通常基于以下几种技术 公钥基础建设 PKI，更强力的相互认证 使用 PKI 相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了 SSL 握手环节的漏洞，而如果使用相互认证的的话，基本可以保证 延迟测试 使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费 20 秒来计算，并且整个通讯花费了 60 秒计算才到达对方，这就能表明存在第三方中间人。 https 通信安全性的保证通信过程的安全性自下而上就是这样保证的： 双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证。 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了。 数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由*上级 CA 证书的正确性保证的了。*（数字签名保证了数字证书没有被篡改**） 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了。 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了。 至此，整个信任链就建立起来了，只需要有一台设备上安装了可以信任的根证书，就可以用来分发更多安全的操作系统了。之后的所有信任链都是安全的了。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"CSRF攻击","slug":"CSRF攻击","date":"2019-06-18T12:05:23.000Z","updated":"2019-11-10T14:37:39.013Z","comments":true,"path":"2019/06/18/CSRF攻击/","link":"","permalink":"http://yoursite.com/2019/06/18/CSRF攻击/","excerpt":"CSRF 攻击1.什么是 CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 一个典型的 CSRF 攻击有着如下的流程：","text":"CSRF 攻击1.什么是 CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 一个典型的 CSRF 攻击有着如下的流程： 受害者登录 a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了 b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。 a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com 以受害者的名义执行了 act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。 2.常见的攻击类型 GET 类型的 CSRF GET 类型的 CSRF 利用非常简单，只需要一个 HTTP 请求，一般会这样利用： 1&lt;img src=\"http://bank.example/withdraw?amount=10000&amp;for=hacker\" /&gt; 在受害者访问含有这个 img 的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次 HTTP 请求。bank.example 就会收到包含受害者登录信息的一次跨域请求。 POST 类型的 CSRF 这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，如： 12345678&lt;form action=\"http://bank.example/withdraw\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"account\" value=\"xiaoming\" /&gt; &lt;input type=\"hidden\" name=\"amount\" value=\"10000\" /&gt; &lt;input type=\"hidden\" name=\"for\" value=\"hacker\" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit();&lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。 POST 类型的攻击通常比 GET 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面。 链接类型的 CSRF 链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如： 1234567&lt;a href=\"http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker\" taget=\"_blank\"&gt; 重磅消息！！ &lt;a/&gt;&lt;/a&gt; 由于之前用户登录了信任的网站 A，并且保存登录状态，只要用户主动访问上面的这个 PHP 页面，则表示攻击成功。 3.CSRF 的特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 CSRF 通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。 4.防护策略CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。 上文中讲了CSRF 的两个特点： CSRF（通常）发生在第三方域名。 CSRF 攻击者不能获取到 Cookie 等信息，只是使用。 针对这两点，我们可以专门制定防护策略，如下： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重 Cookie 验证 同源检测既然 CSRF 大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。 我们如何判断请求是否来自外域呢？ 在 HTTP 协议中，每一个异步请求都会携带两个 Header，用于标记来源域名： Origin Header Referer Header 这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。 1. 使用 Origin Header 确定来源域名在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段。字段内包含请求的域名（不包含 path 及 query）。 如果 Origin 存在，那么直接使用 Origin 中的字段确认来源域名就可以。 但是 Origin 在以下两种情况下并不存在： IE11 同源策略： IE 11 不会在跨站 CORS 请求上添加 Origin 标头，Referer 头将仍然是唯一的标识。最根本原因是因为 IE 11 对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions 302 重定向： 在 302 重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。对于 302 重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 Origin 泄漏到新的服务器上。 2. 使用 Referer Header 确定来源域名根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的来源地址。对于 Ajax 请求，图片和 script 等资源请求，Referer 为发起请求的页面地址。对于页面跳转，Referer 为打开页面历史记录的前一个页面地址。因此我们使用 Referer 中链接的 Origin 部分可以得知请求的来源域名。 这种方法并非万无一失，Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的 Referer。 2014 年，W3C 的 Web 应用安全工作组发布了 Referrer Policy 草案，对浏览器该如何发送 Referer 做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的 Referer 策略了。新版的 Referrer Policy 规定了五种 Referer 策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。之前就存在的三种策略：never、default 和 always，在新标准里换了个名称。他们的对应关系如下： 根据上面的表格因此需要把 Referrer Policy 的策略设置成 same-origin，对于同源的链接和引用，会发送 Referer，referer 值为 Host 不带 Path；跨域访问则不携带 Referer。例如：aaa.com引用bbb.com的资源，不会发送 Referer。 设置 Referrer Policy 的方法有三种： 在 CSP 设置 页面头部增加 meta 标签 a 标签增加 referrerpolicy 属性 攻击者可以在自己的请求中隐藏 Referer。 另外在以下情况下 Referer 没有或者不可信： IE6、7 下使用 window.location.href=url 进行界面的跳转，会丢失 Referer。 IE6、7 下使用 window.open，也会缺失 Referer。 HTTPS 页面跳转到 HTTP 页面，所有浏览器 Referer 都丢失。 点击 Flash 上到达另外一个网站的时候，Referer 的情况就比较杂乱，不太可信。 无法确认来源域名情况当 Origin 和 Referer 头文件不存在时该怎么办？如果 Origin 和 Referer 都不存在，建议直接进行阻止，特别是如果您没有使用随机 CSRF Token（参考下方）作为第二次检查。 如何阻止外域请求通过 Header 的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。 CSRF 大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称 UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。 综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的 CSRF 攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。 CSRF Token我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。 CSRF Token 的防护策略分为三个步骤： 将 CSRF Token 输出到页面中 首先，用户打开页面的时候，服务器需要给这个用户生成一个 Token，该 Token 通过加密算法对数据进行加密，一般 Token 都包括随机字符串和时间戳的组合，显然在提交时 Token 不能再放在 Cookie 中了，否则又会被攻击者冒用。因此，为了安全起见 Token 最好还是存在服务器的 Session 中，之后在每次页面加载时，使用 JS 遍历整个 DOM 树，对于 DOM 中所有的 a 和 form 标签后加入 Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 HTML 代码，这种方法就没有作用，还需要程序员在编码时手动添加 Token。 页面提交的请求携带这个 Token 对于 GET 请求，Token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上： 1&lt;input type=\"”hidden”\" name=\"”csrftoken”\" value=\"”tokenvalue”\" /&gt; ​ 这样，就把 Token 以参数的形式加入请求了。 服务器验证 Token 是否正确 当用户从客户端得到了 Token，再次提交给服务器的时候，服务器需要判断 Token 的有效性，验证过程是先解密 Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个 Token 就是有效的。 这种方法要比之前检查 Referer 或者 Origin 要安全一些，Token 可以在产生并放于 Session 之中，然后在每次请求时把 Token 从 Session 中拿出，与请求中的 Token 进行比对，但这种方法的比较麻烦的在于如何把 Token 以参数的形式加入请求。 分布式校验 在大型网站中，使用 Session 存储 CSRF Token 会带来很大的压力。访问单台服务器 session 是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的 HTTP 请求通常要经过像 Ngnix 之类的负载均衡器之后，再路由到具体的服务器上，由于 Session 默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次 HTTP 请求可能会先后落到不同的服务器上，导致后面发起的 HTTP 请求无法拿到之前的 HTTP 请求存储在服务器中的 Session 数据，从而使得 Session 机制在分布式环境下失效，因此在分布式集群中 CSRF Token 需要存储在 Redis 之类的公共存储空间。 由于使用 Session 存储，读取和验证 CSRF Token 会引起比较大的复杂度和性能问题，目前很多网站采用 Encrypted Token Pattern 方式。这种方法的 Token 是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的 Token，只用再次计算一次即可。 这种 Token 的值通常是使用 UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的 Token 一致，又能保证 Token 不容易被破解。 在 token 解密成功之后，服务器可以访问解析值，Token 中包含的 UserID 和时间戳将会被拿来被验证有效性，将 UserID 与当前登录的 UserID 进行比较，并将时间戳与当前时间进行比较。 双重 Cookie 验证使用双重提交 Cookie。利用 CSRF 攻击不能获取到用户 Cookie 的特点，我们可以要求 Ajax 和表单请求携带一个 Cookie 中的值。 双重 Cookie 采用以下流程： 在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。 此方法相对于 CSRF Token 就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储 Token。 由于任何跨域都会导致前端无法获取 Cookie 中的字段（包括子域名之间），于是发生了如下情况： 如果用户访问的网站为www.a.com，而后端的 api 域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的 Cookie，也就无法完成双重 Cookie 认证。 于是这个认证 Cookie 必须被种在a.com下，这样每个子域都可以访问。 任何一个子域都可以修改a.com下的 Cookie。 某个子域名存在漏洞被 XSS 攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的 Cookie。 攻击者可以直接使用自己配置的 Cookie，对 XSS 中招的用户再向www.a.com下，发起 CSRF 攻击。 总结 用双重 Cookie 防御 CSRF 的优点： 无需使用 Session，适用面更广，易于实施。 Token 储存于客户端中，不会给服务器带来压力。 相对于 Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。 缺点： Cookie 中增加了额外的字段。 如果有其他漏洞（例如 XSS），攻击者可以注入 Cookie，那么该防御方式失效。 难以做到子域名的隔离。 为了确保 Cookie 传输安全，采用这种防御方式最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式也会有风险。 Samesite Cookie 属性Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax Samesite=Strict这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie： 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3 我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。 Samesite=Lax这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 Cookie 可以作为第三方 Cookie。 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。 生成 Token 放到 Cookie 中并且设置 Cookie 的 Samesite 我们应该如何使用 SamesiteCookie如果 SamesiteCookie 被设置为 Strict，浏览器在任何跨域请求中都不会携带 Cookie，新标签重新打开也不携带，所以说 CSRF 攻击基本没有机会。 但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的 Cookie 都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。 如果 SamesiteCookie 被设置为 Lax，那么其他网站通过页面跳转过来的时候可以使用 Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。 另外一个问题是 Samesite 的兼容性不是很好，现阶段除了从新版 Chrome 和 Firefox 支持以外，Safari 以及 iOS Safari 都还不支持，现阶段看来暂时还不能普及。 而且，SamesiteCookie 目前有一个致命的缺陷：不支持子域。例如，种在 topic.a.com 下的 Cookie，并不能使用 a.com 下种植的 SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用 SamesiteCookie 在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。 总之，SamesiteCookie 是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。 5.防止网站被利用（防止攻击的发生）CSRF 的攻击可以来自： 攻击者自己的网站。 有文件上传漏洞的网站。 第三方论坛等用户内容。 被攻击网站自己的评论功能等。 如何防止自己的网站被利用成为攻击的源头呢？ 严格管理所有的上传接口，防止任何预期之外的上传内容（例如 HTML）。 添加 Header X-Content-Type-Options: nosniff 防止黑客上传 HTML 内容的资源（例如图片）被解析为网页。 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。 6.CSRF 其他防范措施CSRF 测试CSRFTester 是一款 CSRF 漏洞的测试工具，CSRFTester 工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在 CSRFTester 中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被网站服务器接受，则说明存在 CSRF 漏洞，当然此款工具也可以被用来进行 CSRF 攻击。CSRFTester 使用方法大致分下面几个步骤： 步骤 1：设置浏览器代理 CSRFTester 默认使用 Localhost 上的端口 8008 作为其代理，如果代理配置成功，CSRFTester 将为您的浏览器生成的所有后续 HTTP 请求生成调试消息。 步骤 2：使用合法账户访问网站开始测试 我们需要找到一个我们想要为 CSRF 测试的特定业务 Web 页面。找到此页面后，选择 CSRFTester 中的“开始录制”按钮并执行业务功能；完成后，点击 CSRFTester 中的“停止录制”按钮；正常情况下，该软件会全部遍历一遍当前页面的所有请求。 步骤 3：通过 CSRF 修改并伪造请求 之后，我们会发现软件上有一系列跑出来的记录请求，这些都是我们的浏览器在执行业务功能时生成的所有 GET 或者 POST 请求。通过选择列表中的某一行，我们现在可以修改用于执行业务功能的参数，可以通过点击对应的请求修改 query 和 form 的参数。当修改完所有我们希望诱导用户 form 最终的提交值，可以选择开始生成 HTML 报告。 步骤 4：拿到结果如有漏洞进行修复 首先必须选择“报告类型”。报告类型决定了我们希望受害者浏览器如何提交先前记录的请求。目前有 5 种可能的报告：表单、iFrame、IMG、XHR 和链接。一旦选择了报告类型，我们可以选择在浏览器中启动新生成的报告，最后根据报告的情况进行对应的排查和修复。 CSRF 监控对于一个比较复杂的网站系统，某些项目、页面、接口漏掉了 CSRF 防护措施是很可能的。 一旦发生了 CSRF 攻击，我们如何及时的发现这些攻击呢？ CSRF 攻击有着比较明显的特征： 跨域请求。 GET 类型请求 Header 的 MIME 类型大概率为图片，而实际返回 Header 的 MIME 类型为 Text、JSON、HTML。 我们可以在网站的代理层监控所有的接口请求，如果请求符合上面的特征，就可以认为请求有 CSRF 攻击嫌疑。我们可以提醒对应的页面和项目负责人，检查或者 Review 其 CSRF 防护策略。 个人用户 CSRF 安全的建议经常上网的个人用户，可以采用以下方法来保护自己： 使用网页版邮件的浏览邮件或者新闻也会带来额外的风险，因为查看邮件或者新闻消息有可能导致恶意代码的攻击。 尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/安全/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"XSS攻击","slug":"XSS攻击","date":"2019-06-13T10:29:55.000Z","updated":"2019-11-10T14:37:39.023Z","comments":true,"path":"2019/06/13/XSS攻击/","link":"","permalink":"http://yoursite.com/2019/06/13/XSS攻击/","excerpt":"XSS 攻击1.什么是 XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。","text":"XSS 攻击1.什么是 XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 在处理输入时，以下内容都不可信： 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入） 2.XSS 分类根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。 存储型 XSS存储型 XSS 的攻击步骤： 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 反射型 XSS反射型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 DOM 型 XSSDOM 型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 3.XSS 的预防XSS 攻击有两大要素： 攻击者提交恶意代码。 浏览器执行恶意代码。 输入过滤输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。 对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。 输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类： 防止 HTML 中出现注入。 防止 JavaScript 执行时，执行恶意代码。 预防存储型和反射型 XSS 攻击预防这两种漏洞，有两种常见做法： 改成纯前端渲染，把代码和数据分隔开。 纯前端渲染的过程： 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免 DOM 型 XSS 漏洞 对 HTML 做充分转义。 转义应该在输出 HTML 时进行，而不是在提交用户输入时。 常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; &quot; &#39; / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善： 预防 DOM 型 XSS 攻击 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。 4.其他 XSS 防范措施Content Security Policy严格的 CSP 在 XSS 的防范中可以起到以下的作用： 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 输入内容长度控制对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 其他安全措施 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 5.XSS 漏洞总结漏洞总结 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。 在 onload、onerror、onclick 等事件中，注入不受控制代码。 在 style 属性和标签中，包含类似 background-image:url(&quot;javascript:...&quot;); 的代码（新版本浏览器已经可以防范）。 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。 总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。 内联 JSON 也是不安全的： 当 JSON 中包含 U+2028 或 U+2029 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。 当 JSON 中包含字符串 &lt;/script&gt; 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 &lt;script&gt; 标签等方法就可以完成注入。 6.减少漏洞产生的原则 利用模板引擎开启模板引擎自带的 HTML 转义功能。例如：在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。 避免内联事件尽量不要使用 onLoad=&quot;onload(&#39;&#39;)&quot;、onClick=&quot;go(&#39;&#39;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。 避免拼接 HTML前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。 时刻保持警惕在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。 增加攻击难度，降低攻击后果通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。 主动检测和发现可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。 7.vue react 框架对 xss 的防护有做什么？ VUE 尽量使用插值表达式(双花括号)，它会把要显示的内容转为字符串。 如果使用v-html，要保证来自服务端的渲染数据都是安全的。 在使用第三方 UI 组件库的的时候，要检查一下它们渲染页面的方式，是否使用了v-html REACT XSS 防御措施就是对任何用户输入的信息进行处理，只允许合法值，其它值一概过滤掉 所有的用户输入都需要经过 HTML 实体编码，React 已经做了，它会在运行时动态创建 DOM 节点然后填入文本内容 (也可以强制设置 HTML 内容，不过这样比较危险) 序列化某些状态并且传给客户端的时候，也进行 HTML 实体编码，可以使用 Yahoo 的 Serialize JavaScript 中的 serialize 方法替换 JSON.stringify 方法，Serialize JavaScript 中的方法会自动将 HTML 和 JavaScript 代码进行转码，GitHub 访问地址 : https://github.com/yahoo/serialize-javascript 默认情况下，React DOM 在重新渲染页面时将所有进行转码，官方宣称在 React 应用中确保不会注入任何没显式编写的数据，所有的数据在页面渲染之前都会被转换成字符串，这防止 XSS 进攻 8.xss 攻击后果？恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 9.需要转义的字符？ escapeHTML() 按照如下规则进行转义： 连 javascript: 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。 %20javascript:alert(&#39;XSS&#39;) 经过 URL 解析后变成 javascript:alert(&#39;XSS&#39;)，这个字符串以空格开头。这样攻击者可以绕过后端的关键词规则，又成功的完成了注入。 插入 JSON 的地方不能使用 escapeHTML()，因为转义 &quot; 后，JSON 格式会被破坏。 要实现一个 escapeEmbedJSON() 函数，对内联 JSON 进行转义。","categories":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/categories/安全/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"}]},{"title":"ES6 的新特性总结","slug":"ES6 的新特性总结","date":"2019-06-01T14:23:01.000Z","updated":"2019-11-10T14:37:39.016Z","comments":true,"path":"2019/06/01/ES6 的新特性总结/","link":"","permalink":"http://yoursite.com/2019/06/01/ES6 的新特性总结/","excerpt":"ES6 的新特性1. 数组的拓展数组的方法 array.concat(array1, array2,…arrayN)合并多个数组，返回合并后的新数组，原数组没有变化。 array.every(callback[, thisArg])检测数组中的每一个元素是否都通过了 callback 测试，全部通过返回 true，否则返回 false。 array.filter(callback[, thisArg])返回一个新数组，包含通过 callback 函数测试的所有元素。(callback 定义，三个参数： element:当前元素值；index：当前元素下标； array:当前数组) array.find(callback[, thisArg])返回通过 callback 函数测试的第一个元素，否则返回 undefined，callback 函数定义同上。","text":"ES6 的新特性1. 数组的拓展数组的方法 array.concat(array1, array2,…arrayN)合并多个数组，返回合并后的新数组，原数组没有变化。 array.every(callback[, thisArg])检测数组中的每一个元素是否都通过了 callback 测试，全部通过返回 true，否则返回 false。 array.filter(callback[, thisArg])返回一个新数组，包含通过 callback 函数测试的所有元素。(callback 定义，三个参数： element:当前元素值；index：当前元素下标； array:当前数组) array.find(callback[, thisArg])返回通过 callback 函数测试的第一个元素，否则返回 undefined，callback 函数定义同上。 array.findIndex(callback[, thisArg])返回通过 callback 函数测试的第一个元素的索引，否则返回-1，callback 函数定义同上。 array.includes(searchElement, fromIndex)includes() 方法用来判断一个数组是否包含一个指定的值，返回 true 或 false。searchElement：要查找的元素；fromIndex：开始查找的索引位置。 array.indexOf(searchElement[, fromIndex = 0])返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。searchElement：要查找的元素；fromIndex：开始查找的索引位置。 array.join(separator=&#39;,&#39;)将数组中的元素通过 separator 连接成字符串，并返回该字符串，separator 默认为”,”。 array.map(callback[, thisArg])返回一个新数组，新数组中的每个元素都是调用 callback 函数后返回的结果。注意：如果没有 return 值，则新数组会插入一个 undefined 值。array.map 由于不具有过滤的功能，因此 array 调用 map 函数时，如果 array 中的数据并不是每一个都会 return，则必须先 filter，然后再 map，即 map 调用时必须是对数组中的每一个元素都有效。 array.pop() 与 array.shift()pop 为从数组中删除最后一个元素，并返回最后一个元素的值，原数组的最后一个元素被删除。数组为空时返回 undefined。shift 删除数组的第一个元素，并返回第一个元素，原数组的第一个元素被删除。数组为空返回 undefined。 array.push(element1, element2, ....elementN) 与 array.unshift(element1, element2, ...elementN)push 是将一个或多个元素添加到数组的末尾，并返回新数组的长度; unshift 将一个或多个元素添加到数组的开头，并返回新数组的长度。唯一的区别就是插入的位置不同。 array.reduce(callback[, initialValue])对数组中的每个元素（从左到右）执行 callback 函数累加，将其减少为单个值。 array.reverse()将数组中元素的位置颠倒。 array.slice(begin, end)返回一个新数组，包含原数组从 begin 到 end(不包含 end)索引位置的所有元素。 array.some(callback[, thisArg])判断数组中是否包含可以通过 callback 测试的元素，与 every 不同的是，这里只要某一个元素通过测试，即返回 true。callback 定义同上。 array.sort([compareFunction])对数组中的元素进行排序，compareFunction 不存在时，元素按照转换为的字符串的诸个字符的 Unicode 位点进行排序，慎用！请使用时一定要加 compareFunction 函数，而且该排序是不稳定的。 array.splice(start[, deleteCount, item1, item2, ...])通过删除现有元素和/或添加新元素来更改一个数组的内容。start:指定修改的开始位置；deleteCount：从 start 位置开始要删除的元素个数；item…：要添加进数组的元素,从 start 位置开始。返回值是由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 注：push、 shift、 pop、 unshift、 reverse、 sort、 splice 方法会对原来的数组进行修改，其他的数组操作方法只有返回值不同，对原数组都没有影响，即原数组不变。 ES6 中对数组的扩展 Array.from() : 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3) : 将一系列值转换成数组。 当使用单个数值参数来调用 Array 构造器时，数组的长度属性会被设置为该参数。 如果使用多个参数(无论是否为数值类型)来调用，这些参数也会成为目标数组的项。数组的这种行为既混乱又有风险，因为有时可能不会留意所传参数的类型。 Array.of( )方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型 1234567let items = Array.of(1, 2);console.log(items.length); // 2console.log(items[0]); // 1console.log(items[1]); // 2items = Array.of(2);console.log(items.length); // 1console.log(items[0]); // 2 Array.of 基本上可以用来替代 Array()或 newArray()，并且不存在由于参数不同而导致的重载，而且他们的行为非常统一。 数组实例的 find() 和 findIndex() find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。 1[1, 4, -5, 10].find(n =&gt; n &lt; 0); // -5 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;); // 2 数组实例的 includes() Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值。该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。 1234[1, 2, 3] .includes(2) // true [(1, 2, 3)].includes(3, -1); // true[1, 2, 3, 5, 1].includes(1, 2); // true 没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。它内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判。 123[NaN] .indexOf(NaN) // -1 [NaN].includes(NaN); // true 数组实例的 entries()，keys() 和 values() 它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [\"a\", \"b\"].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [\"a\", \"b\"].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of [\"a\", \"b\"].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 2. 箭头函数 缩减代码和改变 this 指向 使用注意点： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 3. rest 参数 用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 注意点： 每个函数最多只能声明一个 rest 参数，而且 rest 参数必须是最后一个参数，否则报错。 rest 参数不能用于对象字面量 setter 之中 4. 展开运算符剩余参数允许你把多个独立的参数合并到一个数组中；而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。 5. 解构赋值—-更方便的数据访问6. 模板字符串用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量和函数，需要将变量名写在${}之中。 7. class 类8. promise9. Iterator 和 for…of 循环JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 添加了 Map 和 Set。 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。 原生具备 iterator 接口的数据(可用 for of 遍历) Array set 容器 map 容器 String 函数的 arguments 对象 NodeList 对象 几种遍历方式比较 for of 循环不仅支持数组、大多数伪数组对象，也支持字符串遍历，此外还支持 Map 和 Set 对象遍历 for in 循环可以遍历字符串、对象、数组，不能遍历 Set/Map forEach 循环不能遍历字符串、对象,可以遍历 Set/Map 10. ES6 模块化其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS元素居中","slug":"CSS元素居中","date":"2019-05-23T10:06:01.000Z","updated":"2019-11-10T14:37:39.014Z","comments":true,"path":"2019/05/23/CSS元素居中/","link":"","permalink":"http://yoursite.com/2019/05/23/CSS元素居中/","excerpt":"CSS 元素居中1.水平居中 行内元素水平居中 利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。","text":"CSS 元素居中1.水平居中 行内元素水平居中 利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。 1234.parent &#123; //在父容器设置 text-align: center;&#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; text-align: center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 块级元素的水平居中 这种情形可以有多种实现方式，下面我们详细介绍: ① 将该块级元素左右外边距 margin-left 和 margin-right 设置为 auto1234.child &#123; width: 100px; //确保该块级元素定宽 margin: 0 auto;&#125; ② 使用 table+margin先将子元素设置为块级表格来显示（类似），再将其设置水平居中 display:table 在表现上类似 block 元素，但是宽度为内容宽。 123456789&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; ③ 使用 absolute+transform先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 12345678910111213&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position: absolute; left: 50%; transform: translateX(-50%); &#125; .parent &#123; position: relative; &#125;&lt;/style&gt; 不过 transform 属于 css3 内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 ④ 使用 flex+justify-content通过 CSS3 中的布局利器 flex 中的 justify-content 属性来达到水平居中。 123456789&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content: center; &#125;&lt;/style&gt; ⑤ 使用 flex+margin通过 flex 将父容器设置为为 Flex 布局，再设置子元素居中。 1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 多块级元素水平居中 ① 利用 flex 布局利用弹性布局(flex)，实现水平居中，其中 justify-content 用于设置弹性盒子元素在主轴（默认横轴）方向上的对齐方式，本例中设置子元素水平居中显示。 1234#container &#123; display: flex; justify-content: center;&#125; ② 利用 inline-block将要水平排列的块状元素设为 display:inline-block，然后在父级元素上设置 text-align:center，达到与上面的行内元素的水平居中一样的效果。 123456.container &#123; text-align: center;&#125;.inline-block &#123; display: inline-block;&#125; 浮动元素水平居中 对于定宽的浮动元素，通过子元素设置 relative + 负 margin 对于不定宽的浮动元素，父子容器都用相对定位 通用方法(不管是定宽还是不定宽)：flex 布局 ① 定宽的非浮动元素通过子元素设置 relative + 负 margin,原理见下图： 注意：样式设置在浮动元素本身 123456.child &#123; position:relative; left:50%; margin-left:-250px; &#125;&lt;div class=\"parent\"&gt; &lt;span class=\"child\" style=\"float: left;width: 500px;\" &gt;我是要居中的浮动元素&lt;/span &gt;&lt;/div&gt; ② 不定宽的浮动元素通过父子容器都相对定位，偏移位移见下图：注意：要清除浮动，给外部元素加上 float。这里的父元素就是外部元素 123456&lt;div class=\"box\"&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%; &#125; p&#123; float:left;position:relative; right:50%; &#125; ③ 通用办法 flex 布局(不管是定宽还是不定宽)利用弹性布局(flex)的 justify-content 属性，实现水平居中。 12345.parent &#123; display:flex; justify-content:center; &#125; .chlid&#123; float: left; width:200px;//有无宽度不影响居中 &#125;&lt;div class=\"parent\"&gt; &lt;span class=\"chlid\"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 绝对定位元素水平居中 这种方式非常独特，通过子元素绝对定位，外加 margin: 0 auto 来实现。 123456&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt;.parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width:200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0;/*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 2.垂直居中 单行内联元素垂直居中 12345678&lt;div id=\"box\"&gt;&lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 多行内联元素垂直居中 ① 利用 flex 布局（flex）利用 flex 布局实现垂直居中，其中 flex-direction: column 定义主轴方向为纵向。这种方式在较老的浏览器存在兼容性问题。 12345678910111213141516&lt;div class=\"parent\"&gt; &lt;p&gt; Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. &lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; ② 利用表布局（table）利用表布局的 vertical-align: middle 可以实现子元素的垂直居中 123456789101112131415161718&lt;div class=\"parent\"&gt; &lt;p class=\"child\"&gt; The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know. &lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table; height: 140px; border: 2px dashed #f69c55; &#125; .child &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 块级元素垂直居中 ① 使用 absolute+负 margin(已知高度宽度)通过绝对定位元素距离顶部 50%，并设置 margin-top 向上偏移元素高度的一半，就可以实现了。 12345&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; height:100px; margin-top: -50px; &#125; ② 使用 absolute+transform当垂直居中的元素的高度和宽度未知时，可以借助 CSS3 中的 transform 属性向 Y 轴反向偏移 50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题。 12345&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%;transform: translateY(-50%); &#125; ③ 使用 flex+align-items通过设置 flex 布局中的属性 align-items，使子元素垂直居中。 1234&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center; &#125; ④ 使用 table-cell+vertical-align通过将父元素转化为一个表格单元格显示（类似 和 ），再通过设置 vertical-align 属性，使表格单元格内容垂直居中。 123456789&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 3.水平垂直居中12345678// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id=\"container\"&gt; &lt;div id=\"center\" style=\"width: 100px;height: 100px;background-color: #666\"&gt; center &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 绝对定位与负边距实现（已知高度宽度） 这种方式需要知道被垂直居中元素的高和宽，才能计算出 margin 值，兼容所有浏览器。 12345678910// css部分#container &#123; position: relative;&#125;#center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px;&#125; 绝对定位与 margin:auto（已知高度宽度） 这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的 IE 浏览器。 123456789101112#container &#123; position: relative; height: 100px; //必须有个高度&#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; //注意此处的写法&#125; 绝对定位+transform(未知元素的高宽) 利用 Css3 的 transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中。CSS3 的 transform 固然好用，但在项目的实际运用中必须考虑兼容问题，大量的 hack 代码可能会导致得不偿失。 123456789#container &#123; position: relative;&#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex 布局 利用 flex 布局，其中 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而 align-items 属性定义 flex 子项在 flex 容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的 IE 浏览器。 1234567#container &#123; //直接在父容器设置即可 height: 100vh; //必须有高度 display: flex; justify-content: center; align-items: center;&#125; flex/grid 与 margin:auto(最简单写法) 容器元素设为 flex 布局或是 grid 布局，子元素只要写 margin: auto 即可,不能兼容低版本的 IE 浏览器。 1234567#container &#123; height: 100vh; //必须有高度 display: grid;&#125;#center &#123; margin: auto;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"居中","slug":"居中","permalink":"http://yoursite.com/tags/居中/"}]},{"title":"CSS多列布局","slug":"CSS多列布局","date":"2019-05-08T03:25:33.000Z","updated":"2019-11-10T14:37:39.014Z","comments":true,"path":"2019/05/08/CSS多列布局/","link":"","permalink":"http://yoursite.com/2019/05/08/CSS多列布局/","excerpt":"1.单列布局常见的单列布局有两种： header,content 和 footer 等宽的单列布局 header 与 footer 等宽,content 略窄的单列布局","text":"1.单列布局常见的单列布局有两种： header,content 和 footer 等宽的单列布局 header 与 footer 等宽,content 略窄的单列布局 第一种：对于第一种，先通过对 header,content,footer 统一设置 width：1000px;或者 max-width：1000px(这两者的区别是当屏幕小于 1000px 时，前者会出现滚动条，后者则不会，显示出实际宽度);然后设置 margin:auto 实现居中即可得到。 123&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;div class=\"content\"&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 123456789101112131415161718.header &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: blue;&#125;.content &#123; margin: 0 auto; max-width: 960px; height: 400px; background-color: aquamarine;&#125;.footer &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua;&#125; 第二种：对于第二种，header、footer 的内容宽度不设置，块级元素充满整个屏幕，但 header、content 和 footer 的内容区设置同一个 width，并通过 margin:auto 实现居中。 12345&lt;div class=\"header\"&gt; &lt;div class=\"nav\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"content\"&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324.header &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: blue;&#125;.nav &#123; margin: 0 auto; max-width: 800px; background-color: darkgray; height: 50px;&#125;.content &#123; margin: 0 auto; max-width: 800px; height: 400px; background-color: aquamarine;&#125;.footer &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua;&#125; 2.两列自适应布局两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式 float+overflow:hidden如果是普通的两列布局，浮动+普通元素的 margin便可以实现，但如果是自适应的两列布局，利用float+overflow:hidden便可以实现，这种办法主要通过 overflow 触发 BFC,而 BFC 不会重叠浮动元素。由于设置 overflow:hidden 并不会触发 IE6-浏览器的 haslayout 属性，所以需要设置 zoom:1 来兼容 IE6-浏览器。具体代码如下： 123456789&lt;div class=\"parent\" style=\"background-color: lightgrey;\"&gt; &lt;div class=\"left\" style=\"background-color: lightblue;\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\" style=\"background-color: lightgreen;\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.parent &#123; overflow: hidden; zoom: 1;&#125;.left &#123; float: left; margin-right: 20px;&#125;.right &#123; overflow: hidden; zoom: 1;&#125; 注意点:如果侧边栏在右边时，注意渲染顺序。即在 HTML 中，先写侧边栏后写主内容 Flex 布局Flex 布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。 12345678//html部分同上.parent &#123; display: flex;&#125;.right &#123; margin-left: 20px; flex: 1;&#125; grid 布局Grid 布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。 123456//html部分同上.parent &#123; display: grid; grid-template-columns: auto 1fr; grid-gap: 20px;&#125; 3.三栏布局特征：中间列自适应宽度，旁边两侧固定宽度 圣杯布局 特点 比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是 dom 结构必须是先写中间列部分，这样实现中间列可以优先加载。 1234567&lt;article class=\"container\"&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;圣杯布局&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 12345678910111213141516171819202122232425262728.container &#123; padding-left: 220px; //为左右栏腾出空间 padding-right: 220px;&#125;.left &#123; float: left; width: 200px; height: 400px; background: red; margin-left: -100%; position: relative; left: -220px;&#125;.center &#123; float: left; width: 100%; height: 500px; background: yellow;&#125;.right &#123; float: left; width: 200px; height: 400px; background: blue; margin-left: -200px; position: relative; right: -220px;&#125; 实现步骤 三个部分都设定为左浮动，否则左右两边内容上不去，就不可能与中间列同一行。然后设置 center 的宽度为 100%(实现中间列内容自适应)，此时，left 和 right 部分会跳到下一行 通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行 通过设置父容器的 padding-left 和 padding-right，让左右两边留出间隙。 通过设置相对定位，让 left 和 right 部分移动到两边。 缺点 center 部分的最小宽度不能小于 left 部分的宽度，否则会 left 部分掉到下一行 如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正 padding+负 margin 可解决，下文会介绍) 双飞翼布局 特点 同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。 1234567&lt;article class=\"container\"&gt; &lt;div class=\"center\"&gt; &lt;div class=\"inner\"&gt;双飞翼布局&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 1234567891011121314151617181920212223242526.container &#123; min-width: 600px; //确保中间内容可以显示出来，两倍left宽+right宽&#125;.left &#123; float: left; width: 200px; height: 400px; background: red; margin-left: -100%;&#125;.center &#123; float: left; width: 100%; height: 500px; background: yellow;&#125;.center .inner &#123; margin: 0 200px; //新增部分&#125;.right &#123; float: left; width: 200px; height: 400px; background: blue; margin-left: -200px;&#125; 实现步骤(前两步与圣杯布局一样) 三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行； 通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行； center 部分增加一个内层 div，并设 margin: 0 200px； 缺点多加一层 dom 树节点，增加渲染树生成的计算量。 两种布局实现方式对比: 两种布局方式都是把主列放在文档流最前面，使主列优先加载。 两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。 两种布局方式的不同之处在于如何处理中间主列的位置：圣杯布局是利用父容器的左、右内边距+两个从列相对定位；双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整 浮动布局1234567891011&lt;article class=\"left-right-center\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; // 右栏部分要写在中间内容之前 &lt;div class=\"center\"&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt;&lt;/article&gt; 12345678910111213.layout.float .left &#123; float: left; width: 300px; background: red;&#125;.layout.float .center &#123; background: yellow;&#125;.layout.float .right &#123; float: right; width: 300px; background: blue;&#125; 这种布局方式，dom 结构必须是先写浮动部分，然后再中间块，否则右浮动块会掉到下一行。浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。 绝对布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 123456789101112131415161718.layout.absolute .left-center-right &gt; div &#123; position: absolute; //三块都是绝对定位&#125;.layout.absolute .left &#123; left: 0; width: 300px; background: red;&#125;.layout.absolute .center &#123; right: 300px; left: 300px; //离左右各三百 background: yellow;&#125;.layout.absolute .right &#123; right: 0; width: 300px; background: blue;&#125; 绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 flexbox 布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 123456789101112131415.layout.flexbox .left-center-right &#123; display: flex;&#125;.layout.flexbox .left &#123; width: 300px; background: red;&#125;.layout.flexbox .center &#123; background: yellow; flex: 1;&#125;.layout.flexbox .right &#123; width: 300px; background: blue;&#125; flexbox 布局是 css3 里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用 flexbox。 flexbox 的缺点就是 IE10 开始支持，但是 IE10 的是-ms 形式的。 表格布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 12345678910111213141516171819.layout.table .left-center-right &#123; display: table; height: 150px; width: 100%;&#125;.layout.table .left-center-right &gt; div &#123; display: table-cell;&#125;.layout.table .left &#123; width: 300px; background: red;&#125;.layout.table .center &#123; background: yellow;&#125;.layout.table .right &#123; width: 300px; background: blue;&#125; 表格布局的兼容性很好(见下图)，在 flex 布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素。 表格布局也是有缺陷:① 无法设置栏边距；② 对 seo 不友好；③ 当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。 网格布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 123456789101112131415.layout.grid .left-center-right &#123; display: grid; width: 100%; grid-template-columns: 300px auto 300px; grid-template-rows: 150px; //行高&#125;.layout.grid .left &#123; background: red;&#125;.layout.grid .center &#123; background: yellow;&#125;.layout.grid .right &#123; background: blue;&#125; CSS Grid 是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让 Web 设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。 但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性。 4.等高布局等高布局是指子元素在父元素中高度相等的布局方式。接下来我们介绍常见几种实现方式： 利用正 padding+负 margin 我们通过等高布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。新增代码如下： 1234567891011.center,.left,.right &#123; padding-bottom: 10000px; margin-bottom: -10000px;&#125;.container &#123; padding-left: 220px; padding-right: 220px; overflow: hidden; //把溢出背景切掉&#125; 利用背景图片 这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行 Y 轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的 css 样式就可以轻松实现,但此方法不适合流体布局等高列的布局。 在制作样式之前需要一张类似下面的背景图： 12345&lt;div class=\"”container\" clearfix”&gt; &lt;div class=\"”left”\"&gt;&lt;/div&gt; &lt;div class=\"”content”\"&gt;&lt;/div&gt; &lt;div class=\"”right”\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.container &#123; background: url(\"column.png\") repeat-y; width: 960px; margin: 0 auto;&#125;.left &#123; float: left; width: 220px;&#125;.content &#123; float: left; width: 480px;&#125;.right &#123; float: left; width: 220px;&#125; 模仿表格布局 这是一种非常简单，易于实现的方法。不过兼容性不好，在 ie6-7 无法正常运行。 12345678910111213141516171819&lt;div class=\"container table\"&gt; &lt;div class=\"containerInner tableRow\"&gt; &lt;div class=\"column tableCell cell1\"&gt; &lt;div class=\"left aside\"&gt; .... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column tableCell cell2\"&gt; &lt;div class=\"content section\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column tableCell cell3\"&gt; &lt;div class=\"right aside\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324.table &#123; width: auto; min-width: 1000px; margin: 0 auto; padding: 0; display: table;&#125;.tableRow &#123; display: table-row;&#125;.tableCell &#123; display: table-cell; width: 33%;&#125;.cell1 &#123; background: #f00; height: 800px;&#125;.cell2 &#123; background: #0f0;&#125;.cell3 &#123; background: #00f;&#125; 使用边框和定位 这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。 1234&lt;div id=\"wrapper\"&gt; &lt;div id=\"mainContent\"&gt;...&lt;/div&gt; &lt;div id=\"sidebar\"&gt;...&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718#wrapper &#123; width: 960px; margin: 0 auto;&#125;#mainContent &#123; border-right: 220px solid #dfdfdf; position: absolute; width: 740px; height: 800px; background: green;&#125;#sidebar &#123; background: #dfdfdf; margin-left: 740px; position: absolute; height: 800px; width: 220px;&#125; 5.粘连布局 特点 有一块内容&lt;main&gt;，当&lt;main&gt;的高康足够长的时候，紧跟在&lt;main&gt;后面的元素&lt;footer&gt;会跟在&lt;main&gt;元素的后面。 当&lt;main&gt;元素比较短的时候(比如小于屏幕的高度),我们期望这个&lt;footer&gt;元素能够“粘连”在屏幕的底部 具体代码如下： 12345678&lt;div id=\"wrap\"&gt; &lt;div class=\"main\"&gt; main &lt;br /&gt; main &lt;br /&gt; main &lt;br /&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=\"footer\"&gt;footer&lt;/div&gt; 123456789101112131415161718192021222324* &#123; margin: 0; padding: 0;&#125;html,body &#123; height: 100%; //高度一层层继承下来&#125;#wrap &#123; min-height: 100%; background: pink; text-align: center; overflow: hidden;&#125;#wrap .main &#123; padding-bottom: 50px;&#125;#footer &#123; height: 50px; line-height: 50px; background: deeppink; text-align: center; margin-top: -50px;&#125; 实现步骤 footer 必须是一个独立的结构，与 wrap 没有任何嵌套关系 wrap 区域的高度通过设置 min-height，变为视口高度 footer 要使用 margin 为负来确定自己的位置 在 main 区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"}]},{"title":"CSS常用布局方式","slug":"CSS常用布局方式","date":"2019-05-02T07:44:43.000Z","updated":"2019-11-10T14:37:39.014Z","comments":true,"path":"2019/05/02/CSS常用布局方式/","link":"","permalink":"http://yoursite.com/2019/05/02/CSS常用布局方式/","excerpt":"CSS 常用布局方式1.静态布局（固定布局）布局特点不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。","text":"CSS 常用布局方式1.静态布局（固定布局）布局特点不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。 设计方法 PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个 Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分； 12345.wrap &#123; width: 640px; overflow: hidden; margin: 0 auto;&#125; ​ 有固定的版型大小，例如 640px，然后设置 margin：0 auto；来居中。小于 640 时出现滚动条。 移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如 wap.或 m.。在 &lt;viewport meta&gt; 标签上设置 width，页面的各个元素也采用px作为单位。通过用 JS 动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。 实现方法 普通/文档流 布局 Float 布局 绝对布局 优缺点优点：这种布局方式对设计师和 CSS 编写者来说都是最简单的，亦没有兼容性问题。 缺点：显而易见，不能根据用户的屏幕尺寸做出不同的展现。当前，大部分门户网站、大部分企业的 PC 宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。 窄屏幕滚动条体验很差 宽屏有大片空白，不利于空间利用 2.流式布局流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。网页中主要的划分区域的尺寸使用百分数（搭配 min-、max-属性使用），例如，设置网页主体的宽度为 80%，min-width 为 960px。图片也作类似处理（width:100%, max-width 一般设定为图片本身的尺寸，防止被拉伸而失真）。 布局特点屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示。 设计方法使用%百分比定义宽度，而高度大都是用 px 来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。 这种布局方式在 Web 前端开发的早期历史上，用来应对不同尺寸的 PC 屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式。流式布局目的是在不同大小的设备上满屏呈现同样网页。它是用于解决类似的设备不同分辨率之间的兼容(一般分辨率差异较少)。 百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。 如果用百分比写 width，那么指的是父元素 width 的百分之多少。 如果用百分比写 height，那么指的是父元素 height 的百分之多少。 如果用百分比写 padding，那么指的是*父元素 width *的百分之多少，无论是水平的 padding 还是竖直的 padding。 如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。 不能用百分比写 border 的宽度 实现方法 允许网页宽度自动调整：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; 不使用绝对尺寸（包括容器/字体/图片），使用百分比、em、rem、vw、vh 等 可使用 flex 等弹性盒子（不要使用 px 定尺寸） 优缺点优点：页面左右满屏。 但缺点明显： 主要的问题**是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用 px 来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调 使用百分比定义，所以在大屏幕的手机/Pad 下（或者横屏下）显示效果会变成有些页面元素被拉的很大，但是内容数量却不变，显得稀疏不紧凑，空间利用率低下。 如果文字也按照百分比放大，则整体效果会非常不协调（老人机效果）。 例子https://www.trip.com/flightsh5/status/ 3.自适应布局自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个合集。 布局特点屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。 设计方法使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。 实现方式 静态布局方法 分辨率 detector（media query/server-side detector/UA） 优缺点优点：自适应布局页面里面元素的位置会变化，很好的解决了流式布局中的大屏空间利用率不高弊端。 缺点：单个布局容器无法灵活伸缩，未触发布局切换的情况下，容器仍然容易出现静态布局中提到的问题。 例子www.baidu.com/ 自适应设计（AWD）自适应设计是通过服务端检测设备类型、从 site 的不同版本中选择最合适该设备类型的设计布局/尺寸的版本进行展示。它可以使用到所有（包括响应式布局）布局方案。 实现方式： server-side detection different versions to different devices 对于 PC: 可使用流式布局； 对于 Mobile: 可使用流式布局。推荐一个 Rem 解决方案： 设置元素（可以包括字体等）大小为 rem （rem 是以跟元素font-size为基准的单位） 按照屏幕宽度的不同，JS 动态设置 &lt;html&gt; 的 font-size 大小，元素同样会按照屏幕宽度等比例放大缩小 举个栗子：www.trip.com/ 4.响应式布局（媒体查询）随着 CSS3 出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的 PC、手机、手表、冰箱的 Web 浏览器等等）都能显示出令人满意的效果，对 CSS 编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。改变屏幕分辨率可以通过 CSS Media query 实时地切换不同的布局（页面元素位置可能发生改变），在每个布局中，页面元素会随窗口大小的调整发生流式布局中的自动尺寸变化。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。 响应式几乎已经成为优秀页面布局的标准。 布局特点每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。 设计方法媒体查询+流式布局。通常使用 @media 媒体查询和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。 实现方式 流式布局 CSS media query 优缺点优点：适应 pc 和移动端，如果足够耐心，效果完美。融合了流式布局和自适应布局的优势。 缺点： 媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。 要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。 CSS 代码繁琐，对于特定的设备有较多冗余，适用于对于各个终端（特别是移动端）性能要求不高的 Blog Dos 站点。 响应式页面在头部会加上这一段代码： 12&lt;meta name=\"applicable-device\" content=\"pc,mobile\" /&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-transform \" /&gt; 例子elevenbeans.github.io/ 响应式设计（RWD）响应式设计基于响应式布局，使用同一套页面在各种各样不同大小的设备上进行大小合适、布局（甚至功能）合理的展现。 响应式设计会根据识别屏幕宽度对于展示的具体内容块进行位置调整，甚至展示和隐藏。 实现方式： 响应式布局 特性检测 （用于网页功能的渐进增强） 举个栗子：elevenbeans.github.io/， RWD 和 AWD 的异同相同点： 均针对不同的分辨率/device 采用不同的样式和布局达到页面展示最优 布局方式本质没有差别（AWD 也 including responsive layout） 不同点： 前者强调同一套页面多端兼容展示，而后者给出多套页面，对于不同 device 进行了分类处理 前者是通过 CSS Media query 进行分辨率检测，可以实时的响应浏览器尺寸变化，改变元素尺寸/布局，而后者一般是 server side detection，一次性渲染既定布局和样式 媒体查询用法 开始在 html 中写入 Media 在 html 头部添加以下代码，用来显示兼容移动设备的显示效果 1234&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"/&gt; 参数详解： width=device-width ：宽度等于当前设备的宽度 initial-scale=1 ：初始的缩放比例。（默认为 1） minimum-scale=1 ：允许用户缩放到的最小比例。（默认为 1） maximum-scale=1 ：允许用户缩放到的最大比例。（默认为 1） user-scalable=no ：用户是否可以手动缩放（默认为 no） 引入包含 Media 的 css 文件我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。(IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。) 123456789101112131415161718body &#123; background-color: grey;&#125;@media screen and (min-width: 1200px) &#123; body &#123; background-color: pink; &#125;&#125;@media screen and (min-width: 700px) and (max-width: 1200px) &#123; body &#123; background-color: blue; &#125;&#125;@media screen and (max-width: 700px) &#123; body &#123; background-color: orange; &#125;&#125; 媒体类型 值 描述 all 用于所有设备 aural 已废弃。用于语音和声音合成器 braille 已废弃。 应用于盲文触摸式反馈设备 embossed 已废弃。 用于打印的盲人印刷设备 handheld 已废弃。 用于掌上设备或更小的装置，如 PDA 和小型电话 print 用于打印机和打印预览 projection 已废弃。 用于投影设备 screen 用于电脑屏幕，平板电脑，智能手机等。 speech 应用于屏幕阅读器等发声设备 tty 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 tv 已废弃。 用于电视和网络电视 逻辑操作符 and操作符用来把多个媒体属性组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。 not操作符用来对一条媒体查询的结果进行取反。 only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。 也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于or操作符。 若使用了not或only操作符，必须明确指定一个媒体类型。 媒体功能 值 描述 值 媒体 是否接受 min/max 前缀 aspect-ratio 定义输出设备中的页面可见区域宽度与高度的比率 visual/tactile 是 color 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于 0 visual 是 color-index 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于 0 visual 是 device-aspect-ratio 定义输出设备的屏幕可见宽度与高度的比率。 visual/tactile 是 device-height 定义输出设备的屏幕可见高度。 visual/tactile 是 device-width 定义输出设备的屏幕可见宽度。 visual/tactile 是 grid 用来查询输出设备是否使用栅格或点阵。 all 否 height 定义输出设备中的页面可见区域高度。 visual/tactile 是 monochrome 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于 0 visual 是 orientation 定义输出设备中的页面可见区域高度是否大于或等于宽度。 landscape` `portrait visual resolution 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm bitmap 是 scan 定义电视类设备的扫描工序。 progressive` `interlace tv width 定义输出设备中的页面可见区域宽度。 visual/tactile 是 5.弹性布局（flex）Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间（他会根据页面的剩余宽度自动分配空间）。 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性基本语法： 123.box &#123; display: flex; /* 或者 inline-flex */&#125; 上述写法，定义了一个 flex 容器，根据设值的不同可以是块状容器或内联容器。这使得直接子结点拥有了一个 flex 上下文。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3.flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 4.justify-content定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 6.align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性 order flex-grow flex-shrink flex-basis flex align-self 1.order定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 123.item &#123; order: &lt;integer&gt;;&#125; 2.flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 3.flex-shrink定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 负值对该属性无效。 4.flex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如 350px），则项目将占据固定空间。 5.flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 6.align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 兼容性 Chrome Safari Firefox Opera IE Android iOS 21+ 6.1+ 22+ 12.1+ 11+ 4.4+ 7.1+ Flexbox 需要一些特定的前缀以支持大多数的浏览器。甚至还存在完全不同的属性名称或属性值。这就需要Autoprefixer或类似的 CSS 后处理器的辅助，具体内容请参考相关文档。 6.REM 布局rem/em 区别rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的 em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border。 rem 作用于非根元素时，相对于根元素字体大小；rem 作用于根元素字体大小时，相对于其出初始字体大小（16px）。 rem 有一点优势就是可以和媒体查询配合，实现响应式布局： 使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为 em 是相对父级元素的原因没有得到推广。【中国站点制作网页的时候，习惯用 CSS 强制定义字体大小，保证每个人都看到一致的效果，包括网易、搜狐这些门户网站在内的大部分站点，用的都是绝对单位 px（像素）。但是，如果从网站易用性方面考虑，字体大小应该是可变的，一些视力不是那么好的人需要放大字体才能看得清页面内容。然而，占据大部分浏览器市场的 IE 无法调整那些使用 px 作为单位的字体大小。国外人士非常重视网站的易用性，相当一部分外国站点已经使用 em 作为字体单位。 布局特点包裹文字的各元素的尺寸采用 em/rem 做单位，而页面的主要划分区域的尺寸仍使用百分数或 px 做单位（同「流式布局」或「静态/固定布局」）。早期浏览器不支持整个页面按比例缩放，仅支持网页内文字尺寸的放大，这种情况下。使用 em/rem 做单位，可以使包裹文字的元素随着文字的缩放而缩放。 浏览器的默认字体高度一般为16px，即 1em:16px，但是 1:16 的比例不方便计算，为了使单位 em/rem 更直观，CSS 编写者常常将页面跟节点字体设为 62.5%，比如选择用 rem 控制字体时，先需要设置根节点 html 的字体大小，因为浏览器默认字体大小 16px*62.5%=10px。这样 1rem 便是 10px，方便了计算。 设计思想 一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值 高度值可以设置固定值,设计稿有多大,我们就严格写多大 所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值) JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了 优点更能适应缩进/以字体单位 padding 或 margin／浏览器设置字体尺寸等情况（因为 em/rem 相对于字体大小，会同步改变）。例如：p{ text-indent: 2em; }。 123p &#123; text-indent: 2em;&#125; rem 单位对于（根据屏幕尺寸）调整页面的各元素的尺寸、文字大小时比较好用 Rem 布局的 js 实现1234// px转rem，方便模拟小程序 rpxpx2rem($px) &#123; $px / 750 * 10 * 1rem;&#125; 123456789101112131415161718192021222324252627282930313233343536if remlayout script. (function flexible (window, document) &#123; var docEl = document.documentElement var dpr = window.devicePixelRatio || 1 function setBodyFontSize () &#123; if (document.body) &#123; document.body.style.fontSize = (12 * dpr) + 'px' &#125; else &#123; document.addEventListener('DOMContentLoaded', setBodyFontSize) &#125; &#125; setBodyFontSize() function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + 'px' &#125; setRemUnit() window.addEventListener('resize', setRemUnit) window.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; setRemUnit() &#125; &#125;) if (dpr &gt;= 2) &#123; var fakeBody = document.createElement('body') var testElement = document.createElement('div') testElement.style.border = '.5px solid transparent' fakeBody.appendChild(testElement) docEl.appendChild(fakeBody) if (testElement.offsetHeight === 1) &#123; docEl.classList.add('hairlines') &#125; docEl.removeChild(fakeBody) &#125; &#125;(window, document)) 对比三种方式（响应式&amp;&amp;REM&amp;&amp;viewport）响应式的优缺点优点：兼容性好，@media 在 ie9 以上是支持的，PC 和 MOBILE 是同一套代码的，不用分开。 缺点：要写得 css 相对另外两个多很多，而且各个断点都要做好。css 样式会稍微大点，更麻烦。 REM 优缺点优点：能维持能整体的布局效果，移动端兼容性好，不用写多个 css 代码，而且还可以利用@media 进行优化。 缺点：开头要引入一段 js 代码，单位都要改成 rem(font-size 可以用 px)，计算 rem 比较麻烦(可以引用预处理器，但是增加了编译过程，相对麻烦了点)。pc 和 mobile 要分开。 设置 viewport 中的 width1&lt;meta name=\"viewport\" content=\"width=750\" /&gt; 优点：和 REM 相同，而且不用写 rem，直接使用 px，更加快捷。 缺点：效果可能没 rem 的好，图片可能会相对模糊，而且无法使用@media 进行断点，不同 size 的手机上显示，高度间距可能会相差很大。 7.Grid 布局（BOOTSTRAP 布局）网格布局（Grid）是最强大的 CSS 布局方案。 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。容器里面的水平区域称为”行”（row），垂直区域为”列”（column）。行和列的交叉区域，称为”单元格”（cell）。划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 容器的属性1.displaydisplay: grid指定一个容器采用网格布局。 默认情况下，容器元素都是块级元素，但也可以设成行内元素。display: inline-grid; 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 2.grid-template-columns 属性， grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 除了使用绝对单位，也可以使用百分比 repeat()：接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。重复某种模式也是可以的。 1grid-template-columns: repeat(2, 100px 20px 80px); auto-fill 关键字：有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; fr 关键字：为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。（fr可以与绝对长度的单位结合使用） minmax()：minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 auto 关键字：表示由浏览器自己决定长度 网格线的名称：grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。（网格布局允许同一根线有多个名字，比如[fifth-line row-5]。） 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 3.grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性 grid-row-gap属性设置行与行的间隔（行间距） grid-column-gap属性设置列与列的间隔（列间距）。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式：grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;(如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。) 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 4.grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。 1234grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 5.grid-auto-flow 属性划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。 也可以将它设成column，变成”先列后行”。 设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。 column dense，表示”先列后行”，并且尽量填满空格。 6.justify-items 属性， align-items 属性， place-items 属性 justify-items属性设置单元格内容的水平位置（左中右） align-items属性设置单元格内容的垂直位置（上中下）。 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-items属性是align-items属性和justify-items属性的合并简写形式。（如果省略第二个值，则浏览器认为与第一个值相等。） 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 7.justify-content 属性， align-content 属性， place-content 属性 justify-content属性是整个内容区域在容器里面的水平位置（左中右） align-content属性是整个内容区域的垂直位置（上中下）。 这两个属性的写法完全相同，都可以取下面这些值。 只是将水平方向改成垂直方向。） start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。（如果省略第二个值，浏览器就会假定第二个值等于第一个值。） 1place-content: &lt;align-content&gt; &lt;justify-content&gt;; 8.grid-auto-columns 属性， grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。 123456.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px;&#125; 上面代码指定新增的行高统一为 50px（原始的行高为 100px）。 9.grid-template 属性， grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 项目属性1.grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 2.grid-column 属性， grid-row 属性 grid-column属性是grid-column-start和grid-column-end的合并简写形式 grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。斜杠以及后面的部分可以省略，默认跨越一个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 3.grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 4.justify-self 属性， align-self 属性， place-self 属性 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 兼容性 对比 Bootstrap 标签会更加简洁：相比Bootstrap，使用 grid 会使你的 HTML 更加干净。Bootstrap需要创建的标签，每个 row 都需要一个&lt;div&gt;标签，使用了 class name 来指定布局(col-xs-2)。grid 用来布局看起来更简单，丑陋的类名和每行所需的额外的 div 标签一去不复返了，简简单单一个 container 和里面的 item。与Bootstrap不同的是，随着布局复杂度的增加，Grid 布局标签的复杂度将不会增加太多。 更灵活：用CSS Grid的话会非常简单，我们只需要添加一个media query就可以重新排列布局。而如果想在Bootstrap中做同样的事情，就必须得修改 HTML 了，需要调整标签的顺序。 不再限死 12 列：Bootstrap的 grid 系统分为了 12 列，如果你想要一个 5 列的布局就会纠结，或是 7 列、9 列、任何不会合为 12 列的。CSS Grid就没有任何限制，你可以让 grid 正好有你想要的数量。 浏览器支持：全球 75%的网站流量支持CSS Grid 结论： 如果只做 pc 端，那么静态布局（定宽度）是最好的选择； 如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份 css+一份 js 调节 font-size 搞定； 如果 pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"}]},{"title":"CSS3新特性","slug":"CSS3新特性","date":"2019-04-28T04:37:08.000Z","updated":"2019-09-21T13:56:29.728Z","comments":true,"path":"2019/04/28/CSS3新特性/","link":"","permalink":"http://yoursite.com/2019/04/28/CSS3新特性/","excerpt":"CSS3 新特性1. 选择器CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。 element1~element2: 选择前面有 element1 元素的每个 element2 元素。 [attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。 [attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。 [attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。 E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。 E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。 E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。 E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。 E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。 E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。 E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。 E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。 E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。 :root: 选择文档的根元素。 E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。 E:target: 选择当前活动的 E 元素。 E:enabled: 选择每个启用的 E 元素。 E:disabled: 选择每个禁用的 E 元素。 E:checked: 选择每个被选中的 E 元素。 E:not(selector): 选择非 selector 元素的每个元素。 E::selection: 选择被用户选取的元素部分。","text":"CSS3 新特性1. 选择器CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。 element1~element2: 选择前面有 element1 元素的每个 element2 元素。 [attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。 [attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。 [attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。 E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。 E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。 E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。 E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。 E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。 E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。 E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。 E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。 E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。 :root: 选择文档的根元素。 E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。 E:target: 选择当前活动的 E 元素。 E:enabled: 选择每个启用的 E 元素。 E:disabled: 选择每个禁用的 E 元素。 E:checked: 选择每个被选中的 E 元素。 E:not(selector): 选择非 selector 元素的每个元素。 E::selection: 选择被用户选取的元素部分。 2. Transition,Transform 和 Animation这三个特性是 CSS3 新增的和动画相关的特性。 Transition Transition 可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用 Flash 动画或 JavaScript。Transition 有如下属性： transition-property: 规定应用过渡的 CSS 属性的名称。 transition-duration: 规定完成过渡效果需要多长时间。 transition-delay: 规定过渡效果何时开始，默认是 0。 transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有 linear、ease-in、ease-out、ease-in-out 和 cubic-bezier 等过渡类型。 transition: 简写属性，用于在一个属性中设置四个过渡属性。 Transform Transform 用来向元素应用各种 2D 和 3D 转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。 变换类型： none: 定义不进行转换。 matrix(n,n,n,n,n,n): 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y): 定义 2D 位移转换。 translate3d(x,y,z): 定义 3D 位移转换。 translateX(x): 定义位移转换，只是用 X 轴的值。 translateY(y): 定义位移转换，只是用 Y 轴的值。 translateZ(z): 定义 3D 位移转换，只是用 Z 轴的值。 scale(x,y): 定义 2D 缩放转换。 scale3d(x,y,z): 定义 3D 缩放转换。 scaleX(x): 通过设置 X 轴的值来定义缩放转换。 scaleY(y): 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z): 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle): 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle): 定义 3D 旋转。 rotateX(angle): 定义沿着 X 轴的 3D 旋转。 rotateY(angle): 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle): 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle): 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle): 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle): 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n): 为 3D 转换元素定义透视视图。 Animation Animation 让 CSS 拥有了可以制作动画的功能。使用 CSS3 的 Animation 制作动画我们可以省去复杂的 js 代码。 3. 边框CSS3 新增了三个边框属性，分别是 border-radius、box-shadow 和 border-image。 border-radius 可以创建圆角边框 box-shadow 可以为元素添加阴影 border-image 可以使用图片来绘制边框。 4. 背景CSS3 新增了几个关于背景的属性，分别是 background-clip、background-origin、background-size 和 background-break。 background-clip background-clip 属性用于确定背景画区，有以下几种可能的属性： background-clip: border-box; 背景从 border 开始显示 background-clip: padding-box; 背景从 padding 开始显示 background-clip: content-box; 背景显 content 区域开始显示 background-clip: no-clip; 默认属性，等同于 border-box 通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。 background-origin background-clip 属性用于确定背景的位置，它通常与 background-position 联合使用，可以从 border、padding、content 来计算 background-position（就像 background-clip）。 background-origin: border-box; 从 border 开始计算 background-position background-origin: padding-box; 从 padding 开始计算 background-position background-origin: content-box; 从 content 开始计算 background-position background-size background-size 属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性： background-size: contain; 缩小图片以适合元素（维持像素长宽比） background-size: cover; 扩展元素以填补元素（维持像素长宽比） background-size: 100px 100px; 缩小图片至指定的大小 background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 background-break CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样） background-break: bounding-box; 把盒之间的距离计算在内； background-break: each-box; 为每个盒子单独重绘背景。 5. 文字效果 word-wrap CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行，即这意味着会对单词进行拆分。所有主流浏览器都支持 word-wrap 属性。 text-overflow 它与 word-wrap 是协同工作的，word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。 text-shadow CSS3 中，text-shadow 可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 text-decoration CSS3 里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置： text-fill-color: 设置文字内部填充颜色 text-stroke-color: 设置文字边界填充颜色 text-stroke-width: 设置文字边界宽度 6. 渐变CSS3 新增了渐变效果，包括 linear-gradient(线性渐变)和 radial-gradient(径向渐变)。 7. @font-face 特性通过 CSS3，web 设计师可以使用他们喜欢的任意字体。当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。字体是在 CSS3 @font-face 规则中定义的。Firefox、Chrome、Safari 以及 Opera 支持 .ttf(True Type Fonts)和 .otf(OpenType Fonts)类型的字体。IE9+ 支持新的@font-face 规则，但是仅支持 .eot 类型的字体(Embedded OpenType)。 在新的@font-face 规则中，必须首先定义字体的名称（比如 myFont），然后指向该字体文件。如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFont) 8. 多列布局通过 CSS3，能够创建多个列来对文本进行布局，IE10 和 Opera 支持多列属性。Firefox 需要前缀-moz-，Chrome 和 Safari 需要前缀-webkit-。主要有如下三个属性： column-count: 规定元素应该被分隔的列数。 column-gap: 规定列之间的间隔。 column-rule: 设置列之间的宽度、样式和颜色规则 9. 用户界面CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。Firefox、Chrome 以及 Safari 支持 resize 属性。IE、Chrome、Safari 以及 Opera 支持 box-sizing 属性。Firefox 需要前缀-moz-。所有主流浏览器都支持 outline-offset 属性，除了 IE。 resize resize 属性规定是否可由用户调整元素尺寸。如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll。 box-sizing box-sizing 属性可设置的值有 content-box、border-box 和 inherit。 content-box: padding 和 border 不被包含在定义的 width 和 height 之内。对象的实际宽度等于设置的 width 值和 border、padding 之和，即 (Element width = width + border + padding)，此属性表现为标准模式下的盒模型。 border-box: padding 和 border 被包含在定义的 width 和 height 之内。对象的实际宽度就等于设置的 width 值，即使定义有 border 和 padding 也不会改变对象的实际宽度，即 (Element width = width)，此属性表现为怪异模式下的盒模型。 outline-offset outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"BFC","slug":"BFC","date":"2019-04-10T00:11:20.000Z","updated":"2019-11-16T11:49:13.403Z","comments":true,"path":"2019/04/10/BFC/","link":"","permalink":"http://yoursite.com/2019/04/10/BFC/","excerpt":"BFCBFC 的定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。通俗地讲，BFC 是一个容器，用于管理块级元素。","text":"BFCBFC 的定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。通俗地讲，BFC 是一个容器，用于管理块级元素。 触发 BFC 的方式（以下任意一条就可以） 根元素，即 HTML 元素 float 的值不为 none（为 left或right） overflow 的值不为 visible（为hidden或auto或scroll） display 的值为table-cell、table-caption、inline-flex、flex和inline-block之一 position 的值不为 static 或者 releative 中任何一个(为absolute或fixed) BFC 的布局规则 内部的 Box 会在垂直方向，一个接一个地放置。 Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠（margin 重叠三个条件:同属于一个 BFC;相邻;块级元素），两个相邻的 BFC 上下 margin 不会重叠 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC 的区域不会与 float box 重叠。非浮动元素不会覆盖浮动元素的位置。 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。（触发 BFC，回流的局部渲染） 计算 BFC 的高度时，浮动元素也参与计算（清除浮动 haslayout） margin 不会传递给父级（父级触发了 BFC） 对比普通文档流的布局规则 浮动的元素是不会被父级计算高度 非浮动元素会覆盖浮动元素的位置 margin 会传递给父级 两个相邻的元素上下 margin 会重叠 BFC 有哪些作用： 自适应两栏布局（规则 4） 可以阻止元素被浮动元素覆盖（规则 4） 可以包含浮动元素——清除内部浮动（规则 6） 分属于不同的 BFC 时可以阻止 margin 重叠（规则 2）","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"},{"name":"布局","slug":"布局","permalink":"http://yoursite.com/tags/布局/"}]},{"title":"字符编码：Unicode与JavaScript","slug":"字符编码：Unicode与Javascript","date":"2019-04-06T11:08:55.000Z","updated":"2019-11-10T14:37:39.035Z","comments":true,"path":"2019/04/06/字符编码：Unicode与Javascript/","link":"","permalink":"http://yoursite.com/2019/04/06/字符编码：Unicode与Javascript/","excerpt":"字符编码：Unicode 与 Javascript1.ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从00000000到11111111。 上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了 128 个字符的编码，比如空格SPACE是 32（二进制00100000），大写的字母A是 65（二进制01000001）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为0。","text":"字符编码：Unicode 与 Javascript1.ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从00000000到11111111。 上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了 128 个字符的编码，比如空格SPACE是 32（二进制00100000），大写的字母A是 65（二进制01000001）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为0。 2.非 ASCII 编码英语用 128 个符号编码就够了，但是用来表示其他语言，128 个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为 130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多 256 个符号。 这里就又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用 256 个符号的编码方式，代表的字母却不一样。比如，130 在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127 表示的符号是一样的，不一样的只是 128–255 的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达 10 万左右。一个字节只能表示 256 种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，此处不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是 GB 类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 3.UnicodeUnicode 源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。 Unicode 当然是一个很大的集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 码点它从 0 开始，为每个符号指定一个编号，这叫做”码点”（code point）。比如，码点 0 的符号就是 null（表示所有二进制位都是 0）。 1U+0000 = null 上式中，U+表示紧跟在后面的十六进制数是 Unicode 的码点。 目前，Unicode 的最新版本是 7.0 版，一共收入了 109449 个符号，其中的中日韩文字为 74500 个。可以近似认为，全世界现有的符号当中，三分之二以上来自东亚文字。比如，中文”好”的码点是十六进制的 597D。 分区（基本平面&amp;&amp;辅助平面）这么多符号，Unicode 不是一次性定义的，而是分区定义。每个区可以存放 65536 个（216）字符，称为一个平面（plane）。目前，一共有 17 个（25）平面，也就是说，整个 Unicode 字符集的大小现在是 221。 最前面的 65536 个字符位，称为基本平面（缩写 BMP），它的码点范围是从 0 一直到 216-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。 剩下的字符都放在辅助平面（缩写 SMP），码点范围从 U+010000 一直到 U+10FFFF。 问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有 15 位（100111000100101），也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。 如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？ 我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 4.UTF-32 与 UTF-8UTF-32最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做 UTF-32。比如，码点 0 就用四个字节的 0 表示，码点 597D 就在前面加两个字节的 0。 123U+0000 = 0x0000 0000U+597D = 0x0000 597D UTF-32 的优点转换规则简单直观，查找效率高。 缺点浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。 UTF-8UTF-8 是一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。 由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 编码规则： 1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）----------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 5.UTF-16UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。 它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。 于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？ 在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 具体来说，辅助平面的字符位共有 220 个，也就是说，对应这些字符至少需要 20 个二进制位。UTF-16 将这 20 位拆成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 210），称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 编码规则 所以，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 Unicode 码点与 UTF-16 转码 首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。 1U+597D = 0x597D 如果是辅助平面字符，Unicode 3.0 版给出了转码公式。 123H = Math.floor((c - 0x10000) / 0x400) + 0xd800;L = ((c - 0x10000) % 0x400) + 0xdc00; 6.JavaScript 用的是 UCS-2JavaScript 语言采用 Unicode 字符集，但是只支持一种编码方法。UCS-2！ 互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的 Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集 1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。 两者的关系简单说，就是 UTF-16 取代了 UCS-2，或者说 UCS-2 整合进了 UTF-16。 在 JavaScript 语言出现的时候，还没有 UTF-16 编码。 由于 JavaScript 只能处理 UCS-2 编码，造成所有字符在这门语言中都是 2 个字节，如果是 4 个字节的字符，会当作两个双字节的字符处理。JavaScript 的字符函数都受到这一点的影响，无法返回正确结果。 以字符为例，它的 UTF-16 编码是 4 个字节的 0xD834 DF06。问题就来了，4 个字节的编码不属于 UCS-2，JavaScript 不认识，只会把它看作单独的两个字符 U+D834 和 U+DF06。前面说过，这两个码点是空的，所以 JavaScript 会认为是两个空字符组成的字符串！ 上面代码表示，JavaScript 认为字符的长度是 2，取到的第一个字符是空字符，取到的第一个字符的码点是 0xDB34。这些结果都不正确！ 解决这个问题，必须对码点做一个判断，然后手动调整。下面是正确的遍历字符串的写法。 12345678while (++index &lt; length) &#123; // ... if (charCode &gt;= 0xd800 &amp;&amp; charCode &lt;= 0xdbff) &#123; output.push(character + string.charAt(++index)); &#125; else &#123; output.push(character); &#125;&#125; 上面代码表示，遍历字符串的时候，必须对码点做一个判断，只要落在 0xD800 到 0xDBFF 的区间，就要连同后面 2 个字节一起读取。 类似的问题存在于所有的 JavaScript 字符操作函数。 String.prototype.replace() String.prototype.substring() String.prototype.slice() … 上面的函数都只对 2 字节的码点有效。要正确处理 4 字节的码点，就必须逐一部署自己的版本，判断一下当前字符的码点范围。 7.ES6ECMAScript 6（简称 ES6），大幅增强了 Unicode 支持，基本上解决了这个问题。 （1）正确识别字符 ES6 可以自动识别 4 字节的码点。因此，遍历字符串就简单多了。 123for (let s of string) &#123; // ...&#125; 但是，为了保持兼容，length 属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。 1Array.from(string).length; （2）码点表示法 JavaScript 允许直接用码点表示 Unicode 字符，写法是”反斜杠+u+码点”。 1\"好\" === \"\\u597D\"; // true 但是，这种表示法对 4 字节的码点无效。ES6 修正了这个问题，只要将码点放在大括号内，就能正确识别。 （3）字符串处理函数 ES6 新增了几个专门处理 4 字节码点的函数。 String.fromCodePoint()：从 Unicode 码点返回对应字符 String.prototype.codePointAt()：从字符返回对应的码点 String.prototype.at()：返回字符串给定位置的字符 （4）正则表达式 ES6 提供了 u 修饰符，对正则表达式添加 4 字节码点的支持。 （5）Unicode 正规化 有些字符除了字母以外，还有附加符号。比如，汉语拼音的 Ǒ，字母上面的声调就是附加符号。对于许多欧洲语言来说，声调符号是非常重要的。 Unicode 提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如 Ǒ 的码点是 U+01D1；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如 Ǒ 可以写成 O（U+004F） + ˇ（U+030C）。 1234567// 方法一\"\\u01D1\";// 'Ǒ'// 方法二\"\\u004F\\u030C\";// 'Ǒ' 这两种表示方法，视觉和语义都完全一样，理应作为等同情况处理。但是，JavaScript 无法辨别。 12\"\\u01D1\" === \"\\u004F\\u030C\";//false ES6 提供了 normalize 方法，允许“Unicode 正规化”，即将两种方法转为同样的序列。 12\"\\u01D1\".normalize() === \"\\u004F\\u030C\".normalize();// true 8.总结截取含有四字节字符的字符串不会出现乱码的方法12let nickname = \"非拉🍒非拉\";nickname.length; // 6 Array.from 方法Array.from这个方法能够将类数组转换为真实的数组，比如NodeList, argument等，同样，也包括字符串。 12Array.from(nickname); // [\"非\", \"拉\", \"🍒\", \"非\", \"拉\"]nickname.split(\"\"); // [\"非\", \"拉\", \"�\", \"�\", \"非\", \"拉\"] 使用 Array.from 把 nickname 转换后，可以看到转换成一个真实的数组了，樱桃字符占了数组中的一个位置，然后按照数组中的方法截取再进行拼接即可，而使用 split 方法拆分，则还是乱码： 123456function truncated(str, num) &#123; return Array.from(str) .slice(0, num) .join(\"\");&#125;truncated(nickname, 3); // 非拉🍒 codePointAt()方法在 ES6 之前， JS 的字符串以 16 位字符编码(UTF-16)为基础。每个 16 位序列(相当于 2 个字节)是一个编码单元(code unit)，可简称为码元，用于表示一个字符。字符串所有的属性与方法(如 length 属性与 charAt() 方法等)都是基于 16 位序列。 比如 length 方法、nickname[2]、split 方法等操作，都会产生异常。为此在 ES6 中，加强了对 Unicode 的支持，并且扩展了字符串对象。 对于 Unicode 码点大于 0xFFFF 的字符，是使用 4 个字节进行存储。ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 12345// 获取樱桃的码点\"🍒\".codePointAt(0).toString(16); // 1f352// 输出码点对应的字符(\"\\u&#123;1f352&#125;\"); // 🍒 请注意： 在之前 Unicode 编码，均在[\\u000-\\uFFFF]之间，因此可以使用类似\\u0047这样的编码；但是现在码点超过\\uFFFF的界限，若再这样使用，则获取不到对应的字符。因此在 ES6 中，码点的字符放在中括号内，类似上面的格式（所有的码点均可以使用这种格式）： 123\"\\u&#123;1f352&#125;\"; // 🍒\"\\u&#123;47&#125;\"; // G\"\\u&#123;0047&#125;\"; // G 那么就容易了：判断需要截取的位置是否正好是 4 字节的字符，如果是则延长一位截取，否则正常截取： 12345function truncated(str, num) &#123; let index = Array.from(str)[num - 1].codePointAt(0) &gt; 0xffff ? num + 1 : num; return str.slice(0, index);&#125;truncated(nickname, 3); // 非拉🍒 for-offor-in方法是遍历 key 值，for-of是遍历 value 值： 123456789101112let arr = [\"a\", \"b\", \"c\"];for (let k in arr) &#123; console.log(k); // 0 1 2&#125;for (let v of arr) &#123; console.log(v); // a b c&#125;for (let v of nickname) &#123; console.log(v); // 非 拉 🍒 非 拉&#125; 因此利用这个功能，我们也能进行截取： 123456789101112function truncated(str, num) &#123; let s = \"\"; for (let v of nickname) &#123; s += v; num--; if (num &lt;= 0) &#123; break; &#125; &#125; return s;&#125;truncated(nickname, 3); 正确输出字符串的字符个数：1234567891011function getLen(str) &#123; var len = str.length; for (var i = 0; i &lt; len; i++) &#123; var charCode = str.charCodeAt(i); if (charCode &gt;= 0xd800 &amp;&amp; charCode &lt;= 0xdbff) &#123; len--; i++; &#125; &#125; return len;&#125; 1Array.from(str).length; 9.string.lengthstring.length 返回的是什么 字符的个数还是字节数？为什么会与实际长度不一样？编码的部分详细说string.length():返回字符串的长度（以字节为单位）。是符合字符串内容的实际字节数，不一定等于其容量。 string.size()和 string.length()是同义词，并返回完全相同的值。 string.max_size()：返回字符串的最大大小，返回字符串可以达到的最大长度。 string.resize():string.resize(n)：把字符串的长度设置为 n 个字符如果 n 小于当前字符串长度 ，则只截取前 n 个字符，删除超出第 n 个字符的字符。如果大于，则在末端插入尽可能多的字符来扩展当前内容，以达到大小 n。 如果指定 c，则新元素将初始化为 c 的副本，否则为值初始化字符（空字符）。 string.capacity()：返回已分配存储的大小。当前为字符串分配的存储空间的大小，以字节表示。 此容量不一定等于字符串长度。 它可以相等或更大，额外的空间允许对象在将新字符添加到字符串时优化其操作。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"常用的正则","slug":"常用的正则","date":"2019-03-29T14:07:27.000Z","updated":"2019-11-10T14:37:39.036Z","comments":true,"path":"2019/03/29/常用的正则/","link":"","permalink":"http://yoursite.com/2019/03/29/常用的正则/","excerpt":"正则1.校验数字123456789101112131415161718数字：^\\d*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9]\\d*)+(\\.\\d&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+\\.\\d&#123;1,2&#125;$正数、负数、和小数：^(\\-)?\\d+(\\.\\d+)?$有两位小数的正实数：^\\d+\\.\\d&#123;2&#125;$有1~3位小数的正实数：^\\d+\\.\\d&#123;1,3&#125;$非零的正整数：^[1-9]\\d*$非零的负整数：^-[1-9]\\d*$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$","text":"正则1.校验数字123456789101112131415161718数字：^\\d*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9]\\d*)+(\\.\\d&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+\\.\\d&#123;1,2&#125;$正数、负数、和小数：^(\\-)?\\d+(\\.\\d+)?$有两位小数的正实数：^\\d+\\.\\d&#123;2&#125;$有1~3位小数的正实数：^\\d+\\.\\d&#123;1,3&#125;$非零的正整数：^[1-9]\\d*$非零的负整数：^-[1-9]\\d*$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 2.校验字符的表达式123456789101112汉字：^[\\u4e00-\\u9fa5]+$英文和数字：^[A-Za-z0-9]+$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+禁止输入含有~的字符：[^~\\x22]+ 3.特殊需求表达式1234567891011121314Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$国内手机号码：^1[34578]&#123;1&#125;\\d&#123;9&#125;帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z]\\w&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)IP地址：^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5]))&#123;3&#125;$xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"移动端的触屏事件","slug":"移动端的触屏事件","date":"2019-03-22T08:28:36.000Z","updated":"2019-11-10T14:37:39.040Z","comments":true,"path":"2019/03/22/移动端的触屏事件/","link":"","permalink":"http://yoursite.com/2019/03/22/移动端的触屏事件/","excerpt":"移动端的触屏事件1.原生触摸事件（touch 类事件）在移动端，原生触摸事件只有以下三种类型，其他所有的触摸事件都是由这三种事件相结合产生的，例如，上划、下滑、左滑、右滑、双击等等；","text":"移动端的触屏事件1.原生触摸事件（touch 类事件）在移动端，原生触摸事件只有以下三种类型，其他所有的触摸事件都是由这三种事件相结合产生的，例如，上划、下滑、左滑、右滑、双击等等； 这三种原生触摸事件为： touchstart：开始触摸 touchmove：触摸过程中 touchend：触摸结束 另外，还有一个触摸被系统取消的事件：touchcancel（由更高级的事件打断当前正在执行的移动端事件时，会触发该事件，我们可以在这个事件中保存当前相关的触碰事件操作的数据，以保证用户回到页面后接着刚才断开的位置继续操作）； 触摸事件下的一些相关属性 targetTouches：可获取到事件对象下的触摸点，该属性是一个类数组的结构，同时触发这个事件的手指有几个，则数组中就有几个元素。触摸点的相关坐标数据就存在这些对象中。 pageX\\pageY:坐标系原点在页面的左上角； screenX\\screenY:坐标系的原点在屏幕的左上角点（不包含操作系统在左上角的组件）； clientX\\clientY:触摸目标在视口中的坐标，原点在视口左上角(适口视用来展示 html 代码的容器)； targer:保存的是触发事件的标签，使用事件委托时可以通过该属性获取到触发该事件的标签对象； identifier:ID 值，唯一标示了手指触摸点，如果手指在屏幕上产生移动（如果有多个触摸点，则可以根据这个 id 值跟踪对应的触摸点）； event 对象：由于手机端的手指触发不是单个的，所以在 event 里面生成的与触摸有关的数据都是以数组的形式列出来的，有以下三个： touches：表示当前跟踪的触摸操作的 touch 对象的数组。当前屏幕上所有触摸点的集合列表 targetTouches：特定于事件目标的 Touch 对象的数组。绑定事件的那个结点上的触摸点的集合列表 changedTouches：表示自上次触摸以来发生了什么改变的 Touch 对象的数组。触发事件时改变的触摸点的集合 2.触碰事件（tap 类事件）触碰事件，我目前还不知道它和 touch 的区别，一般用于代替 click 事件 tap: 手指碰一下屏幕会触发 longTap: 手指长按屏幕会触发 singleTap: 手指碰一下屏幕会触发 doubleTap: 手指双击屏幕会触发 3.滑动事件（swipe 类事件）滑动事件 swipe：手指在屏幕上滑动时会触发 swipeLeft：手指在屏幕上向左滑动时会触发 swipeRight：手指在屏幕上向右滑动时会触发 swipeUp：手指在屏幕上向上滑动时会触发 swipeDown：手指在屏幕上向下滑动时会触发 4.自定义手势事件 gesture手势事件只是概念型，目前还没有浏览器原生支持，按照概念可分为 gesturestart gesturechange gestureend 三种事件 gesturestart：当有两根或多根手指放到屏幕上的时候触发 gesturechange：当有两根或多根手指在屏幕上，并且有手指移动的时候触发 gestureend：当倒数第二根手指提起的时候触发，结束 gesture 按照定义，当分别将两根手指放到屏幕上的时候，会有如下顺序的事件触发： 1、第一根手指放下，触发 touchstart 2、第二根手指放下，触发 gesturestart 3、触发第二根手指的 touchstart 4、立即触发 gesturechange 5、手指移动，持续触发 gesturechange 6、第二根手指提起，触发 gestureend，以后将不会再触发 gesturechange 7、触发第二根手指的 touchend 8、触发 touchstart（多根手指在屏幕上，提起一根，会刷新一次全局 touch，重新触发第一根手指的 touchstart） 9、提起第一根手指，触发 touchend 5.Zepto.js 库可以更好的支持，基于 CSS3","categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/移动端/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"},{"name":"触屏","slug":"触屏","permalink":"http://yoursite.com/tags/触屏/"}]},{"title":"双向数据绑定Proxy和Object.defineProperty对比","slug":"双向数据绑定Proxy和Object.defineProperty对比","date":"2019-03-11T03:52:12.000Z","updated":"2019-11-10T14:37:39.033Z","comments":true,"path":"2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/","link":"","permalink":"http://yoursite.com/2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/","excerpt":"双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在： 无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &#39;渣渣辉&#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 zone.js 避免显示调用,不展开),react 需要显示调用setState。 可精确得知变化数据：还是上面的小例子，我们劫持了属性的 setter,当属性值改变,我们可以精确获知变化的内容newVal,因此在这部分不需要额外的 diff 操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量 diff 来找出变化值,这是额外性能损耗。","text":"双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在： 无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &#39;渣渣辉&#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 zone.js 避免显示调用,不展开),react 需要显示调用setState。 可精确得知变化数据：还是上面的小例子，我们劫持了属性的 setter,当属性值改变,我们可以精确获知变化的内容newVal,因此在这部分不需要额外的 diff 操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量 diff 来找出变化值,这是额外性能损耗。 基于数据劫持双向绑定的实现思路数据劫持是双向绑定各种方案中比较流行的一种,最著名的实现就是 Vue。 基于数据劫持的双向绑定离不开Proxy与Object.defineProperty等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。 利用Proxy或Object.defineProperty生成的 Observer 针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者 解析器 Compile 解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染 Watcher 属于 Observer 和 Compile 桥梁,它将接收到的 Observer 产生的数据变化,并根据 Compile 提供的指令进行视图渲染,使得数据变化促使视图变化 在 new Vue() 后， Vue 会调用_init 函数进行初始化，也就是 init 过程，在 这个过程 Data 通过 Observer 转换成了 getter/setter 的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行getter 函数，而在当被赋值的时候会执行 setter函数。 当 render function 执行的时候，因为会读取所需对象的值，所以会触发getter函数从而将 Watcher 添加到依赖中进行依赖收集。 在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图。 基于 Object.defineProperty 双向绑定的特点Vue 通过设定对象属性的 setter/getter 方法来监听数据的变化，通过 getter 进行依赖收集，而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 在 getter 中收集依赖，在 setter 中触发依赖。 当外界通过 Watcher 读取数据时，便会触发 getter 从而将 Watcher 添加到依赖中，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 极简版的双向绑定Object.defineProperty的作用就是劫持一个对象的属性,通常我们对属性的getter和setter方法进行劫持,在对象的属性发生变化时进行特定的操作。 我们就对对象obj的text属性进行劫持,在获取此属性的值时打印&#39;get val&#39;,在更改属性值的时候对 DOM 进行操作,这就是一个极简的双向绑定。 12345678910111213141516const obj = &#123;&#125;;Object.defineProperty(obj, \"text\", &#123; get: function() &#123; console.log(\"get val\"); &#125;, set: function(newVal) &#123; console.log(\"set val:\" + newVal); document.getElementById(\"input\").value = newVal; document.getElementById(\"span\").innerHTML = newVal; &#125;&#125;);const input = document.getElementById(\"input\");input.addEventListener(\"keyup\", function(e) &#123; obj.text = e.target.value;&#125;); 升级改造我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。 原因如下: 我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。 违反开放封闭原则,我们如果了解开放封闭原则的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。 代码耦合严重,我们的数据、方法和 DOM 都是耦合在一起的，就是传说中的面条代码。 那么如何解决上述问题？ Vue 的操作就是加入了发布订阅模式，结合Object.defineProperty的劫持能力，实现了可用性很高的双向绑定。 首先，我们以发布订阅的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。 我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。 123456789101112131415161718192021222324let uid = 0;// 用于储存订阅者并发布消息class Dep &#123; constructor() &#123; // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher this.id = uid++; // 储存订阅者的数组 this.subs = []; &#125; // 触发target上的Watcher中的addDep方法,参数为dep的实例本身 depend() &#123; Dep.target.addDep(this); &#125; // 添加订阅者 addSub(sub) &#123; this.subs.push(sub); &#125; notify() &#123; // 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理 this.subs.forEach(sub =&gt; sub.update()); &#125;&#125;// 为Dep类设置一个静态属性,默认为null,工作时指向当前的WatcherDep.target = null; 现在我们需要实现监听者(Observer),用于监听属性值的变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 监听者,监听对象属性值的变化class Observer &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; // 遍历属性值并监听 walk(value) &#123; Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); &#125; // 执行监听的具体方法 convert(key, val) &#123; defineReactive(this.value, key, val); &#125;&#125;function defineReactive(obj, key, val) &#123; const dep = new Dep(); // 给当前属性的值添加监听 let chlidOb = observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: () =&gt; &#123; // 如果Dep类存在target属性，将其添加到dep实例的subs数组中 // target指向一个Watcher实例，每个Watcher都是一个订阅者 // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法 if (Dep.target) &#123; dep.depend(); &#125; return val; &#125;, set: newVal =&gt; &#123; if (val === newVal) return; val = newVal; // 对新值进行监听 chlidOb = observe(newVal); // 通知所有订阅者，数值被改变了 dep.notify(); &#125; &#125;);&#125;function observe(value) &#123; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 if (!value || typeof value !== \"object\") &#123; return; &#125; return new Observer(value);&#125; 那么接下来就简单了,我们需要实现一个订阅者(Watcher)。 12345678910111213141516171819202122232425262728293031323334353637class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.depIds = &#123;&#125;; // hash储存订阅者的id,避免重复的订阅者 this.vm = vm; // 被订阅的数据一定来自于当前Vue实例 this.cb = cb; // 当数据更新时想要做的事情 this.expOrFn = expOrFn; // 被订阅的数据 this.val = this.get(); // 维护更新之前的数据 &#125; // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用 update() &#123; this.run(); &#125; addDep(dep) &#123; // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存 // 此判断是避免同id的Watcher被多次储存 if (!this.depIds.hasOwnProperty(dep.id)) &#123; dep.addSub(this); this.depIds[dep.id] = dep; &#125; &#125; run() &#123; const val = this.get(); console.log(val); if (val !== this.val) &#123; this.val = val; this.cb.call(this.vm, val); &#125; &#125; get() &#123; // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this; const val = this.vm._data[this.expOrFn]; // 置空，用于下一个Watcher使用 Dep.target = null; return val; &#125;&#125; 那么我们最后完成 Vue,将上述方法挂载在 Vue 上。 123456789101112131415161718192021222324252627class Vue &#123; constructor(options = &#123;&#125;) &#123; // 简化了$options的处理 this.$options = options; // 简化了对data的处理 let data = (this._data = this.$options.data); // 将所有data最外层属性代理到Vue实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)); // 监听数据 observe(data); &#125; // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者 $watch(expOrFn, cb) &#123; new Watcher(this, expOrFn, cb); &#125; _proxy(key) &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get: () =&gt; this._data[key], set: val =&gt; &#123; this._data[key] = val; &#125;, &#125;); &#125; &#125;] 至此,一个简单的双向绑定算是被我们实现了。 Object.defineProperty 的缺陷 Object.defineProperty的第一个缺陷,无法监听数组变化。Vue 的文档提到了 Vue 是可以检测到数组变化的，但是只有以下八种方法,vm.items[indexOfItem] = newValue这种是无法检测的。push()、pop()、shift()、unshift()、splice()、sort()、reverse() Object.defineProperty的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 Object.keys(value).forEach(key =&gt; **this**.convert(key, value[key])); 无法检测到对象属性的添加或删除(如data.location.a=1)。 这是因为 Vue 通过Object.defineProperty来将对象的 key 转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。如果是删除属性，我们可以用vm.$delete实现，那如果是新增属性，该怎么办呢？1）可以使用 Vue.set(location, a, 1) 方法向嵌套对象添加响应式属性;2）也可以给这个对象重新赋值，比如data.location = {...data.location,a:1} Proxy 实现的双向绑定的特点Proxy 在 ES2015 规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy 是Object.defineProperty的全方位加强版 Proxy 可以直接监听对象而非属性我们还是以上文中用Object.defineProperty实现的极简版双向绑定为例,用 Proxy 进行改写。 12345678910111213141516171819202122const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");const obj = &#123;&#125;;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === \"text\") &#123; input.value = value; p.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;&#125;);input.addEventListener(\"keyup\", function(e) &#123; newObj.text = e.target.value;&#125;); 我们可以看到,Proxy 直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于Object.defineProperty。 Proxy 可以直接监听数组的变化当我们对数组进行操作(push、shift、splice 等)时，会触发对应的方法名称和length的变化，我们可以借此进行操作,以上文中Object.defineProperty无法生效的列表渲染为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const list = document.getElementById(\"list\");const btn = document.getElementById(\"btn\");// 渲染列表const Render = &#123; // 初始化 init: function(arr) &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) &#123; const li = document.createElement(\"li\"); li.textContent = arr[i]; fragment.appendChild(li); &#125; list.appendChild(fragment); &#125;, // 我们只考虑了增加的情况,仅作为示例 change: function(val) &#123; const li = document.createElement(\"li\"); li.textContent = val; list.appendChild(li); &#125;&#125;;// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, &#123; get: function(target, key, receiver) &#123; console.log(key); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key !== \"length\") &#123; Render.change(value); &#125; return Reflect.set(target, key, value, receiver); &#125;&#125;);// 初始化window.onload = function() &#123; Render.init(arr);&#125;;// push数字btn.addEventListener(\"click\", function() &#123; newArr.push(6);&#125;); 很显然,Proxy 不需要那么多 hack（即使 hack 也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于 hack。 Proxy 的其他优势Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是Object.defineProperty不具备的。 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。 当然,Proxy 的劣势就是兼容性问题,而且无法用 polyfill 磨平,因此 Vue 的作者才声明需要等到下个大版本(3.0)才能用 Proxy 重写。 基础 proxy 的双向数据绑定的实现发布订阅中心(Dep)Dep保存订阅者,并在 Observer 发生变化时通知保存在 Dep 中的订阅者,让订阅者得知变化并更新视图,这样才能保证视图与状态的同步。 12345678910111213141516171819202122232425262728293031/** * [subs description] 订阅器,储存订阅者,通知订阅者 * @type &#123;Map&#125; */export default class Dep &#123; constructor() &#123; // 我们用 hash 储存订阅者 this.subs = new Map(); &#125; // 添加订阅者 addSub(key, sub) &#123; // 取出键为 key 的订阅者 const currentSub = this.subs.get(key); // 如果能取出说明有相同的 key 的订阅者已经存在,直接添加 if (currentSub) &#123; currentSub.add(sub); &#125; else &#123; // 用 Set 数据结构储存,保证唯一值 this.subs.set(key, new Set([sub])); &#125; &#125; // 通知 notify(key) &#123; // 触发键为 key 的订阅者们 if (this.subs.get(key)) &#123; this.subs.get(key).forEach(sub =&gt; &#123; sub.update(); &#125;); &#125; &#125;&#125; 监听者的实现(Observer)我们在订阅器 Dep 中实现了一个notify方法来通知相应的订阅这们,然而notify方法到底什么时候被触发呢? 当然是当状态发生变化时,即 MVVM 中的 Modal 变化时触发通知,然而Dep 显然无法得知 Modal 是否发生了变化,因此我们需要创建一个监听者Observer来监听 Modal, 当 Modal 发生变化的时候我们就执行通知操作。 与Object.defineProperty监听属性不同, Proxy 可以监听(实际是代理)整个对象,因此就不需要遍历对象的属性依次监听了,但是如果对象的属性依然是个对象,那么 Proxy 也无法监听,所以我们实现了一个observify进行递归监听即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * [Observer description] 监听器,监听对象,触发后通知订阅 * @param &#123;[type]&#125; obj [description] 需要被监听的对象 */const Observer = obj =&gt; &#123; const dep = new Dep(); return new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // 如果订阅者存在，直接添加订阅 if (Dep.target) &#123; dep.addSub(key, Dep.target); &#125; return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; // 如果对象值没有变,那么不触发下面的操作直接返回 if (Reflect.get(receiver, key) === value) &#123; return; &#125; const res = Reflect.set(target, key, observify(value), receiver); // 当值被触发更改的时候,触发 Dep 的通知方法 dep.notify(key); return res; &#125; &#125;);&#125;;/** * 将对象转为监听对象 * @param &#123;*&#125; obj 要监听的对象 */export default function observify(obj) &#123; if (!isObject(obj)) &#123; return obj; &#125; // 深度监听 Object.keys(obj).forEach(key =&gt; &#123; obj[key] = observify(obj[key]); &#125;); return Observer(obj);&#125; 订阅者的实现(watcher)我们目前已经解决了两个问题,一个是如何得知 Modal 发生了改变(利用监听者 Observer 监听 Modal 对象),一个是如何收集订阅者并通知其变化(利用订阅器收集订阅者,并用 notify 通知订阅者)。 我们目前还差一个订阅者（Watcher） 12345678910111213141516171819202122232425262728293031// 订阅者export default class Watcher &#123; constructor(vm, exp, cb) &#123; this.vm = vm; // vm 是 vue 的实例 this.exp = exp; // 被订阅的数据 this.cb = cb; // 触发更新后的回调 this.value = this.get(); // 获取老数据 &#125; get() &#123; const exp = this.exp; let value; Dep.target = this; if (typeof exp === \"function\") &#123; value = exp.call(this.vm); &#125; else if (typeof exp === \"string\") &#123; value = this.vm[exp]; &#125; Dep.target = null; return value; &#125; // 将订阅者放入待更新队列等待批量更新 update() &#123; pushQueue(this); &#125; // 触发真正的更新操作 run() &#123; const val = this.get(); // 获取新数据 this.cb.call(this.vm, val, this.value); this.value = val; &#125;&#125; 批量更新的实现我们在上一节中实现了订阅者( Watcher),但是其中的update方法是将订阅者放入了一个待更新的队列中,而不是直接触发,原因如下: 因此这个队列需要做的是异步且去重,因此我们用 Set作为数据结构储存 Watcher 来去重,同时用Promise模拟异步更新。 1234567891011121314151617181920212223// 创建异步更新队列let queue = new Set();// 用Promise模拟nextTickfunction nextTick(cb) &#123; Promise.resolve().then(cb);&#125;// 执行刷新队列function flushQueue(args) &#123; queue.forEach(watcher =&gt; &#123; watcher.run(); &#125;); // 清空 queue = new Set();&#125;// 添加到队列export default function pushQueue(watcher) &#123; queue.add(watcher); // 下一个循环调用 nextTick(flushQueue);&#125;","categories":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/categories/VUE/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"九种实现跨域的方式","slug":"九种实现跨域的方式","date":"2019-03-07T07:00:20.000Z","updated":"2019-11-10T14:37:39.029Z","comments":true,"path":"2019/03/07/九种实现跨域的方式/","link":"","permalink":"http://yoursite.com/2019/03/07/九种实现跨域的方式/","excerpt":"基本概念同源策略是约定，它是浏览器最核心也最基本的安全功能。同源：”协议+域名+端口” 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了","text":"基本概念同源策略是约定，它是浏览器最核心也最基本的安全功能。同源：”协议+域名+端口” 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了 有三个标签是允许跨域加载资源： 123&lt;img src=XXX&gt;&lt;link href=XXX&gt;&lt;script src=XXX&gt; 跨域解决方案：JSONPJSONP 原理利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。 JSONP 优缺点JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。 JSONP 的实现流程 声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。 创建一个 script 标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show(‘我不爱你’)。 最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。 123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(\"script\"); window[callback] = function(data) &#123; resolve(data); document.body.removeChild(script); &#125;; params = &#123; ...params, callback &#125;; // wd=b&amp;callback=show let arrs = []; for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join(\"&amp;\")&#125;`; document.body.appendChild(script); &#125;);&#125;jsonp(&#123; url: \"http://localhost:3000/say\", params: &#123; wd: \"Iloveyou\" &#125;, callback: \"show\"&#125;).then(data =&gt; &#123; console.log(data);&#125;); 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show 这个地址请求数据，然后后台返回 show(‘我不爱你’)，最后会运行 show()这个函数，打印出’我不爱你’ 12345678910// server.jslet express = require(\"express\");let app = express();app.get(\"/say\", function(req, res) &#123; let &#123; wd, callback &#125; = req.query; console.log(wd); // Iloveyou console.log(callback); // show res.end(`$&#123;callback&#125;('我不爱你')`);&#125;);app.listen(3000); corsCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 简单请求使用方法为 GET、HEAD、POST 之一Content-Type 的值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一同时满足这两大条件，为简单请求 复杂请求复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest();document.cookie = \"name=xiamen\"; // cookie不能跨域xhr.withCredentials = true; // 前端设置是否带cookiexhr.open(\"PUT\", \"http://localhost:4000/getData\", true);xhr.setRequestHeader(\"name\", \"xiamen\");xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response); //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader(\"name\")); &#125; &#125;&#125;;xhr.send(); 12345//server1.jslet express = require(\"express\");let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require(\"express\");let app = express();let whitList = [\"http://localhost:3000\"]; //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin; if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader(\"Access-Control-Allow-Origin\", origin); // 允许携带哪个头访问我 res.setHeader(\"Access-Control-Allow-Headers\", \"name\"); // 允许哪个方法访问我 res.setHeader(\"Access-Control-Allow-Methods\", \"PUT\"); // 允许携带cookie res.setHeader(\"Access-Control-Allow-Credentials\", true); // 预检的存活时间 res.setHeader(\"Access-Control-Max-Age\", 6); // 允许返回的头 res.setHeader(\"Access-Control-Expose-Headers\", \"name\"); if (req.method === \"OPTIONS\") &#123; res.end(); // OPTIONS请求不做任何处理 &#125; &#125; next();&#125;);app.put(\"/getData\", function(req, res) &#123; console.log(req.headers); res.setHeader(\"name\", \"jw\"); //返回一个响应头，后台需设置 res.end(\"我不爱你\");&#125;);app.get(\"/getData\", function(req, res) &#123; console.log(req.headers); res.end(\"我不爱你\");&#125;);app.use(express.static(__dirname));app.listen(4000); postMessage是为数不多可以跨域操作的 window 属性，可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的 iframe 消息传递 上面三个场景的跨域数据传递postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 1otherWindow.postMessage(message, targetOrigin, [transfer]); 例子： 123456789101112131415161718// a.html&lt;iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt;//等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html&lt;script&gt; function load() &#123; let frame = document.getElementById(\"frame\"); frame.contentWindow.postMessage(\"我爱你\", \"http://localhost:4000\"); //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data); //我不爱你 &#125;; &#125;&lt;/script&gt; 12345// b.htmlwindow.onmessage = function(e) &#123; console.log(e.data); //我爱你 e.source.postMessage(\"我不爱你\", e.origin);&#125;; websocketWebsocket 是 HTML5 的 WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 12345678910// socket.html&lt;script&gt; let socket = new WebSocket(\"ws://localhost:3000\"); socket.onopen = function() &#123; socket.send(\"我爱你\"); //向服务器发送数据 &#125;; socket.onmessage = function(e) &#123; console.log(e.data); //接收服务器返回的数据 &#125;;&lt;/script&gt; 1234567891011// server.jslet express = require(\"express\");let app = express();let WebSocket = require(\"ws\"); //记得安装wslet wss = new WebSocket.Server(&#123; port: 3000 &#125;);wss.on(\"connection\", function(ws) &#123; ws.on(\"message\", function(data) &#123; console.log(data); ws.send(\"我不爱你\"); &#125;);&#125;); Node 中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求 转发给服务器。 拿到服务器 响应 数据。 将 响应 转发给客户端。 本地文件 index.html 文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据： 12345678910111213141516// index.html(http://127.0.0.1:5500)&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url: \"http://localhost:3000\", type: \"post\", data: &#123; name: \"xiamen\", password: \"123456\" &#125;, contentType: \"application/json;charset=utf-8\", success: function(result) &#123; console.log(result); // &#123;\"title\":\"fontend\",\"password\":\"123456\"&#125; &#125;, error: function(msg) &#123; console.log(msg); &#125; &#125;);&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require(\"http\");// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; \"Access-Control-Allow-Origin\": \"*\", \"Access-Control-Allow-Methods\": \"*\", \"Access-Control-Allow-Headers\": \"Content-Type\" &#125;); // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: \"127.0.0.1\", port: 4000, url: \"/\", method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = \"\"; serverResponse.on(\"data\", chunk =&gt; &#123; body += chunk; &#125;); serverResponse.on(\"end\", () =&gt; &#123; console.log(\"The data is \" + body); // 第四步：将响应结果转发给浏览器 response.end(body); &#125;); &#125; ) .end();&#125;);server.listen(3000, () =&gt; &#123; console.log(\"The proxyServer is running at http://localhost:3000\");&#125;); 1234567891011// server2.js(http://localhost:4000)const http = require(\"http\");const data = &#123; title: \"fontend\", password: \"123456\" &#125;;const server = http.createServer((request, response) =&gt; &#123; if (request.url === \"/\") &#123; response.end(JSON.stringify(data)); &#125;&#125;);server.listen(4000, () =&gt; &#123; console.log(\"The server is running at http://localhost:4000\");&#125;); nginx 反向代理实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。 使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。 先下载 nginx，然后将 nginx 目录下的 nginx.conf 修改，最后通过命令行 nginx -s reload 启动 nginx window.name + iframewindow.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。其中 a.html 和 b.html 是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 12345678910111213141516171819202122// a.html(http://localhost:3000/b.html)&lt;iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"&gt;&lt;/iframe&gt;&lt;script&gt; let first = true; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if (first) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById(\"iframe\"); iframe.src = \"http://localhost:3000/b.html\"; first = false; &#125; else &#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125;&lt;/script&gt; b.html 为中间代理页，与 a.html 同域，内容为空。 1234// c.html(http://localhost:4000/c.html)&lt;script&gt; window.name = \"我不爱你\";&lt;/script&gt; 通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。 具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 12345678// a.html&lt;iframe src=\"http://localhost:4000/c.html#iloveyou\"&gt;&lt;/iframe&gt;&lt;script&gt; window.onhashchange = function() &#123; //检测hash的变化 console.log(location.hash); &#125;;&lt;/script&gt; 12345// b.html&lt;script&gt; window.parent.parent.location.hash = location.hash; //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面&lt;/script&gt; 12345// c.htmlconsole.log(location.hash);let iframe = document.createElement(\"iframe\");iframe.src = \"http://localhost:3000/b.html#idontloveyou\";document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =’test.com’ 表示二级域名都相同就可以实现跨域。实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。 12345678910111213141516// a.zf1.cn:3000/a.html&lt;body&gt; helloa &lt;iframe src=\"http://b.zf1.cn:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\" &gt;&lt;/iframe&gt; &lt;script&gt; document.domain = \"zf1.cn\"; function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678// b.zf1.cn:3000/b.html&lt;body&gt; hellob &lt;script&gt; document.domain = \"zf1.cn\"; var a = 100; &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"树的diff算法（vue 2.0）","slug":"树的diff算法（vue 2.0）","date":"2019-02-25T16:26:33.000Z","updated":"2019-11-10T14:37:39.036Z","comments":true,"path":"2019/02/26/树的diff算法（vue 2.0）/","link":"","permalink":"http://yoursite.com/2019/02/26/树的diff算法（vue 2.0）/","excerpt":"树的 diff 算法（vue 2.0）模板转换成视图的过程 Vue.js 通过编译将 template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树 在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。 简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。","text":"树的 diff 算法（vue 2.0）模板转换成视图的过程 Vue.js 通过编译将 template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树 在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。 简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。 渲染函数：渲染函数是用来生成 Virtual DOM 的。Vue 推荐使用模板来构建我们的应用界面，在底层实现中 Vue 会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。 VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode 可以理解成节点描述对象，它描述了应该怎样去创建真实的 DOM 节点。 patch(也叫做 patching 算法)：虚拟 DOM 最核心的部分，它可以将 vnode 渲染成真实的 DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch 本身就有补丁、修补的意思，其实际作用是在现有 DOM 上进行修改来实现更新视图的目的。Vue 的 Virtual DOM Patching 算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。 Virtual DOM 是什么？Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。 简单来说，可以把 Virtual DOM 理解为一个简单的 JS 对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。 对于虚拟 DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了模板 → 渲染函数 → 虚拟DOM树 → 真实DOM的一个过程 Virtual DOM 作用是什么？虚拟 DOM 的最终目标是将虚拟节点渲染到视图上。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的 DOM 操作。例如，一个 ul 标签下很多个 li 标签，其中只有一个 li 有变化，这种情况下如果使用新的 ul 去替代旧的 ul,因为这些不必要的 DOM 操作而造成了性能上的浪费。 为了避免不必要的 DOM 操作，虚拟 DOM 在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行 DOM 操作，从而避免操作其他无需改动的 DOM。 其实虚拟 DOM 在 Vue.js 主要做了两件事： 提供与真实 DOM 节点所对应的虚拟节点 vnode 将虚拟节点 vnode 和旧虚拟节点 oldVnode 进行对比，然后更新视图 为何需要 Virtual DOM？ 具备跨平台的优势 由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 操作 DOM 慢，js 运行效率高。我们可以将 DOM 对比操作放在 JS 层，提高效率。 因为 DOM 操作的执行速度远不如 Javascript 的运算速度快，因此，把大量的 DOM 操作搬运到 Javascript 中，运用 patching 算法来计算出真正需要更新的节点，最大限度地减少 DOM 操作，从而显著提高性能。 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM） 提升渲染性能 Virtual DOM 的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。 为了实现高效的 DOM 操作，一套高效的虚拟 DOM diff 算法显得很有必要。我们通过 patch 的核心—-diff 算法，找出本次 DOM 需要更新的节点来更新，其他的不更新。 VNode抽象 Dom 树把真实 Dom 树抽象成一棵以 javascript 对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实 Dom 重绘到页面上呢？于是虚拟 Dom 出现了，它是真实 Dom 的一层抽象，用属性描述真实 Dom 的各个特性。当它发生变化的时候，就会去修改视图。 但是这样的 javascript 操作 Dom 进行重绘整个视图层是相当消耗性能的，我们是不是可以每次只更新它的修改呢？所以 Vue.js 将 Dom 抽象成一个以 javascript 对象为节点的虚拟 Dom 树，以 VNode 节点模拟真实 Dom，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实 Dom，只需要操作 javascript 对象，大大提升了性能。修改以后经过 diff 算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的 Dom 操作，大大提高了性能。 Vue 就使用了这样的抽象节点 VNode，它是对真实 Dom 的一层抽象，而不依赖某个平台，它可以是浏览器平台，也可以是 weex，甚至是 node 平台也可以对这样一棵抽象 Dom 树进行创建删除修改等操作，这也为前后端同构提供了可能。 VNode 基类先来看一下 Vue.js 源码中对 VNode 类的定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope functionalContext: Component | void; // only for functional component root nodes key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? constructor( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions ) &#123; /*当前节点的标签名*/ this.tag = tag; /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.data = data; /*当前节点的子节点，是一个数组*/ this.children = children; /*当前节点的文本*/ this.text = text; /*当前虚拟节点对应的真实dom节点*/ this.elm = elm; /*当前节点的名字空间*/ this.ns = undefined; /*编译作用域*/ this.context = context; /*函数化组件作用域*/ this.functionalContext = undefined; /*节点的key属性，被当作节点的标志，用以优化*/ this.key = data &amp;&amp; data.key; /*组件的option选项*/ this.componentOptions = componentOptions; /*当前节点对应的组件的实例*/ this.componentInstance = undefined; /*当前节点的父节点*/ this.parent = undefined; /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.raw = false; /*静态节点标志*/ this.isStatic = false; /*是否作为跟节点插入*/ this.isRootInsert = true; /*是否为注释节点*/ this.isComment = false; /*是否为克隆节点*/ this.isCloned = false; /*是否有v-once指令*/ this.isOnce = false; &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next https://github.com/answershuto/learnVue*/ get child(): Component | void &#123; return this.componentInstance; &#125;&#125; 这是一个最基础的 VNode 节点，作为其他派生 VNode 类的基类，里面定义了下面这些数据。 tag: 当前节点的标签名 data: 当前节点对应的对象，包含了具体的一些数据信息，是一个 VNodeData 类型，可以参考 VNodeData 类型中的数据信息 children: 当前节点的子节点，是一个数组 text: 当前节点的文本 elm: 当前虚拟节点对应的真实 dom 节点 ns: 当前节点的名字空间 context: 当前节点的编译作用域 functionalContext: 函数化组件作用域 key: 节点的 key 属性，被当作节点的标志，用以优化 componentOptions: 组件的 option 选项 componentInstance: 当前节点对应的组件的实例 parent: 当前节点的父节点 raw: 简而言之就是是否为原生 HTML 或只是普通文本，innerHTML 的时候为 true，textContent 的时候为 false isStatic: 是否为静态节点 isRootInsert: 是否作为跟节点插入 isComment: 是否为注释节点 isCloned: 是否为克隆节点 isOnce: 是否有 v-once 指令 打个比方，比如说我现在有这么一个 VNode 树 123456789101112131415&#123; tag: 'div' data: &#123; class: 'test' &#125;, children: [ &#123; tag: 'span', data: &#123; class: 'demo' &#125; text: 'hello,VNode' &#125; ]&#125; 渲染之后的结果就是这样的 123&lt;div class=\"test\"&gt; &lt;span class=\"demo\"&gt;hello,VNode&lt;/span&gt;&lt;/div&gt; 生成一个新的 VNode 的方法下面这些方法都是一些常用的构造 VNode 的方法。 createEmptyVNode 创建一个空 VNode 节点 1234567/*创建一个空VNode节点*/export const createEmptyVNode = () =&gt; &#123; const node = new VNode(); node.text = \"\"; node.isComment = true; return node;&#125;; createTextVNode 创建一个文本节点 1234/*创建一个文本节点*/export function createTextVNode(val: string | number) &#123; return new VNode(undefined, undefined, undefined, String(val));&#125; createComponent 创建一个组件节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 // plain options object: turn it into a constructor https://github.com/answershuto/learnVue if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor) &#125; // if at this stage it's not a constructor or an async component factory, // reject. /*Github:https://github.com/answershuto*/ /*如果在该阶段Ctor依然不是一个构造函数或者是一个异步组件工厂则直接返回*/ if (typeof Ctor !== 'function') &#123; if (process.env.NODE_ENV !== 'production') &#123; warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context) &#125; return &#125; // async component /*处理异步组件*/ if (isUndef(Ctor.cid)) &#123; Ctor = resolveAsyncComponent(Ctor, baseCtor, context) if (Ctor === undefined) &#123; // return nothing if this is indeed an async component // wait for the callback to trigger parent update. /*如果这是一个异步组件则会不会返回任何东西（undifiened），直接return掉，等待回调函数去触发父组件更新。s*/ return &#125; &#125; // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor) data = data || &#123;&#125; // transform component v-model data into props &amp; events if (isDef(data.model)) &#123; transformModel(Ctor.options, data) &#125; // extract props const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent(Ctor, propsData, data, context, children) &#125; // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier data.on = data.nativeOn if (isTrue(Ctor.options.abstract)) &#123; // abstract components do not keep anything // other than props &amp; listeners data = &#123;&#125; &#125; // merge component management hooks onto the placeholder node mergeHooks(data) // return a placeholder vnode const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125; ) return vnode&#125; cloneVNode 克隆一个 VNode 节点 12345678910111213141516export function cloneVNode(vnode: VNode): VNode &#123; const cloned = new VNode( vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions ); cloned.ns = vnode.ns; cloned.isStatic = vnode.isStatic; cloned.key = vnode.key; cloned.isCloned = true; return cloned;&#125; createElementcreateElement 用来创建一个虚拟节点。当 data 上已经绑定ob的时候，代表该对象已经被 Oberver 过了，所以创建一个空节点。tag 不存在的时候同样创建一个空节点。当 tag 不是一个 String 类型的时候代表 tag 是一个组件的构造类，直接用 new VNode 创建。当 tag 是 String 类型的时候，如果是保留标签，则用 new VNode 创建一个 VNode 实例，如果在 vm 的 option 的 components 找得到该 tag，代表这是一个组件，否则统一用 new VNode 创建。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// wrapper function for providing a more flexible interface// without getting yelled at by flowexport function createElement( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode &#123; /*兼容不传data的情况*/ if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children; children = data; data = undefined; &#125; /*如果alwaysNormalize为true，则normalizationType标记为ALWAYS_NORMALIZE*/ if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE; &#125; /*Github:https://github.com/answershuto*/ /*创建虚拟节点*/ return _createElement(context, tag, data, children, normalizationType);&#125;/*创建虚拟节点*/export function _createElement( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode &#123; /* 如果data未定义（undefined或者null）或者是data的__ob__已经定义（代表已经被observed，上面绑定了Oberver对象）， https://cn.vuejs.org/v2/guide/render-function.html#约束 那么创建一个空节点 */ if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== \"production\" &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify( data )&#125;\\n` + \"Always create fresh vnode data objects in each render!\", context ); return createEmptyVNode(); &#125; /*如果tag不存在也是创建一个空节点*/ if (!tag) &#123; // in case of component :is set to falsy value return createEmptyVNode(); &#125; // support single function children as default scoped slot /*默认默认作用域插槽*/ if (Array.isArray(children) &amp;&amp; typeof children[0] === \"function\") &#123; data = data || &#123;&#125;; data.scopedSlots = &#123; default: children[0] &#125;; children.length = 0; &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children); &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children); &#125; let vnode, ns; if (typeof tag === \"string\") &#123; let Ctor; /*获取tag的名字空间*/ ns = config.getTagNamespace(tag); /*判断是否是保留的标签*/ if (config.isReservedTag(tag)) &#123; // platform built-in elements /*如果是保留的标签则创建一个相应节点*/ vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); &#125; else if ( isDef((Ctor = resolveAsset(context.$options, \"components\", tag))) ) &#123; // component /*从vm实例的option的components中寻找该tag，存在则就是一个组件，创建相应节点，Ctor为组件的构造类*/ vnode = createComponent(Ctor, data, context, children, tag); &#125; else &#123; // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children /*未知的元素，在运行时检查，因为父组件可能在序列化子组件的时候分配一个名字空间*/ vnode = new VNode(tag, data, children, undefined, undefined, context); &#125; &#125; else &#123; // direct component options / constructor /*tag不是字符串的时候则是组件的构造类*/ vnode = createComponent(tag, data, context, children); &#125; if (isDef(vnode)) &#123; /*如果有名字空间，则递归所有子节点应用该名字空间*/ if (ns) applyNS(vnode, ns); return vnode; &#125; else &#123; /*如果vnode没有成功创建则创建空节点*/ return createEmptyVNode(); &#125;&#125; diff 概解1.当数据发生变化时，vue 是怎么更新节点的？周所周知，Vue 通过数据绑定来修改视图，当某个数据被修改的时候，set 方法会让闭包中的 Dep 调用 notify 通知所有订阅者 Watcher，Watcher 通过 get 方法执行 vm._update(vm._render(), hydrating)。 这里看一下_update 方法 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this /*如果已经该组件已经挂载过了则代表进入这个步骤是个更新的过程，触发beforeUpdate钩子*/ if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. /*基于后端渲染Vue.prototype.__patch__被用来作为一个入口*/ if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false /* removeOnly */, vm.$options._parentElm, vm.$options._refElm ) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; activeInstance = prevActiveInstance // update __vue__ reference /*更新新的实例对象的__vue__*/ if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. &#125;复制代码 _update 方法的第一个参数是一个 VNode 对象，在内部会将该 VNode 对象与之前旧的 VNode 对象进行patch。 要知道渲染真实 DOM 的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实 dom 上会引起整个 dom 树的重绘和重排，有没有可能我们只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？diff 算法能够帮助我们。 我们先根据真实 DOM 生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的 DOM 上，然后使oldVnode的值为Vnode。 diff 的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的 DOM打补丁。 2. virtual DOM 和真实 DOM 的区别？虚拟 dom 对应的是真实 dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。 virtual DOM 是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构。比如 dom 是这样的： 123&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 对应的 virtual DOM（伪代码）： 1234var Vnode = &#123; tag: \"div\", children: [&#123; tag: \"p\", text: \"123\" &#125;]&#125;; （温馨提示：VNode和oldVNode都是对象，一定要记住） virtual dom 很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。 3. diff 的比较方式？在采取 diff 算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。 1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;456&lt;/span&gt;&lt;/div&gt; 上面的代码会分别比较同一层的两个 div 以及第二层的 p 和 span，但是不会拿 div 和 span 作比较。在别处看到的一张很形象的图： diff 流程图当数据发生改变时，set 方法会让调用Dep.notify通知所有订阅者 Watcher，订阅者就会调用patch给真实的 DOM 打补丁，更新相应的视图。 diff 算法包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了 diff 算法具体分析1. patch来看看patch是怎么打补丁的（代码只保留核心部分） 123456789101112131415161718function patch(oldVnode, vnode) &#123; // some code if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode); &#125; else &#123; const oEl = oldVnode.el; // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl); // 父元素 createEle(vnode); // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)); // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el); // 移除以前的旧元素节点 oldVnode = null; &#125; &#125; // some code return vnode;&#125;复制代码; patch 函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode 1234567891011function sameVnode(a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 );&#125;复制代码; 不值得比较则用Vnode替换oldVnode 如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff 可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…） 2. patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？ 123456789101112131415161718patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el's children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125;复制代码 这个函数做了以下事情： 找到对应的真实 dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 其他几个点都很好理解，我们详细来讲一下 updateChildren 3. updateChildren代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125;else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125;else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125;else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125;else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125;复制代码 先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 图解 updateChildren终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。 粉红色的部分为 oldCh、黄色的部分为 vCh 我们将它们取出来并分别用 s 和 e 指针指向它们的头 child 和尾 child 现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，这句话有点绕，打个比方 如果是 oldS 和 E 匹配上了，那么真实 dom 中的第一个节点会移到最后 如果是 oldE 和 S 匹配上了，那么真实 dom 中的最后一个节点会移到最前，匹配上的两个指针向中间移动 如果四种匹配没有一对是成功的，分为两种情况 如果新旧子节点都存在 key，那么会根据oldChild的 key 生成一张 hash 表，用S的 key 与 hash 表做匹配，匹配成功就判断S和匹配节点是否为sameNode，如果是，就在真实 dom 中将成功的节点移到最前面，否则，将S生成对应的节点插入到 dom 中对应的oldS位置，oldS和S指针向中间移动。 如果没有 key,则直接将S生成新的节点插入真实DOM（ps：这下可以解释为什么 v-for 的时候需要设置 key 了，如果没有 key 那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了） 再配个图（假设下图中的所有节点都是有 key 的，且 key 为自身的值） 第一步 12oldS = a, oldE = d；S = a, E = b; oldS和S匹配，则将 dom 中的 a 节点放到第一个，已经是第一个了就不管了，此时 dom 的位置为：a b d 第二步 12oldS = b, oldE = d；S = c, E = b; oldS和E匹配，就将原本的 b 节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，此时 dom 的位置为：a d b 第三步 12oldS = d, oldE = d；S = c, E = d; oldE和E匹配，位置不变此时 dom 的位置为：a d b 第四步 123oldS++;oldE--;oldS &gt; oldE; 遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的 index 插入到真实 dom 中去，此时 dom 位置为：a c d b 一次模拟完成。 这个匹配过程的结束有两个条件： oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据 index 添加到 dom 中去（如上图） S &gt; E表示 vCh 先遍历完，那么就在真实 dom 中将区间为[oldS, oldE]的多余节点删掉 下面再举一个例子，可以像上面那样自己试着模拟一下 当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码 123if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode);&#125; 就这样层层递归下去，直到将 oldVnode 和 Vnode 中的所有子节点比对完。也将 dom 的所有补丁都打好啦。那么现在再回过去看 updateChildren 的代码会不会容易很多呢？ 4. 操作 dom这里我们只是将虚拟 DOM 映射成了真实的 DOM。那如何给这些 DOM 加入 attr、class、style 等 DOM 属性呢？ 这要依赖于虚拟 DOM 的生命钩子。虚拟 DOM 提供了如下的钩子函数，分别在不同的时期会进行调用。 1234567891011const hooks = [\"create\", \"activate\", \"update\", \"remove\", \"destroy\"];/*构建cbs回调函数，web平台上见/platforms/web/runtime/modules*/for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = []; for (j = 0; j &lt; modules.length; ++j) &#123; if (isDef(modules[j][hooks[i]])) &#123; cbs[hooks[i]].push(modules[j][hooks[i]]); &#125; &#125;&#125; 同理，也会根据不同平台有自己不同的实现，我们这里以 Web 平台为例。Web 平台的钩子函数见/platforms/web/runtime/modules。里面有对 attr、class、props、events、style 以及 transition（过渡状态）的 DOM 属性进行操作。 以 attr 为例，代码很简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* @flow */import &#123; isIE9 &#125; from \"core/util/env\";import &#123; extend, isDef, isUndef &#125; from \"shared/util\";import &#123; isXlink, xlinkNS, getXlinkProp, isBooleanAttr, isEnumeratedAttr, isFalsyAttrValue&#125; from \"web/util/index\";/*更新attr*/function updateAttrs(oldVnode: VNodeWithData, vnode: VNodeWithData) &#123; /*如果旧的以及新的VNode节点均没有attr属性，则直接返回*/ if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) &#123; return; &#125; let key, cur, old; /*VNode节点对应的Dom实例*/ const elm = vnode.elm; /*旧VNode节点的attr*/ const oldAttrs = oldVnode.data.attrs || &#123;&#125;; /*新VNode节点的attr*/ let attrs: any = vnode.data.attrs || &#123;&#125;; // clone observed objects, as the user probably wants to mutate it /*如果新的VNode的attr已经有__ob__（代表已经被Observe处理过了）， 进行深拷贝*/ if (isDef(attrs.__ob__)) &#123; attrs = vnode.data.attrs = extend(&#123;&#125;, attrs); &#125; /*遍历attr，不一致则替换*/ for (key in attrs) &#123; cur = attrs[key]; old = oldAttrs[key]; if (old !== cur) &#123; setAttr(elm, key, cur); &#125; &#125; // #4391: in IE9, setting type can reset value for input[type=radio] /* istanbul ignore if */ if (isIE9 &amp;&amp; attrs.value !== oldAttrs.value) &#123; setAttr(elm, \"value\", attrs.value); &#125; for (key in oldAttrs) &#123; if (isUndef(attrs[key])) &#123; if (isXlink(key)) &#123; elm.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else if (!isEnumeratedAttr(key)) &#123; elm.removeAttribute(key); &#125; &#125; &#125;&#125;/*设置attr*/function setAttr(el: Element, key: string, value: any) &#123; if (isBooleanAttr(key)) &#123; // set attribute for blank value // e.g. &lt;option disabled&gt;Select one&lt;/option&gt; if (isFalsyAttrValue(value)) &#123; el.removeAttribute(key); &#125; else &#123; el.setAttribute(key, key); &#125; &#125; else if (isEnumeratedAttr(key)) &#123; el.setAttribute( key, isFalsyAttrValue(value) || value === \"false\" ? \"false\" : \"true\" ); &#125; else if (isXlink(key)) &#123; if (isFalsyAttrValue(value)) &#123; el.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else &#123; el.setAttributeNS(xlinkNS, key, value); &#125; &#125; else &#123; if (isFalsyAttrValue(value)) &#123; el.removeAttribute(key); &#125; else &#123; el.setAttribute(key, value); &#125; &#125;&#125;export default &#123; create: updateAttrs, update: updateAttrs&#125;; attr 只需要在 create 以及 update 钩子被调用时更新 DOM 的 attr 属性即可。","categories":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/categories/VUE/"}],"tags":[{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"}]},{"title":"leetcode算法刷题笔记（三）——排序","slug":"leetcode算法刷题笔记（三）——排序","date":"2019-02-22T06:54:39.000Z","updated":"2019-11-10T14:37:39.026Z","comments":true,"path":"2019/02/22/leetcode算法刷题笔记（三）——排序/","link":"","permalink":"http://yoursite.com/2019/02/22/leetcode算法刷题笔记（三）——排序/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [56] Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.难度：Medium (34.95%)思路： 首先按 start 升序或按 end 升序排列 如果前一项的 end 大于后一项的 start，说明要 merge 因为已经做了升序排列，所以要 push 进结果的那一项的 start 一定为前一项的 start，而 end 为两项中 end 较大的那个值。","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [56] Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.难度：Medium (34.95%)思路： 首先按 start 升序或按 end 升序排列 如果前一项的 end 大于后一项的 start，说明要 merge 因为已经做了升序排列，所以要 push 进结果的那一项的 start 一定为前一项的 start，而 end 为两项中 end 较大的那个值。 12345678910111213141516171819202122var merge = function(intervals) &#123; var res = []; if (intervals.length == 0) &#123; return res; &#125; intervals.sort(function(a, b) &#123; return a.start !== b.start ? a.start - b.start : a.end - b.end; &#125;); var pre = intervals[0]; res.push(pre); for (var cur of intervals) &#123; if (pre.end &gt;= cur.start) &#123; if (cur.end &gt; pre.end) &#123; pre.end = cur.end; &#125; &#125; else &#123; res.push(cur); pre = cur; &#125; &#125; return res;&#125;; [75] Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.Note: You are not suppose to use the library’s sort function for this problem.难度：Medium (41.44%)思路：遇到 0 放在最前面，遇到 2 放在最后面，1 不动 i 从 0 开始，如果 nums[i]等于 1，则 i++。 如果 nums[i]等于 0，则把 nums[i]放到最前面 如果 nums[i]等于 2，则把 nums[i]放到最后面 1234567891011121314151617181920212223242526var sortColors = function(nums) &#123; if (nums.length == 0) &#123; return -1; &#125; var i = 0; var m = 0; var n = nums.length - 1; var temp; while (i &lt;= n) &#123; if (nums[i] == 1) &#123; i++; &#125; else if (nums[i] == 0) &#123; temp = nums[m]; nums[m] = nums[i]; nums[i] = temp; m++; i++; &#125; else &#123; temp = nums[n]; nums[n] = nums[i]; nums[i] = temp; n--; &#125; &#125; return nums;&#125;; [147] Insertion Sort ListSort a linked list using insertion sort.A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list.Algorithm of Insertion Sort:Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.难度：Medium (36.50%)思路：新开辟一个空链表，作为以排序区域，每次拿出 head 来，与以排序区域的链表的 val 进行比较，找到插入位置，插入。则未排序区域的了链表长度减一。 123456789101112131415var insertionSortList = function(head) &#123; var current = &#123; val: -Number.MAX_VALUE, next: null &#125;; while (head) &#123; var prev = current; while (prev.next &amp;&amp; prev.next.val &lt; head.val) &#123; prev = prev.next; &#125; var next = head.next; head.next = prev.next; prev.next = head; head = next; &#125; return current.next;&#125;; [148] Sort ListSort a linked list in O(n log n) time using constant space complexity.难度：Medium (34.12%)思路：归并排序的链表实现 123456789101112131415161718192021222324252627282930313233343536373839404142var sortList = function(head) &#123; if (head == null || head.next == null) &#123; return head; &#125; var fast = head; var slow = head; var pre = null; while (fast &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; return merge(sortList(head), sortList(slow));&#125;;function merge(left, right) &#123; var result = &#123;&#125;; var pre = result; while (left &amp;&amp; right) &#123; if (left.val &lt; right.val) &#123; pre.next = left; pre = pre.next; left = left.next; &#125; else &#123; pre.next = right; pre = pre.next; right = right.next; &#125; &#125; while (left) &#123; pre.next = left; pre = pre.next; left = left.next; &#125; while (right) &#123; pre.next = right; pre = pre.next; right = right.next; &#125; return result.next;&#125; [179] Largest NumberGiven a list of non negative integers, arrange them such that they form the largest number.难度：Medium (25.32%) 12345678910111213var largestNumber = function(nums) &#123; nums.sort(function(a, b) &#123; var ab = a.toString() + b.toString(); var ba = b.toString() + a.toString(); return ba - ab; &#125;); var result = nums.join(\"\"); if (parseInt(result) == 0) &#123; return \"0\"; &#125; else &#123; return result; &#125;&#125;; [242] Valid AnagramGiven two strings s and t , write a function to determine if t is an anagram of s.Note: You may assume the string contains only lowercase alphabets.难度：Easy (51.12%) 1234567891011121314151617var isAnagram = function(s, t) &#123; if (s.length != = t.length) &#123; return false; &#125; var res = new Array(26); res.fill(0); for (var i = 0; i &lt; s.length; i++) &#123; res[s.codePointAt(i) - 97]++; res[t.codePointAt(i) - 97]--; &#125; for (var i = 0; i &lt; res.length; i++) &#123; if (res[i] !== 0) &#123; return false; &#125; &#125; return true;&#125;; [274] H-IndexGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”难度：Medium (34.43%)思路：一个人在其所有学术文章中有 N 篇论文分别被引用了至少 N 次，他的 H 指数就是 N。根据这个规则，首先讲数组倒序排列，判断数组中的第 i 个，是否大于等于 i+1，如果成立，则代表，至少有 i+1 篇文章，被引用了 i+1 次，则他的 h-index 就是 i+1. 12345678910111213141516var hIndex = function(citations) &#123; if (citations.length == 0) &#123; return 0; &#125; citations.sort((a, b) =&gt; b - a); var res = citations.length; for (var i = citations.length - 1; i &gt;= 0; i--) &#123; if (citations[i] &gt;= res) &#123; return res; &#125; res--; &#125; if (res == 0) &#123; return 0; &#125;&#125;; [324] Wiggle Sort IIGiven an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….难度：Medium (27.54%)思路：将数组正序排序之后，从中间分为两个数组，每次从小数组里拿一个数，从大数组里拿一个数，组成的 新数组就是一个数大一个数小的状态。 12345678910111213141516171819202122232425262728var wiggleSort = function(nums) &#123; if (nums.length &lt;= 1) &#123; return nums; &#125; nums = nums.sort((a, b) =&gt; a - b); var mid = Math.floor((nums.length + 1) / 2); var small = nums.slice(0, mid); var big = nums.slice(mid); if (big.length &gt; small.length) &#123; return []; &#125; var i = 0; var j = small.length - 1; var k = big.length - 1; while (i &lt; nums.length &amp;&amp; j &gt;= 0 &amp;&amp; k &gt;= 0) &#123; nums[i] = small[j]; nums[i + 1] = big[k]; i = i + 2; j--; k--; &#125; while (i &lt; nums.length &amp;&amp; j &gt;= 0) &#123; nums[i] = small[j]; i++; j--; &#125; return nums;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"前端路由","slug":"前端路由","date":"2019-01-28T12:56:32.000Z","updated":"2019-11-10T14:37:39.032Z","comments":true,"path":"2019/01/28/前端路由/","link":"","permalink":"http://yoursite.com/2019/01/28/前端路由/","excerpt":"前端路由1.什么是前端路由对于用户来说，路由就是浏览器地址栏中的 url 与所见网页的对应关系。而对于 web 开发人员来说，路由更像是 url 与处理函数的对应关系。 传统的服务端路由，根据客户端请求的不同网址，返回不同的网页内容，这种情况一是会造成服务器压力增加，二是每次都重新请求，响应较慢、用户体验下降。于是，单页应用（spa,single page application）应运而生。在 url 地址改变的过程中，通过 js 来实现不同 UI 之间的切换（js 对 DOM 的操作），而不再向服务器重新请求页面，只通过 ajax 向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。其中，根据 url 地址栏的变化而展示不同的 UI，就是通过前端路由来实现的。目前主流的支持单页应用的前端框架，基本都有配套的或第三方的路由系统。","text":"前端路由1.什么是前端路由对于用户来说，路由就是浏览器地址栏中的 url 与所见网页的对应关系。而对于 web 开发人员来说，路由更像是 url 与处理函数的对应关系。 传统的服务端路由，根据客户端请求的不同网址，返回不同的网页内容，这种情况一是会造成服务器压力增加，二是每次都重新请求，响应较慢、用户体验下降。于是，单页应用（spa,single page application）应运而生。在 url 地址改变的过程中，通过 js 来实现不同 UI 之间的切换（js 对 DOM 的操作），而不再向服务器重新请求页面，只通过 ajax 向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。其中，根据 url 地址栏的变化而展示不同的 UI，就是通过前端路由来实现的。目前主流的支持单页应用的前端框架，基本都有配套的或第三方的路由系统。 2.前端路由的实现方式在 HTML5 的 history API 出现之前，前端路由主要是通过 hash 来实现的，hash 能兼容低版本的浏览器。下面分别来介绍这 2 种方式。 方法一：基于 hash（location.hash+hashchange 事件） 我们知道 location.hash 的值是 url 中#后面的内容，如http://www.163.com#netease此网址中，location.hash=’#netease’。 hash 满足以下几个特性，才使得其可以实现前端路由： url 中 hash 值的变化并不会重新加载页面，因为 hash 是用来指导浏览器行为的，对服务端是无用的，所以不会包括在 http 请求中。 hash 值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制 hash 的切换 我们可以通过 hashchange 事件，监听到 hash 值的变化，从而响应不同路径的逻辑处理。 1window.addEventListener(\"hashchange\", funcRef, false); 如此一来，我们就可以在 hashchange 事件里，根据 hash 值来更新对应的视图，但不会去重新请求页面，同时呢，也在 history 里增加了一条访问记录，用户也仍然可以通过前进后退键实现 UI 的切换。 触发 hash 值的变化有 2 种方法:一种是通过 a 标签，设置 href 属性，当标签点击之后，地址栏会改变，同时会触发 hashchange 事件 1&lt;a href=\"#kaola\"&gt;to KAOLA&lt;/a&gt; 另一种是通过 js 直接赋值给 location.hash，也会改变 url，触发 hashchange 事件。 1location.hash = \"#kaola\"; 下面展示一个通过 hash 实现的简易 Router：123456789101112131415161718192021222324function Router() &#123; this.routes = &#123;&#125;; this.currentUrl = \"\";&#125;Router.prototype.route = function(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;;&#125;;Router.prototype.refresh = function() &#123; this.currentUrl = location.hash.slice(1) || \"/\"; this.routes[this.currentUrl]();&#125;;Router.prototype.init = function() &#123; window.addEventListener(\"load\", this.refresh.bind(this), false); window.addEventListener(\"hashchange\", this.refresh.bind(this), false);&#125;;window.Router = new Router();window.Router.init();// 添加路由规则Router.route(\"/\", function() &#123; // 设置响应内容&#125;);Router.route(\"/blue\", function() &#123; // 设置响应内容&#125;); 【route vs router】route 是一条路由，是将一个 URL 路径和一个处理函数相关联，是一条 url 和函数的映射规则，如上面代码中通过原型上的 route 可以设置一条路由规则，将一个 path 和其 callback 关联起来。 而 router 则更像是一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了 URL 和函数的映射，而在当接收到一个 URL 之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的，如上面代码，Router 管理传入的 route，并且在 hash 改变的时候，根据当前的 url 响应其对应的函数。 方法二：基于 History 新 API（history.pushState()+popState 事件） HTML5 中 history 对象上新的 API，同样能实现前端的路由。通过 pushState()方法或 replaceState()方法可以修改 url 的地址，并在 popstate 事件中能监听地址的改变，不同的是，手动的进行 pushState()并不会触发 popstate 事件。 两个新增的 API：history.pushState 和 history.replaceState这两个 API 都接收三个参数： 1window.history.pushState(null, null, \"http://www.163.com\"); 状态对象（state object），一个 JavaScript 对象，与用 pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发 popstate 事件，并能在事件中使用该对象。 标题（title） ：传入一个短标题给当前 state。现在大多数浏览器不支持或者会忽略此参数，最好传入 null 代替； 地址（URL）：新的历史记录条目的地址。浏览器不会在调用 pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的 URL 不一定是绝对路径；如果是相对路径，它将以当前 URL 为基准；传入的 URL 与当前 URL 应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前 URL。 这两个 API 的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState 会增加一条新的历史记录，而 replaceState 则会替换当前的历史记录。这两个 api，加上 state 改变触发的 popstate 事件，提供了单页应该的另一种路由方式。 下面展示一个使用这种方式的简单 demo：12345678910111213141516171819202122232425&lt;p id=\"menu\"&gt; &lt;a href=\"/profile\" title=\"profile\"&gt;profile&lt;/a&gt; &lt;a href=\"/account\" title=\"account\"&gt;account&lt;/a&gt;?&lt;/p&gt;&lt;div class=\"main\" id=\"main\"&gt;&lt;/div&gt;&lt;script&gt; (function() &#123; var menubox = document.getElementById(\"menu\"); var mainbox = document.getElementById(\"main\"); menubox.addEventListener(\"click\", function(e) &#123; e.preventDefault(); var elm = e.target; var uri = elm.href; var tlt = elm.title; history.pushState(&#123; path: uri, title: tlt &#125;, null, uri); mainbox.innerHTML = \"current page is \" + tlt; &#125;); window.addEventListener(\"popstate\", function(e) &#123; var state = e.state; console.log(state); mainbox.innerHTML = \"current page is \" + state.title; // 还原UI &#125;); &#125;)();&lt;/script&gt; 当我们在历史记录中切换时就会触发 popstate 事件，可以在事件中还原当前 state 对应的 UI。对于触发 popstate 事件的方式，各浏览器实现也有差异，我们可以根据不同浏览器做兼容处理。 两种方式对比（History&amp;&amp;hash） 两种方式对比，基于 Hash 的路由，兼容性更好；基于 History API 的路由，则更正式，可以设置与当前 URL 同源的任意 URL，路径更直观。另外，基于 Hash 的路由不需要对服务器做改动，基于 History API 的路由需要对服务器做一些改造，配置不同的路由都返回相同的页面。 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。当从http://example.com/跳转到http://example.com/#/foobar或者http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问http://example.com/#/foobar的时候，实际上向服务器发起的请求是http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar的时候，实际上向服务器发起的请求也是http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于 History API 的路由，需要改造服务器端，使得访问/foobar 的时候也能返回 index.html 文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。 Vue Routervue-router 基本的路由配置如下： 123456789101112131415161718192021222324import Router from 'vue-router'import Index from 'pages/index'import Error from 'pages/error'Vue.use(Router)export default new Router(&#123; mode: 'history', // 设置路由方式 routes: [ &#123; path: '/', name: 'index', component: Index &#125;, &#123; path: '*', name: '404', component: Error &#125; ]&#125;)// 在组件中使用router视图组件&lt;router-view&gt;&lt;/router-view&gt; 可以通过 vue-router 实例来配置路由规则列表，指定路径 path 与组件 component 的对应关系。 1.模式参数在 vue-router 中是通过 mode 这一参数控制路由的实现模式的： 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 创建 VueRouter 的实例对象时，mode 以构造函数参数的形式传入。从 VueRouter 类的定义入手。一般插件对外暴露的类都是定义在源码 src 根目录下的 index.js 文件中，打开该文件，可以看到 VueRouter 类的定义，摘录与 mode 参数有关的部分如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export default class VueRouter &#123; mode: string; // 传入的字符串参数，指示history类别 history: HashHistory | HTML5History | AbstractHistory; // 实际起作用的对象属性，必须是以上三个类的枚举 fallback: boolean; // 如浏览器不支持，'history'模式需回滚为'hash'模式 constructor(options: RouterOptions = &#123;&#125;) &#123; let mode = options.mode || \"hash\"; // 默认为'hash'模式 this.fallback = mode === \"history\" &amp;&amp; !supportsPushState; // 通过supportsPushState判断浏览器是否支持'history'模式 if (this.fallback) &#123; mode = \"hash\"; &#125; if (!inBrowser) &#123; mode = \"abstract\"; // 不在浏览器环境下运行需强制为'abstract'模式 &#125; this.mode = mode; // 根据mode确定history实际的类并实例化 switch (mode) &#123; case \"history\": this.history = new HTML5History(this, options.base); break; case \"hash\": this.history = new HashHistory(this, options.base, this.fallback); break; case \"abstract\": this.history = new AbstractHistory(this, options.base); break; default: if (process.env.NODE_ENV !== \"production\") &#123; assert(false, `invalid mode: $&#123;mode&#125;`); &#125; &#125; &#125; init(app: any /* Vue component instance */) &#123; const history = this.history; // 根据history的类别执行相应的初始化操作和监听 if (history instanceof HTML5History) &#123; history.transitionTo(history.getCurrentLocation()); &#125; else if (history instanceof HashHistory) &#123; const setupHashListener = () =&gt; &#123; history.setupListeners(); &#125;; history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ); &#125; history.listen(route =&gt; &#123; this.apps.forEach(app =&gt; &#123; app._route = route; &#125;); &#125;); &#125; // VueRouter类暴露的以下方法实际是调用具体history对象的方法 push(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.push(location, onComplete, onAbort); &#125; replace(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.replace(location, onComplete, onAbort); &#125;&#125; 可以看出： 作为参数传入的字符串属性 mode 只是一个标记，用来指示实际起作用的对象属性 history 的实现类，两者对应关系如下： modehistory： ‘history’——HTML5History ‘hash’——HashHistory ‘abstract’——AbstractHistory 在初始化对应的 history 之前，会对 mode 做一些校验：若浏览器不支持 HTML5History 方式（通过 supportsPushState 变量判断），则 mode 强制设为’hash’；若不是在浏览器环境下运行，则 mode 强制设为’abstract’ VueRouter 类中的 onReady(), push()等方法只是一个代理，实际是调用的具体 history 对象的对应方法，在 init()方法中初始化时，也是根据 history 对象具体的类别执行不同操作 在浏览器环境下的两种方式，分别就是在 HTML5History，HashHistory 两个类中实现的。他们都定义在 src/history 文件夹下，继承自同目录下 base.js 文件中定义的 History 类。History 中定义的是公用和基础的方法，直接看会一头雾水，我们先从 HTML5History，HashHistory 两个类中看着亲切的 push(), replace()方法的说起。 2.HashHistory看源码前先回顾一下原理： hash（“#”）符号的本来作用是加在 URL 中指示网页中的位置： http://www.example.com/index.html#print #符号本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取。它具有如下特点： hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面 可以为 hash 的改变添加监听事件： 1window.addEventListener(\"hashchange\", funcRef, false); 每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录 利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了。 HashHistory.push()我们来看 HashHistory 中的 push()方法： 12345678910push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; pushHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;function pushHash (path) &#123; window.location.hash = path&#125; transitionTo()方法是父类中定义的是用来处理路由变化中的基础逻辑的，push()方法最主要的是对 window 的 hash 进行了直接赋值： 1window.location.hash = route.fullPath; hash 的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，我们来看父类 History 中 transitionTo()方法的这么一段： 123456789101112131415transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const route = this.router.match(location, this.current) this.confirmTransition(route, () =&gt; &#123; this.updateRoute(route) ... &#125;)&#125;updateRoute (route: Route) &#123; this.cb &amp;&amp; this.cb(route)&#125;listen (cb: Function) &#123; this.cb = cb&#125; 可以看到，当路由变化时，调用了 History 中的 this.cb 方法，而 this.cb 方法是通过 History.listen(cb)进行设置的。回到 VueRouter 类定义中，找到了在 init()方法中对其进行了设置： 12345678910init (app: any /* Vue component instance */) &#123; this.apps.push(app) history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; app._route = route &#125;) &#125;)&#125; 根据注释，app 为 Vue 组件实例，但我们知道 Vue 作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性_route，如果组件中要有这个属性，应该是在插件加载的地方，即 VueRouter 的 install()方法中混合入 Vue 对象的，查看 install.js 源码，有如下一段： 123456789101112export function install(Vue) &#123; Vue.mixin(&#123; beforeCreate() &#123; if (isDef(this.$options.router)) &#123; this._router = this.$options.router; this._router.init(this); Vue.util.defineReactive(this, \"_route\", this._router.history.current); &#125; registerInstance(this, this); &#125; &#125;);&#125; 通过 Vue.mixin()方法，全局注册一个混合，影响注册之后所有创建的每个 Vue 实例，该混合在 beforeCreate 钩子中通过 Vue.util.defineReactive()定义了响应式的_route 属性。所谓响应式属性，即当_route 值改变时，会自动调用 Vue 实例的 render()方法，更新视图。 总结一下，从设置路由改变到视图更新的流程如下：1$router.push() --&gt; HashHistory.push() --&gt; History.transitionTo() --&gt; History.updateRoute() --&gt; &#123;app._route = route&#125; --&gt; vm.render() HashHistory.replace()replace()方法与 push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由： 12345678910111213replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; replaceHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;function replaceHash (path) &#123; const i = window.location.href.indexOf('#') window.location.replace( window.location.href.slice(0, i &gt;= 0 ? i : 0) + '#' + path )&#125; 可以看出，它与 push()的实现结构上基本相似，不同点在于它不是直接对 window.location.hash 进行赋值，而是调用 window.location.replace 方法将路由进行替换。 监听地址栏以上讨论的 VueRouter.push()和 VueRouter.replace()是可以在 vue 组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此 VueRouter 还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在 HashHistory 中这一功能通过 setupListeners 实现： 12345678910setupListeners () &#123; window.addEventListener('hashchange', () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; this.transitionTo(getHash(), route =&gt; &#123; replaceHash(route.fullPath) &#125;) &#125;)&#125; 该方法设置监听了浏览器事件 hashchange，调用的函数为 replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了 replace()方法 3.HTML5HistoryHistory interface 是浏览器历史记录栈提供的接口，通过 back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。 从 HTML5 开始，History interface 提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改：12window.history.pushState(stateObject, title, URL);window.history.replaceState(stateObject, title, URL); stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本 title: 所添加记录的标题 URL: 所添加记录的 URL 这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会立即发送请求该 URL（the browser won’t attempt to load this URL after a call to pushState()），这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。 我们来看 vue-router 中的源码： 123456789101112131415161718192021222324252627282930313233343536373839push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; pushState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; replaceState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;// src/util/push-state.jsexport function pushState (url?: string, replace?: boolean) &#123; saveScrollPosition() // try...catch the pushState call to get around Safari // DOM Exception 18 where it limits to 100 pushState calls const history = window.history try &#123; if (replace) &#123; history.replaceState(&#123; key: _key &#125;, '', url) &#125; else &#123; _key = genKey() history.pushState(&#123; key: _key &#125;, '', url) &#125; &#125; catch (e) &#123; window.location[replace ? 'replace' : 'assign'](url) &#125;&#125;export function replaceState (url?: string) &#123; pushState(url, true)&#125; 代码结构以及更新视图的逻辑与 hash 模式基本类似，只不过将对 window.location.hash 直接进行赋值 window.location.replace()改为了调用 history.pushState()和 history.replaceState()方法。 在 HTML5History 中添加对修改浏览器地址栏 URL 的监听是直接在构造函数中执行的：1234567891011constructor (router: Router, base: ?string) &#123; window.addEventListener('popstate', e =&gt; &#123; const current = this.current this.transitionTo(getLocation(this.base), route =&gt; &#123; if (expectScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;)&#125; 当然了 HTML5History 用到了 HTML5 的新特特性，是需要特定浏览器版本的支持的，前文已经知道，浏览器是否支持是通过变量 supportsPushState 来检查的： 1234567891011121314151617// src/util/push-state.jsexport const supportsPushState = inBrowser &amp;&amp; (function() &#123; const ua = window.navigator.userAgent; if ( (ua.indexOf(\"Android 2.\") !== -1 || ua.indexOf(\"Android 4.0\") !== -1) &amp;&amp; ua.indexOf(\"Mobile Safari\") !== -1 &amp;&amp; ua.indexOf(\"Chrome\") === -1 &amp;&amp; ua.indexOf(\"Windows Phone\") === -1 ) &#123; return false; &#125; return window.history &amp;&amp; \"pushState\" in window.history; &#125;)(); 这两种模式都是通过浏览器接口实现的，除此之外 vue-router 还为非浏览器环境准备了一个 abstract 模式，其原理为用一个数组 stack 模拟出浏览器历史记录栈的功能。 4.vue 中两种模式比较在一般的需求场景中，hash 模式与 history 模式是差不多的，但几乎所有的文章都推荐使用 history 模式，理由竟然是：”#” 符号太丑…0_0 “ 如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档 当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据 MDN 的介绍，调用 history.pushState()相比于直接修改 hash 主要有以下优势： pushState 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL pushState 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中 pushState 通过 stateObject 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串 pushState 可额外设置 title 属性供后续使用 a 标签 hash 跳转，会改变页面路径的 hash 值，但不会重载 history 模式的一个问题 我们知道对于单页应用来讲，理想的使用场景是仅在进入应用时加载 index.html，后续在的网络操作通过 Ajax 完成，不会根据 URL 重新请求页面，但是难免遇到特殊情况，比如用户直接在地址栏中输入并回车，浏览器重启重新加载应用等。 hash 模式仅改变 hash 部分的内容，而 hash 部分是不会包含在 HTTP 请求中的： 1http://oursite.com/#/user/id // 如重新请求只会发送http://oursite.com/ 故在 hash 模式下遇到根据 URL 请求页面的情况不会有问题。 而 history 模式则会将 URL 修改得就和正常请求后端的 URL 一样 1http://oursite.com/user/id 在此情况下重新向后端发送请求，如后端没有配置对应/user/id 的路由处理，则会返回 404 错误。官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。 5.AbstractHistory‘abstract’模式，不涉及和浏览器地址的相关记录，流程跟’HashHistory’是一样的，其原理是通过数组模拟浏览器历史记录栈的功能 12345678910111213141516171819// 对于 go 的模拟 go (n: number) &#123; // 新的历史记录位置 const targetIndex = this.index + n // 超出返回了 if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) &#123; return &#125; // 取得新的 route 对象 // 因为是和浏览器无关的 这里得到的一定是已经访问过的 const route = this.stack[targetIndex] // 所以这里直接调用 confirmTransition 了 // 而不是调用 transitionTo 还要走一遍 match 逻辑 this.confirmTransition(route, () =&gt; &#123; // 更新 this.index = targetIndex this.updateRoute(route) &#125;) &#125; 6.直接加载应用文件 Tip: built files are meant to be served over an HTTP server. Opening index.html over file:// won’t work. Vue 项目通过 vue-cli 的 webpack 打包完成后，命令行会有这么一段提示。通常情况，无论是开发还是线上，前端项目都是通过服务器访问，不存在 “Opening index.html over file://“ ，但程序员都知道，需求和场景永远是千奇百怪的，只有你想不到的，没有产品经理想不到的。 本文写作的初衷就是遇到了这样一个问题：需要快速开发一个移动端的展示项目，决定采用 WebView 加载 Vue 单页应用的形式，但没有后端服务器提供，所以所有资源需从本地文件系统加载： 123456789101112131415161718192021222324// AndroidAppWrapperpublic class MainActivity extends AppCompatActivity &#123; private WebView webView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); webView = new WebView(this); webView.getSettings().setJavaScriptEnabled(true); webView.loadUrl(\"file:///android_asset/index.html\"); setContentView(webView); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; webView.canGoBack()) &#123; webView.goBack(); return true; &#125; return false; &#125;&#125; 此情此景看来是必须 “Opening index.html over file://“ 了，为此，我首先要进行了一些设置 在项目 config.js 文件中将 assetsPublicPath 字段的值改为相对路径 ‘./‘ 调整生成的 static 文件夹中图片等静态资源的位置与代码中的引用地址一致 这是比较明显的需要改动之处，但改完后依旧无法顺利加载，经过反复排查发现，项目在开发时，router 设置为了 history 模式（为了美观…0_0”），当改为 hash 模式后就可正常加载了。 为什么会出现这种情况呢？我分析原因可能如下： 当从文件系统中直接加载 index.html 时，URL 为： 1file:///android_asset/index.html 而首页视图需匹配的路径为 path: ‘/‘ : 12345678910export default new Router(&#123; mode: \"history\", routes: [ &#123; path: \"/\", name: \"index\", component: IndexView &#125; ]&#125;); 我们先来看 history 模式，在 HTML5History 中： 1234567891011121314ensureURL (push?: boolean) &#123; if (getLocation(this.base) !== this.current.fullPath) &#123; const current = cleanPath(this.base + this.current.fullPath) push ? pushState(current) : replaceState(current) &#125;&#125;export function getLocation (base: string): string &#123; let path = window.location.pathname if (base &amp;&amp; path.indexOf(base) === 0) &#123; path = path.slice(base.length) &#125; return (path || '/') + window.location.search + window.location.hash&#125; 逻辑只会确保存在 URL，path 是通过剪切的方式直接从 window.location.pathname 获取到的，它的结尾是 index.html，因此匹配不到 ‘/‘ ，故 “Opening index.html over file:// won’t work” 。 再看 hash 模式，在 HashHistory 中： 123456789101112131415161718192021222324252627282930313233343536export class HashHistory extends History &#123; constructor (router: Router, base: ?string, fallback: boolean) &#123; ... ensureSlash() &#125; // this is delayed until the app mounts // to avoid the hashchange listener being fired too early setupListeners () &#123; window.addEventListener('hashchange', () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; ... &#125;) &#125; getCurrentLocation () &#123; return getHash() &#125;&#125;function ensureSlash (): boolean &#123; const path = getHash() if (path.charAt(0) === '/') &#123; return true &#125; replaceHash('/' + path) return false&#125;export function getHash (): string &#123; const href = window.location.href const index = href.indexOf('#') return index === -1 ? '' : href.slice(index + 1)&#125; 我们看到在代码逻辑中，多次出现一个函数 ensureSlash()，当#符号后紧跟着的是’/‘，则返回 true，否则强行插入这个’/‘，故我们可以看到，即使是从文件系统打开 index.html，URL 依旧会变为以下形式： 1file:///C:/Users/dist/index.html#/ getHash()方法返回的 path 为 ‘/‘ ，可与首页视图的路由匹配。 故要想从文件系统直接加载 Vue 单页应用而不借助后端服务器，除了打包后的一些路径设置外，还需确保 vue-router 使用的是 hash 模式。 React Routerreact-router 是基于 history 模块提供的 api 进行开发的。其路由配置是通过 react component 方式进行的，路由更改触发的回调函数是我们自己写的操作 DOM 的函数；在 react 中我们不直接操作 DOM，而是管理抽象出来的 VDOM 或者说 JSX，对 react 的来说路由需要管理组件的生命周期，对不同的路由渲染不同的组件。 如下： 1234567891011121314render(( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;users&quot; component=&#123;Users&#125;&gt; &lt;Route path=&quot;/user/:userId&quot; component=&#123;User&#125;/&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; component=&#123;NoMatch&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body)// link 触发路由&lt;Link to=&#123;`/user/89757`&#125;&gt;&apos;joey&apos;&lt;/Link&gt; 以上声明了一份含有 path to component 的各个映射的路由表。Router 在 react 组件生命周期的钩子 componentWillMount （组件被挂载前）中，使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 会去 render 新的 component。 1.historyhistory 库，是 rr4 依赖的一个对 window.history 加强版的 history 库。 match源自 history 库，表示当前的 URL 与 path 的匹配的结果 123456match: &#123; path: &quot;/&quot;, // 用来匹配的 path url: &quot;/&quot;, // 当前的 URL params: &#123;&#125;, // 路径中的参数 isExact: pathname === &quot;/&quot; // 是否为严格匹配&#125; location还是源自 history 库，是 history 库基于 window.location 的一个衍生。 12345hash: &quot;&quot; // hashkey: &quot;nyi4ea&quot; // 一个 uuidpathname: &quot;/explore&quot; // URL 中路径部分search: &quot;&quot; // URL 参数state: undefined // 路由跳转时传递的 state 我们带着问题去分析源码，先逐个分析每个组件的作用，在最后会有回答，在这里先举一个 rr4 的小 DEMO 页面初始化时的渲染过程？ 点击一个 Link 跳转及渲染更新的过程？ 2.packagesrr4 将路由拆成了几个包： react-router 负责通用的路由逻辑 react-router-dom 负责浏览器的路由管理 react-router-native 负责 react-native 的路由管理 通用的部分直接从 react-router 中导入，用户只需引入 react-router-dom 或 react-router-native 即可，react-router 作为依赖存在不再需要单独引入。 Router123456789101112import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;import App from &apos;./components/App&apos;;render()&#123; return( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; ))&#125; 这是我们调用 Router 的方式，这里拿 BrowserRouter 来举例。 BrowserRouter 的源码在 react-router-dom 中，它是一个高阶组件，在内部创建一个全局的 history 对象（可以监听整个路由的变化），并将 history 作为 props 传递给 react-router 的 Router 组件（Router 组件再会将这个 history 的属性作为 context 传递给子组件） 123render() &#123; return &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125; /&gt;;&#125; 整个 Router 的核心是在 react-router 的 Router 组件中，如下，借助 context 向 Route 传递组件，这也解释了为什么 Router 要在所有 Route 的外面。 123456789101112getChildContext() &#123; return &#123; router: &#123; ...this.context.router, history: this.props.history, route: &#123; location: this.props.history.location, match: this.state.match &#125; &#125; &#125;;&#125; 这是 Router 传递给子组件的 context，事实上 Route 也会将 router 作为 context 向下传递，如果我们在 Route 渲染的组件中加入 1234567static contextTypes = &#123; router: PropTypes.shape(&#123; history: PropTypes.object.isRequired, route: PropTypes.object.isRequired, staticContext: PropTypes.object &#125;)&#125;; 来通过 context 访问 router，不过 rr4 一般通过 props 传递，将 history, location, match 作为三个独立的 props 传递给要渲染的组件，这样访问起来方便一点（实际上已经完全将 router 对象的属性完全传递了）。 在 Router 的 componentWillMount 中， 添加了 1234567891011121314151617componentWillMount() &#123; const &#123; children, history &#125; = this.props; invariant( children == null || React.Children.count(children) === 1, &quot;A &lt;Router&gt; may have only one child element&quot; ); // Do this here so we can setState when a &lt;Redirect&gt; changes the // location in componentWillMount. This happens e.g. when doing // server rendering using a &lt;sStaticRouter&gt;. this.unlisten = history.listen(() =&gt; &#123; this.setState(&#123; match: this.computeMatch(history.location.pathname) &#125;); &#125;);&#125; history.listen 能够监听路由的变化并执行回调事件。 在这里每次路由的变化执行的回调事件为 123this.setState(&#123; match: this.computeMatch(history.location.pathname)&#125;); 相比于在 setState 里做的操作，setState 本身的意义更大 —— 每次路由变化 -&gt; 触发顶层 Router 的回调事件 -&gt; Router 进行 setState -&gt; 向下传递 nextContext（context 中含有最新的 location）-&gt; 下面的 Route 获取新的 nextContext 判断是否进行渲染。 之所以把这个 subscribe 的函数写在 componentWillMount 里，就像源码中给出的注释：是为了 SSR 的时候，能够使用 Redirect。 RouteRoute 的作用是匹配路由，并传递给要渲染的组件 props。 在 Route 的 componentWillReceiveProps 中 123456componentWillReceiveProps(nextProps, nextContext) &#123; ... this.setState(&#123; match: this.computeMatch(nextProps, nextContext.router) &#125;);&#125; Route 接受上层的 Router 传入的 context，Router 中的 history 监听着整个页面的路由变化，当页面发生跳转时，history 触发监听事件，Router 向下传递 nextContext，就会更新 Route 的 props 和 context 来判断当前 Route 的 path 是否匹配 location，如果匹配则渲染，否则不渲染。 是否匹配的依据就是 computeMatch 这个函数，在下文会有分析，这里只需要知道匹配失败则 match 为 null，如果匹配成功则将 match 的结果作为 props 的一部分，在 render 中传递给传进来的要渲染的组件。 接下来看一下 Route 的 render 部分。 123456789101112131415161718render() &#123; const &#123; match &#125; = this.state; // 布尔值，表示 location 是否匹配当前 Route 的 path const &#123; children, component, render &#125; = this.props; // Route 提供的三种可选的渲染方式 const &#123; history, route, staticContext &#125; = this.context.router; // Router 传入的 context const location = this.props.location || route.location; const props = &#123; match, location, history, staticContext &#125;; if (component) return match ? React.createElement(component, props) : null; // Component 创建 if (render) return match ? render(props) : null; // render 创建 if (typeof children === &quot;function&quot;) return children(props); // 回调 children 创建 if (children &amp;&amp; !isEmptyChildren(children)) // 普通 children 创建 return React.Children.only(children); return null;&#125; rr4 提供了三种渲染组件的方法：component props，render props 和 children props，渲染的优先级也是依次按照顺序，如果前面的已经渲染后了，将会直接 return。 component (props) —— 由于使用 React.createElement 创建，所以可以传入一个 class component。 render (props) —— 直接调用 render() 展开子元素，所以需要传入 stateless function component。 children (props) —— 其实和 render 差不多，区别是不判断 match，总是会被渲染。 children（子元素）—— 如果以上都没有，那么会默认渲染子元素，但是只能有一个子元素。 这里解释一下官网的 tips，component 是使用 React.createElement 来创建新的元素，所以如果传入一个内联函数，比如 1&lt;Route path=&apos;/&apos; component=&#123;()=&gt;(&lt;div&gt;hello world&lt;/div&gt;)&#125; 的话，由于每次的 props.component 都是新创建的，所以 React 在 diff 的时候会认为进来了一个全新的组件，所以会将旧的组件 unmount，再 re-mount。这时候就要使用 render，少了一层包裹的 component 元素，render 展开后的元素类型每次都是一样的，就不会发生 re-mount 了（children 也不会发生 re-mount）。 Switch我们紧接着 Route 来看 Switch，Switch 是用来嵌套在 Route 的外面，当 Switch 中的第一个 Route 匹配之后就不会再渲染其他的 Route 了。 123456789101112131415161718192021222324252627282930render() &#123; const &#123; route &#125; = this.context.router; const &#123; children &#125; = this.props; const location = this.props.location || route.location; let match, child; React.Children.forEach(children, element =&gt; &#123; if (match == null &amp;&amp; React.isValidElement(element)) &#123; const &#123; path: pathProp, exact, strict, sensitive, from &#125; = element.props; const path = pathProp || from; child = element; match = matchPath( location.pathname, &#123; path, exact, strict, sensitive &#125;, route.match ); &#125; &#125;); return match ? React.cloneElement(child, &#123; location, computedMatch: match &#125;) : null;&#125; Switch 也是通过 matchPath 这个函数来判断是否匹配成功，一直按照 Switch 中 children 的顺序依次遍历子元素，如果匹配失败则 match 为 null，如果匹配成功则标记这个子元素和它对应的 location、computedMatch。在最后的时候使用 React.cloneElement 渲染，如果没有匹配到的子元素则返回 null。 接下来我们看下 matchPath 是如何判断 location 是否符合 path 的。 matchPathmatchPath 返回的是一个如下结构的对象 123456789101112&#123; path, // 用来进行匹配的路径，其实是直接导出的传入 matchPath 的 options 中的 path url: path === &quot;/&quot; &amp;&amp; url === &quot;&quot; ? &quot;/&quot; : url, // 整个的 URL isExact, // url 与 path 是否是 exact 的匹配 // 返回的是一个键值对的映射 // 比如你的 path 是 /users/:id，然后匹配的 pathname 是 /user/123 // 那么 params 的返回值就是 &#123;id: &apos;123&apos;&#125; params: keys.reduce((memo, key, index) =&gt; &#123; memo[key.name] = values[index]; return memo; &#125;, &#123;&#125;) &#125; 这些信息将作为匹配的参数传递给 Route 和 Switch（Switch 只是一个代理，它的作用还是渲染 Route，Switch 计算得到的 computedMatch 会传递给要渲染的 Route，此时 Route 将直接使用这个 computedMatch 而不需要再自己来计算）。 在 matchPath 内部 compilePath 时，有个 123const patternCache = &#123;&#125;;const cacheLimit = 10000;let cacheCount = 0; 作为 pathToRegexp 的缓存，因为 ES6 的 import 模块导出的是值的引用，所以将 patternCache 可以理解为一个全局变量缓存，缓存以 {option:{pattern: }} 的形式存储，之后如果需要匹配相同 pattern 和 option 的 path，则可以直接从缓存中获得正则表达式和 keys。 加缓存的原因是路由页面大部分情况下都是相似的，比如要访问 /user/123 或 /users/234，都会使用 /user/:id 这个 path 去匹配，没有必要每次都生成一个新的正则表达式。SPA 在页面整个访问的过程中都维护着这份缓存。 Link实际上我们可能写的最多的就是 Link 这个标签了，我们从它的 render 函数开始看 12345678910111213141516171819202122render() &#123; const &#123; replace, to, innerRef, ...props &#125; = this.props; // eslint-disable-line no-unused-vars invariant( this.context.router, &quot;You should not use &lt;Link&gt; outside a &lt;Router&gt;&quot; ); invariant(to !== undefined, &apos;You must specify the &quot;to&quot; property&apos;); const &#123; history &#125; = this.context.router; const location = typeof to === &quot;string&quot; ? createLocation(to, null, null, history.location) : to; const href = history.createHref(location); // 最终创建的是一个 a 标签 return ( &lt;a &#123;...props&#125; onClick=&#123;this.handleClick&#125; href=&#123;href&#125; ref=&#123;innerRef&#125; /&gt; ); &#125; 可以看到Link 最终还是创建一个 a 标签来包裹住要跳转的元素，但是如果只是一个普通的带 href 的 a 标签，那么就会直接跳转到一个新的页面而不是 SPA 了，所以在这个 a 标签的 handleClick 中会 preventDefault 禁止默认的跳转，所以这里的 href 并没有实际的作用，但仍然可以标示出要跳转到的页面的 URL 并且有更好的 html 语义。 在 handleClick 中，对没有被 “preventDefault 的 &amp;&amp; 鼠标左键点击的 &amp;&amp; 非 _blank 跳转 的&amp;&amp; 没有按住其他功能键的“ 单击进行 preventDefault，然后 push 进 history 中，这也是前面讲过的 —— 路由的变化 与 页面的跳转 是不互相关联的，rr4 在 Link 中通过 history 库的 push 调用了 HTML5 history 的 pushState，但是这仅仅会让路由变化，其他什么都没有改变。还记不记得 Router 中的 listen，它会监听路由的变化，然后通过 context 更新 props 和 nextContext 让下层的 Route 去重新匹配，完成需要渲染部分的更新。 123456789101112131415161718192021handleClick = event =&gt; &#123; if (this.props.onClick) this.props.onClick(event); if ( !event.defaultPrevented &amp;&amp; // onClick prevented default event.button === 0 &amp;&amp; // ignore everything but left clicks !this.props.target &amp;&amp; // let browser handle &quot;target=_blank&quot; etc. !isModifiedEvent(event) // ignore clicks with modifier keys ) &#123; event.preventDefault(); const &#123; history &#125; = this.context.router; const &#123; replace, to &#125; = this.props; if (replace) &#123; history.replace(to); &#125; else &#123; history.push(to); &#125; &#125;&#125;; withRouter1234567891011121314151617181920212223242526const withRouter = Component =&gt; &#123; const C = props =&gt; &#123; const &#123; wrappedComponentRef, ...remainingProps &#125; = props; return ( &lt;Route children=&#123;routeComponentProps =&gt; ( &lt;Component &#123;...remainingProps&#125; &#123;...routeComponentProps&#125; ref=&#123;wrappedComponentRef&#125; /&gt; )&#125; /&gt; ); &#125;; C.displayName = `withRouter($&#123;Component.displayName || Component.name&#125;)`; C.WrappedComponent = Component; C.propTypes = &#123; wrappedComponentRef: PropTypes.func &#125;; return hoistStatics(C, Component);&#125;;export default withRouter; withRouter 的作用是让我们在普通的非直接嵌套在 Route 中的组件也能获得路由的信息，这时候我们就要 WithRouter(wrappedComponent) 来创建一个 HOC 传递 props，WithRouter 的其实就是用 Route 包裹了 SomeComponent 的一个 HOC。 创建 Route 有三种方法，这里直接采用了传递 children props 的方法，因为这个 HOC 要原封不动的渲染 wrappedComponent（children props 比较少用得到，某种程度上是一个内部方法）。 在最后返回 HOC 时，使用了 hoistStatics 这个方法，这个方法的作用是保留 SomeComponent 类的静态方法，因为 HOC 是在 wrappedComponent 的外层又包了一层 Route，所以要将 wrappedComponent 类的静态方法转移给新的 Route，具体参见 Static Methods Must Be Copied Over。 3.理解现在回到一开始的问题，重新理解一下点击一个 Link 跳转的过程。 有两件事需要完成： 路由的改变 页面的渲染部分的改变 过程如下： 在最一开始 mount Router 的时候，Router 在 componentWillMount 中 listen 了一个回调函数，由 history 库管理，路由每次改变的时候触发这个回调函数。这个回调函数会触发 setState。 当点击 Link 标签的时候，实际上点击的是页面上渲染出来的 a 标签，然后通过 preventDefault 阻止 a 标签的页面跳转。 Link 中也能拿到 Router -&gt; Route 中通过 context 传递的 history，执行 hitsory.push(to)，这个函数实际上就是包装了一下 window.history.pushState()，是 HTML5 history 的 API，但是 pushState 之后除了地址栏有变化其他没有任何影响，到这一步已经完成了目标 1：路由的改变。 第 1 步中，路由改变是会触发 Router 的 setState 的，在 Router 那章有写道：每次路由变化 -&gt; 触发顶层 Router 的监听事件 -&gt; Router 触发 setState -&gt; 向下传递新的 nextContext（nextContext 中含有最新的 location） 下层的 Route 拿到新的 nextContext 通过 matchPath 函数来判断 path 是否与 location 匹配，如果匹配则渲染，不匹配则不渲染，完成目标 2：页面的渲染部分的改变。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"VUE","slug":"VUE","permalink":"http://yoursite.com/tags/VUE/"},{"name":"路由","slug":"路由","permalink":"http://yoursite.com/tags/路由/"}]},{"title":"leetcode算法刷题笔记（二）——回溯问题","slug":"leetcode算法刷题笔记（二）——回溯问题","date":"2019-01-15T14:07:43.000Z","updated":"2019-11-10T14:37:39.026Z","comments":true,"path":"2019/01/15/leetcode算法刷题笔记（二）——回溯问题/","link":"","permalink":"http://yoursite.com/2019/01/15/leetcode算法刷题笔记（二）——回溯问题/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯 123456789101112131415161718192021222324252627282930313233var letterCombinations = function(digits) &#123; var res = []; var sort = []; if (digits.length == 0) &#123; return res; &#125; var phone = [ \"0\", \"1\", [\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"], [\"j\", \"k\", \"l\"], [\"m\", \"n\", \"o\"], [\"p\", \"q\", \"r\", \"s\"], [\"t\", \"u\", \"v\"], [\"w\", \"x\", \"y\", \"z\"] ]; finger(0); return res; function finger(index) &#123; if (index == digits.length) &#123; return res.push(sort.join(\"\")); &#125; var temp = phone[digits[index]]; for (var i = 0; i &lt; temp.length; i++) &#123; sort.push(temp[i]); finger(index + 1); sort.pop(); &#125; &#125;&#125;; [22] Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.难度：Medium (53.42%)考点：回溯思路： 给定 n 值，则总共有 n 个左括号，n 个右括号。 第一个添加的一定是左括号。 当添加了一个左括号之后，才会有一个右括号可以添加。所以回溯时，left-1 的同时 right+1 当已添加了 n 个左括号后，剩下的都应该添加右括号 123456789101112131415161718192021var generateParenthesis = function(n) &#123; var res = []; var left = n - 1; var right = 1; function quote(left, right, str) &#123; if (left &lt;= 0) &#123; if (right) &#123; for (var i = 0; i &lt; right; i++) &#123; str = str + \")\"; &#125; &#125; return res.push(str); &#125; quote(left - 1, right + 1, str + \"(\"); if (right &gt; 0) &#123; quote(left, right - 1, str + \")\"); &#125; &#125; quote(left, right, \"(\"); return res;&#125;; [46] PermutationsGiven a collection of distinct integers, return all possible permutations.难度：Medium (53.67%)考点：回溯思路：选择一个元素之后，则下次可选择的元素就少一个。 12345678910111213141516171819202122var permute = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [47] Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations.难度：Medium (39.35%)考点：回溯思路：思路同上题。注意筛选条件。 12345678910111213141516171819202122232425262728var permuteUnique = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; &#123; return a - b; &#125;); select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i - 1]) &#123; continue; &#125; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [60] Permutations II ☆☆The set [1,2,3,…,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:“123”“132”“213”“231”“312”“321”Given n and k, return the k^th permutation sequence.Note:Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.难度：Medium (32.42%)考点：回溯 123456789101112131415161718192021var getPermutation = function(n, k) &#123; (res = []), (pos = k - 1); var nums = []; if (n == 0) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; var numsSort = nums.reduce((a, b) =&gt; a * b); if (k &lt; 1 || k &gt; numsSort) &#123; return \"error\"; &#125; for (var j = n; j &gt;= 1; --j) &#123; numsSort /= j; res.push(nums.splice(parseInt(pos / numsSort), 1)[0]); pos %= numsSort; &#125; return res.join(\"\");&#125;; [77] ombinations ☆☆Given two integers n and k, return all possible combinations of k numbers out of 1 … n.难度：Medium (46.23%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件 12345678910111213141516171819202122232425262728var combine = function(n, k) &#123; var nums = []; var res = []; var temp = []; if (n == 0 || k &lt;= 0 || k &gt; n) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; select(0, nums); return res; function select(start, nums) &#123; if (temp.length == k) &#123; return res.push(temp.slice()); &#125; for (var i = start; i &lt; n; i++) &#123; if (temp.length &gt;= 1 &amp;&amp; temp[temp.length - 1] &gt; i) &#123; continue; &#125; temp.push(nums[i]); select(start + 1, nums); temp.pop(); &#125; &#125;&#125;; [78] SubsetsGiven a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (51.26%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件。 123456789101112131415161718192021222324252627282930313233var subsets = function(nums) &#123; var res = []; var subsets = []; var used = []; res.push(subsets.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var j = 1; j &lt;= nums.length; j++) &#123; findSubsets(0, j); &#125; return res; function findSubsets(start, k) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (subsets.length == k) &#123; return res.push(subsets.slice()); &#125; if (used[i]) &#123; continue; &#125; if (start &gt; 0 &amp;&amp; nums[i] &lt; subsets[subsets.length - 1]) &#123; continue; &#125; subsets.push(nums[i]); used[i] = true; findSubsets(start + 1, k); subsets.pop(); used[i] = false; &#125; &#125;&#125;; [79] Word SearchGiven a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.难度：Medium (30.52%)考点：回溯思路：要分四个方向分别回溯。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var exist = function(board, word) &#123; var row = board.length; var col = board[0].length; if (word.length &gt; row * col) &#123; return false; &#125; function search(i, j, n) &#123; if ( i &gt;= row || j &gt;= col || i &lt; 0 || j &lt; 0 || board[i][j] != word[n] || n &gt; word.length ) &#123; return false; &#125; if (n == word.length - 1) &#123; return true; &#125; board[i][j] = true; if (search(i + 1, j, n + 1)) &#123; return true; &#125; if (search(i - 1, j, n + 1)) &#123; return true; &#125; if (search(i, j + 1, n + 1)) &#123; return true; &#125; if (search(i, j - 1, n + 1)) &#123; return true; &#125; board[i][j] = word[n]; return false; &#125; for (var i = 0; i &lt; row; i++) &#123; for (var j = 0; j &lt; col; j++) &#123; if (search(i, j, 0)) &#123; return true; &#125; &#125; &#125; return false;&#125;; [89] Gray Code ☆☆The gray code is a binary numeral system where two successive values differ in only one bit.Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.难度：Medium (45.03%)考点：回溯思路：可根据格雷码的特性考虑解法一（普通解法）： 123456789101112131415161718192021222324252627282930var grayCode = function(n) &#123; var result = []; var graycodeFn = function(n) &#123; var graycode = []; if (n == 1) &#123; graycode[0] = \"0\"; graycode[1] = \"1\"; return graycode; &#125; var last = arguments.callee(n - 1); // arguments.callee(n-1) == graycodeFn(n-1) for (var i = last.length - 1; i &gt;= 0; --i) &#123; graycode.unshift(\"0\" + last[i]); graycode.push(\"1\" + last[i]); &#125; return graycode; &#125;; var graycode = n == 0 ? [\"0\"] : graycodeFn(n); for (var i = 0; i &lt; graycode.length; ++i) &#123; result.push(parseInt(parseInt(graycode[i], 2), 10)); // String To Number &#125; return result;&#125;; 解法二（大神解法）： 1234567var grayCode = function(n) &#123; let nums = [0], c = -1; while (c++ &lt; n - 1) nums = [...nums, ...nums.map(num =&gt; num + Math.pow(2, c)).reverse()]; return nums;&#125;; [90] Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (41.57%)考点：回溯 12345678910111213141516171819202122232425262728var subsetsWithDup = function(nums) &#123; var sub = []; var res = []; res.push(sub.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var i = 1; i &lt;= nums.length; i++) &#123; findSub(0, i); &#125; return res; function findSub(start, k) &#123; if (sub.length == k) &#123; return res.push(sub.slice()); &#125; for (var j = start; j &lt; nums.length; j++) &#123; if (j &gt; start &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; sub.push(nums[j]); findSub(j + 1, k); sub.pop(); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"}]},{"title":"浏览器内核","slug":"浏览器内核","date":"2019-01-07T13:07:44.000Z","updated":"2019-11-10T14:37:39.037Z","comments":true,"path":"2019/01/07/浏览器内核/","link":"","permalink":"http://yoursite.com/2019/01/07/浏览器内核/","excerpt":"浏览器内核浏览器内核有哪几种？Trident：IE（Internet Explorer），由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大。 但是由于微软长时间没有更新 Trident 内核，则导致了两个后果：一是 Trident 内核曾经几乎与 W3C 标准脱节（2005 年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器。","text":"浏览器内核浏览器内核有哪几种？Trident：IE（Internet Explorer），由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大。 但是由于微软长时间没有更新 Trident 内核，则导致了两个后果：一是 Trident 内核曾经几乎与 W3C 标准脱节（2005 年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器。 Trident 内核常见浏览器（1）IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）； （2）猎豹安全浏览器：1.0-4.2 版本为 Trident+Webkit，4.3 版本为 Trident+Blink； （3）360 安全浏览器 ：1.0-5.0 为 Trident，6.0 为 Trident+Webkit，7.0 为 Trident+Blink； （4）360 极速浏览器：7.5 之前为 Trident+Webkit,7.5 为 Trident+Blink； （5）傲游浏览器 ：傲游 1.x、2.x 为 IE 内核，3.x 为 IE 与 Webkit 双核； （6）搜狗高速浏览器：1.x 为 Trident，2.0 及以后版本为 Trident+Webkit； 兼容模式国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 EdgeHTML 内核Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 Gecko ([‘gekəʊ])开源内核Gecko(Firefox 内核)：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。 Firefox 内核事实上，Gecko 引擎的由来跟 IE 不无关系，前面说过 IE 没有使用 W3C 的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape 的一些员工一起创办了 Mozilla，以当时的 Mosaic 内核为基础重新编写内核，于是开发出了 Gecko。不过事实上，Gecko 内核的浏览器仍然还是 Firefox (火狐) 用户最多，所以有时也会被称为 Firefox 内核。此外 Gecko 也是一个跨平台内核，可以在 Windows、 BSD、Linux 和 Mac OS X 中使用。 WebkitSafari 浏览器只要提到 Webkit，大多数人立马想到的必然是 Chrome，结果导致如今有了把 webkit 称为 chrome 内核的错误说法，即使 chrome 的内核已经是 blink，其实 Webkit 的祖先是 Safari，也就是苹果系列产品的专属浏览器。 WebKit 是 KHTML 的分支WebKit 的前身是苹果公司使用 KDE（Linux 桌面系统）开发的 KHTML 开源引擎，可以说 WebKit 是 KHTML 的一个开源分支。 Chromium/BlinkChromium Fork webkit2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。chromium fork 自开源引擎 webkit，并提高了 WebKit 的代码可读性和编译速度。 V8 引擎谷歌公司还研发了自己的 Javascript 引擎，V8，极大地提高了 Javascript 的运算速度。 Blink 是 WebKit 的分支Google 的 Chromium 项目最初一直使用 WebKit(WebCore) 作为渲染引擎，但由于后来苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发）。 Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入 Webkit。 后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。 基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。这样以来，唯一一条维系 Google 和苹果之间技术关系的纽带就这样被切断了。 Presto ([‘prestəʊ])Opera 浏览器Presto 是 Opera 自主研发的渲染引擎，然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎。 在 Chrome 于 2013 年推出 Blink 引擎之后，Opera 也紧跟其脚步表示将转而使用 Blink 作为浏览器核心引擎。 移动端移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。 1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。 2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android 4.4 系统浏览器切换到了 Chromium，内核是 Webkit 的分支 Blink。 3、Windows Phone 8 系统浏览器内核是 Trident。 webkit 内核了解多少？（chrome 内核是 b-link）深入剖析 webkit 微信 x5 内核和别的内核有什么差别？（x5 是基于 webkit 的）认识 X5 腾讯基于优秀开源 Webkit 深度优化的浏览器渲染引擎 为抹平不同 Android 版本不同 Webview 的坑而生。但本身也带来了许多坑。 虽然官方不承认，但实际上它是基于 Chromuim 开源项目的。 webkit 内核以及 blink 内核在 x5 的使用情况 QQ 浏览器：6.2 版本及以后使用 blink 内核。 X5 tbs 1.x：版本号为 02xxxx，使用 webkit 内核。 X5 tbs 2.x：版本号为 03xxxx。使用 blink 内核。 拓展：Webkit &amp; Chromuim &amp;Chrome &amp; Blink WebKit是一个开源的项目，其前身是来源于 KDE 的 KHTML 和 KJS。该项目专注于网页内容的展示，开发出一流的网页渲染引擎。 Chromium是一个建立在 WebKit 之上的浏览器开源项目，由 Google 发起的。 ** Chrome**是 Google 公司的浏览器产品，它基于 chromium 开源项目。可以理解为，内核是开源的，UI 是闭源的。 Blink是 Google 退出 WebKit 项目，从而自己创建的渲染引擎。但并不是全新的引擎，Blink 目前就是从 WebKit 直接复制出一个版本出来，然后将与 chromium 无关的 Ports 全部移除掉，将代码结构重新整理，就目前而言，Blink 的渲染和 WebKit 是一样，但是，以后两者将各自走不同的路。 X5 升级了截至 16 年 4 月份，x5 升级全量发布。TBS2.0 基于 Android 5.0 WebView Blink 内核（M37 版本）适配定制优化，适配 Android 全部主流平台，可以在所有 Android 手机上使用 Blink 的技术能力。具有更好的 H5/CSS3 支持和性能。TBS2.0 已经发布，将逐步在各客户端中静默升级，无需更新微信、手机 QQ、QQ 空间即可使用最新的 TBS2.0 Blink 内核。 更简洁地说，即是： 基于 Blink 内核（chrome 37 版本） 适用于 Android 全部主流平台 静默升级 PS：iOS 版本的微信 Web View 一直是 WKWebView 内核，WKWebView 的版本依赖于 iOS 的系统版本。 TBS2.0 内核详情 BLINK 版本: 基于 Chrome 37 HTML 版本: HTML5.0 XHTML 版本: xHTML Basic 1.0 | xHTML1.1 SVG 版本: SVG1.2 WML 版本: Wml 1.0 CSS 版本: CSS3 Spdy 版本: 3.1 支持的 JavaScript 版本: Ecma5 Changelog 以及 解读1.内核从 Webkit 升级至 Blink，拥有更好的支持 那么哪里可以查阅兼容性呢？ X5 CanIUse 2.内核版本号升级到 362xx 版本。可以根据 UserAgent判断当前环境是否已升级到 TBS2.0 版本,包含（TBS/03xxxx）字段。 那么怎么查看自己微信里的 TBS 版本？ 用微信打开这个页面，检查 TBS 的版本号，0362xx 表示已更新。页面的代码只有两句，为： 123// 检测页面的核心代码var resultDiv = document.getElementById(\"result\");resultDiv.innerHTML = window.navigator.userAgent; 3.CSS3 属性支持增强： 完整支持 flex 伪元素支持动画效果 filter: blur 有模糊效果 PS：更多更具体的支持情况可查阅这里 4.autoplay 属性有效，可自动播放 5.canvas 支持设置背景色 6.标准的缓存策略，支持 Spdy 3.1 7.动画性能提升 8.更好的 inspector 支持 微信远程调试解决方案——微信 web 开发者工具 手机 QQ 浏览器的远程调试解决方案 参考资料： 解读微信全面升级 X5 Blink 内核，H5 游戏行业重大利好 官方网站：腾讯浏览服务－技术指南 总结常用工具 检测是否为 x5－TBS/03xxxx x5 的各项支持情况－X5 CanIUse Android 下微信远程调试工具-微信 web 开发者工具（PS:iOS 下使用 Safari 远程调试即可） 我们可以从中了解到什么一、工具方面： 可以通过查询 UA 来检测是否为 X5－TBS/03xxxx，在线检测地址 想知道某个 CSS3 属性，或者其他 API 在 X5 是否支持的时候，可以查询X5 CanIUse 远程调试微信内页面时，在 Android 下可以使用微信远程调试工具-微信 web 开发者工具，在 iOS 下使用 Safari 远程调试即可。 二、对于开发调试页面 目前，暂时还没有查找到 X5 在微信 android 客户端的版本分布情况的数据(可能是由于 X5 tbs2.0 是今年 4 月份初才开始全量发布的)。 虽然说，X5 是静默升级，无需用户手动更新，基本上都实现升级为最新版本(业界说法)，但仍存在 X5 内核是旧版本的情况(根据是部分测试的检测 UA 结果)。希望能够在后续的日子可以获取到相关的数据。 手机同时安装了 QQ 浏览器和微信，但 QQ 浏览器内核版本不等于微信内核版本，只有在 QQ 浏览器内核为大于等于 6.2 版本才是 Blink 内核，调试页面的结果才可以替代在微信内页面调试的结果（想要不登陆微信用 QQ 浏览器来替代调试的需要注意下 X5 的版本分布情况据腾讯内部的小伙伴告知，x5 内核基本覆盖理论上达到 100%，但难免会有漏网之鱼。而根据实际数据抽样整理显示，截至 2016 年 5 月 19 日，x5 内核基本覆盖率达到 91.47%。 X5 问题汇总","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"leetcode算法刷题笔记（一）——数组","slug":"leetcode算法刷题笔记（一）——数组","date":"2018-12-18T16:07:06.000Z","updated":"2019-11-10T14:37:39.025Z","comments":true,"path":"2018/12/19/leetcode算法刷题笔记（一）——数组/","link":"","permalink":"http://yoursite.com/2018/12/19/leetcode算法刷题笔记（一）——数组/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断 1234567891011var twoSum = function(nums, target) &#123; var map = &#123;&#125;; for (i = 0; i &lt; nums.length; i++) &#123; const complement = target - nums[i]; if (complement in map) &#123; return [i, map[complement]]; &#125; map[nums[i]] = i; &#125; return -1;&#125;; [11] Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2.难度：Medium (42.93%)考点：动态规划思路： 设定 i，j 分别指向数组的头和尾 比较 i，j 所对应的位置的值，值较小的那一个移动（i++或 j–） 123456789101112131415161718var maxArea = function(height) &#123; var maxArea = 0; var i = 0; var j = height.length - 1; while (i &lt; j) &#123; const long = Math.min(height[i], height[j]); const area = long * (j - i); if (area &gt; maxArea) &#123; maxArea = area; &#125; if (height[i] &lt; height[j]) &#123; i++; &#125; else &#123; j--; &#125; &#125; return maxArea;&#125;; [15] 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.难度：Medium (23.55%)思路： 数组排序（升序） 设定三个指针，最外层循环从 0 开始，到数组的尾结束（i=0） 第二层循环，一个指向上一个指针的下一个元素（j=i+1），另一个指向数组的尾部(k=nums.length-1) 如果三个元素之和等于 0，则 push 进要返回的数组中；如果三个元素之和大于 0，说明第三个指针指向的元素过大，则第三个指针向前移(k–);如果三个元素之和小于 0，说明第二个指针指向的元素过小，则第二个指针向后移(j++); 123456789101112131415161718192021222324252627282930313233343536var threeSum = function(nums) &#123; var rtn = []; if (nums.length &lt; 3) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; 0) &#123; return rtn; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === 0) &#123; rtn.push([nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; 0) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return rtn;&#125;; [16] 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.难度：Medium (41.40%)思路：与上题类似 12345678910111213141516171819202122232425262728var threeSumClosest = function(nums, target) &#123; var sum; if (nums.length &lt; 3) &#123; return sum; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); var sum = nums[0] + nums[1] + nums[2]; var distance = Math.abs(sum - target); for (var i = 0; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (Math.abs(nums[i] + nums[j] + nums[k] - target) &lt; distance) &#123; sum = nums[i] + nums[j] + nums[k]; distance = Math.abs(sum - target); &#125; if (nums[i] + nums[j] + nums[k] === target) &#123; break; &#125; if (nums[i] + nums[j] + nums[k] &gt; target) &#123; k--; &#125; else if (nums[i] + nums[j] + nums[k] &lt; target) &#123; j++; &#125; &#125; &#125; return sum;&#125;; [18] 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.难度：Medium (29.83%)思路：思路同 3Sum，多一层循环。注意跳过相同的数（最外两层的循环变量） 1234567891011121314151617181920212223242526272829303132333435363738var fourSum = function(nums, target) &#123; var rtn = []; if (nums.length &lt; 4) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var m = 0; m &lt; nums.length - 3; m++) &#123; var complement = target - nums[m]; for (var i = m + 1; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === complement) &#123; rtn.push([nums[m], nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; complement) &#123; k--; &#125; else &#123; j++; &#125; if (i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; ++i; &#125; &#125; if (m &lt; nums.length - 1 &amp;&amp; nums[m] == nums[m + 1]) &#123; ++m; &#125; &#125; &#125; return rtn;&#125;; [26] Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.难度：Easy (39.80%)思路：两个指针，一个指针负责寻找和后一个不相等的数，另一个指针负责一步步向后移去重。 1234567891011121314151617181920var removeDuplicates = function(nums) &#123; if (nums.length == 0) &#123; return 0; &#125; var i = 0; var j = 0; for (i = 0; i &lt; nums.length - 1; ) &#123; if (nums[i] === nums[i + 1]) &#123; i++; &#125; else &#123; if (i !== j) &#123; nums[j + 1] = nums[i + 1]; &#125; j++; i++; &#125; &#125; nums = nums.slice(0, j + 1); return nums.length;&#125;; [27] Remove ElementGiven an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length.难度：Easy (43.73%)思路：找到和 val 值相等的位置，将数组最后一个元素赋值过来（去掉这个 val，数组长度减一） 12345678910111213var removeElement = function(nums, val) &#123; var i = 0; var n = nums.length; for (i = 0; i &lt; n; ) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; n--; &#125; else &#123; i++; &#125; &#125; return n;&#125;; [31] Next PermutationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place and use only constant extra memory.Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1难度：Medium (30.09%)思路： 从后向前比较相邻的两个元素，直到前一个元素小于后一个元素，停止（i）。 若已经没有了前一个元素（i=0），则该序列为递减序列，没有 Next Permutation。按照题目要求，直接反转序列。 前一个元素（j=i-1）小于后一个元素（i），找到前一个元素（j）要交换的元素，从 i 的后一个元素开始往后查找，找到最后一个比“前一个元素（j）”大的元素（k），也就是再往后的元素，就比元素 j 小了。交换 j 和 k 元素。 从 i 开始，包括 i 到序列的尾部，反转。则得出的即是 Next Permutation 1234567891011121314151617181920212223var nextPermutation = function(nums) &#123; var i = nums.length - 1; while (nums[i] &lt;= nums[i - 1]) &#123; i--; &#125; if (i !== 0) &#123; var j = i - 1; var k = i + 1; while (nums[j] &lt; nums[k]) &#123; k++; &#125; var temp = nums[k - 1]; nums[k - 1] = nums[j]; nums[j] = temp; for (var m = i, n = nums.length - 1; m &lt; n; m++, n--) &#123; var temp = nums[n]; nums[n] = nums[m]; nums[m] = temp; &#125; &#125; else &#123; nums = nums.reverse(); &#125;&#125;; [33] Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.Your algorithm’s runtime complexity must be in the order of O(log n).难度：Medium (32.68%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627var search = function(nums, target) &#123; if (nums.length == 0) &#123; return -1; &#125; var start = 0; var end = nums.length - 1; while (start &lt;= end) &#123; var middle = parseInt((start + end) / 2); if (nums[middle] == target) &#123; return middle; &#125; if (nums[middle] &gt; nums[end]) &#123; if (target &gt;= nums[start] &amp;&amp; target &lt; nums[middle]) &#123; end = middle - 1; &#125; else &#123; start = middle + 1; &#125; &#125; else &#123; if (target &gt; nums[middle] &amp;&amp; target &lt;= nums[end]) &#123; start = middle + 1; &#125; else &#123; end = middle - 1; &#125; &#125; &#125; return -1;&#125;; [34] Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].难度：Medium (33.06%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627282930var searchRange = function(nums, target) &#123; if (nums.length == 0) &#123; return [-1, -1]; &#125; var startFind = 0; var endFind = nums.length - 1; var start; var end; while (startFind &lt;= endFind) &#123; var mid = parseInt((startFind + endFind) / 2); if (nums[mid] == target) &#123; start = mid; end = mid; while (nums[start - 1] == target || nums[end + 1] == target) &#123; if (nums[start - 1] == target) &#123; start--; &#125; if (nums[end + 1] == target) &#123; end++; &#125; &#125; return [start, end]; &#125; else if (nums[mid] &lt; target) &#123; startFind = mid + 1; &#125; else &#123; endFind = mid - 1; &#125; &#125; return [-1, -1];&#125;; [35] Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.难度：Easy (40.50%) 123456789101112var searchInsert = function(nums, target) &#123; if (nums.length == 0) &#123; return 0; &#125; let out = nums.indexOf(target); if (out == -1) &#123; let i = 0; for (; target &gt; nums[i]; i++) &#123;&#125; out = i; &#125; return out;&#125;; [39] Combination SumGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (46.97%)考点：递归 12345678910111213141516171819202122232425262728var combinationSum = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); sarch(0, target); function sarch(start, target) &#123; if (start == candidates.length) &#123; return; &#125; if (target == 0) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0) &#123; return; &#125; solution.push(candidates[start]); sarch(start, target - candidates[start]); solution.pop(); sarch(start + 1, target); &#125; return rt;&#125;; [40] Combination Sum IIGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.Each number in candidates may only be used once in the combination.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (40.37%)考点：递归注意：限制边界条件，过滤重复的结果 12345678910111213141516171819202122232425262728var combinationSum2 = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); search(0, target); return rt; function search(start, target) &#123; if (target === 0 &amp;&amp; start === candidates.length) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0 || start === candidates.length) &#123; return; &#125; solution.push(candidates[start]); search(start + 1, target - candidates[start]); solution.pop(); if (solution[solution.length - 1] !== candidates[start]) &#123; search(start + 1, target); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"LeetCode","slug":"LeetCode","permalink":"http://yoursite.com/tags/LeetCode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"webpack基础知识（二）","slug":"webpack基础知识（二）","date":"2018-12-05T07:12:28.000Z","updated":"2019-09-21T14:06:57.241Z","comments":true,"path":"2018/12/05/webpack基础知识（二）/","link":"","permalink":"http://yoursite.com/2018/12/05/webpack基础知识（二）/","excerpt":"代码分离代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。","text":"代码分离代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。 入口起点(entry points)问题： 如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中。 这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。 防止重复(prevent duplication)CommonsChunkPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。使用这个插件，可将重复的 lodash 模块去除。需要注意的是，CommonsChunkPlugin 插件将 lodash 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小。 以下是由社区提供的，一些对于代码分离很有帮助的插件和 loaders： ExtractTextPlugin: 用于将 CSS 从主应用程序中分离。 bundle-loader: 用于分离代码和延迟加载生成的 bundle。 promise-loader: 类似于 bundle-loader ，但是使用的是 promises。 CommonsChunkPlugin 插件还可以通过使用显式的 vendor chunks 功能，从应用程序代码中分离 vendor 模块。 动态导入(dynamic imports)当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。 懒加载懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。 缓存我们使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的 /dist 目录，然后把打包后的内容放置在此目录中。只要 /dist 目录中的内容部署到服务器上，客户端（通常是浏览器）就能够访问网站此服务器的网站及其资源。而最后一步获取资源是比较耗费时间的。因此我们使用缓存技术。以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。所以需要通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。 输出文件的文件名(Output Filenames)通过使用 output.filename 进行文件名替换，可以确保浏览器获取到修改后的文件。[hash] 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 [chunkhash] 替换，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。 提取模板(Extracting Boilerplate)CommonsChunkPlugin 可以用于将模块分离到单独的文件中，还能够在每次修改后的构建结果中，将 webpack 的样板(boilerplate)和 manifest 提取出来。通过指定 entry 配置中未用到的名称，此插件会自动将我们需要的内容提取到单独的包中： 12345678910111213141516171819202122const path = require('path');+ const webpack = require('webpack'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; entry: './src/index.js', plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123; title: 'Caching'- &#125;)+ &#125;),+ new webpack.optimize.CommonsChunkPlugin(&#123;+ name: 'manifest'+ &#125;) ], output: &#123; filename: '[name].[chunkhash].js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用客户端的长效缓存机制，可以通过命中缓存来消除请求，并减少向服务器获取资源，同时还能保证客户端代码和服务器端代码版本一致。 模块标识符(Module Identifiers)每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。 可以使用两个插件来解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建。 library可以通过以下方式暴露 library： 变量：作为一个全局变量，通过 script 标签来访问（libraryTarget:’var’）。 this：通过 this 对象访问（libraryTarget:’this’）。 window：通过 window 对象访问，在浏览器中（libraryTarget:’window’）。 UMD：在 AMD 或 CommonJS 的 require 之后可访问（libraryTarget:’umd’）。如果设置了 library 但没设置 libraryTarget，则 libraryTarget 默认为 var shimming一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 $）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方。 shimming 全局变量使用 ProvidePlugin 后，能够在通过 webpack 编译的每个模块中，通过访问一个变量来获取到 package 包。如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package。我们还可以使用 ProvidePlugin 暴露某个模块中单个导出值，只需通过一个“数组路径”进行配置（例如 [module, child, …children?]） src/index.js 12345678910 function component() &#123; var element = document.createElement('div');- element.innerHTML = _.join(['Hello', 'webpack'], ' ');+ element.innerHTML = join(['Hello', 'webpack'], ' '); return element; &#125; document.body.appendChild(component()); webpack.config.js 12345678910111213141516 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ new webpack.ProvidePlugin(&#123;- _: 'lodash'+ join: ['lodash', 'join'] &#125;) ] &#125;; 这样，无论 join 方法在何处调用，我们都只会得到的是 lodash 中提供的 join 方法。与 tree shaking 配合，能够很好的将 lodash 库中的其他没用到的部分去除。 细粒度 shimming一些传统的模块依赖的 this 指向的是 window 对象。当模块运行在 CommonJS 环境下这将会变成一个问题，也就是说此时的 this 指向的是 module.exports。此时，可以通过使用 imports-loader 覆写 this： 1234567891011121314151617181920212223 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: require.resolve('index.js'),+ use: 'imports-loader?this=&gt;window'+ &#125;+ ]+ &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 全局 exports使用 exports-loader，将一个全局变量作为一个普通的模块来导出。 12345678910111213141516171819202122232425262728 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: require.resolve('index.js'), use: 'imports-loader?this=&gt;window'- &#125;+ &#125;,+ &#123;+ test: require.resolve('globals.js'),+ use: 'exports-loader?file,parse=helpers.parse'+ &#125; ] &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 渐进式网络应用程序渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的。 添加 Workbox 注册 Service Worker 停止服务器并刷新页面。如果浏览器能够支持 Service Worker，你应该可以看到你的应用程序还在正常运行。然而，服务器已经停止了服务，此刻是 Service Worker 在提供服务。 构建性能chunks减少编译的整体大小，以提高构建性能。尽量保持 chunks 小巧。 使用 更少/更小 的库。 在多页面应用程序中使用 CommonsChunksPlugin。 在多页面应用程序中以 async 模式使用 CommonsChunksPlugin 。 移除不使用的代码。 只编译你当前正在开发部分的代码。 最小化入口 chunkwebpack 只会在文件系统中生成已经更新的 chunk 。对于某些配置选项(HMR, [name]/[chunkhash] in output.chunkFilename, [hash])来说，除了更新的 chunks 无效之外，入口 chunk 也不会生效。应当在生成入口 chunk 时，尽量减少入口 chunk 的体积，以提高性能。下述代码块将只提取包含 runtime 的 chunk ，其他 chunk 都作为子模块: 1234new CommonsChunkPlugin(&#123; name: \"manifest\", minChunks: Infinity&#125;); Worker Poolthread-loader 可以将非常消耗资源的 loaders 转存到 worker pool 中 持久化缓存使用 cache-loader 启用持久化缓存。使用 package.json 中的 “postinstall” 清除缓存目录。 Dlls使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。 公共路径(public path)webpack 提供一个非常有用的配置，该配置能帮助你为项目中的所有资源指定一个基础路径。它被称为公共路径(publicPath)。webpack 提供一个全局变量供你设置，它名叫 webpack_public_path 1__webpack_public_path__ = process.env.ASSET_PATH;","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识（一）","slug":"webpack基础知识（一）","date":"2018-11-25T04:03:08.000Z","updated":"2019-09-21T14:26:18.053Z","comments":true,"path":"2018/11/25/webpack基础知识（一）/","link":"","permalink":"http://yoursite.com/2018/11/25/webpack基础知识（一）/","excerpt":"基本概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的，会以正确顺序执行的 bundle。","text":"基本概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的，会以正确顺序执行的 bundle。 依赖图(dependency graph)任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有 依赖关系 。这使得 webpack 可以接收非代码资源(non-code asset)（例如图像或 web 字体），并且可以把它们作为 依赖 提供给你的应用程序。 webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些 入口起点 开始，webpack 递归地构建一个 依赖图 ，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载。 入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 123module.exports = &#123; entry: \"./path/to/my/entry/file.js\"&#125;; 入口配置支持： 单个入口语法注：向 entry 传入一个「文件路径(file path)数组」时将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。 对象语法这是应用程序中定义入口的最可扩展的方式。 出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 123456789const path = require(\"path\");module.exports = &#123; entry: \"./path/to/my/entry/file.js\", output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"my-first-webpack.bundle.js\" &#125;&#125;; filename 用于输出文件的文件名。目标输出目录 path 的绝对路径。 注：如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 设定 HtmlWebpackPlugin，虽然在 dist/ 文件夹我们已经有 index.html 这个文件，然而 HtmlWebpackPlugin 还是会默认生成 index.html 文件。这就是说，它会用新生成的 index.html 文件，把我们的原来的替换。 使用 source map当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112const path = require(\"path\");const config = &#123; output: &#123; filename: \"my-first-webpack.bundle.js\" &#125;, module: &#123; rules: [&#123; test: /\\.txt$/, use: \"raw-loader\" &#125;] &#125;&#125;;module.exports = config; 在你的应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览 内联：在每个 import 语句中显式指定 loader。可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 CLI：在 shell 命令中指定它们。 loader 特性： loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 插件(plugins)loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。插件目的在于解决 loader 无法实现的其他事。 1234567891011const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // 通过 npm 安装const webpack = require(\"webpack\"); // 用于访问内置插件const config = &#123; module: &#123; rules: [&#123; test: /\\.txt$/, use: \"raw-loader\" &#125;] &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: \"./src/index.html\" &#125;)]&#125;;module.exports = config; 用法：用 require（）引入由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 模式提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。通过选择 development 或 production 之中的一个，来设置 mode 参数，可以启用相应模式下的 webpack 内置的优化 用法： 只在配置中提供 mode 选项： 123module.exports = &#123; mode: \"production\"&#125;; 从 CLI 参数中传递： 1webpack --mode=production 模块热替换(hot module replacement)模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 tree shaking通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。 如果所有代码都不包含副作用，我们就可以简单地将 package.json 的 “sideEffects” 属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。注：「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。 如果你的代码确实有一些副作用，那么可以改为提供一个数组： 123456&#123; \"name\": \"your-project\", \"sideEffects\": [ \"./src/some-side-effectful-file.js\" ]&#125; 数组方式支持相关文件的相对路径、绝对路径和 glob 模式。它在内部使用 micromatch。 注意，任何导入的文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 css-loader 并导入 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除。 从 webpack 4 开始，也可以通过 “mode” 配置选项轻松切换到压缩输出，只需设置为 “production”。","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"React组件","slug":"React组件","date":"2018-11-11T04:10:52.000Z","updated":"2019-11-10T14:37:39.023Z","comments":true,"path":"2018/11/11/React组件/","link":"","permalink":"http://yoursite.com/2018/11/11/React组件/","excerpt":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上）","text":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上） 自动绑定每个方法的上下文都会指向该组件的实例——自动绑定 this 为当前组件。React 会对这种引用进行缓存，达到 CPU 内存最优。（使用 ES6 class 或纯函数时，自动绑定不复存在，需要手动绑定 this） bind 绑定绑定事件处理器内的 this，并可以向事件处理器中传参 构造器内声明好处：仅需进行一次绑定 箭头函数箭头函数自动绑定了定义此函数作用域的 this，因此不需要再用 bind 绑定 注意：React 中使用 DOM 原生事件，一定要在组件卸载时手动移除，否则内存泄漏。使用合成事件则不需要。 React 合成事件与 JS 原生事件对比原生 DOM 事件传播 3 个阶段：事件捕获阶段、目标对象本身的事件处理程序调用，以及事件冒泡。 事件捕获阶段会优先调用结构树最外层的元素上绑定的事件侦听器，依次向内调用，一直调用到目标元素上的事件监听器为止。 1e.addEventListener(\"click\", () =&gt; &#123;&#125;, false); 第三个参数，若传 true，为元素 e 注册捕获事件处理程序，并且在事件捕获阶段调用。 事件冒泡与事件捕获相反，它会从目标元素向外传播，由内而外。React 的合成事件仅支持事件冒泡阻止原生事件冒泡用 e.preventDefault() React 受控组件更新 state 的流程 可以通过在初始 state 中设置表单的默认值 每当表单的值发生变化时，调用 onchange 事件处理器 事件处理器通过合成事件对象 e 拿到改变后的状态，并更行应用的 state setState 触发视图的重新渲染，完成表单的组件值更新 React 非受控组件是一种反模式，他的值不受组件自身的 state 或 props 控制。通常需要为其添加 ref prop 来访问渲染后的底层 DOM","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"浏览器缓存位置","slug":"浏览器缓存位置","date":"2018-11-01T15:10:55.000Z","updated":"2019-11-10T14:37:39.038Z","comments":true,"path":"2018/11/01/浏览器缓存位置/","link":"","permalink":"http://yoursite.com/2018/11/01/浏览器缓存位置/","excerpt":"浏览器缓存位置缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache","text":"浏览器缓存位置缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1.Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 2.Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源, 例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快, 内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如&lt;link rel=&quot;prefetch&quot;&gt;）下载的资源。众所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。 3.Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先； 当前系统内存使用率高的话，文件优先存储进硬盘。 4.Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存, 但是 Edge 和 Safari 浏览器支持相对比较差； 可以推送 no-cache 和 no-store 的资源； 一旦连接被关闭，Push Cache 就被释放； 多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接； Push Cache 中的缓存只能被使用一次； 浏览器可以拒绝接受已经存在的资源推送； 你可以给其他域名推送资源。 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 http 状态码与缓存策略200 from memory cache不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当 kill 进程后，也就是浏览器关闭以后，数据将不存在。 但是这种方式只能缓存派生资源 200 from disk cache不访问服务器，直接读缓存，从磁盘中读取缓存，当 kill 进程时，数据还是存在。 这种方式也只能缓存派生资源 304 Not Modified访问服务器，发现数据没有 更新，服务器返回此状态码。然后从缓存中读取数据。 三级缓存原理 先去内存看，如果有，直接加载 如果内存没有，择取硬盘获取，如果有直接加载 如果硬盘也没有，那么就进行网络请求 加载到的资源缓存到硬盘和内存 常见缓存情况 第一个现象： 访问-&gt; 200 -&gt; 退出浏览器 再进来-&gt; 200(from disk cache) -&gt; 刷新 -&gt; 200(from memory cache) 总结: 会不会是 chrome 很聪明的判断既然已经从 disk 拿来了， 第二次就内存拿吧 快。（笑哭) 第二个现象: 只要图片是 base64 都是 from memroy cache。 总结: 解析渲染图片这么费劲的事情，还是做一次然后放到内存吧。 用的时候直接拿 第三个现象(以 js css 为例): 个人在做静态测试的发现，大型的 js css 文件都是直接 disk cache 总结: chrome 会不会说 我擦 你这么大 太 JB 占地方了。 你就去硬盘里呆着吧。 慢就慢点吧。 第四个现象: 隐私模式下，几乎都是 from memroy cache. 总结: 隐私模式 是吧。 我不能暴露你东西。还是放到内存吧。 你关，我死。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"}]},{"title":"Proxy","slug":"Proxy","date":"2018-10-27T03:07:46.000Z","updated":"2019-11-10T14:37:39.021Z","comments":true,"path":"2018/10/27/Proxy/","link":"","permalink":"http://yoursite.com/2018/10/27/Proxy/","excerpt":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。","text":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。 下面是一个拦截读取属性行为的例子。 123456789101112var proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125; &#125;);proxy.time; // 35proxy.name; // 35proxy.title; // 35 上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。注意，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。如果 handler 没有设置任何拦截，那就等同于直接通向原对象。同一个拦截器函数，可以设置拦截多个操作。 12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === \"prototype\") &#123; return Object.prototype; &#125; return \"Hello, \" + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123; value: args[1] &#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2); // 1new fproxy(1, 2); // &#123;value: 2&#125;fproxy.prototype === Object.prototype; // truefproxy.foo === \"Hello, foo\"; // true Proxy 支持的拦截操作一览Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。 set(target, propKey, value, receiver)拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)拦截 propKey in proxy 的操作，返回一个布尔值。 deleteProperty(target, propKey)拦截 delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)拦截 Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)拦截 Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)拦截 Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例），其中最后一个参数可选。 12345678910111213141516var person = &#123; name: \"张三\"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError('Property \"' + property + '\" does not exist.'); &#125; &#125;&#125;);proxy.name; // \"张三\"proxy.age; // 抛出一个错误 get 方法可以继承。 123456789101112let proto = new Proxy( &#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(\"GET \" + propertyKey); return target[propertyKey]; &#125; &#125;);let obj = Object.create(proto);obj.foo; // \"GET foo\" 上面代码中，拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效。利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 1234567891011121314151617181920212223242526272829303132var pipe = (function() &#123; return function(value) &#123; var funcStack = []; var oproxy = new Proxy( &#123;&#125;, &#123; get: function(pipeObject, fnName) &#123; if (fnName === \"get\") &#123; return funcStack.reduce(function(val, fn) &#123; return fn(val); &#125;, value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125; ); return oproxy; &#125;;&#125;)();var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n .toString() .split(\"\") .reverse() .join(\"\") | 0;pipe(3).double.pow.reverseInt.get; // 63 下面是一个 get 方法的第三个参数的例子 1234567891011const proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property, receiver) &#123; return receiver; &#125; &#125;);const d = Object.create(proxy);d.a === d; // true 上面代码中，d 对象本身没有 a 属性，所以读取 d.a 的时候，会去 d 的原型 proxy 对象找。这时，receiver 就指向 d，代表原始的读操作所在的那个对象。如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。 123456789101112131415161718192021const target = Object.defineProperties( &#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125; &#125;);const handler = &#123; get(target, propKey) &#123; return \"abc\"; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo;// TypeError: Invariant check failed set()set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。利用 set 方法，可以进行数据验证，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。 12345678910111213141516171819202122const handler = &#123; get(target, key) &#123; invariant(key, \"get\"); return target[key]; &#125;, set(target, key, value) &#123; invariant(key, \"set\"); target[key] = value; return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;const target = &#123;&#125;;const proxy = new Proxy(target, handler);proxy._prop;// Error: Invalid attempt to get private \"_prop\" propertyproxy._prop = \"c\";// Error: Invalid attempt to set private \"_prop\" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。下面是 set 方法第四个参数的例子。 1234567891011const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = receiver; &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);const myObj = &#123;&#125;;Object.setPrototypeOf(myObj, proxy);myObj.foo = \"bar\";myObj.foo === myObj; // true 上面代码中，设置 myObj.foo 属性的值时，myObj 并没有 foo 属性，因此引擎会到 myObj 的原型链去找 foo 属性。myObj 的原型对象 proxy 是一个 Proxy 实例，设置它的 foo 属性会触发 set 方法。这时，第四个参数 receiver 就指向原始赋值行为所在的对象 myObj。如果目标对象自身的某个属性，不可写且不可配置，那么 set 方法将不起作用。 123456789101112131415const obj = &#123;&#125;;Object.defineProperty(obj, \"foo\", &#123; value: \"bar\", writable: false&#125;);const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = \"baz\"; &#125;&#125;;const proxy = new Proxy(obj, handler);proxy.foo = \"baz\";proxy.foo; // \"bar\" apply()apply 方法拦截函数的调用、call 和 apply 操作。apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345678910111213var target = function() &#123; return \"I am the target\";&#125;;var handler = &#123; apply: function() &#123; return \"I am the proxy\"; &#125;&#125;;var p = new Proxy(target, handler);p();// \"I am the proxy\" 上面代码中，变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串。另外，直接调用 Reflect.apply 方法，也会被拦截。 has()has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。has 方法可以接受两个参数，分别是目标对象、需查询的属性名。下面的例子使用 has 方法隐藏某些属性，不被 in 运算符发现。 1234567891011var handler = &#123; has(target, key) &#123; if (key[0] === \"_\") &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: \"foo\", prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);\"_prop\" in proxy; // false 如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。 12345678910var obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false; &#125;&#125;);\"a\" in p; // TypeError is thrown 上面代码中，obj 对象禁止扩展，结果使用 has 拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则 has 方法就不得“隐藏”（即返回 false）目标对象的该属性。has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性。另外，虽然 for…in 循环也用到了 in 运算符，但是 has 拦截对 for…in 循环不生效。 construct()construct 方法用于拦截 new 命令，下面是拦截对象的写法。 12345var handler = &#123; construct(target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct 方法可以接受三个参数。target：目标对象。args：构造函数的参数对象。newTarget：创造实例对象时，new 命令作用的构造函数。construct 方法返回的必须是一个对象，否则会报错。 12345678910var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, args) &#123; console.log(\"called: \" + args.join(\", \")); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);new p(1).value;// \"called: 1\"// 10 1234567var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, argumentsList) &#123; return 1; &#125;&#125;);new p(); // 报错 deleteProperty()deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。 12345678910111213141516var handler = &#123; deleteProperty(target, key) &#123; invariant(key, \"delete\"); return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;var target = &#123; _prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);delete proxy._prop;// Error: Invalid attempt to delete private \"_prop\" property deleteProperty 方法拦截了 delete 操作符，删除第一个字符为下划线的属性会报错。注意，目标对象自身的不可配置（configurable）的属性，不能被 deleteProperty 方法删除，否则报错。 defineProperty()defineProperty 方法拦截了 Object.defineProperty 操作。 12345678var handler = &#123; defineProperty(target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = \"bar\"; // 不会生效 defineProperty 方法返回 false，导致添加新属性总是无效。注意，如果目标对象不可扩展（extensible），则 defineProperty 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则 defineProperty 方法不得改变这两个设置。 getOwnPropertyDescriptor()getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者 undefined。 12345678910111213141516var handler = &#123; getOwnPropertyDescriptor(target, key) &#123; if (key[0] === \"_\") &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: \"bar\", baz: \"tar\" &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, \"wat\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"_foo\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"baz\");// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名会返回 undefined。 getPrototypeOf()getPrototypeOf 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 12345678910var proto = &#123;&#125;;var p = new Proxy( &#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125; &#125;);Object.getPrototypeOf(p) === proto; // true getPrototypeOf 方法的返回值必须是对象或者 null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf 方法必须返回目标对象的原型对象。 isExtensible()isExtensible 方法拦截 Object.isExtensible 操作 12345678910111213var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; console.log(\"called\"); return true; &#125; &#125;);Object.isExtensible(p);// \"called\"// true 该方法只能返回布尔值，否则返回值会被自动转为布尔值。这个方法有一个强限制，它的返回值必须与目标对象的 isExtensible 属性保持一致，否则就会抛出错误。 1234567891011var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; return false; &#125; &#125;);Object.isExtensible(p); // 报错Object.isExtensible(proxy) === Object.isExtensible(target); //true ownKeys()ownKeys 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for…in 循环 12345678910111213141516let target = &#123; a: 1, b: 2, c: 3&#125;;let handler = &#123; ownKeys(target) &#123; return [\"a\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// [ 'a' ] 注意，使用 Object.keys 方法时，有三类属性会被 ownKeys 方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 123456789101112131415161718192021222324let target = &#123; a: 1, b: 2, c: 3, [Symbol.for(\"secret\")]: \"4\"&#125;;Object.defineProperty(target, \"key\", &#123; enumerable: false, configurable: true, writable: true, value: \"static\"&#125;);let handler = &#123; ownKeys(target) &#123; return [\"a\", \"d\", Symbol.for(\"secret\"), \"key\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// ['a'] 上面代码中，ownKeys 方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for(‘secret’)）、不可遍历的属性（key），结果都被自动过滤掉。 123456789101112131415161718192021222324//ownKeys方法还可以拦截Object.getOwnPropertyNames()var p = new Proxy( &#123;&#125;, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\", \"c\"]; &#125; &#125;);Object.getOwnPropertyNames(p);// [ 'a', 'b', 'c' ]//for...in循环也受到ownKeys方法的拦截const obj = &#123; hello: \"world\" &#125;;const proxy = new Proxy(obj, &#123; ownKeys: function() &#123; return [\"a\", \"b\"]; &#125;&#125;);for (let key in proxy) &#123; console.log(key); // 没有任何输出&#125; 上面代码中，ownkeys 指定只返回 a 和 b 属性，由于 obj 没有这两个属性，因此 for…in 循环不会有任何输出。ownKeys 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。 12345678910var obj = &#123;&#125;;var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [123, true, undefined, null, &#123;&#125;, []]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 123 is not a valid property name 如果目标对象自身包含不可配置的属性，则该属性必须被 ownKeys 方法返回，否则报错。 123456789101112131415var obj = &#123;&#125;;Object.defineProperty(obj, \"a\", &#123; configurable: false, enumerable: true, value: 10&#125;);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a' 如果目标对象是不可扩展的（non-extensition），这时 ownKeys 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。 1234567891011121314var obj = &#123; a: 1&#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible preventExtensions()preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy)为 false），proxy.preventExtensions 才能返回 true，否则会报错。 1234567891011121314151617181920212223242526var p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125; &#125;);Object.preventExtensions(p); // 报错//为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensionsvar p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; console.log(\"called\"); Object.preventExtensions(target); return true; &#125; &#125;);Object.preventExtensions(p);// \"called\"// true setPrototypeOf()setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。 12345678910var handler = &#123; setPrototypeOf(target, proto) &#123; throw new Error(\"Changing the prototype is forbidden\"); &#125;&#125;;var proto = &#123;&#125;;var target = function() &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden 上面代码中，只要修改 target 的原型对象，就会报错。注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf 方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable 方法返回一个可取消的 Proxy 实例 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo; // 123revoke();proxy.foo; // TypeError: Revoked Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。Proxy.revocable 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function() &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m(); // falseproxy.m(); // true proxy 用途Proxy，见名知意，其功能非常类似于设计模式中的代理模式，该模式常用于三个方面： 拦截和监视外部对对象的访问 降低函数或类的复杂度 在复杂操作前对操作进行校验或对所需资源进行管理 在支持 Proxy 的浏览器环境中，Proxy 是一个全局对象，可以直接使用。Proxy(target, handler) 是一个构造函数，target 是被代理的对象，handlder 是声明了各类代理操作的对象，最终返回一个代理对象。外界每次通过代理对象访问 target 对象的属性时，就会经过 handler 对象，从这个流程来看，代理对象很类似 middleware（中间件）。那么 Proxy 可以拦截什么操作呢？最常见的就是 get（读取）、set（修改）对象属性等操作，完整的可拦截操作列表请点击这里。此外，Proxy 对象还提供了一个 revoke 方法，可以随时注销所有的代理操作。在我们正式介绍 Proxy 之前，建议你对 Reflect 有一定的了解，它也是一个 ES6 新增的全局对象，详细信息请参考 MDN Reflect。 Basic123456789101112131415161718const target = &#123; name: \"Billy Bob\", age: 15&#125;;const handler = &#123; get(target, key, proxy) &#123; const today = new Date(); console.log(`GET request made for $&#123;key&#125; at $&#123;today&#125;`); return Reflect.get(target, key, proxy); &#125;&#125;;const proxy = new Proxy(target, handler);proxy.name;// =&gt; \"GET request made for name at Thu Jul 21 2016 15:26:20 GMT+0800 (CST)\"// =&gt; \"Billy Bob\" 在上面的代码中，我们首先定义了一个被代理的目标对象 target，然后声明了包含所有代理操作的 handler 对象，接下来使用 Proxy(target, handler) 创建代理对象 proxy，此后所有使用 proxy 对 target 属性的访问都会经过 handler 的处理。 1. 抽离校验模块让我们从一个简单的类型校验开始做起，这个示例演示了如何使用 Proxy 保障数据类型的准确性： 1234567891011121314151617181920let numericDataStore = &#123; count: 0, amount: 1234, total: 14&#125;;numericDataStore = new Proxy(numericDataStore, &#123; set(target, key, value, proxy) &#123; if (typeof value !== \"number\") &#123; throw Error(\"Properties in numericDataStore can only be numbers\"); &#125; return Reflect.set(target, key, value, proxy); &#125;&#125;);// 抛出错误，因为 \"foo\" 不是数值numericDataStore.count = \"foo\";// 赋值成功numericDataStore.count = 333; 如果要直接为对象的所有属性开发一个校验器可能很快就会让代码结构变得臃肿，使用 Proxy 则可以将校验器从核心逻辑分离出来自成一体： 12345678910111213141516171819202122232425262728293031323334353637383940function createValidator(target, validator) &#123; return new Proxy(target, &#123; _validator: validator, set(target, key, value, proxy) &#123; if (target.hasOwnProperty(key)) &#123; let validator = this._validator[key]; if (!!validator(value)) &#123; return Reflect.set(target, key, value, proxy); &#125; else &#123; throw Error(`Cannot set $&#123;key&#125; to $&#123;value&#125;. Invalid.`); &#125; &#125; else &#123; throw Error(`$&#123;key&#125; is not a valid property`); &#125; &#125; &#125;);&#125;const personValidators = &#123; name(val) &#123; return typeof val === \"string\"; &#125;, age(val) &#123; return typeof age === \"number\" &amp;&amp; age &gt; 18; &#125;&#125;;class Person &#123; constructor(name, age) &#123; this.name = name; this.age = age; return createValidator(this, personValidators); &#125;&#125;const bill = new Person(\"Bill\", 25);// 以下操作都会报错bill.name = 0;bill.age = \"Bill\";bill.age = 15; 通过校验器和主逻辑的分离，你可以无限扩展 personValidators 校验器的内容，而不会对相关的类或函数造成直接破坏。更复杂一点，我们还可以使用 Proxy 模拟类型检查，检查函数是否接收了类型和数量都正确的参数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let obj = &#123; pickyMethodOne: function(obj, str, num) &#123; /* ... */ &#125;, pickyMethodTwo: function(num, obj) &#123; /*... */ &#125;&#125;;const argTypes = &#123; pickyMethodOne: [\"object\", \"string\", \"number\"], pickyMethodTwo: [\"number\", \"object\"]&#125;;obj = new Proxy(obj, &#123; get: function(target, key, proxy) &#123; var value = target[key]; return function(...args) &#123; var checkArgs = argChecker(key, args, argTypes[key]); return Reflect.apply(value, target, args); &#125;; &#125;&#125;);function argChecker(name, args, checkers) &#123; for (var idx = 0; idx &lt; args.length; idx++) &#123; var arg = args[idx]; var type = checkers[idx]; if (!arg || typeof arg !== type) &#123; console.warn( `You are incorrectly implementing the signature of $&#123;name&#125;. Check param $&#123;idx + 1&#125;` ); &#125; &#125;&#125;obj.pickyMethodOne();// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 1// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 2// &gt; You are incorrectly implementing the signature of pickyMethodOne. Check param 3obj.pickyMethodTwo(\"wopdopadoo\", &#123;&#125;);// &gt; You are incorrectly implementing the signature of pickyMethodTwo. Check param 1// No warnings loggedobj.pickyMethodOne(&#123;&#125;, \"a little string\", 123);obj.pickyMethodOne(123, &#123;&#125;); 2. 私有属性在 JavaScript 或其他语言中，大家会约定俗成地在变量名之前添加下划线 _ 来表明这是一个私有属性（并不是真正的私有），但我们无法保证真的没人会去访问或修改它。在下面的代码中，我们声明了一个私有的 apiKey，便于 api 这个对象内部的方法调用，但不希望从外部也能够访问 api._apiKey: 1234567891011121314var api = &#123; _apiKey: \"123abc456def\", /* mock methods that use this._apiKey */ getUsers: function() &#123;&#125;, getUser: function(userId) &#123;&#125;, setUser: function(userId, config) &#123;&#125;&#125;;// logs '123abc456def';console.log(\"An apiKey we want to keep private\", api._apiKey);// get and mutate _apiKeys as desiredvar apiKey = api._apiKey;api._apiKey = \"987654321\"; 很显然，约定俗成是没有束缚力的。使用 ES6 Proxy 我们就可以实现真实的私有变量了，下面针对不同的读取方式演示两个不同的私有化方法。第一种方法是使用 set / get 拦截读写请求并返回 undefined: 123456789101112131415161718192021222324252627282930let api = &#123; _apiKey: \"123abc456def\", getUsers: function() &#123;&#125;, getUser: function(userId) &#123;&#125;, setUser: function(userId, config) &#123;&#125;&#125;;const RESTRICTED = [\"_apiKey\"];api = new Proxy(api, &#123; get(target, key, proxy) &#123; if (RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error( `$&#123;key&#125; is restricted. Please see api documentation for further info.` ); &#125; return Reflect.get(target, key, proxy); &#125;, set(target, key, value, proxy) &#123; if (RESTRICTED.indexOf(key) &gt; -1) &#123; throw Error( `$&#123;key&#125; is restricted. Please see api documentation for further info.` ); &#125; return Reflect.get(target, key, value, proxy); &#125;&#125;);// 以下操作都会抛出错误console.log(api._apiKey);api._apiKey = \"987654321\"; 第二种方法是使用 has 拦截 in 操作： 123456789101112131415161718192021222324var api = &#123; _apiKey: \"123abc456def\", getUsers: function() &#123;&#125;, getUser: function(userId) &#123;&#125;, setUser: function(userId, config) &#123;&#125;&#125;;const RESTRICTED = [\"_apiKey\"];api = new Proxy(api, &#123; has(target, key) &#123; return RESTRICTED.indexOf(key) &gt; -1 ? false : Reflect.has(target, key); &#125;&#125;);// these log false, and `for in` iterators will ignore _apiKeyconsole.log(\"_apiKey\" in api);for (var key in api) &#123; if (api.hasOwnProperty(key) &amp;&amp; key === \"_apiKey\") &#123; console.log( \"This will never be logged because the proxy obscures _apiKey...\" ); &#125;&#125; 3. 访问日志对于那些调用频繁、运行缓慢或占用执行环境资源较多的属性或接口，开发者会希望记录它们的使用情况或性能表现，这个时候就可以使用 Proxy 充当中间件的角色，轻而易举实现日志功能： 123456789101112131415161718192021222324252627282930let api = &#123; _apiKey: \"123abc456def\", getUsers: function() &#123; /* ... */ &#125;, getUser: function(userId) &#123; /* ... */ &#125;, setUser: function(userId, config) &#123; /* ... */ &#125;&#125;;function logMethodAsync(timestamp, method) &#123; setTimeout(function() &#123; console.log(`$&#123;timestamp&#125; - Logging $&#123;method&#125; request asynchronously.`); &#125;, 0);&#125;api = new Proxy(api, &#123; get: function(target, key, proxy) &#123; var value = target[key]; return function(...arguments) &#123; logMethodAsync(new Date(), key); return Reflect.apply(value, target, arguments); &#125;; &#125;&#125;);api.getUsers(); 4. 预警和拦截假设你不想让其他开发者删除 noDelete 属性，还想让调用 oldMethod 的开发者了解到这个方法已经被废弃了，或者告诉开发者不要修改 doNotChange 属性，那么就可以使用 Proxy 来实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243let dataStore = &#123; noDelete: 1235, oldMethod: function() &#123; /*...*/ &#125;, doNotChange: \"tried and true\"&#125;;const NODELETE = [\"noDelete\"];const NOCHANGE = [\"doNotChange\"];const DEPRECATED = [\"oldMethod\"];dataStore = new Proxy(dataStore, &#123; set(target, key, value, proxy) &#123; if (NOCHANGE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; is immutable.`); &#125; return Reflect.set(target, key, value, proxy); &#125;, deleteProperty(target, key) &#123; if (NODELETE.includes(key)) &#123; throw Error(`Error! $&#123;key&#125; cannot be deleted.`); &#125; return Reflect.deleteProperty(target, key); &#125;, get(target, key, proxy) &#123; if (DEPRECATED.includes(key)) &#123; console.warn(`Warning! $&#123;key&#125; is deprecated.`); &#125; var val = target[key]; return typeof val === \"function\" ? function(...args) &#123; Reflect.apply(target[key], target, args); &#125; : val; &#125;&#125;);// these will throw errors or log warnings, respectivelydataStore.doNotChange = \"foo\";delete dataStore.noDelete;dataStore.oldMethod(); 5. 过滤操作某些操作会非常占用资源，比如传输大文件，这个时候如果文件已经在分块发送了，就不需要在对新的请求作出相应（非绝对），这个时候就可以使用 Proxy 对当请求进行特征检测，并根据特征过滤出哪些是不需要响应的，哪些是需要响应的。下面的代码简单演示了过滤特征的方式，并不是完整代码，相信大家会理解其中的妙处： 123456789101112131415161718192021222324let obj = &#123; getGiantFile: function(fileId) &#123; /*...*/ &#125;&#125;;obj = new Proxy(obj, &#123; get(target, key, proxy) &#123; return function(...args) &#123; const id = args[0]; let isEnroute = checkEnroute(id); let isDownloading = checkStatus(id); let cached = getCached(id); if (isEnroute || isDownloading) &#123; return false; &#125; if (cached) &#123; return cached; &#125; return Reflect.apply(target[key], target, args); &#125;; &#125;&#125;); 6. 中断代理Proxy 支持随时取消对 target 的代理，这一操作常用于完全封闭对数据或接口的访问。在下面的示例中，我们使用了 Proxy.revocable 方法创建了可撤销代理的代理对象： 1234567891011let sensitiveData = &#123; username: \"devbryce\" &#125;;const &#123; sensitiveData, revokeAccess &#125; = Proxy.revocable(sensitiveData, handler);function handleSuspectedHack() &#123; revokeAccess();&#125;// logs 'devbryce'console.log(sensitiveData.username);handleSuspectedHack();// TypeError: Revokedconsole.log(sensitiveData.username); DecoratorES7 中实现的 Decorator，相当于设计模式中的装饰器模式。如果简单地区分 Proxy 和 Decorator 的使用场景，可以概括为：Proxy 的核心作用是控制外界对被代理者内部的访问，Decorator 的核心作用是增强被装饰者的功能。只要在它们核心的使用场景上做好区别，那么像是访问日志这样的功能，虽然本文使用了 Proxy 实现，但也可以使用 Decorator 实现，开发者可以根据项目的需求、团队的规范、自己的偏好自由选择。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"浏览器缓存机制","slug":"浏览器缓存机制","date":"2018-10-20T07:23:45.000Z","updated":"2019-11-10T14:37:39.039Z","comments":true,"path":"2018/10/20/浏览器缓存机制/","link":"","permalink":"http://yoursite.com/2018/10/20/浏览器缓存机制/","excerpt":"浏览器缓存机制概念浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。（浏览器缓存分为强缓存和协商缓存）","text":"浏览器缓存机制概念浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。（浏览器缓存分为强缓存和协商缓存） 浏览器缓存机制要素： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识； 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。 九种浏览器缓存：http 缓存http 缓存是基于 HTTP 协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件。主要是针对重复的 http 请求，在有缓存的情况下判断过程主要分 3 步：判断 expires，如果未过期，直接读取 http 缓存文件，不发 http 请求，否则进入下一步；判断是否含有 etag，有则带上 if-none-match 发送请求，未修改返回 304，修改返回 200，否则进入下一步；判断是否含有 last-modified，有则带上 if-modified-since 发送请求，无效返回 200，有效返回 304，否则直接向服务器请求 websql它是将数据以数据库的形式存储在客户端，根据需求去读取；跟 Storage 的区别是： Storage 和 Cookie 都是以键值对的形式存在的。 indexDBIndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。同步 API 本来是要用于仅供 Web Workers 内部使用，但是还没有被任何浏览器所实现。异步 API 在 Web Workers 内部和外部都可以使用，另外浏览器可能对 indexDB 有 50M 大小的限制，一般用户保存大量用户数据并要求数据之间有搜索需要的场景。 Cookie指一般网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。cookie 一般通过 http 请求中在头部一起发送到服务器端。一条 cookie 记录主要由键、值、域、过期时间、大小组成，一般用于保存用户的认证信息。cookie 最大长度和域名个数由不同浏览器决定。不同域名之间的 cookie 信息是独立的，如果需要设置共享可以在服务器端设置 cookie 的 path 和 domain 来实现共享。浏览器端也可以通过 document.cookie 来获取 cookie，并通过 js 浏览器端也可以方便地读取/设置 cookie 的值。（Cookie 只能存储少量的数据，每个 Cookie 的大小不超过 4KB。RFC 标准不允许浏览器保存超过 300 个 Cookie，为每个 web 服务器保存的 Cookie 数不超过 20 个。JavaScript 中使用 Cookie 不会采用任何加密机制，因此它们是不安全的。） LocalstoragelocalStorage 是 html5 的一种新的本地缓存方案，目前用的比较多，一般用来存储 ajax 返回的数据，加快下次页面打开时的渲染速度。 SessionstoragesessionStorage 和 localstorage 类似，但是浏览器关闭则会全部删除，api 和 localstorage 相同，实际项目中使用较少。 application cacheapplication cahce 是将大部分图片资源、js、css 等静态资源放在 manifest 文件配置中。当页面打开时通过 manifest 文件来读取本地文件或是请求服务器文件。在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。并在下一次生效。离线的情况下，浏览器就直接使用离线存储的资源。 cacheStorageCacheStorage 是在 ServiceWorker 的规范中定义的。CacheStorage 可以保存每个 serverWorker 申明的 cache 对象，cacheStorage 有 open、match、has、delete、keys 五个核心方法，可以对 cache 对象的不同匹配进行不同的响应。 flash 缓存这种方式基本不用，这一方法主要基于 flash 有读写浏览器端本地目录的功能，同时也可以向 js 提供调用的 api，则页面可以通过 js 调用 flash 去读写特定的磁盘目录，达到本地数据缓存的目的。 cookie 背景：早期 Web 开发面临的最大问题之一是如何管理状态。简言之，服务器端没有办法知道两个请求是否来自于同一个浏览器。那时的办法是在请求的页面中插入一个 token，并且在下一次请求中将这个 token 返回（至服务器）。这就需要在 form 中插入一个包含 token 的隐藏表单域，或着在 URL 的 qurey 字符串中传递该 token。这两种办法都强调手工操作并且极易出错。 内容：键、值、域、过期时间、大小 是否生效：expires 指定了 cookie 何时不会再被发送到服务器端的，因此该 cookie 可能会被浏览器删掉。（过期时间）在没有 expires 选项时，cookie 的寿命仅限于单一的会话中。浏览器的关闭意味这一次会话的结束，所以会话 cookie 只存在于浏览器保持打开的状态之下。如果 expires 选项设置了一个过去的时间点，那么这个 cookie 会被立即删除。 存在哪里：cookie 的值被存储在名为 Cookie 的 HTTP 消息头中，并且只包含了 cookie 的值，其它的选项全部被去除。 存放形式：Cookies 是纯文本形式。几乎所有的实现方式都对 cookie 的值进行了一些列的 URL 编码（但不是必须）。原始的文档中指示仅有三种类型的字符必须进行编码：分号，逗号，和空格。 不同域名之间的 cookie 信息是独立的，不会冲突。浏览器会对 domain 的值与请求所要发送至的域名，做一个尾部比较（即从字符串的尾部开始比较），并且在匹配后发送一个 Cookie 消息头。domain 设置的值必须是发送 Set-Cookie 消息头的域名。与 domain 选项相同的是，path 指明了在发 Cookie 消息头之前必须在请求资源中存在一个 URL 路径。这个比较是通过将 path 属性值与请求的 URL 从头开始逐字符串比较完成的。如果字符匹配，则发送 Cookie 消息头。只有在 domain 选项核实完毕之后才会对 path 属性进行比较。path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。path 值越详细则 cookie 越靠前。domain-path 越详细则 cookie 字符串越靠前。可以通过设置 Cookie 的 path 属性来修改 Cookie 的作用域，如果把 path 设为“/”，就等同于让 Cookie 拥有了 localStorage 的作用域，即整个文档源。 默认情况下，Cookie 对于创建它的页面，以及与该页面同目录或子目录下的其他 web 页面可见。在 a.example.com 下的一个页面设置了 Cookie，将其 path 设为“/”，并将 domain 设为“.example.com”，这样该 Cookie 就对 example.com 域下的所有页面可见。 创建和存储 Cookie：对 Cookie 的所有操作都要通过读写 document 对象的 Cookie 属性来完成。Cookie 的值都是以键值对的形式存储。同样的，如果要设置 path、domain 等属性，只须以如下形式追加到 Cookie 值的后面: ;path=path 1234567891011//创建一个名字Cookie，同时设置它的过期时间function setCookie(c_name, value, expiredays) &#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); //encodeURIComponent() 对 URI 进行编码 document.cookie = c_name + \"=\" + encodeURIComponent(value) + (expiredays == null ? \"\" : \";expires=\" + exdate.toGMTString());&#125; 读取 Cookie：使用 document.cookie 可以获取到 Cookie 的值，不过这个值是一个字符串，为了更好地查看 Cookie 的值，往往会采用 split()方法将 Cookie 中的名值对分离出来。 12345678910111213141516171819202122function getCookie() &#123; // 初始化要返回的对象 var cookie = &#123;&#125;; var all = document.cookie; if (all === null) &#123; return cookie; &#125; //分离出Cookie的各个属性 var list = all.split(\";\"); for (var i = 0; i &lt; list.length; i++) &#123; // 查询出等号所在的位置 var p = list[i].indexOf(\"=\"); // 分离出名字和值 var name = list[i].substring(0, p); var value = list[i].substring(p + 1); //对值进行解码 value = decodeURIComponent(value); // 将名值对存储到对象中 cookie[name] = value; &#125; return cookie;&#125; Localstorage 和 sessionstorageLocalstorage 和 sessionstorage 是做什么的？localstorage 怎么清除它？在代码层面怎么清除？setitem 的是什么数据类型？getitem 的值是什么数据类型？ 怎么清除 12localStorage.removeItem(key); //删除该域名下单条记录localStorage.clear(); //删除该域名下所有记录 存储格式：所有的数据都是以文本格式保存。其中 value 需为可转化为字符串的对象。localStorage 对象的键和值只能是字符串，假设我们要保存一个对象到 localStorage 中，可以使用拼接的方式。当然也可以借助 JSON 类，将对象转换成字符串保存，然后在取出来的时候将 json 字符串转换成真正可用的 json 对象格式 数据共享：不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"缓存","slug":"缓存","permalink":"http://yoursite.com/tags/缓存/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-10-14T07:55:35.000Z","updated":"2019-11-10T14:37:39.040Z","comments":true,"path":"2018/10/14/箭头函数/","link":"","permalink":"http://yoursite.com/2018/10/14/箭头函数/","excerpt":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。","text":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function(v) &#123; return v;&#125;; 参数部分如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 1234567891011var f = () =&gt; 5;// 等同于var f = function() &#123; return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 返回对象由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 1234let foo = () =&gt; &#123; a: 1;&#125;;foo(); // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句 a: 1。这时，a 可以被解释为语句的标签，因此实际执行的语句是 1;，然后函数就结束了，没有返回值。箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + \" \" + last;// 等同于function full(person) &#123; return person.first + \" \" + person.last;&#125; 简化回调函数箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1, 2, 3].map(function(x) &#123; return x * x;&#125;);// 箭头函数写法[1, 2, 3].map(x =&gt; x * x); rest 参数与箭头函数结合123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5);// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5);// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。上面四点中，第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(\"id:\", this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this 应该指向全局对象 window，这时应该输出 21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是 42。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。 123456789101112131415161718192021222324252627282930function insert(value) &#123; return &#123; into: function(array) &#123; return &#123; after: function(afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;; &#125; &#125;;&#125;insert(2) .into([1, 3]) .after(1); //[1, 2, 3]//使用箭头函数改写let insert = value =&gt; (&#123; into: array =&gt; (&#123; after: afterValue =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;)&#125;);insert(2) .into([1, 3]) .after(1); //[1, 2, 3] 改写 λ 演算123456// λ演算的写法fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))// ES6的写法var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v)));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"this和super关键字","slug":"this和super关键字","date":"2018-09-24T10:41:35.000Z","updated":"2019-11-10T14:37:39.028Z","comments":true,"path":"2018/09/24/this和super关键字/","link":"","permalink":"http://yoursite.com/2018/09/24/this和super关键字/","excerpt":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身","text":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身 12345678910var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向obj对象obj.getA(); 作为普通函数调用作为普通函数调用时，this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。 1234567891011var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向window对象var getA = obj.getA;getA(); 这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。 构造器调用构造器调用时，this 指向返回的对象。用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。 12345678910111213var a = 10;var b = 20;function Point(x, y) &#123; this.x = x; this.y = y;&#125;var a = new Point(1, 2);console.log(a.x); // 1console.log(x); // 10var b = new Point(1, 2);console.log(a === b); // false call apply bind当函数通过 call()和 apply()方法绑定时，this 指向两个方法的第一个参数对象上，若第一个参数不是对象，JS 内部会尝试将其转化为对象然后再指向它。通过 bind 方法绑定后，无论其在什么情况下被调用，函数将被永远绑定在其第一个参数对象上，bind 绑定后返回的是一个函数。 call, apply 的用途 改变 this 的指向 Function.prototype.bind 12345678Function.prototype.bind = function() &#123; var self = this; var context = [].shift.call(arguments); var args = [].slice.call(arguments); return function() &#123; return self.apply(context, args.concat([].slice.call(arguments))); &#125;;&#125;; 三者区别call 只能一个一个传入参数apply 可直接传入参数数组bind 会返回一个新的函数 super 关键字关键字 super，指向当前对象的原型对象。 12345678910111213const proto = &#123; foo: \"hello\"&#125;;const obj = &#123; foo: \"world\", find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find(); // \"hello\" 上面代码中，对象 obj 的 find 方法之中，通过 super.foo 引用了原型对象 proto 的 foo 属性。注意，super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;;// 报错const obj = &#123; foo: function() &#123; return super.foo; &#125;&#125;; 上面三种 super 的用法都会报错，因为对于 JavaScript 引擎来说，这里的 super 都没有用在对象的方法之中。第一种写法是 super 用在属性里面，第二种和第三种写法是 super 用在一个函数里面，然后赋值给 foo 属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。JavaScript 引擎内部，super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)（方法）。 1234567891011121314151617const proto = &#123; x: \"hello\", foo() &#123; console.log(this.x); &#125;&#125;;const obj = &#123; x: \"world\", foo() &#123; super.foo(); &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.foo(); // \"world\" 上面代码中，super.foo 指向原型对象 proto 的 foo 方法，但是绑定的 this 却还是当前对象 obj，因此输出的就是 world。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"常用git命令","slug":"常用git命令","date":"2018-09-16T03:50:00.000Z","updated":"2019-09-21T14:18:54.013Z","comments":true,"path":"2018/09/16/常用git命令/","link":"","permalink":"http://yoursite.com/2018/09/16/常用git命令/","excerpt":"常用git命令红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库","text":"常用git命令红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库 git status 查看状态“.” 代表文件夹中所有文件 git add [file1][file2]添加指定文件到暂存区 git commit在第一行写入这次修改记录。将缓存区文件放入提交区。git commit -m [‘message’]git commit -amend修改上次记录信息 git log查看提交记录vim ~/.zshrc 配置文件中可自定义操作source ~/.zshrc 修改配置文件后 source 保存生效 git config查看当前 git 配置git config -h查看帮助信息vim ~/.gitconfig 自定义 git 命令，修改个人名字邮箱等信息cat .git/config 本地配置 touch .gitignore 忽略一些文件 12.vscodenode_modules 写入 gitignore 后即可忽略 node_modules 文件更多信息查看gitignore git diff现实暂存区和工作区的差异 git checkout –a放弃 a 的变更依照提交区恢复工作区的文件，丢弃工作区的变更 git reset HEAD –a从暂存区恢复到工作区 git stash把工作区和暂存区的文件都存入 stash 中git stash list查看 stash 中的文件git stash pop恢复 stash 中的文件到工作区（pop=apply+drop） git reset HEAD\b^后退一步（几个^代表后退几步）git reset HEAD~[number]抛弃了 number 个 commit git reflog查看近期的 log 记录git reset [版本号]回退到版本号为……的 commit 分支操作 git branch develop创建 develop 分支,但依然停留在当前分支git branch -v查看分支 git checkout develop切换进入 develop 分支git checkout -b feature创建并切换进入 feature 分支 合并分支a. 先进入要合并的分支（checkout develop）在执行 git merge feature 即可把 feature 合并到 develop 分支上b. git merge feature develop可达到同样的效果 改变基线git rebase -i [提交记录号]将 HEAD 指向记录号所在位置 远程仓库 git remote add origin [SSH 地址]创建远程仓库连接 git push -u origin develop上传 develop 分支到远程仓库上（远程无项目可直接 push，有项目先 merge 再 push） git pull origin feature拉取远程 feature 分支（pull=fetch+merge） git brach -d feature删除 feature 分支 git push origin :feature删除远程 feature 分支 git tag [标签号]git push origin [标签号]打标签 git remote remove origin取消本地目录下关联的远程仓库 git clone [url]下载一个项目和它的整个代码历史 打 tag vim package.json(vim package-lock.json)可以查看 version 号 npm version -h查看这一个 tag 即将提升的版本号（大版本或者小版本） npm version patch提升 patch 这个小版本（v0.2.2） git tag –list查看 tag 的列表 git push origin masterpush 代码 git push origin v0.2.3push tag","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"跨域请求：JSONP&&CORS","slug":"跨域请求：JSONP&&CORS","date":"2018-09-03T09:28:34.000Z","updated":"2019-11-10T14:37:39.041Z","comments":true,"path":"2018/09/03/跨域请求：JSONP&&CORS/","link":"","permalink":"http://yoursite.com/2018/09/03/跨域请求：JSONP&&CORS/","excerpt":"JSONPJSONP 是 JSON with Padding 的略称。它是一个非官方的协议，它允许在服务器端集成 Script tags 返回至客户端，通过 javascript callback 的形式实现跨域访问（这仅仅是 JSONP 简单的实现形式） JSONP 的简单实现模式：创建一个回调函数，然后在远程服务上调用这个函数并且将 JSON 数据形式作为参数传递，完成回调。 我们知道script，link，img 等标签引入外部资源，都是GET请求的，那么就决定了 JSONP 一定是 GET的。","text":"JSONPJSONP 是 JSON with Padding 的略称。它是一个非官方的协议，它允许在服务器端集成 Script tags 返回至客户端，通过 javascript callback 的形式实现跨域访问（这仅仅是 JSONP 简单的实现形式） JSONP 的简单实现模式：创建一个回调函数，然后在远程服务上调用这个函数并且将 JSON 数据形式作为参数传递，完成回调。 我们知道script，link，img 等标签引入外部资源，都是GET请求的，那么就决定了 JSONP 一定是 GET的。 原生 JS 实现 JSONP 的步骤：客户端 定义获取数据后调用的回调函数 动态生成对服务端 JS 进行引用的代码 设置url为提供jsonp服务的url地址，并在该url中设置相关callback参数 创建script标签，并设置其src属性 把script标签加入head，此时调用开始。 服务端将客户端发送的callback参数作为函数名来包裹住JSON数据，返回数据至客户端。 例子：客户端代码： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data) &#123; alert( \"你查询的航班结果是：票价 \" + data.price + \" 元，\" + \"余票 \" + data.tickets + \" 张。\" ); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler\"; // 创建script标签，设置其属性 var script = document.createElement(\"script\"); script.setAttribute(\"src\", url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(\"head\")[0].appendChild(script); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 编码实现动态查询，而这也正是 JSONP 客户端实现的核心部分，本例中的重点也就在于如何完成 JSONP 调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是 CA1998 次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 12345flightHandler(&#123; code: \"CA1998\", price: 1780, tickets: 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，JSONP 的执行全过程顺利完成！ CORS跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 1.两种请求浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 2.简单请求 基本流程 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送 Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 withCredentials 属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在 AJAX 请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。 3.非简单请求 预检请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的 JavaScript 脚本。 12345var url = \"http://api.alice.com/cors\";var xhr = new XMLHttpRequest();xhr.open(\"PUT\", url, true);xhr.setRequestHeader(\"X-Custom-Header\", \"value\");xhr.send(); 上面代码中，HTTP 请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的 HTTP 头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的 HTTP 回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他 CORS 相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应 一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常 CORS 请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 4.与 JSONP 的比较CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。 JSONP 只支持GET请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"正则的扩展","slug":"正则的扩展","date":"2018-08-29T08:56:12.000Z","updated":"2019-11-10T14:37:39.037Z","comments":true,"path":"2018/08/29/正则的扩展/","link":"","permalink":"http://yoursite.com/2018/08/29/正则的扩展/","excerpt":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。","text":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 12345var regex = new RegExp(\"xyz\", \"i\");// 等价于var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; ES6 中，如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/gi, \"i\").flags;// \"i\" 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和 split()。ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 点字符点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。 1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true Unicode 字符表示法ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别当中的大括号，否则会被解读为量词。 12345/\\u&#123;61&#125;/.test(\"a\") / // falsea /u.test(\"a\") / // true 𠮷 / u.test(\"𠮷\"); // true 量词使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。 1234/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true 预定义模式\\S 是预定义模式，匹配所有非空白字符。只有加了 u 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。 12/^\\S$/.test('𠮷') // false/^\\S$/u.test('𠮷') // true i 修饰符有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B 与\\u212A 都是大写的 K。不加 u 修饰符，就无法识别非规范的 K 字符。 123/[a-z]/i.test(\"\\u212A\") / // false [a - z] / iu.test(\"\\u212A\"); // true RegExp.prototype.unicode 属性正则实例对象新增 unicode 属性，表示是否设置了 u 修饰符 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode; // falser2.unicode; // true 上面代码中，正则表达式是否设置了 u 修饰符，可以从 unicode 属性看出来。 y 修饰符ES6 为正则表达式添加了 y 修饰符，叫做“粘连”（sticky）修饰符。y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = \"aaa_aa_a\";var r1 = /a+/g;var r2 = /a+/y;r1.exec(s); // [\"aaa\"]r2.exec(s); // [\"aaa\"]r1.exec(s); // [\"aa\"]r2.exec(s); // null 单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。 12\"a1a2a3\".match(/a\\d/y); // [\"a1\"]\"a1a2a3\".match(/a\\d/gy); // [\"a1\", \"a2\", \"a3\"] RegExp.prototype.sticky 属性与 y 修饰符相匹配，ES6 的正则实例对象多了 sticky 属性，表示是否设置了 y 修饰符。 12var r = /hello\\d/y;r.sticky; // true RegExp.prototype.flags 属性ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。 12345678910// ES5 的 source 属性// 返回正则表达式的正文/abc/gi.source / // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 abc / ig.flags;// 'gi' s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 u 修饰符解决；另一个是行终止符。行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator）ES2018 引入 s 修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test(\"foo\\nbar\"); // true 这被称为 dotAll 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。/s 修饰符和多行修饰符/m 不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言”先行断言“指的是，x 只有在 y 前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。”先行否定断言“指的是，x 只有不在 y 前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。“后行断言”正好与“先行断言”相反，x 只有在 y 后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=$)\\d+/。”后行否定断言“则与”先行否定断言“相反，x 只有不在 y 后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!$)\\d+/。 123const RE_DOLLAR_PREFIX = /(?&lt;=\\$)foo/g;\"$foo %foo foo\".replace(RE_DOLLAR_PREFIX, \"bar\");// '$bar %foo foo' “后行断言”的实现，需要先匹配/(?&lt;=y)x/的 x，然后再回到左边，匹配 y 的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。首先，后行断言的组匹配，与正常情况下结果是不一样的。 12/(?&lt;=(\\d+)(\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]/^(\\d+)(\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 Unicode 属性类ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。\\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。这两种类只对 Unicode 有效，所以使用的时候一定要加上 u 修饰符。如果不加 u 修饰符，正则表达式使用\\p 和\\P 会报错，ECMAScript 预留了这两个类。 123456789101112131415// 匹配所有空格\\p&#123;White_Space&#125;// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w[\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W[^\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配 Emoji/\\p&#123;Emoji_Modifier_Base&#125;\\p&#123;Emoji_Modifier&#125;?|\\p&#123;Emoji_Presentation&#125;|\\p&#123;Emoji&#125;\\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 具名组匹配正则表达式使用圆括号进行组匹配。 123456const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 正则表达式里面有三组圆括号。使用 exec 方法，就可以将这三组匹配结果提取出来。组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如 matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 “具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在 exec 方法返回结果的 groups 属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。 解构赋值和替换具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。字符串替换时，使用$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;\"2015-01-02\".replace(re, \"$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;\");// '02/01/2015' 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法或者数字引用（\\1）的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;RE_TWICE.test(\"abc!abc!abc\"); // trueRE_TWICE.test(\"abc!abc!ab\"); // false String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用 g 修饰符或 y 修饰符，在循环里面逐一取出。或者使用 String.prototype.matchAll 方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = \"test1test2test3\";// g 修饰符加不加都可以const regex = /t(e)(st(\\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于 string.matchAll(regex)返回的是遍历器，所以可以用 for…of 循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。遍历器转为数组是非常简单的，使用…运算符和 Array.from 方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)];// 转为数组方法二Array.from(string.matchAll(regex));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"柯里化&&闭包","slug":"柯里化&&闭包","date":"2018-08-16T00:30:22.000Z","updated":"2019-11-10T14:37:39.036Z","comments":true,"path":"2018/08/16/柯里化&&闭包/","link":"","permalink":"http://yoursite.com/2018/08/16/柯里化&&闭包/","excerpt":"柯里化闭包实现multi(2)(3)(4)=24 1234567function multi(a) &#123; return function(b) &#123; return function(c) &#123; return a * b * c; &#125;; &#125;;&#125;","text":"柯里化闭包实现multi(2)(3)(4)=24 1234567function multi(a) &#123; return function(b) &#123; return function(c) &#123; return a * b * c; &#125;; &#125;;&#125; 函数柯里化函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。 函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 普通版把固定的函数变成柯里化。如果传入的参数个数小于 fn 所需要的形参个数，就继续执行 curry 函数接收参数，如果参数达到 fn 所需要的形参个数，就执行柯里化了的函数。 1234567891011121314151617181920function curry(fn, args) &#123; var length = fn.length; var args = args || []; return function() &#123; newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length &lt; length) &#123; return curry.call(this, fn, newArgs); &#125; else &#123; return fn.apply(this, newArgs); &#125; &#125;;&#125;function multiFn(a, b, c) &#123; return a * b * c;&#125;var multi = curry(multiFn);multi(2)(3)(4);multi(2, 3, 4);multi(2)(3, 4);multi(2, 3)(4); 优化版不需要事先知道函数形参个数。可以任意参数个数调用。（重写 valueOf 函数） 12345678910111213function multi() &#123; var args = Array.prototype.slice.call(arguments); var fn = function() &#123; var newArgs = args.concat(Array.prototype.slice.call(arguments)); return multi.apply(this, newArgs); &#125;; fn.valueOf = function() &#123; return args.reduce(function(a, b) &#123; return a * b; &#125;); &#125;; return fn;&#125; 闭包1234567var func = [];for (var i = 0; i &lt; 10; i++) &#123; func[i] = function() &#123; return i; &#125;;&#125;console.log(func[6]); //10 改成 12345678910var func = [];for (var i = 0; i &lt; 10; i++) &#123; func[i] = (function() &#123; return (function() &#123; return i; &#125;)(); &#125;)();&#125;console.log(func[6]); //6","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"字符串的扩展","slug":"字符串的扩展","date":"2018-08-09T03:20:29.000Z","updated":"2019-11-10T14:37:39.035Z","comments":true,"path":"2018/08/09/字符串的扩展/","link":"","permalink":"http://yoursite.com/2018/08/09/字符串的扩展/","excerpt":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。","text":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12345678\"\\u0061\";// \"a\"\"\\uD842\\uDFB7\";// \"𠮷\"\"\\u20BB7\";// \" 7\" 如果直接在\\u 后面跟上超过 0xFFFF 的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7。ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 codePointAt()codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。例如，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点（codePointAt 方法返回的是码点的十进制值）。 1234567891011121314var s = \"𠮷\";s.length; // 2s.charAt(0); // ''s.charAt(1); // ''s.charCodeAt(0); // 55362s.charCodeAt(1); // 57271let a = \"𠮷a\";a.codePointAt(0); // 134071a.codePointAt(1); // 57271a.codePointAt(2); // 97 codePointAt 方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷 a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的 20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt 方法的结果与 charCodeAt 方法相同。 String.fromCodePoint()ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 0xFFFF）。ES6 提供了 String.fromCodePoint 方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。且如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回。 1234String.fromCodePoint(0x20bb7);// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === \"x\\uD83D\\uDE80y\";// true 字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被 for…of 循环遍历,并且遍历器最大的优点是可以识别大于 0xFFFF 的码点。 1234567891011for (let codePoint of \"foo\") &#123; console.log(codePoint);&#125;// \"f\"// \"o\"// \"o\"for (let i of text) &#123; console.log(i);&#125;// \"𠮷\" at()ES5 对字符串对象提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符。字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符。 12\"abc\".at(0); // \"a\"\"𠮷\".at(0); // \"𠮷\" normalize()在字符排序或比较时，会出现一种情况，就是“等效”。 规范的等效是指，无论从哪个角度看，两个序列的码位都是没有区别的。 兼容关系，两个互相兼容的码位序列看起来不同，但是在特定的情况下可以相互交换使用。例如 Ǒ（\\u01D1）和 O（\\u004F） ˇ（\\u030C）两个字符的组合（\\u004F\\u030C），在视觉和语义上其实是等效的。 ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12\"\\u01D1\".normalize() === \"\\u004F\\u030C\".normalize();// true 不过，normalize 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 includes(), startsWith(), endsWith()includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。 12345let s = \"Hello world!\";s.startsWith(\"world\", 6); // trues.endsWith(\"Hello\", 5); // trues.includes(\"Hello\", 6); // false repeat()repeat 方法返回一个新字符串，表示将原字符串重复 n 次。参数如果是小数，会被取整。如果 repeat 的参数是负数或者 Infinity，会报错。参数 NaN 等同于 0。如果 repeat 的参数是字符串，则会先转换成数字。 1234567891011121314\"x\".repeat(3); // \"xxx\"\"hello\".repeat(2); // \"hellohello\"\"na\".repeat(0); // \"\"\"na\".repeat(2.9); // \"nana\"\"na\".repeat(Infinity);// RangeError\"na\".repeat(-1);// RangeError\"na\".repeat(NaN); // \"\"\"na\".repeat(\"na\"); // \"\"\"na\".repeat(\"3\"); // \"nanana\" padStart()，padEnd()如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。 1234567891011\"x\".padStart(4, \"ab\"); // 'abax'\"x\".padEnd(5, \"ab\"); // 'xabab'\"xxx\".padStart(2, \"ab\"); // 'xxx'\"xxx\".padEnd(2, \"ab\"); // 'xxx'\"abc\".padStart(10, \"0123456789\");// '0123456abc'\"x\".padStart(4); // ' x'\"x\".padEnd(4); // 'x ' matchAll()matchAll 方法返回一个正则表达式在当前字符串的所有匹配 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。如果模板字符串中的变量没有声明，将报错。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.``In JavaScript this is // 多行字符串 not legal.`;console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`;let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 所有模板字符串的空格和换行，都是被保留的，比如”&lt; ul&gt;”标签前面会有一个换行。如果你不想要这个换行，可以使用 trim 方法消除它。如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = \"return \" + \"`Hello $&#123;name&#125;!`\";let func = new Function(\"name\", str);func(\"Jack\"); // \"Hello Jack!\"// 写法二let str = \"(name) =&gt; `Hello $&#123;name&#125;!`\";let func = eval.call(null, str);func(\"Jack\"); // \"Hello Jack!\" 标签模板模板字符串，紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`;// 等同于tag([\"Hello \", \" world \", \"\"], 15, 50); 上面代码中，模板字符串前面有一个标识名 tag，它是一个函数。整个表达式的返回值，就是 tag 函数处理模板字符串后的返回值。函数 tag 依次会接收到多个参数。tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。tag 函数的其他参数，都是模板字符串各个变量被替换后的值。 “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg .replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。 标签模板的另一个应用，就是多语言转换（国际化处理）。多语言转换（国际化处理）。可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性。保存的是转义后的原字符串。 1234567tag`First line\\nSecond line`;function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"&#125; String.raw()ES6 还为原生的 String 对象，提供了一个 raw 方法。String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。如果原字符串的斜杠已经转义，那么 String.raw 会进行再次转义。 12345678String.raw`Hi\\n$&#123;2 + 3&#125;!`;// 返回 \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 返回 \"Hi\\\\u000A!\"String.raw`Hi\\\\n`;// 返回 \"Hi\\\\\\\\n\"","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"递归与尾递归","slug":"递归与尾递归","date":"2018-07-23T10:15:56.000Z","updated":"2019-11-10T14:37:39.041Z","comments":true,"path":"2018/07/23/递归与尾递归/","link":"","permalink":"http://yoursite.com/2018/07/23/递归与尾递归/","excerpt":"递归的问题函数的递归调用是通过栈来实现的，每一次函数调用都会把当前函数的状态，如变量，返回地址保存在栈中一直到函数返回才能出栈。因为程序运行时，栈的大小一般很有限（在 chrome 中运行下面的代码可以计算出 chrome 给每个线程的栈大小），因此如果递归调用的层次如果过多，将会使栈区溢出。","text":"递归的问题函数的递归调用是通过栈来实现的，每一次函数调用都会把当前函数的状态，如变量，返回地址保存在栈中一直到函数返回才能出栈。因为程序运行时，栈的大小一般很有限（在 chrome 中运行下面的代码可以计算出 chrome 给每个线程的栈大小），因此如果递归调用的层次如果过多，将会使栈区溢出。 尾递归尾递归就是函数最后的语句是调用函数自身，但调用自己的时候，已经不再需要上一个函数的环境了。 123456function factorial(n,a)&#123; if(n&lt;=0) return 0; if(n == 1) return a; return factorial(n-1,a*n); 相比较之前一般形式的递归代码，有两个不同的地方： 递归调用时，把 n 当做参数传给了递归函数，无需等待递归调用返回后参与计算。 最终的计算结果在最后一次递归调用后产生，无需回溯。 我们通过这种形式，解决了需要函数回跳才能计算的问题，但最后产生的计算结果仍然需要层层的回调，但这种代码的形式对于普通的递归来说，编译器更容易对其进行优化。这种特殊的递归叫做尾递归，从递归代码形式上看，它自身的调用是函数的最后一个操作。尾递归的目的是为了优化，而优化的目标是减少栈的空间。 尾递归是递归的一种优化 按照尾递归的定义，尾递归就至少必须解决一般递归的两个问题： 不能重复计算 重复利用栈空间 然而尾递归是为编译器优化的目的，所以还要依赖于编译器的实现，如果一种语言不支持尾递归，那么尾递归也就仅仅是个形式上递归了，JavaScript 就是这样的语言，因为它无法优化栈空间的利用。 实际上尾递归一直被看作一种编译技巧，特别是对于函数式编程语言来说，尾递归的编译器实现做当做的一种必须的标准 es6 中的尾调用优化尾调用被识别出来，重复利用了已存在的栈结构来进行递归，移除了之前函数调用的本地变量和状态。 如果使用了BABEL，它会直接、自递归地处理尾调用。 爆栈问题解决递归改循环","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"变量的解构赋值","slug":"变量的解构赋值","date":"2018-07-16T04:05:20.000Z","updated":"2019-11-10T14:37:39.034Z","comments":true,"path":"2018/07/16/变量的解构赋值/","link":"","permalink":"http://yoursite.com/2018/07/16/变量的解构赋值/","excerpt":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。","text":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 解构不成功如果解构不成功，变量的值就等于 undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo 的值都会等于 undefined。 不完全解构等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x; // 1y; // 2let [a, [b], d] = [1, [2, 3], 4];a; // 1b; // 2d; // 4 等号右边不是数组如果等号的右边不是数组，那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo; // truelet [x, y = \"b\"] = [\"a\"]; // x='a', y='b'let [x, y = \"b\"] = [\"a\", undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效。null 不严格等于 undefined。所以，如果数组成员是 null，默认值则不会生效。 12345let [x = 1] = [undefined];x; // 1let [x = 1] = [null];x; // null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1let [x = y, y = 1] = []; // ReferenceError: y is not defined 上式之所以会报错，是因为 x 用 y 做默认值时，y 还没有声明。 对象的解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1234567891011121314let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\"bar; // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // undefinedlet &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"let obj = &#123; first: \"hello\", last: \"world\" &#125;;let &#123; first: f, last: l &#125; = obj;f; // 'hello'l; // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"foo; // error: foo is not defined 上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。 解构失败如果解构失败，变量的值等于 undefined。 12let &#123; foo &#125; = &#123; bar: \"baz\" &#125;;foo; // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 1234// 报错let &#123; foo: &#123; bar &#125;&#125; = &#123; baz: \"baz\" &#125;; 上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因为 foo 这时等于 undefined，再取子属性就会报错。 默认值对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于 undefined。 12345var &#123; x = 3 &#125; = &#123; x: undefined &#125;;x; // 3var &#123; x = 3 &#125; = &#123; x: null &#125;;x; // null 上面代码中，属性 x 等于 null，因为 null 与 undefined 不严格相等，所以是个有效的赋值，导致默认值 3 不会生效。 字符串的解构赋值字符串被转换成了一个类似数组的对象。 123456789const [a, b, c, d, e] = \"hello\";a; // \"h\"b; // \"e\"c; // \"l\"d; // \"l\"e; // \"o\"let &#123; length: len &#125; = \"hello\";len; // 5 数值和布尔值的解构赋值等号右边是数值和布尔值，则会先转为对象。解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值1234567function add([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。 12345678function move(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"var，let和const声明及区别","slug":"var，let和const声明及区别","date":"2018-07-04T03:29:59.000Z","updated":"2019-11-10T14:37:39.028Z","comments":true,"path":"2018/07/04/var，let和const声明及区别/","link":"","permalink":"http://yoursite.com/2018/07/04/var，let和const声明及区别/","excerpt":"var 声明在函数作用域或全局作用域中通过 var 声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。","text":"var 声明在函数作用域或全局作用域中通过 var 声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。 例如： 123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 事实上，在预编译阶段，JavaScript 引擎会将上面的函数修改为下面这样： 12345678910111213fuction getValue(condition)&#123; var value; if(condition)&#123; value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 变量 value 的声明会被提升至函数顶部，而初始化操作依然留在原处执行。这样，就意味着，在函数的其他部分，else 子句中或者 if-else 外，也能访问到 value 变量，而由于此时 value 变量并未被初始化赋值，所以访问到值为 undefined。 块级声明ES6 中引入块级作用域来强化对变量生命周期的控制。块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（词法作用域）存在于： 函数内部 块中（字符{和}之间的区域） let 声明let 声明的用法与 var 相同。用 let 代替 var 来声明变量，就可以把变量的作用域限制在当前代码块中。let 声明不会被提升，因此通常将 let 声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。 123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //变量value在此处不存在 return null; &#125; //变量value在此处不存在&#125; let 声明后，不会被提升至函数顶部。因此执行流离开 if 块之后，value 立刻被销毁，如果 condition 的值为 false，就永远不会声明并初始化 value。并且，假设作用域中已经存在了某个标识符，此时再用 let 关键字声明它，就会抛出错误： 123var count = 30;//抛出语法错误let count = 40; 在同一作用域中不能用 let 重复定义已经存在的标识符，所以此处使用 let 声明会抛出错误。但如果当前作用域内内嵌另一个作用域，就可在内嵌的作用域中使用 let 声明同名变量。例如： 12345var count = 30;if (condition) &#123; //不会抛出错误 let count = 40;&#125; 此时，if 内部块中的 count 会遮蔽全局作用域中的 count，而 var 声明的 count 只能在 if 块外访问到。 const 声明使用 const 声明的是常量，其值一旦被设定后不可更改。因此每个通过 const 声明的常量必须在声明的同时被初始化。 12345//有效的常量const max=30;//语法错误，常量未初始化const name; const 和 let 声明都是块级标识符，所以常量也只在当前的代码块内有效，一旦执行到代码块外会被立即销毁。并且，常量也不会被提升至作用域顶部。同样，与 let 相似，在同一作用域用 const 声明已经存在的标识符，也会导致语法错误。 如上所述，const 定义的值一旦被设定后不可更改，无论在严格模式还是非严格模式下，都不可以为 const 定义的常量再赋值，否则会抛出语法错误： 123const max = 50;//抛出语法错误max = 30; 然而，与其他语言中的常量不同的是，JavaScript 中的常量，如果是对象，则对象的值可以修改，也就是 const 声明不允许修改绑定，但允许修改值这也意味着，const 声明对象后，可以修改对象的属性。const 实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const 只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。 1234567891011const person=&#123; name:\"Nicholas\";&#125;;//可以修改对象属性的值person.name=\"Greg\";//抛出语法错误person=&#123; name:\"Greg\";&#125;; 如果真的想将对象冻结，应该使用 Object.freeze 方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量 foo 指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = obj =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach((key, i) =&gt; &#123; if (typeof obj[key] === \"object\") &#123; constantize(obj[key]); &#125; &#125;);&#125;; 临时死区（Temporal Dead Zone）临时死区常被描述 let 和 const 的不提升的效果。JavaScript 引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到 var 声明时），要么将声明放到 TDZ 中（遇到 let 和 const 声明时）。访问 TDZ 中的变量会触发运行错误。只有在执行过变量声明语句后，变量才会从 TDZ 中移出，然后方可正常访问。ES6 明确规定，如果区块中存在 let 和 const 命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 1234if (condition) &#123; console.log(typeof value); //引用错误！ let value = \"blue\";&#125; 但在 let 声明的作用域外对该变量使用 typeof 则不会报错： 12345console.log(typeof value); //\"undefined\"if (condition) &#123; let value = \"blue\";&#125; typeof 是在声明变量 value 的代码块外执行的，此时 value 并不在 TDZ 中，也就意味着不存在 value 这个绑定，typeof 操作最终返回”undefined”。 循环中的块级作用域绑定先看这段代码： 1234567891011var funcs = [];for (var i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); //输出10次数字10&#125;); 预想结果是输出数字 0 ～ 9，但是因为循环里的每次迭代同时共享着 i，循环内部创建的函数全部都保存了对相同变量的引用。循环结束时变量 i 的值为 10，所以每次调用 console.log（i）时都会输出数字 10。而使用 let 声明，每次迭代循环都会创建一个新变量，并以之前的迭代中同名变量的值将其初始化，得到预期的效果。 1234567891011var funcs = [];for (let i = 0; i &lt; 10; i++) &#123; funcs.push(function() &#123; console.log(i); &#125;);&#125;funcs.forEach(function(func) &#123; func(); //输出0，1，2，……，9&#125;); 当前的 i 只在本轮循环有效，所以每一次循环的 i 其实都是一个新的变量，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量 i 时，就在上一轮循环的基础上进行计算。另外，for 循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。const 也是同样，但在循环中不能修改 const 声明的变量，否则会抛出错误。 全局作用域绑定当 var 被用在全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的 window 对象）的属性。这意味着，用 var 很可能会无意中覆盖一个已经存在的全局属性。例如： 123//在浏览器中var RegExp = \"Hello!\";console.log(window.RegExp); //\"Hello!\" 全局对象定义在 RegExp 定义在 window 上，但不能幸免被 var 覆盖，成为 window 的属性。但如果在全局作用域中使用 let 或者 const，会在全局作用域下创建一个新的绑定，但该绑定不会添加全局对象的属性。用 let 或 const 不能覆盖全局变量，只能遮蔽它。 1234//在浏览器中let RegExp = \"Hello!\";console.log(RegExp); //\"Hello!\"console.log(window.RegExp === RegExp); //false 这里 let 声明的 RegExp 创建了一个绑定并遮蔽了全局的 RegExp 变量，但 window.RegExp 和 RegExp 并不相同，说明它不会破坏全局作用域，不会为全局对象创建属性。 ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var 命令和 function 命令。ES6 除了添加 let 和 const 命令，还有另外两种声明变量的方法：import 命令和 class 命令。所以，ES6 一共有 6 种声明变量的方法。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]}]}