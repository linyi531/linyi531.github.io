{"meta":{"title":"01不是包子脸","subtitle":"小01的程序猿成长之路","description":null,"author":"Linyi Li","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:37:46.747Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T07:21:46.777Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 ProfileCease to struggle and you cease to live. 大家好，我是『01』。一个不承认自己是包子脸的小仙女～哈哈哈哈～ 作为一只程序猿，虽然我比较菜，但是我在努力成长啊。这个博客，想记录一路走来的点点滴滴。 希望我们，都能有自己的一技之长，在社会上的某个方面能成为独当一面的佼佼者。 生命不止，奋斗不息。 Social Info : 01 : 01"},{"title":"Tags","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:36:30.431Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"leetcode算法刷题笔记（二）——回溯问题","slug":"leetcode算法刷题笔记（二）——回溯问题","date":"2019-02-15T14:07:43.000Z","updated":"2019-03-22T06:52:29.060Z","comments":true,"path":"2019/02/15/leetcode算法刷题笔记（二）——回溯问题/","link":"","permalink":"http://yoursite.com/2019/02/15/leetcode算法刷题笔记（二）——回溯问题/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯 123456789101112131415161718192021222324252627282930313233var letterCombinations = function(digits) &#123; var res = []; var sort = []; if (digits.length == 0) &#123; return res; &#125; var phone = [ \"0\", \"1\", [\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"], [\"j\", \"k\", \"l\"], [\"m\", \"n\", \"o\"], [\"p\", \"q\", \"r\", \"s\"], [\"t\", \"u\", \"v\"], [\"w\", \"x\", \"y\", \"z\"] ]; finger(0); return res; function finger(index) &#123; if (index == digits.length) &#123; return res.push(sort.join(\"\")); &#125; var temp = phone[digits[index]]; for (var i = 0; i &lt; temp.length; i++) &#123; sort.push(temp[i]); finger(index + 1); sort.pop(); &#125; &#125;&#125;; [22] Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.难度：Medium (53.42%)考点：回溯思路： 给定 n 值，则总共有 n 个左括号，n 个右括号。 第一个添加的一定是左括号。 当添加了一个左括号之后，才会有一个右括号可以添加。所以回溯时，left-1 的同时 right+1 当已添加了 n 个左括号后，剩下的都应该添加右括号 123456789101112131415161718192021var generateParenthesis = function(n) &#123; var res = []; var left = n - 1; var right = 1; function quote(left, right, str) &#123; if (left &lt;= 0) &#123; if (right) &#123; for (var i = 0; i &lt; right; i++) &#123; str = str + \")\"; &#125; &#125; return res.push(str); &#125; quote(left - 1, right + 1, str + \"(\"); if (right &gt; 0) &#123; quote(left, right - 1, str + \")\"); &#125; &#125; quote(left, right, \"(\"); return res;&#125;; [46] PermutationsGiven a collection of distinct integers, return all possible permutations.难度：Medium (53.67%)考点：回溯思路：选择一个元素之后，则下次可选择的元素就少一个。 12345678910111213141516171819202122var permute = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [47] Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations.难度：Medium (39.35%)考点：回溯思路：思路同上题。注意筛选条件。 12345678910111213141516171819202122232425262728var permuteUnique = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; &#123; return a - b; &#125;); select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i - 1]) &#123; continue; &#125; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [60] Permutations II ☆☆The set [1,2,3,…,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:“123”“132”“213”“231”“312”“321”Given n and k, return the k^th permutation sequence.Note:Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.难度：Medium (32.42%)考点：回溯 123456789101112131415161718192021var getPermutation = function(n, k) &#123; (res = []), (pos = k - 1); var nums = []; if (n == 0) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; var numsSort = nums.reduce((a, b) =&gt; a * b); if (k &lt; 1 || k &gt; numsSort) &#123; return \"error\"; &#125; for (var j = n; j &gt;= 1; --j) &#123; numsSort /= j; res.push(nums.splice(parseInt(pos / numsSort), 1)[0]); pos %= numsSort; &#125; return res.join(\"\");&#125;; [77] ombinations ☆☆Given two integers n and k, return all possible combinations of k numbers out of 1 … n.难度：Medium (46.23%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件 12345678910111213141516171819202122232425262728var combine = function(n, k) &#123; var nums = []; var res = []; var temp = []; if (n == 0 || k &lt;= 0 || k &gt; n) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; select(0, nums); return res; function select(start, nums) &#123; if (temp.length == k) &#123; return res.push(temp.slice()); &#125; for (var i = start; i &lt; n; i++) &#123; if (temp.length &gt;= 1 &amp;&amp; temp[temp.length - 1] &gt; i) &#123; continue; &#125; temp.push(nums[i]); select(start + 1, nums); temp.pop(); &#125; &#125;&#125;; [78] SubsetsGiven a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (51.26%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件。 123456789101112131415161718192021222324252627282930313233var subsets = function(nums) &#123; var res = []; var subsets = []; var used = []; res.push(subsets.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var j = 1; j &lt;= nums.length; j++) &#123; findSubsets(0, j); &#125; return res; function findSubsets(start, k) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (subsets.length == k) &#123; return res.push(subsets.slice()); &#125; if (used[i]) &#123; continue; &#125; if (start &gt; 0 &amp;&amp; nums[i] &lt; subsets[subsets.length - 1]) &#123; continue; &#125; subsets.push(nums[i]); used[i] = true; findSubsets(start + 1, k); subsets.pop(); used[i] = false; &#125; &#125;&#125;; [79] Word SearchGiven a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.难度：Medium (30.52%)考点：回溯思路：要分四个方向分别回溯。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var exist = function(board, word) &#123; var row = board.length; var col = board[0].length; if (word.length &gt; row * col) &#123; return false; &#125; function search(i, j, n) &#123; if ( i &gt;= row || j &gt;= col || i &lt; 0 || j &lt; 0 || board[i][j] != word[n] || n &gt; word.length ) &#123; return false; &#125; if (n == word.length - 1) &#123; return true; &#125; board[i][j] = true; if (search(i + 1, j, n + 1)) &#123; return true; &#125; if (search(i - 1, j, n + 1)) &#123; return true; &#125; if (search(i, j + 1, n + 1)) &#123; return true; &#125; if (search(i, j - 1, n + 1)) &#123; return true; &#125; board[i][j] = word[n]; return false; &#125; for (var i = 0; i &lt; row; i++) &#123; for (var j = 0; j &lt; col; j++) &#123; if (search(i, j, 0)) &#123; return true; &#125; &#125; &#125; return false;&#125;; [89] Gray Code ☆☆The gray code is a binary numeral system where two successive values differ in only one bit.Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.难度：Medium (45.03%)考点：回溯思路：可根据格雷码的特性考虑解法一（普通解法）： 123456789101112131415161718192021222324252627282930var grayCode = function(n) &#123; var result = []; var graycodeFn = function(n) &#123; var graycode = []; if (n == 1) &#123; graycode[0] = \"0\"; graycode[1] = \"1\"; return graycode; &#125; var last = arguments.callee(n - 1); // arguments.callee(n-1) == graycodeFn(n-1) for (var i = last.length - 1; i &gt;= 0; --i) &#123; graycode.unshift(\"0\" + last[i]); graycode.push(\"1\" + last[i]); &#125; return graycode; &#125;; var graycode = n == 0 ? [\"0\"] : graycodeFn(n); for (var i = 0; i &lt; graycode.length; ++i) &#123; result.push(parseInt(parseInt(graycode[i], 2), 10)); // String To Number &#125; return result;&#125;; 解法二（大神解法）： 1234567var grayCode = function(n) &#123; let nums = [0], c = -1; while (c++ &lt; n - 1) nums = [...nums, ...nums.map(num =&gt; num + Math.pow(2, c)).reverse()]; return nums;&#125;; [90] Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (41.57%)考点：回溯 12345678910111213141516171819202122232425262728var subsetsWithDup = function(nums) &#123; var sub = []; var res = []; res.push(sub.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var i = 1; i &lt;= nums.length; i++) &#123; findSub(0, i); &#125; return res; function findSub(start, k) &#123; if (sub.length == k) &#123; return res.push(sub.slice()); &#125; for (var j = start; j &lt; nums.length; j++) &#123; if (j &gt; start &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; sub.push(nums[j]); findSub(j + 1, k); sub.pop(); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"leetcode算法刷题笔记（一）——数组","slug":"leetcode算法刷题笔记（一）——数组","date":"2019-01-18T16:07:06.000Z","updated":"2019-03-19T14:58:11.005Z","comments":true,"path":"2019/01/19/leetcode算法刷题笔记（一）——数组/","link":"","permalink":"http://yoursite.com/2019/01/19/leetcode算法刷题笔记（一）——数组/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断 1234567891011var twoSum = function(nums, target) &#123; var map = &#123;&#125;; for (i = 0; i &lt; nums.length; i++) &#123; const complement = target - nums[i]; if (complement in map) &#123; return [i, map[complement]]; &#125; map[nums[i]] = i; &#125; return -1;&#125;; [11] Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2.难度：Medium (42.93%)考点：动态规划思路： 设定 i，j 分别指向数组的头和尾 比较 i，j 所对应的位置的值，值较小的那一个移动（i++或 j–） 123456789101112131415161718var maxArea = function(height) &#123; var maxArea = 0; var i = 0; var j = height.length - 1; while (i &lt; j) &#123; const long = Math.min(height[i], height[j]); const area = long * (j - i); if (area &gt; maxArea) &#123; maxArea = area; &#125; if (height[i] &lt; height[j]) &#123; i++; &#125; else &#123; j--; &#125; &#125; return maxArea;&#125;; [15] 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.难度：Medium (23.55%)思路： 数组排序（升序） 设定三个指针，最外层循环从 0 开始，到数组的尾结束（i=0） 第二层循环，一个指向上一个指针的下一个元素（j=i+1），另一个指向数组的尾部(k=nums.length-1) 如果三个元素之和等于 0，则 push 进要返回的数组中；如果三个元素之和大于 0，说明第三个指针指向的元素过大，则第三个指针向前移(k–);如果三个元素之和小于 0，说明第二个指针指向的元素过小，则第二个指针向后移(j++); 123456789101112131415161718192021222324252627282930313233343536var threeSum = function(nums) &#123; var rtn = []; if (nums.length &lt; 3) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; 0) &#123; return rtn; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === 0) &#123; rtn.push([nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; 0) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return rtn;&#125;; [16] 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.难度：Medium (41.40%)思路：与上题类似 12345678910111213141516171819202122232425262728var threeSumClosest = function(nums, target) &#123; var sum; if (nums.length &lt; 3) &#123; return sum; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); var sum = nums[0] + nums[1] + nums[2]; var distance = Math.abs(sum - target); for (var i = 0; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (Math.abs(nums[i] + nums[j] + nums[k] - target) &lt; distance) &#123; sum = nums[i] + nums[j] + nums[k]; distance = Math.abs(sum - target); &#125; if (nums[i] + nums[j] + nums[k] === target) &#123; break; &#125; if (nums[i] + nums[j] + nums[k] &gt; target) &#123; k--; &#125; else if (nums[i] + nums[j] + nums[k] &lt; target) &#123; j++; &#125; &#125; &#125; return sum;&#125;; [18] 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.难度：Medium (29.83%)思路：思路同 3Sum，多一层循环。注意跳过相同的数（最外两层的循环变量） 1234567891011121314151617181920212223242526272829303132333435363738var fourSum = function(nums, target) &#123; var rtn = []; if (nums.length &lt; 4) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var m = 0; m &lt; nums.length - 3; m++) &#123; var complement = target - nums[m]; for (var i = m + 1; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === complement) &#123; rtn.push([nums[m], nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; complement) &#123; k--; &#125; else &#123; j++; &#125; if (i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; ++i; &#125; &#125; if (m &lt; nums.length - 1 &amp;&amp; nums[m] == nums[m + 1]) &#123; ++m; &#125; &#125; &#125; return rtn;&#125;; [26] Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.难度：Easy (39.80%)思路：两个指针，一个指针负责寻找和后一个不相等的数，另一个指针负责一步步向后移去重。 1234567891011121314151617181920var removeDuplicates = function(nums) &#123; if (nums.length == 0) &#123; return 0; &#125; var i = 0; var j = 0; for (i = 0; i &lt; nums.length - 1; ) &#123; if (nums[i] === nums[i + 1]) &#123; i++; &#125; else &#123; if (i !== j) &#123; nums[j + 1] = nums[i + 1]; &#125; j++; i++; &#125; &#125; nums = nums.slice(0, j + 1); return nums.length;&#125;; [27] Remove ElementGiven an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length.难度：Easy (43.73%)思路：找到和 val 值相等的位置，将数组最后一个元素赋值过来（去掉这个 val，数组长度减一） 12345678910111213var removeElement = function(nums, val) &#123; var i = 0; var n = nums.length; for (i = 0; i &lt; n; ) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; n--; &#125; else &#123; i++; &#125; &#125; return n;&#125;; [31] Next PermutationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place and use only constant extra memory.Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1难度：Medium (30.09%)思路： 从后向前比较相邻的两个元素，直到前一个元素小于后一个元素，停止（i）。 若已经没有了前一个元素（i=0），则该序列为递减序列，没有 Next Permutation。按照题目要求，直接反转序列。 前一个元素（j=i-1）小于后一个元素（i），找到前一个元素（j）要交换的元素，从 i 的后一个元素开始往后查找，找到最后一个比“前一个元素（j）”大的元素（k），也就是再往后的元素，就比元素 j 小了。交换 j 和 k 元素。 从 i 开始，包括 i 到序列的尾部，反转。则得出的即是 Next Permutation 1234567891011121314151617181920212223var nextPermutation = function(nums) &#123; var i = nums.length - 1; while (nums[i] &lt;= nums[i - 1]) &#123; i--; &#125; if (i !== 0) &#123; var j = i - 1; var k = i + 1; while (nums[j] &lt; nums[k]) &#123; k++; &#125; var temp = nums[k - 1]; nums[k - 1] = nums[j]; nums[j] = temp; for (var m = i, n = nums.length - 1; m &lt; n; m++, n--) &#123; var temp = nums[n]; nums[n] = nums[m]; nums[m] = temp; &#125; &#125; else &#123; nums = nums.reverse(); &#125;&#125;; [33] Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.Your algorithm’s runtime complexity must be in the order of O(log n).难度：Medium (32.68%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627var search = function(nums, target) &#123; if (nums.length == 0) &#123; return -1; &#125; var start = 0; var end = nums.length - 1; while (start &lt;= end) &#123; var middle = parseInt((start + end) / 2); if (nums[middle] == target) &#123; return middle; &#125; if (nums[middle] &gt; nums[end]) &#123; if (target &gt;= nums[start] &amp;&amp; target &lt; nums[middle]) &#123; end = middle - 1; &#125; else &#123; start = middle + 1; &#125; &#125; else &#123; if (target &gt; nums[middle] &amp;&amp; target &lt;= nums[end]) &#123; start = middle + 1; &#125; else &#123; end = middle - 1; &#125; &#125; &#125; return -1;&#125;; [34] Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].难度：Medium (33.06%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627282930var searchRange = function(nums, target) &#123; if (nums.length == 0) &#123; return [-1, -1]; &#125; var startFind = 0; var endFind = nums.length - 1; var start; var end; while (startFind &lt;= endFind) &#123; var mid = parseInt((startFind + endFind) / 2); if (nums[mid] == target) &#123; start = mid; end = mid; while (nums[start - 1] == target || nums[end + 1] == target) &#123; if (nums[start - 1] == target) &#123; start--; &#125; if (nums[end + 1] == target) &#123; end++; &#125; &#125; return [start, end]; &#125; else if (nums[mid] &lt; target) &#123; startFind = mid + 1; &#125; else &#123; endFind = mid - 1; &#125; &#125; return [-1, -1];&#125;; [35] Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.难度：Easy (40.50%) 123456789101112var searchInsert = function(nums, target) &#123; if (nums.length == 0) &#123; return 0; &#125; let out = nums.indexOf(target); if (out == -1) &#123; let i = 0; for (; target &gt; nums[i]; i++) &#123;&#125; out = i; &#125; return out;&#125;; [39] Combination SumGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (46.97%)考点：递归 12345678910111213141516171819202122232425262728var combinationSum = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); sarch(0, target); function sarch(start, target) &#123; if (start == candidates.length) &#123; return; &#125; if (target == 0) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0) &#123; return; &#125; solution.push(candidates[start]); sarch(start, target - candidates[start]); solution.pop(); sarch(start + 1, target); &#125; return rt;&#125;; [40] Combination Sum IIGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.Each number in candidates may only be used once in the combination.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (40.37%)考点：递归注意：限制边界条件，过滤重复的结果 12345678910111213141516171819202122232425262728var combinationSum2 = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); search(0, target); return rt; function search(start, target) &#123; if (target === 0 &amp;&amp; start === candidates.length) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0 || start === candidates.length) &#123; return; &#125; solution.push(candidates[start]); search(start + 1, target - candidates[start]); solution.pop(); if (solution[solution.length - 1] !== candidates[start]) &#123; search(start + 1, target); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"React组件","slug":"React底层-合成事件","date":"2018-12-11T04:10:52.000Z","updated":"2019-03-19T14:58:15.222Z","comments":true,"path":"2018/12/11/React底层-合成事件/","link":"","permalink":"http://yoursite.com/2018/12/11/React底层-合成事件/","excerpt":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上）","text":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上） 自动绑定每个方法的上下文都会指向该组件的实例——自动绑定 this 为当前组件。React 会对这种引用进行缓存，达到 CPU 内存最优。（使用 ES6 class 或纯函数时，自动绑定不复存在，需要手动绑定 this） bind 绑定绑定事件处理器内的 this，并可以向事件处理器中传参 构造器内声明好处：仅需进行一次绑定 箭头函数箭头函数自动绑定了定义此函数作用域的 this，因此不需要再用 bind 绑定 注意：React 中使用 DOM 原生事件，一定要在组件卸载时手动移除，否则内存泄漏。使用合成事件则不需要。 React 合成事件与 JS 原生事件对比原生 DOM 事件传播 3 个阶段：事件捕获阶段、目标对象本身的事件处理程序调用，以及事件冒泡。 事件捕获阶段会优先调用结构树最外层的元素上绑定的事件侦听器，依次向内调用，一直调用到目标元素上的事件监听器为止。 1e.addEventListener(\"click\", () =&gt; &#123;&#125;, false); 第三个参数，若传 true，为元素 e 注册捕获事件处理程序，并且在事件捕获阶段调用。 事件冒泡与事件捕获相反，它会从目标元素向外传播，由内而外。React 的合成事件仅支持事件冒泡阻止原生事件冒泡用 e.preventDefault() React 受控组件更新 state 的流程 可以通过在初始 state 中设置表单的默认值 每当表单的值发生变化时，调用 onchange 事件处理器 事件处理器通过合成事件对象 e 拿到改变后的状态，并更行应用的 state setState 触发视图的重新渲染，完成表单的组件值更新 React 非受控组件是一种反模式，他的值不受组件自身的 state 或 props 控制。通常需要为其添加 ref prop 来访问渲染后的底层 DOM","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"Proxy","slug":"Proxy","date":"2018-11-27T03:07:46.000Z","updated":"2019-03-19T13:43:35.154Z","comments":true,"path":"2018/11/27/Proxy/","link":"","permalink":"http://yoursite.com/2018/11/27/Proxy/","excerpt":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。","text":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。 下面是一个拦截读取属性行为的例子。 123456789101112var proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125; &#125;);proxy.time; // 35proxy.name; // 35proxy.title; // 35 上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。注意，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。如果 handler 没有设置任何拦截，那就等同于直接通向原对象。同一个拦截器函数，可以设置拦截多个操作。 12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === \"prototype\") &#123; return Object.prototype; &#125; return \"Hello, \" + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123; value: args[1] &#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2); // 1new fproxy(1, 2); // &#123;value: 2&#125;fproxy.prototype === Object.prototype; // truefproxy.foo === \"Hello, foo\"; // true Proxy 支持的拦截操作一览Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。 set(target, propKey, value, receiver)拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)拦截 propKey in proxy 的操作，返回一个布尔值。 deleteProperty(target, propKey)拦截 delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)拦截 Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)拦截 Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)拦截 Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例），其中最后一个参数可选。 12345678910111213141516var person = &#123; name: \"张三\"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError('Property \"' + property + '\" does not exist.'); &#125; &#125;&#125;);proxy.name; // \"张三\"proxy.age; // 抛出一个错误 get 方法可以继承。 123456789101112let proto = new Proxy( &#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(\"GET \" + propertyKey); return target[propertyKey]; &#125; &#125;);let obj = Object.create(proto);obj.foo; // \"GET foo\" 上面代码中，拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效。利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 1234567891011121314151617181920212223242526272829303132var pipe = (function() &#123; return function(value) &#123; var funcStack = []; var oproxy = new Proxy( &#123;&#125;, &#123; get: function(pipeObject, fnName) &#123; if (fnName === \"get\") &#123; return funcStack.reduce(function(val, fn) &#123; return fn(val); &#125;, value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125; ); return oproxy; &#125;;&#125;)();var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n .toString() .split(\"\") .reverse() .join(\"\") | 0;pipe(3).double.pow.reverseInt.get; // 63 下面是一个 get 方法的第三个参数的例子 1234567891011const proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property, receiver) &#123; return receiver; &#125; &#125;);const d = Object.create(proxy);d.a === d; // true 上面代码中，d 对象本身没有 a 属性，所以读取 d.a 的时候，会去 d 的原型 proxy 对象找。这时，receiver 就指向 d，代表原始的读操作所在的那个对象。如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。 123456789101112131415161718192021const target = Object.defineProperties( &#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125; &#125;);const handler = &#123; get(target, propKey) &#123; return \"abc\"; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo;// TypeError: Invariant check failed set()set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。利用 set 方法，可以进行数据验证，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。 12345678910111213141516171819202122const handler = &#123; get(target, key) &#123; invariant(key, \"get\"); return target[key]; &#125;, set(target, key, value) &#123; invariant(key, \"set\"); target[key] = value; return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;const target = &#123;&#125;;const proxy = new Proxy(target, handler);proxy._prop;// Error: Invalid attempt to get private \"_prop\" propertyproxy._prop = \"c\";// Error: Invalid attempt to set private \"_prop\" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。下面是 set 方法第四个参数的例子。 1234567891011const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = receiver; &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);const myObj = &#123;&#125;;Object.setPrototypeOf(myObj, proxy);myObj.foo = \"bar\";myObj.foo === myObj; // true 上面代码中，设置 myObj.foo 属性的值时，myObj 并没有 foo 属性，因此引擎会到 myObj 的原型链去找 foo 属性。myObj 的原型对象 proxy 是一个 Proxy 实例，设置它的 foo 属性会触发 set 方法。这时，第四个参数 receiver 就指向原始赋值行为所在的对象 myObj。如果目标对象自身的某个属性，不可写且不可配置，那么 set 方法将不起作用。 123456789101112131415const obj = &#123;&#125;;Object.defineProperty(obj, \"foo\", &#123; value: \"bar\", writable: false&#125;);const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = \"baz\"; &#125;&#125;;const proxy = new Proxy(obj, handler);proxy.foo = \"baz\";proxy.foo; // \"bar\" apply()apply 方法拦截函数的调用、call 和 apply 操作。apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345678910111213var target = function() &#123; return \"I am the target\";&#125;;var handler = &#123; apply: function() &#123; return \"I am the proxy\"; &#125;&#125;;var p = new Proxy(target, handler);p();// \"I am the proxy\" 上面代码中，变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串。另外，直接调用 Reflect.apply 方法，也会被拦截。 has()has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。has 方法可以接受两个参数，分别是目标对象、需查询的属性名。下面的例子使用 has 方法隐藏某些属性，不被 in 运算符发现。 1234567891011var handler = &#123; has(target, key) &#123; if (key[0] === \"_\") &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: \"foo\", prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);\"_prop\" in proxy; // false 如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。 12345678910var obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false; &#125;&#125;);\"a\" in p; // TypeError is thrown 上面代码中，obj 对象禁止扩展，结果使用 has 拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则 has 方法就不得“隐藏”（即返回 false）目标对象的该属性。has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性。另外，虽然 for…in 循环也用到了 in 运算符，但是 has 拦截对 for…in 循环不生效。 construct()construct 方法用于拦截 new 命令，下面是拦截对象的写法。 12345var handler = &#123; construct(target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct 方法可以接受三个参数。target：目标对象。args：构造函数的参数对象。newTarget：创造实例对象时，new 命令作用的构造函数。construct 方法返回的必须是一个对象，否则会报错。 12345678910var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, args) &#123; console.log(\"called: \" + args.join(\", \")); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);new p(1).value;// \"called: 1\"// 10 1234567var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, argumentsList) &#123; return 1; &#125;&#125;);new p(); // 报错 deleteProperty()deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。 12345678910111213141516var handler = &#123; deleteProperty(target, key) &#123; invariant(key, \"delete\"); return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;var target = &#123; _prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);delete proxy._prop;// Error: Invalid attempt to delete private \"_prop\" property deleteProperty 方法拦截了 delete 操作符，删除第一个字符为下划线的属性会报错。注意，目标对象自身的不可配置（configurable）的属性，不能被 deleteProperty 方法删除，否则报错。 defineProperty()defineProperty 方法拦截了 Object.defineProperty 操作。 12345678var handler = &#123; defineProperty(target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = \"bar\"; // 不会生效 defineProperty 方法返回 false，导致添加新属性总是无效。注意，如果目标对象不可扩展（extensible），则 defineProperty 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则 defineProperty 方法不得改变这两个设置。 getOwnPropertyDescriptor()getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者 undefined。 12345678910111213141516var handler = &#123; getOwnPropertyDescriptor(target, key) &#123; if (key[0] === \"_\") &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: \"bar\", baz: \"tar\" &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, \"wat\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"_foo\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"baz\");// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名会返回 undefined。 getPrototypeOf()getPrototypeOf 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 12345678910var proto = &#123;&#125;;var p = new Proxy( &#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125; &#125;);Object.getPrototypeOf(p) === proto; // true getPrototypeOf 方法的返回值必须是对象或者 null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf 方法必须返回目标对象的原型对象。 isExtensible()isExtensible 方法拦截 Object.isExtensible 操作 12345678910111213var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; console.log(\"called\"); return true; &#125; &#125;);Object.isExtensible(p);// \"called\"// true 该方法只能返回布尔值，否则返回值会被自动转为布尔值。这个方法有一个强限制，它的返回值必须与目标对象的 isExtensible 属性保持一致，否则就会抛出错误。 1234567891011var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; return false; &#125; &#125;);Object.isExtensible(p); // 报错Object.isExtensible(proxy) === Object.isExtensible(target); //true ownKeys()ownKeys 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for…in 循环 12345678910111213141516let target = &#123; a: 1, b: 2, c: 3&#125;;let handler = &#123; ownKeys(target) &#123; return [\"a\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// [ 'a' ] 注意，使用 Object.keys 方法时，有三类属性会被 ownKeys 方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 123456789101112131415161718192021222324let target = &#123; a: 1, b: 2, c: 3, [Symbol.for(\"secret\")]: \"4\"&#125;;Object.defineProperty(target, \"key\", &#123; enumerable: false, configurable: true, writable: true, value: \"static\"&#125;);let handler = &#123; ownKeys(target) &#123; return [\"a\", \"d\", Symbol.for(\"secret\"), \"key\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// ['a'] 上面代码中，ownKeys 方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for(‘secret’)）、不可遍历的属性（key），结果都被自动过滤掉。 123456789101112131415161718192021222324//ownKeys方法还可以拦截Object.getOwnPropertyNames()var p = new Proxy( &#123;&#125;, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\", \"c\"]; &#125; &#125;);Object.getOwnPropertyNames(p);// [ 'a', 'b', 'c' ]//for...in循环也受到ownKeys方法的拦截const obj = &#123; hello: \"world\" &#125;;const proxy = new Proxy(obj, &#123; ownKeys: function() &#123; return [\"a\", \"b\"]; &#125;&#125;);for (let key in proxy) &#123; console.log(key); // 没有任何输出&#125; 上面代码中，ownkeys 指定只返回 a 和 b 属性，由于 obj 没有这两个属性，因此 for…in 循环不会有任何输出。ownKeys 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。 12345678910var obj = &#123;&#125;;var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [123, true, undefined, null, &#123;&#125;, []]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 123 is not a valid property name 如果目标对象自身包含不可配置的属性，则该属性必须被 ownKeys 方法返回，否则报错。 123456789101112131415var obj = &#123;&#125;;Object.defineProperty(obj, \"a\", &#123; configurable: false, enumerable: true, value: 10&#125;);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a' 如果目标对象是不可扩展的（non-extensition），这时 ownKeys 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。 1234567891011121314var obj = &#123; a: 1&#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible preventExtensions()preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy)为 false），proxy.preventExtensions 才能返回 true，否则会报错。 1234567891011121314151617181920212223242526var p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125; &#125;);Object.preventExtensions(p); // 报错//为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensionsvar p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; console.log(\"called\"); Object.preventExtensions(target); return true; &#125; &#125;);Object.preventExtensions(p);// \"called\"// true setPrototypeOf()setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。 12345678910var handler = &#123; setPrototypeOf(target, proto) &#123; throw new Error(\"Changing the prototype is forbidden\"); &#125;&#125;;var proto = &#123;&#125;;var target = function() &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden 上面代码中，只要修改 target 的原型对象，就会报错。注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf 方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable 方法返回一个可取消的 Proxy 实例 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo; // 123revoke();proxy.foo; // TypeError: Revoked Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。Proxy.revocable 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function() &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m(); // falseproxy.m(); // true","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"this和super关键字","slug":"this和super关键字","date":"2018-10-24T10:41:35.000Z","updated":"2019-03-19T13:43:37.058Z","comments":true,"path":"2018/10/24/this和super关键字/","link":"","permalink":"http://yoursite.com/2018/10/24/this和super关键字/","excerpt":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身","text":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身 12345678910var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向obj对象obj.getA(); 作为普通函数调用作为普通函数调用时，this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。 1234567891011var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向window对象var getA = obj.getA;getA(); 这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。 构造器调用构造器调用时，this 指向返回的对象。用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。 12345678910111213var a = 10;var b = 20;function Point(x, y) &#123; this.x = x; this.y = y;&#125;var a = new Point(1, 2);console.log(a.x); // 1console.log(x); // 10var b = new Point(1, 2);console.log(a === b); // false call apply bind当函数通过 call()和 apply()方法绑定时，this 指向两个方法的第一个参数对象上，若第一个参数不是对象，JS 内部会尝试将其转化为对象然后再指向它。通过 bind 方法绑定后，无论其在什么情况下被调用，函数将被永远绑定在其第一个参数对象上，bind 绑定后返回的是一个函数。 call, apply 的用途 改变 this 的指向 Function.prototype.bind 12345678Function.prototype.bind = function() &#123; var self = this; var context = [].shift.call(arguments); var args = [].slice.call(arguments); return function() &#123; return self.apply(context, args.concat([].slice.call(arguments))); &#125;;&#125;; 三者区别call 只能一个一个传入参数apply 可直接传入参数数组bind 会返回一个新的函数 super 关键字关键字 super，指向当前对象的原型对象。 12345678910111213const proto = &#123; foo: \"hello\"&#125;;const obj = &#123; foo: \"world\", find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find(); // \"hello\" 上面代码中，对象 obj 的 find 方法之中，通过 super.foo 引用了原型对象 proto 的 foo 属性。注意，super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;;// 报错const obj = &#123; foo: function() &#123; return super.foo; &#125;&#125;; 上面三种 super 的用法都会报错，因为对于 JavaScript 引擎来说，这里的 super 都没有用在对象的方法之中。第一种写法是 super 用在属性里面，第二种和第三种写法是 super 用在一个函数里面，然后赋值给 foo 属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。JavaScript 引擎内部，super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)（方法）。 1234567891011121314151617const proto = &#123; x: \"hello\", foo() &#123; console.log(this.x); &#125;&#125;;const obj = &#123; x: \"world\", foo() &#123; super.foo(); &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.foo(); // \"world\" 上面代码中，super.foo 指向原型对象 proto 的 foo 方法，但是绑定的 this 却还是当前对象 obj，因此输出的就是 world。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-10-14T07:55:35.000Z","updated":"2019-03-19T13:43:39.901Z","comments":true,"path":"2018/10/14/箭头函数/","link":"","permalink":"http://yoursite.com/2018/10/14/箭头函数/","excerpt":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。","text":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function(v) &#123; return v;&#125;; 参数部分如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 1234567891011var f = () =&gt; 5;// 等同于var f = function() &#123; return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 返回对象由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 1234let foo = () =&gt; &#123; a: 1;&#125;;foo(); // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句 a: 1。这时，a 可以被解释为语句的标签，因此实际执行的语句是 1;，然后函数就结束了，没有返回值。箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + \" \" + last;// 等同于function full(person) &#123; return person.first + \" \" + person.last;&#125; 简化回调函数箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1, 2, 3].map(function(x) &#123; return x * x;&#125;);// 箭头函数写法[1, 2, 3].map(x =&gt; x * x); rest 参数与箭头函数结合123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5);// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5);// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。上面四点中，第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(\"id:\", this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this 应该指向全局对象 window，这时应该输出 21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是 42。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。 123456789101112131415161718192021222324252627282930function insert(value) &#123; return &#123; into: function(array) &#123; return &#123; after: function(afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;; &#125; &#125;;&#125;insert(2) .into([1, 3]) .after(1); //[1, 2, 3]//使用箭头函数改写let insert = value =&gt; (&#123; into: array =&gt; (&#123; after: afterValue =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;)&#125;);insert(2) .into([1, 3]) .after(1); //[1, 2, 3] 改写 λ 演算123456// λ演算的写法fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))// ES6的写法var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v)));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"常用git命令","slug":"常用git命令","date":"2018-09-16T03:50:00.000Z","updated":"2019-03-19T13:43:41.209Z","comments":true,"path":"2018/09/16/常用git命令/","link":"","permalink":"http://yoursite.com/2018/09/16/常用git命令/","excerpt":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库","text":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库 git status 查看状态“.” 代表文件夹中所有文件 git add [file1][file2]添加指定文件到暂存区 git commit在第一行写入这次修改记录。将缓存区文件放入提交区。git commit -m [‘message’]git commit -amend修改上次记录信息 git log查看提交记录vim ~/.zshrc 配置文件中可自定义操作source ~/.zshrc 修改配置文件后 source 保存生效 git config查看当前 git 配置git config -h查看帮助信息vim ~/.gitconfig 自定义 git 命令，修改个人名字邮箱等信息cat .git/config 本地配置 touch .gitignore 忽略一些文件 12.vscodenode_modules 写入 gitignore 后即可忽略 node_modules 文件更多信息查看gitignore git diff现实暂存区和工作区的差异 git checkout –a放弃 a 的变更依照提交区恢复工作区的文件，丢弃工作区的变更 git reset HEAD –a从暂存区恢复到工作区 git stash把工作区和暂存区的文件都存入 stash 中git stash list查看 stash 中的文件git stash pop恢复 stash 中的文件到工作区（pop=apply+drop） git reset HEAD\b^后退一步（几个^代表后退几步）git reset HEAD~[number]抛弃了 number 个 commit git reflog查看近期的 log 记录git reset [版本号]回退到版本号为……的 commit 分支操作 git branch develop创建 develop 分支,但依然停留在当前分支git branch -v查看分支 git checkout develop切换进入 develop 分支git checkout -b feature创建并切换进入 feature 分支 合并分支a. 先进入要合并的分支（checkout develop）在执行 git merge feature 即可把 feature 合并到 develop 分支上b. git merge feature develop可达到同样的效果 改变基线git rebase -i [提交记录号]将 HEAD 指向记录号所在位置 远程仓库 git remote add origin [SSH 地址]创建远程仓库连接 git push -u origin develop上传 develop 分支到远程仓库上（远程无项目可直接 push，有项目先 merge 再 push） git pull origin feature拉取远程 feature 分支（pull=fetch+merge） git brach -d feature删除 feature 分支 git push origin :feature删除远程 feature 分支 git tag [标签号]git push origin [标签号]打标签 git remote remove origin取消本地目录下关联的远程仓库 git clone [url]下载一个项目和它的整个代码历史 打 tag vim package.json(vim package-lock.json)可以查看 version 号 npm version -h查看这一个 tag 即将提升的版本号（大版本或者小版本） npm version patch提升 patch 这个小版本（v0.2.2） git tag –list查看 tag 的列表 git push origin masterpush 代码 git push origin v0.2.3push tag","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"正则的扩展","slug":"正则的扩展","date":"2018-08-29T08:56:12.000Z","updated":"2019-03-19T13:43:42.770Z","comments":true,"path":"2018/08/29/正则的扩展/","link":"","permalink":"http://yoursite.com/2018/08/29/正则的扩展/","excerpt":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。","text":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 12345var regex = new RegExp(\"xyz\", \"i\");// 等价于var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; ES6 中，如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/gi, \"i\").flags;// \"i\" 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和 split()。ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 点字符点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。 1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true Unicode 字符表示法ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别当中的大括号，否则会被解读为量词。 12345/\\u&#123;61&#125;/.test(\"a\") / // falsea /u.test(\"a\") / // true 𠮷 / u.test(\"𠮷\"); // true 量词使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。 1234/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true 预定义模式\\S 是预定义模式，匹配所有非空白字符。只有加了 u 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。 12/^\\S$/.test('𠮷') // false/^\\S$/u.test('𠮷') // true i 修饰符有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B 与\\u212A 都是大写的 K。不加 u 修饰符，就无法识别非规范的 K 字符。 123/[a-z]/i.test(\"\\u212A\") / // false [a - z] / iu.test(\"\\u212A\"); // true RegExp.prototype.unicode 属性正则实例对象新增 unicode 属性，表示是否设置了 u 修饰符 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode; // falser2.unicode; // true 上面代码中，正则表达式是否设置了 u 修饰符，可以从 unicode 属性看出来。 y 修饰符ES6 为正则表达式添加了 y 修饰符，叫做“粘连”（sticky）修饰符。y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = \"aaa_aa_a\";var r1 = /a+/g;var r2 = /a+/y;r1.exec(s); // [\"aaa\"]r2.exec(s); // [\"aaa\"]r1.exec(s); // [\"aa\"]r2.exec(s); // null 单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。 12\"a1a2a3\".match(/a\\d/y); // [\"a1\"]\"a1a2a3\".match(/a\\d/gy); // [\"a1\", \"a2\", \"a3\"] RegExp.prototype.sticky 属性与 y 修饰符相匹配，ES6 的正则实例对象多了 sticky 属性，表示是否设置了 y 修饰符。 12var r = /hello\\d/y;r.sticky; // true RegExp.prototype.flags 属性ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。 12345678910// ES5 的 source 属性// 返回正则表达式的正文/abc/gi.source / // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 abc / ig.flags;// 'gi' s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 u 修饰符解决；另一个是行终止符。行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator）ES2018 引入 s 修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test(\"foo\\nbar\"); // true 这被称为 dotAll 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。/s 修饰符和多行修饰符/m 不冲突，两者一起使用的情况下，.匹配所有字符，而^和\\$匹配每一行的行首和行尾。 后行断言”先行断言“指的是，x 只有在 y 前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。”先行否定断言“指的是，x 只有不在 y 前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。“后行断言”正好与“先行断言”相反，x 只有在 y 后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\\$)\\d+/。”后行否定断言“则与”先行否定断言“相反，x 只有不在 y 后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\\$)\\d+/。 123const RE_DOLLAR_PREFIX = /(?&lt;=\\$)foo/g;\"$foo %foo foo\".replace(RE_DOLLAR_PREFIX, \"bar\");// '$bar %foo foo' “后行断言”的实现，需要先匹配/(?&lt;=y)x/的 x，然后再回到左边，匹配 y 的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。首先，后行断言的组匹配，与正常情况下结果是不一样的。 12/(?&lt;=(\\d+)(\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]/^(\\d+)(\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 Unicode 属性类ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。\\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。这两种类只对 Unicode 有效，所以使用的时候一定要加上 u 修饰符。如果不加 u 修饰符，正则表达式使用\\p 和\\P 会报错，ECMAScript 预留了这两个类。 123456789101112131415// 匹配所有空格\\p&#123;White_Space&#125;// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w[\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W[^\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配 Emoji/\\p&#123;Emoji_Modifier_Base&#125;\\p&#123;Emoji_Modifier&#125;?|\\p&#123;Emoji_Presentation&#125;|\\p&#123;Emoji&#125;\\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 具名组匹配正则表达式使用圆括号进行组匹配。 123456const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 正则表达式里面有三组圆括号。使用 exec 方法，就可以将这三组匹配结果提取出来。组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如 matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 “具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在 exec 方法返回结果的 groups 属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。 解构赋值和替换具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。字符串替换时，使用\\$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;\"2015-01-02\".replace(re, \"$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;\");// '02/01/2015' 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法或者数字引用（\\1）的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;RE_TWICE.test(\"abc!abc!abc\"); // trueRE_TWICE.test(\"abc!abc!ab\"); // false String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用 g 修饰符或 y 修饰符，在循环里面逐一取出。或者使用 String.prototype.matchAll 方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = \"test1test2test3\";// g 修饰符加不加都可以const regex = /t(e)(st(\\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于 string.matchAll(regex)返回的是遍历器，所以可以用 for…of 循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。遍历器转为数组是非常简单的，使用…运算符和 Array.from 方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)];// 转为数组方法二Array.from(string.matchAll(regex));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"字符串的扩展","slug":"字符串的扩展","date":"2018-08-09T03:20:29.000Z","updated":"2019-03-19T13:43:48.706Z","comments":true,"path":"2018/08/09/字符串的扩展/","link":"","permalink":"http://yoursite.com/2018/08/09/字符串的扩展/","excerpt":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。","text":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12345678\"\\u0061\";// \"a\"\"\\uD842\\uDFB7\";// \"𠮷\"\"\\u20BB7\";// \" 7\" 如果直接在\\u 后面跟上超过 0xFFFF 的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7。ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 codePointAt()codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。例如，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点（codePointAt 方法返回的是码点的十进制值）。 1234567891011121314var s = \"𠮷\";s.length; // 2s.charAt(0); // ''s.charAt(1); // ''s.charCodeAt(0); // 55362s.charCodeAt(1); // 57271let a = \"𠮷a\";a.codePointAt(0); // 134071a.codePointAt(1); // 57271a.codePointAt(2); // 97 codePointAt 方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷 a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的 20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt 方法的结果与 charCodeAt 方法相同。 String.fromCodePoint()ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 0xFFFF）。ES6 提供了 String.fromCodePoint 方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。且如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回。 1234String.fromCodePoint(0x20bb7);// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === \"x\\uD83D\\uDE80y\";// true 字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被 for…of 循环遍历,并且遍历器最大的优点是可以识别大于 0xFFFF 的码点。 1234567891011for (let codePoint of \"foo\") &#123; console.log(codePoint);&#125;// \"f\"// \"o\"// \"o\"for (let i of text) &#123; console.log(i);&#125;// \"𠮷\" at()ES5 对字符串对象提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符。字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符。 12\"abc\".at(0); // \"a\"\"𠮷\".at(0); // \"𠮷\" normalize()在字符排序或比较时，会出现一种情况，就是“等效”。 规范的等效是指，无论从哪个角度看，两个序列的码位都是没有区别的。 兼容关系，两个互相兼容的码位序列看起来不同，但是在特定的情况下可以相互交换使用。例如 Ǒ（\\u01D1）和 O（\\u004F） ˇ（\\u030C）两个字符的组合（\\u004F\\u030C），在视觉和语义上其实是等效的。 ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12\"\\u01D1\".normalize() === \"\\u004F\\u030C\".normalize();// true 不过，normalize 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 includes(), startsWith(), endsWith()includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。 12345let s = \"Hello world!\";s.startsWith(\"world\", 6); // trues.endsWith(\"Hello\", 5); // trues.includes(\"Hello\", 6); // false repeat()repeat 方法返回一个新字符串，表示将原字符串重复 n 次。参数如果是小数，会被取整。如果 repeat 的参数是负数或者 Infinity，会报错。参数 NaN 等同于 0。如果 repeat 的参数是字符串，则会先转换成数字。 1234567891011121314\"x\".repeat(3); // \"xxx\"\"hello\".repeat(2); // \"hellohello\"\"na\".repeat(0); // \"\"\"na\".repeat(2.9); // \"nana\"\"na\".repeat(Infinity);// RangeError\"na\".repeat(-1);// RangeError\"na\".repeat(NaN); // \"\"\"na\".repeat(\"na\"); // \"\"\"na\".repeat(\"3\"); // \"nanana\" padStart()，padEnd()如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。 1234567891011\"x\".padStart(4, \"ab\"); // 'abax'\"x\".padEnd(5, \"ab\"); // 'xabab'\"xxx\".padStart(2, \"ab\"); // 'xxx'\"xxx\".padEnd(2, \"ab\"); // 'xxx'\"abc\".padStart(10, \"0123456789\");// '0123456abc'\"x\".padStart(4); // ' x'\"x\".padEnd(4); // 'x ' matchAll()matchAll 方法返回一个正则表达式在当前字符串的所有匹配 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。嵌入变量，需要将变量名写在\\${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。如果模板字符串中的变量没有声明，将报错。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.``In JavaScript this is // 多行字符串 not legal.`;console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`;let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 所有模板字符串的空格和换行，都是被保留的，比如”&lt; ul&gt;”标签前面会有一个换行。如果你不想要这个换行，可以使用 trim 方法消除它。如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = \"return \" + \"`Hello $&#123;name&#125;!`\";let func = new Function(\"name\", str);func(\"Jack\"); // \"Hello Jack!\"// 写法二let str = \"(name) =&gt; `Hello $&#123;name&#125;!`\";let func = eval.call(null, str);func(\"Jack\"); // \"Hello Jack!\" 标签模板模板字符串，紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`;// 等同于tag([\"Hello \", \" world \", \"\"], 15, 50); 上面代码中，模板字符串前面有一个标识名 tag，它是一个函数。整个表达式的返回值，就是 tag 函数处理模板字符串后的返回值。函数 tag 依次会接收到多个参数。tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。tag 函数的其他参数，都是模板字符串各个变量被替换后的值。 “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg .replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。 标签模板的另一个应用，就是多语言转换（国际化处理）。多语言转换（国际化处理）。可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性。保存的是转义后的原字符串。 1234567tag`First line\\nSecond line`;function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"&#125; String.raw()ES6 还为原生的 String 对象，提供了一个 raw 方法。String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。如果原字符串的斜杠已经转义，那么 String.raw 会进行再次转义。 12345678String.raw`Hi\\n$&#123;2 + 3&#125;!`;// 返回 \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 返回 \"Hi\\\\u000A!\"String.raw`Hi\\\\n`;// 返回 \"Hi\\\\\\\\n\"","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"变量的解构赋值","slug":"变量的解构赋值","date":"2018-07-16T04:05:20.000Z","updated":"2019-03-19T13:43:53.897Z","comments":true,"path":"2018/07/16/变量的解构赋值/","link":"","permalink":"http://yoursite.com/2018/07/16/变量的解构赋值/","excerpt":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。","text":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 解构不成功如果解构不成功，变量的值就等于 undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo 的值都会等于 undefined。 不完全解构等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x; // 1y; // 2let [a, [b], d] = [1, [2, 3], 4];a; // 1b; // 2d; // 4 等号右边不是数组如果等号的右边不是数组，那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo; // truelet [x, y = \"b\"] = [\"a\"]; // x='a', y='b'let [x, y = \"b\"] = [\"a\", undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效。null 不严格等于 undefined。所以，如果数组成员是 null，默认值则不会生效。 12345let [x = 1] = [undefined];x; // 1let [x = 1] = [null];x; // null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1let [x = y, y = 1] = []; // ReferenceError: y is not defined 上式之所以会报错，是因为 x 用 y 做默认值时，y 还没有声明。 对象的解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1234567891011121314let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\"bar; // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // undefinedlet &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"let obj = &#123; first: \"hello\", last: \"world\" &#125;;let &#123; first: f, last: l &#125; = obj;f; // 'hello'l; // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"foo; // error: foo is not defined 上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。 解构失败如果解构失败，变量的值等于 undefined。 12let &#123; foo &#125; = &#123; bar: \"baz\" &#125;;foo; // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 1234// 报错let &#123; foo: &#123; bar &#125;&#125; = &#123; baz: \"baz\" &#125;; 上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因为 foo 这时等于 undefined，再取子属性就会报错。 默认值对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于 undefined。 12345var &#123; x = 3 &#125; = &#123; x: undefined &#125;;x; // 3var &#123; x = 3 &#125; = &#123; x: null &#125;;x; // null 上面代码中，属性 x 等于 null，因为 null 与 undefined 不严格相等，所以是个有效的赋值，导致默认值 3 不会生效。 字符串的解构赋值字符串被转换成了一个类似数组的对象。 123456789const [a, b, c, d, e] = \"hello\";a; // \"h\"b; // \"e\"c; // \"l\"d; // \"l\"e; // \"o\"let &#123; length: len &#125; = \"hello\";len; // 5 数值和布尔值的解构赋值等号右边是数值和布尔值，则会先转为对象。解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值1234567function add([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。 12345678function move(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"var，let和const声明及区别","slug":"var，let和const声明及区别","date":"2018-07-04T03:29:59.000Z","updated":"2018-07-27T03:57:38.924Z","comments":true,"path":"2018/07/04/var，let和const声明及区别/","link":"","permalink":"http://yoursite.com/2018/07/04/var，let和const声明及区别/","excerpt":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。","text":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。例如：123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 事实上，在预编译阶段，JavaScript引擎会将上面的函数修改为下面这样：12345678910111213fuction getValue(condition)&#123; var value; if(condition)&#123; value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 变量value的声明会被提升至函数顶部，而初始化操作依然留在原处执行。这样，就意味着，在函数的其他部分，else子句中或者if-else外，也能访问到value变量，而由于此时value变量并未被初始化赋值，所以访问到值为undefined。 块级声明ES6中引入块级作用域来强化对变量生命周期的控制。块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（词法作用域）存在于： 函数内部 块中（字符{和}之间的区域） let声明let声明的用法与var相同。用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。let声明不会被提升，因此通常将let声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //变量value在此处不存在 return null; &#125; //变量value在此处不存在&#125; let声明后，不会被提升至函数顶部。因此执行流离开if块之后，value立刻被销毁，如果condition的值为false，就永远不会声明并初始化value。并且，假设作用域中已经存在了某个标识符，此时再用let关键字声明它，就会抛出错误： 123var count=30;//抛出语法错误let count=40; 在同一作用域中不能用let重复定义已经存在的标识符，所以此处使用let声明会抛出错误。但如果当前作用域内内嵌另一个作用域，就可在内嵌的作用域中使用let声明同名变量。 例如： 12345var count=30;if(condition)&#123; //不会抛出错误 let count=40;&#125; 此时，if内部块中的count会遮蔽全局作用域中的count，而var声明的count只能在if块外访问到。 const声明使用const声明的是常量，其值一旦被设定后不可更改。因此每个通过const声明的常量必须在声明的同时被初始化。12345//有效的常量const max=30;//语法错误，常量未初始化const name; const和let声明都是块级标识符，所以常量也只在当前的代码块内有效，一旦执行到代码块外会被立即销毁。并且，常量也不会被提升至作用域顶部。同样，与let相似，在同一作用域用const声明已经存在的标识符，也会导致语法错误。 如上所述，const定义的值一旦被设定后不可更改，无论在严格模式还是非严格模式下，都不可以为const定义的常量再赋值，否则会抛出语法错误：123const max=50;//抛出语法错误max=30; 然而，与其他语言中的常量不同的是，JavaScript中的常量，如果是对象，则对象的值可以修改，也就是const声明不允许修改绑定，但允许修改值这也意味着，const声明对象后，可以修改对象的属性。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。1234567891011const person=&#123; name:\"Nicholas\";&#125;;//可以修改对象属性的值person.name=\"Greg\";//抛出语法错误person=&#123; name:\"Greg\";&#125;; 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 临时死区（Temporal Dead Zone）临时死区常被描述let和const的不提升的效果。JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到var声明时），要么将声明放到TDZ中（遇到let和const声明时）。访问TDZ中的变量会触发运行错误。只有在执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。1234if(condition)&#123; console.log(typeof value);//引用错误！ let value=\"blue\";&#125; 但在let声明的作用域外对该变量使用typeof则不会报错：12345console.log(typeof value); //\"undefined\"if(condition)&#123; let value=\"blue\";&#125; typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中，也就意味着不存在value这个绑定，typeof操作最终返回”undefined”。 循环中的块级作用域绑定先看这段代码：1234567891011var funcs=[];for(var i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出10次数字10&#125;); 预想结果是输出数字0～9，但是因为循环里的每次迭代同时共享着i，循环内部创建的函数全部都保存了对相同变量的引用。循环结束时变量i的值为10，所以每次调用console.log（i）时都会输出数字10。而使用let声明，每次迭代循环都会创建一个新变量，并以之前的迭代中同名变量的值将其初始化，得到预期的效果。1234567891011var funcs=[];for(let i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出0，1，2，……，9&#125;); 当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。const也是同样，但在循环中不能修改const声明的变量，否则会抛出错误。 全局作用域绑定当var被用在全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。这意味着，用var很可能会无意中覆盖一个已经存在的全局属性。例如：123//在浏览器中var RegExp=\"Hello!\";console.log(window.RegExp); //\"Hello!\" 全局对象定义在RegExp定义在window上，但不能幸免被var覆盖，成为window的属性。但如果在全局作用域中使用let或者const，会在全局作用域下创建一个新的绑定，但该绑定不会添加全局对象的属性。用let或const不能覆盖全局变量，只能遮蔽它。1234//在浏览器中let RegExp=\"Hello!\";console.log(RegExp); //\"Hello!\"console.log(window.RegExp===RegExp); //false 这里let声明的RegExp创建了一个绑定并遮蔽了全局的RegExp变量，但window.RegExp和RegExp并不相同，说明它不会破坏全局作用域，不会为全局对象创建属性。 ES6声明变量的六种方法ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]}