{"meta":{"title":"01不是包子脸","subtitle":"小01的程序猿成长之路","description":null,"author":"Linyi Li","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:37:46.747Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-06-20T16:00:00.000Z","updated":"2019-04-07T08:28:59.618Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 ProfileCease to struggle and you cease to live. 大家好，我是『01』。一个不承认自己是包子脸的小仙女～哈哈哈哈～ 作为一只程序猿，虽然我比较菜，但是我在努力成长啊。这个博客，想记录一路走来的点点滴滴。 希望我们，都能有自己的一技之长，能在社会上的某个方面成为独当一面的佼佼者。 生命不止，奋斗不息。 Social Info : 01 : 01"},{"title":"Tags","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:36:30.431Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS常用布局方式","slug":"CSS常用布局方式","date":"2019-05-02T07:44:43.000Z","updated":"2019-08-15T16:33:47.257Z","comments":true,"path":"2019/05/02/CSS常用布局方式/","link":"","permalink":"http://yoursite.com/2019/05/02/CSS常用布局方式/","excerpt":"CSS 常用布局方式1.静态布局（固定布局）布局特点不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。","text":"CSS 常用布局方式1.静态布局（固定布局）布局特点不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。 设计方法 PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个 Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分； 12345.wrap &#123; width: 640px; overflow: hidden; margin: 0 auto;&#125; ​ 有固定的版型大小，例如 640px，然后设置 margin：0 auto；来居中。小于 640 时出现滚动条。 移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如 wap.或 m.。在 &lt;viewport meta&gt; 标签上设置 width，页面的各个元素也采用px作为单位。通过用 JS 动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。 实现方法 普通/文档流 布局 Float 布局 绝对布局 优缺点优点：这种布局方式对设计师和 CSS 编写者来说都是最简单的，亦没有兼容性问题。 缺点：显而易见，不能根据用户的屏幕尺寸做出不同的展现。当前，大部分门户网站、大部分企业的 PC 宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。 窄屏幕滚动条体验很差 宽屏有大片空白，不利于空间利用 2.流式布局流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。网页中主要的划分区域的尺寸使用百分数（搭配 min-、max-属性使用），例如，设置网页主体的宽度为 80%，min-width 为 960px。图片也作类似处理（width:100%, max-width 一般设定为图片本身的尺寸，防止被拉伸而失真）。 布局特点屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示。 设计方法使用%百分比定义宽度，而高度大都是用 px 来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。 这种布局方式在 Web 前端开发的早期历史上，用来应对不同尺寸的 PC 屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式。流式布局目的是在不同大小的设备上满屏呈现同样网页。它是用于解决类似的设备不同分辨率之间的兼容(一般分辨率差异较少)。 百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。 如果用百分比写 width，那么指的是父元素 width 的百分之多少。 如果用百分比写 height，那么指的是父元素 height 的百分之多少。 如果用百分比写 padding，那么指的是父元素 width 的百分之多少，无论是水平的 padding 还是竖直的 padding。 如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。 不能用百分比写 border 的宽度 实现方法 允许网页宽度自动调整：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; 不使用绝对尺寸（包括容器/字体/图片），使用百分比、em、rem、vw、vh 等 可使用 flex 等弹性盒子（不要使用 px 定尺寸） 优缺点优点：页面左右满屏。 但缺点明显： 主要的问题**是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用 px 来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调 使用百分比定义，所以在大屏幕的手机/Pad 下（或者横屏下）显示效果会变成有些页面元素被拉的很大，但是内容数量却不变，显得稀疏不紧凑，空间利用率低下。 如果文字也按照百分比放大，则整体效果会非常不协调（老人机效果）。 例子https://www.trip.com/flightsh5/status/ 3.自适应布局自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个合集。 布局特点屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。 设计方法使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。 实现方式 静态布局方法 分辨率 detector（media query/server-side detector/UA） 优缺点优点：自适应布局页面里面元素的位置会变化，很好的解决了流式布局中的大屏空间利用率不高弊端。 缺点：单个布局容器无法灵活伸缩，未触发布局切换的情况下，容器仍然容易出现静态布局中提到的问题。 例子www.baidu.com/ 自适应设计（AWD）自适应设计是通过服务端检测设备类型、从 site 的不同版本中选择最合适该设备类型的设计布局/尺寸的版本进行展示。它可以使用到所有（包括响应式布局）布局方案。 实现方式： server-side detection different versions to different devices 对于 PC: 可使用流式布局； 对于 Mobile: 可使用流式布局。推荐一个 Rem 解决方案： 设置元素（可以包括字体等）大小为 rem （rem 是以跟元素font-size为基准的单位） 按照屏幕宽度的不同，JS 动态设置 &lt;html&gt; 的 font-size 大小，元素同样会按照屏幕宽度等比例放大缩小 举个栗子：www.trip.com/ 4.响应式布局（媒体查询）随着 CSS3 出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的 PC、手机、手表、冰箱的 Web 浏览器等等）都能显示出令人满意的效果，对 CSS 编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。改变屏幕分辨率可以通过 CSS Media query 实时地切换不同的布局（页面元素位置可能发生改变），在每个布局中，页面元素会随窗口大小的调整发生流式布局中的自动尺寸变化。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。 响应式几乎已经成为优秀页面布局的标准。 布局特点每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。 设计方法媒体查询+流式布局。通常使用 @media 媒体查询和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。 实现方式 流式布局 CSS media query 优缺点优点：适应 pc 和移动端，如果足够耐心，效果完美。融合了流式布局和自适应布局的优势。 缺点： 媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。 要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。 CSS 代码繁琐，对于特定的设备有较多冗余，适用于对于各个终端（特别是移动端）性能要求不高的 Blog Dos 站点。 响应式页面在头部会加上这一段代码： 12&lt;meta name=\"applicable-device\" content=\"pc,mobile\" /&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-transform \" /&gt; 例子elevenbeans.github.io/ 响应式设计（RWD）响应式设计基于响应式布局，使用同一套页面在各种各样不同大小的设备上进行大小合适、布局（甚至功能）合理的展现。 响应式设计会根据识别屏幕宽度对于展示的具体内容块进行位置调整，甚至展示和隐藏。 实现方式： 响应式布局 特性检测 （用于网页功能的渐进增强） 举个栗子：elevenbeans.github.io/， RWD 和 AWD 的异同相同点： 均针对不同的分辨率/device 采用不同的样式和布局达到页面展示最优 布局方式本质没有差别（AWD 也 including responsive layout） 不同点： 前者强调同一套页面多端兼容展示，而后者给出多套页面，对于不同 device 进行了分类处理 前者是通过 CSS Media query 进行分辨率检测，可以实时的响应浏览器尺寸变化，改变元素尺寸/布局，而后者一般是 server side detection，一次性渲染既定布局和样式 媒体查询用法 开始在 html 中写入 Media 在 html 头部添加以下代码，用来显示兼容移动设备的显示效果 1234&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"/&gt; 参数详解： width=device-width ：宽度等于当前设备的宽度 initial-scale=1 ：初始的缩放比例。（默认为 1） minimum-scale=1 ：允许用户缩放到的最小比例。（默认为 1） maximum-scale=1 ：允许用户缩放到的最大比例。（默认为 1） user-scalable=no ：用户是否可以手动缩放（默认为 no） 引入包含 Media 的 css 文件我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。(IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。) 123456789101112131415161718body &#123; background-color: grey;&#125;@media screen and (min-width: 1200px) &#123; body &#123; background-color: pink; &#125;&#125;@media screen and (min-width: 700px) and (max-width: 1200px) &#123; body &#123; background-color: blue; &#125;&#125;@media screen and (max-width: 700px) &#123; body &#123; background-color: orange; &#125;&#125; 媒体类型 | 值 | 描述 || :——— | :——————————————————————– || all | 用于所有设备 || aural | 已废弃。用于语音和声音合成器 || braille | 已废弃。 应用于盲文触摸式反馈设备 || embossed | 已废弃。 用于打印的盲人印刷设备 || handheld | 已废弃。 用于掌上设备或更小的装置，如 PDA 和小型电话 || print | 用于打印机和打印预览 || projection | 已废弃。 用于投影设备 || screen | 用于电脑屏幕，平板电脑，智能手机等。 || speech | 应用于屏幕阅读器等发声设备 || tty | 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 || tv | 已废弃。 用于电视和网络电视 | 逻辑操作符 and操作符用来把多个媒体属性组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。 not操作符用来对一条媒体查询的结果进行取反。 only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。 也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于or操作符。 若使用了not或only操作符，必须明确指定一个媒体类型。 媒体功能 | 值 | 描述 | 值 | 媒体 | 是否接受 min/max 前缀 || :—————— | :——————————————————————————- | ———————– | ————– | ——————— || aspect-ratio | 定义输出设备中的页面可见区域宽度与高度的比率 | | visual/tactile | 是 || color | 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于 0 | | visual | 是 || color-index | 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于 0 | | visual | 是 || device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的比率。 | | visual/tactile | 是 || device-height | 定义输出设备的屏幕可见高度。 | | visual/tactile | 是 || device-width | 定义输出设备的屏幕可见宽度。 | | visual/tactile | 是 || grid | 用来查询输出设备是否使用栅格或点阵。 | | all | 否 || height | 定义输出设备中的页面可见区域高度。 | | visual/tactile | 是 || monochrome | 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于 0 | | visual | 是 || orientation | 定义输出设备中的页面可见区域高度是否大于或等于宽度。 | landscape|portrait | visual | 否 || resolution | 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm | | bitmap | 是 || scan | 定义电视类设备的扫描工序。 | progressive|interlace | tv | 否 || width | 定义输出设备中的页面可见区域宽度。 | | visual/tactile | 是 | 5.弹性布局（flex）Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间（他会根据页面的剩余宽度自动分配空间）。 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性基本语法： 123.box &#123; display: flex; /* 或者 inline-flex */&#125; 上述写法，定义了一个 flex 容器，根据设值的不同可以是块状容器或内联容器。这使得直接子结点拥有了一个 flex 上下文。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3.flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 4.justify-content定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 6.align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性 order flex-grow flex-shrink flex-basis flex align-self 1.order定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 123.item &#123; order: &lt;integer&gt;;&#125; 2.flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 3.flex-shrink定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 负值对该属性无效。 4.flex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如 350px），则项目将占据固定空间。 5.flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 6.align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 兼容性 Chrome Safari Firefox Opera IE Android iOS 21+ 6.1+ 22+ 12.1+ 11+ 4.4+ 7.1+ Flexbox 需要一些特定的前缀以支持大多数的浏览器。甚至还存在完全不同的属性名称或属性值。这就需要Autoprefixer或类似的 CSS 后处理器的辅助，具体内容请参考相关文档。 6.REM 布局rem/em 区别rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的 em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border。 rem 作用于非根元素时，相对于根元素字体大小；rem 作用于根元素字体大小时，相对于其出初始字体大小（16px）。 rem 有一点优势就是可以和媒体查询配合，实现响应式布局： 使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为 em 是相对父级元素的原因没有得到推广。【中国站点制作网页的时候，习惯用 CSS 强制定义字体大小，保证每个人都看到一致的效果，包括网易、搜狐这些门户网站在内的大部分站点，用的都是绝对单位 px（像素）。但是，如果从网站易用性方面考虑，字体大小应该是可变的，一些视力不是那么好的人需要放大字体才能看得清页面内容。然而，占据大部分浏览器市场的 IE 无法调整那些使用 px 作为单位的字体大小。国外人士非常重视网站的易用性，相当一部分外国站点已经使用 em 作为字体单位。 布局特点包裹文字的各元素的尺寸采用 em/rem 做单位，而页面的主要划分区域的尺寸仍使用百分数或 px 做单位（同「流式布局」或「静态/固定布局」）。早期浏览器不支持整个页面按比例缩放，仅支持网页内文字尺寸的放大，这种情况下。使用 em/rem 做单位，可以使包裹文字的元素随着文字的缩放而缩放。 浏览器的默认字体高度一般为16px，即 1em:16px，但是 1:16 的比例不方便计算，为了使单位 em/rem 更直观，CSS 编写者常常将页面跟节点字体设为 62.5%，比如选择用 rem 控制字体时，先需要设置根节点 html 的字体大小，因为浏览器默认字体大小 16px*62.5%=10px。这样 1rem 便是 10px，方便了计算。 设计思想 一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值 高度值可以设置固定值,设计稿有多大,我们就严格写多大 所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值) JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了 优点更能适应缩进/以字体单位 padding 或 margin／浏览器设置字体尺寸等情况（因为 em/rem 相对于字体大小，会同步改变）。例如：p{ text-indent: 2em; }。 123p &#123; text-indent: 2em;&#125; rem 单位对于（根据屏幕尺寸）调整页面的各元素的尺寸、文字大小时比较好用 Rem 布局的 js 实现1234// px转rem，方便模拟小程序 rpxpx2rem($px) &#123; $px / 750 * 10 * 1rem;&#125; 123456789101112131415161718192021222324252627282930313233343536if remlayout script. (function flexible (window, document) &#123; var docEl = document.documentElement var dpr = window.devicePixelRatio || 1 function setBodyFontSize () &#123; if (document.body) &#123; document.body.style.fontSize = (12 * dpr) + 'px' &#125; else &#123; document.addEventListener('DOMContentLoaded', setBodyFontSize) &#125; &#125; setBodyFontSize() function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + 'px' &#125; setRemUnit() window.addEventListener('resize', setRemUnit) window.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; setRemUnit() &#125; &#125;) if (dpr &gt;= 2) &#123; var fakeBody = document.createElement('body') var testElement = document.createElement('div') testElement.style.border = '.5px solid transparent' fakeBody.appendChild(testElement) docEl.appendChild(fakeBody) if (testElement.offsetHeight === 1) &#123; docEl.classList.add('hairlines') &#125; docEl.removeChild(fakeBody) &#125; &#125;(window, document)) 对比三种方式（响应式&amp;&amp;REM&amp;&amp;viewport）响应式的优缺点优点：兼容性好，@media 在 ie9 以上是支持的，PC 和 MOBILE 是同一套代码的，不用分开。 缺点：要写得 css 相对另外两个多很多，而且各个断点都要做好。css 样式会稍微大点，更麻烦。 REM 优缺点优点：能维持能整体的布局效果，移动端兼容性好，不用写多个 css 代码，而且还可以利用@media 进行优化。 缺点：开头要引入一段 js 代码，单位都要改成 rem(font-size 可以用 px)，计算 rem 比较麻烦(可以引用预处理器，但是增加了编译过程，相对麻烦了点)。pc 和 mobile 要分开。 设置 viewport 中的 width1&lt;meta name=\"viewport\" content=\"width=750\" /&gt; 优点：和 REM 相同，而且不用写 rem，直接使用 px，更加快捷。 缺点：效果可能没 rem 的好，图片可能会相对模糊，而且无法使用@media 进行断点，不同 size 的手机上显示，高度间距可能会相差很大。 7.Grid 布局（BOOTSTRAP 布局）网格布局（Grid）是最强大的 CSS 布局方案。 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。容器里面的水平区域称为”行”（row），垂直区域为”列”（column）。行和列的交叉区域，称为”单元格”（cell）。划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 容器的属性1.displaydisplay: grid指定一个容器采用网格布局。 默认情况下，容器元素都是块级元素，但也可以设成行内元素。display: inline-grid; 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 2.grid-template-columns 属性， grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 除了使用绝对单位，也可以使用百分比 repeat()：接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。重复某种模式也是可以的。 1grid-template-columns: repeat(2, 100px 20px 80px); auto-fill 关键字：有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; fr 关键字：为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。（fr可以与绝对长度的单位结合使用） minmax()：minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 auto 关键字：表示由浏览器自己决定长度 网格线的名称：grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。（网格布局允许同一根线有多个名字，比如[fifth-line row-5]。） 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 3.grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性 grid-row-gap属性设置行与行的间隔（行间距） grid-column-gap属性设置列与列的间隔（列间距）。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式：grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;(如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。) 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 4.grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。 1234grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 5.grid-auto-flow 属性划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。 也可以将它设成column，变成”先列后行”。 设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。 column dense，表示”先列后行”，并且尽量填满空格。 6.justify-items 属性， align-items 属性， place-items 属性 justify-items属性设置单元格内容的水平位置（左中右） align-items属性设置单元格内容的垂直位置（上中下）。 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-items属性是align-items属性和justify-items属性的合并简写形式。（如果省略第二个值，则浏览器认为与第一个值相等。） 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 7.justify-content 属性， align-content 属性， place-content 属性 justify-content属性是整个内容区域在容器里面的水平位置（左中右） align-content属性是整个内容区域的垂直位置（上中下）。 这两个属性的写法完全相同，都可以取下面这些值。 只是将水平方向改成垂直方向。） start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。（如果省略第二个值，浏览器就会假定第二个值等于第一个值。） 1place-content: &lt;align-content&gt; &lt;justify-content&gt;; 8.grid-auto-columns 属性， grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。 123456.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px;&#125; 上面代码指定新增的行高统一为 50px（原始的行高为 100px）。 9.grid-template 属性， grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 项目属性1.grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 2.grid-column 属性， grid-row 属性 grid-column属性是grid-column-start和grid-column-end的合并简写形式 grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。斜杠以及后面的部分可以省略，默认跨越一个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 3.grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 4.justify-self 属性， align-self 属性， place-self 属性 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 兼容性 对比 Bootstrap 标签会更加简洁：相比Bootstrap，使用 grid 会使你的 HTML 更加干净。Bootstrap需要创建的标签，每个 row 都需要一个&lt;div&gt;标签，使用了 class name 来指定布局(col-xs-2)。grid 用来布局看起来更简单，丑陋的类名和每行所需的额外的 div 标签一去不复返了，简简单单一个 container 和里面的 item。与Bootstrap不同的是，随着布局复杂度的增加，Grid 布局标签的复杂度将不会增加太多。 更灵活：用CSS Grid的话会非常简单，我们只需要添加一个media query就可以重新排列布局。而如果想在Bootstrap中做同样的事情，就必须得修改 HTML 了，需要调整标签的顺序。 不再限死 12 列：Bootstrap的 grid 系统分为了 12 列，如果你想要一个 5 列的布局就会纠结，或是 7 列、9 列、任何不会合为 12 列的。CSS Grid就没有任何限制，你可以让 grid 正好有你想要的数量。 浏览器支持：全球 75%的网站流量支持CSS Grid 结论： 如果只做 pc 端，那么静态布局（定宽度）是最好的选择； 如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份 css+一份 js 调节 font-size 搞定； 如果 pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS3新特性","slug":"CSS3新特性","date":"2019-04-28T04:37:08.000Z","updated":"2019-08-15T16:29:09.967Z","comments":true,"path":"2019/04/28/CSS3新特性/","link":"","permalink":"http://yoursite.com/2019/04/28/CSS3新特性/","excerpt":"CSS3 新特性1. 选择器CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。 element1~element2: 选择前面有 element1 元素的每个 element2 元素。 [attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。 [attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。 [attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。 E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。 E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。 E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。 E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。 E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。 E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。 E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。 E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。 E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。 :root: 选择文档的根元素。 E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。 E:target: 选择当前活动的 E 元素。 E:enabled: 选择每个启用的 E 元素。 E:disabled: 选择每个禁用的 E 元素。 E:checked: 选择每个被选中的 E 元素。 E:not(selector): 选择非 selector 元素的每个元素。 E::selection: 选择被用户选取的元素部分。","text":"CSS3 新特性1. 选择器CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。 element1~element2: 选择前面有 element1 元素的每个 element2 元素。 [attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。 [attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。 [attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。 E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。 E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。 E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。 E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。 E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。 E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。 E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。 E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。 E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。 :root: 选择文档的根元素。 E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。 E:target: 选择当前活动的 E 元素。 E:enabled: 选择每个启用的 E 元素。 E:disabled: 选择每个禁用的 E 元素。 E:checked: 选择每个被选中的 E 元素。 E:not(selector): 选择非 selector 元素的每个元素。 E::selection: 选择被用户选取的元素部分。 2. Transition,Transform 和 Animation这三个特性是 CSS3 新增的和动画相关的特性。 Transition Transition 可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用 Flash 动画或 JavaScript。Transition 有如下属性： transition-property: 规定应用过渡的 CSS 属性的名称。 transition-duration: 规定完成过渡效果需要多长时间。 transition-delay: 规定过渡效果何时开始，默认是 0。 transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有 linear、ease-in、ease-out、ease-in-out 和 cubic-bezier 等过渡类型。 transition: 简写属性，用于在一个属性中设置四个过渡属性。 Transform Transform 用来向元素应用各种 2D 和 3D 转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。 变换类型： none: 定义不进行转换。 matrix(n,n,n,n,n,n): 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y): 定义 2D 位移转换。 translate3d(x,y,z): 定义 3D 位移转换。 translateX(x): 定义位移转换，只是用 X 轴的值。 translateY(y): 定义位移转换，只是用 Y 轴的值。 translateZ(z): 定义 3D 位移转换，只是用 Z 轴的值。 scale(x,y): 定义 2D 缩放转换。 scale3d(x,y,z): 定义 3D 缩放转换。 scaleX(x): 通过设置 X 轴的值来定义缩放转换。 scaleY(y): 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z): 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle): 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle): 定义 3D 旋转。 rotateX(angle): 定义沿着 X 轴的 3D 旋转。 rotateY(angle): 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle): 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle): 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle): 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle): 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n): 为 3D 转换元素定义透视视图。 Animation Animation 让 CSS 拥有了可以制作动画的功能。使用 CSS3 的 Animation 制作动画我们可以省去复杂的 js 代码。 3. 边框CSS3 新增了三个边框属性，分别是 border-radius、box-shadow 和 border-image。 border-radius 可以创建圆角边框 box-shadow 可以为元素添加阴影 border-image 可以使用图片来绘制边框。 4. 背景CSS3 新增了几个关于背景的属性，分别是 background-clip、background-origin、background-size 和 background-break。 background-clip background-clip 属性用于确定背景画区，有以下几种可能的属性： background-clip: border-box; 背景从 border 开始显示 background-clip: padding-box; 背景从 padding 开始显示 background-clip: content-box; 背景显 content 区域开始显示 background-clip: no-clip; 默认属性，等同于 border-box 通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。 background-origin background-clip 属性用于确定背景的位置，它通常与 background-position 联合使用，可以从 border、padding、content 来计算 background-position（就像 background-clip）。 background-origin: border-box; 从 border 开始计算 background-position background-origin: padding-box; 从 padding 开始计算 background-position background-origin: content-box; 从 content 开始计算 background-position background-size background-size 属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性： background-size: contain; 缩小图片以适合元素（维持像素长宽比） background-size: cover; 扩展元素以填补元素（维持像素长宽比） background-size: 100px 100px; 缩小图片至指定的大小 background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 background-break CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样） background-break: bounding-box; 把盒之间的距离计算在内； background-break: each-box; 为每个盒子单独重绘背景。 5. 文字效果 word-wrap CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行，即这意味着会对单词进行拆分。所有主流浏览器都支持 word-wrap 属性。 text-overflow 它与 word-wrap 是协同工作的，word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。 text-shadow CSS3 中，text-shadow 可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 text-decoration CSS3 里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置： text-fill-color: 设置文字内部填充颜色 text-stroke-color: 设置文字边界填充颜色 text-stroke-width: 设置文字边界宽度 6. 渐变CSS3 新增了渐变效果，包括 linear-gradient(线性渐变)和 radial-gradient(径向渐变)。 7. @font-face 特性通过 CSS3，web 设计师可以使用他们喜欢的任意字体。当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。字体是在 CSS3 @font-face 规则中定义的。Firefox、Chrome、Safari 以及 Opera 支持 .ttf(True Type Fonts)和 .otf(OpenType Fonts)类型的字体。IE9+ 支持新的@font-face 规则，但是仅支持 .eot 类型的字体(Embedded OpenType)。 在新的@font-face 规则中，必须首先定义字体的名称（比如 myFont），然后指向该字体文件。如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFont) 8. 多列布局通过 CSS3，能够创建多个列来对文本进行布局，IE10 和 Opera 支持多列属性。Firefox 需要前缀-moz-，Chrome 和 Safari 需要前缀-webkit-。主要有如下三个属性： column-count: 规定元素应该被分隔的列数。 column-gap: 规定列之间的间隔。 column-rule: 设置列之间的宽度、样式和颜色规则 9. 用户界面CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。Firefox、Chrome 以及 Safari 支持 resize 属性。IE、Chrome、Safari 以及 Opera 支持 box-sizing 属性。Firefox 需要前缀-moz-。所有主流浏览器都支持 outline-offset 属性，除了 IE。 resize resize 属性规定是否可由用户调整元素尺寸。如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll。 box-sizing box-sizing 属性可设置的值有 content-box、border-box 和 inherit。 content-box: padding 和 border 不被包含在定义的 width 和 height 之内。对象的实际宽度等于设置的 width 值和 border、padding 之和，即 (Element width = width + border + padding)，此属性表现为标准模式下的盒模型。 border-box: padding 和 border 被包含在定义的 width 和 height 之内。对象的实际宽度就等于设置的 width 值，即使定义有 border 和 padding 也不会改变对象的实际宽度，即 (Element width = width)，此属性表现为怪异模式下的盒模型。 outline-offset outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"BFC","slug":"BFC","date":"2019-04-10T00:11:20.000Z","updated":"2019-08-15T16:25:07.250Z","comments":true,"path":"2019/04/10/BFC/","link":"","permalink":"http://yoursite.com/2019/04/10/BFC/","excerpt":"BFCBFC 的定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。通俗地讲，BFC 是一个容器，用于管理块级元素。","text":"BFCBFC 的定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。通俗地讲，BFC 是一个容器，用于管理块级元素。 触发 BFC 的方式（以下任意一条就可以） 根元素，即 HTML 元素 float 的值不为 none（为 left或right） overflow 的值不为 visible（为hidden或auto或scroll） display 的值为table-cell、table-caption、inline-flex、flex和inline-block之一 position 的值不为 static 或者 releative 中任何一个(为absolute或fixed) BFC 的布局规则 内部的 Box 会在垂直方向，一个接一个地放置。 Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠（margin 重叠三个条件:同属于一个 BFC;相邻;块级元素），两个相邻的 BFC 上下 margin 不会重叠 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC 的区域不会与 float box 重叠。非浮动元素不会覆盖浮动元素的位置。 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。（触发 BFC，回流的局部渲染） 计算 BFC 的高度时，浮动元素也参与计算（清除浮动 haslayout） margin 不会传递给父级（父级触发了 BFC） 对比普通文档流的布局规则 浮动的元素是不会被父级计算高度 非浮动元素会覆盖浮动元素的位置 margin 会传递给父级 两个相邻的元素上下 margin 会重叠 BFC 有哪些作用： 自适应两栏布局（规则 4） 可以阻止元素被浮动元素覆盖（规则 4） 可以包含浮动元素——清除内部浮动（规则 6） 分属于不同的 BFC 时可以阻止 margin 重叠（规则 2）","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"字符编码：Unicode与Javascript","slug":"字符编码：Unicode与Javascript","date":"2019-04-06T11:08:55.000Z","updated":"2019-08-15T16:23:35.837Z","comments":true,"path":"2019/04/06/字符编码：Unicode与Javascript/","link":"","permalink":"http://yoursite.com/2019/04/06/字符编码：Unicode与Javascript/","excerpt":"字符编码：Unicode 与 Javascript1.ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从00000000到11111111。 上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了 128 个字符的编码，比如空格SPACE是 32（二进制00100000），大写的字母A是 65（二进制01000001）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为0。","text":"字符编码：Unicode 与 Javascript1.ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从00000000到11111111。 上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了 128 个字符的编码，比如空格SPACE是 32（二进制00100000），大写的字母A是 65（二进制01000001）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为0。 2.非 ASCII 编码英语用 128 个符号编码就够了，但是用来表示其他语言，128 个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为 130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多 256 个符号。 这里就又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用 256 个符号的编码方式，代表的字母却不一样。比如，130 在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127 表示的符号是一样的，不一样的只是 128–255 的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达 10 万左右。一个字节只能表示 256 种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，此处不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是 GB 类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 3.UnicodeUnicode 源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。 Unicode 当然是一个很大的集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 码点它从 0 开始，为每个符号指定一个编号，这叫做”码点”（code point）。比如，码点 0 的符号就是 null（表示所有二进制位都是 0）。 1U+0000 = null 上式中，U+表示紧跟在后面的十六进制数是 Unicode 的码点。 目前，Unicode 的最新版本是 7.0 版，一共收入了 109449 个符号，其中的中日韩文字为 74500 个。可以近似认为，全世界现有的符号当中，三分之二以上来自东亚文字。比如，中文”好”的码点是十六进制的 597D。 分区（基本平面&amp;&amp;辅助平面）这么多符号，Unicode 不是一次性定义的，而是分区定义。每个区可以存放 65536 个（216）字符，称为一个平面（plane）。目前，一共有 17 个（25）平面，也就是说，整个 Unicode 字符集的大小现在是 221。 最前面的 65536 个字符位，称为基本平面（缩写 BMP），它的码点范围是从 0 一直到 216-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。 剩下的字符都放在辅助平面（缩写 SMP），码点范围从 U+010000 一直到 U+10FFFF。 问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有 15 位（100111000100101），也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。 如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？ 我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 4.UTF-32 与 UTF-8UTF-32最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做 UTF-32。比如，码点 0 就用四个字节的 0 表示，码点 597D 就在前面加两个字节的 0。 123U+0000 = 0x0000 0000U+597D = 0x0000 597D UTF-32 的优点转换规则简单直观，查找效率高。 缺点浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。 UTF-8UTF-8 是一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。 由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 编码规则： 1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）----------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 5.UTF-16UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。 它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。 于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？ 在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 具体来说，辅助平面的字符位共有 220 个，也就是说，对应这些字符至少需要 20 个二进制位。UTF-16 将这 20 位拆成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 210），称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 编码规则 所以，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 Unicode 码点与 UTF-16 转码 首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。 1U+597D = 0x597D 如果是辅助平面字符，Unicode 3.0 版给出了转码公式。 123H = Math.floor((c - 0x10000) / 0x400) + 0xd800;L = ((c - 0x10000) % 0x400) + 0xdc00; 6.JavaScript 用的是 UCS-2JavaScript 语言采用 Unicode 字符集，但是只支持一种编码方法。UCS-2！ 互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的 Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集 1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。 两者的关系简单说，就是 UTF-16 取代了 UCS-2，或者说 UCS-2 整合进了 UTF-16。 在 JavaScript 语言出现的时候，还没有 UTF-16 编码。 由于 JavaScript 只能处理 UCS-2 编码，造成所有字符在这门语言中都是 2 个字节，如果是 4 个字节的字符，会当作两个双字节的字符处理。JavaScript 的字符函数都受到这一点的影响，无法返回正确结果。 以字符为例，它的 UTF-16 编码是 4 个字节的 0xD834 DF06。问题就来了，4 个字节的编码不属于 UCS-2，JavaScript 不认识，只会把它看作单独的两个字符 U+D834 和 U+DF06。前面说过，这两个码点是空的，所以 JavaScript 会认为是两个空字符组成的字符串！ 上面代码表示，JavaScript 认为字符的长度是 2，取到的第一个字符是空字符，取到的第一个字符的码点是 0xDB34。这些结果都不正确！ 解决这个问题，必须对码点做一个判断，然后手动调整。下面是正确的遍历字符串的写法。 12345678while (++index &lt; length) &#123; // ... if (charCode &gt;= 0xd800 &amp;&amp; charCode &lt;= 0xdbff) &#123; output.push(character + string.charAt(++index)); &#125; else &#123; output.push(character); &#125;&#125; 上面代码表示，遍历字符串的时候，必须对码点做一个判断，只要落在 0xD800 到 0xDBFF 的区间，就要连同后面 2 个字节一起读取。 类似的问题存在于所有的 JavaScript 字符操作函数。 String.prototype.replace() String.prototype.substring() String.prototype.slice() … 上面的函数都只对 2 字节的码点有效。要正确处理 4 字节的码点，就必须逐一部署自己的版本，判断一下当前字符的码点范围。 7.ES6ECMAScript 6（简称 ES6），大幅增强了 Unicode 支持，基本上解决了这个问题。 （1）正确识别字符 ES6 可以自动识别 4 字节的码点。因此，遍历字符串就简单多了。 123for (let s of string) &#123; // ...&#125; 但是，为了保持兼容，length 属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。 1Array.from(string).length; （2）码点表示法 JavaScript 允许直接用码点表示 Unicode 字符，写法是”反斜杠+u+码点”。 1\"好\" === \"\\u597D\"; // true 但是，这种表示法对 4 字节的码点无效。ES6 修正了这个问题，只要将码点放在大括号内，就能正确识别。 （3）字符串处理函数 ES6 新增了几个专门处理 4 字节码点的函数。 String.fromCodePoint()：从 Unicode 码点返回对应字符 String.prototype.codePointAt()：从字符返回对应的码点 String.prototype.at()：返回字符串给定位置的字符 （4）正则表达式 ES6 提供了 u 修饰符，对正则表达式添加 4 字节码点的支持。 （5）Unicode 正规化 有些字符除了字母以外，还有附加符号。比如，汉语拼音的 Ǒ，字母上面的声调就是附加符号。对于许多欧洲语言来说，声调符号是非常重要的。 Unicode 提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如 Ǒ 的码点是 U+01D1；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如 Ǒ 可以写成 O（U+004F） + ˇ（U+030C）。 1234567// 方法一\"\\u01D1\";// 'Ǒ'// 方法二\"\\u004F\\u030C\";// 'Ǒ' 这两种表示方法，视觉和语义都完全一样，理应作为等同情况处理。但是，JavaScript 无法辨别。 12\"\\u01D1\" === \"\\u004F\\u030C\";//false ES6 提供了 normalize 方法，允许“Unicode 正规化”，即将两种方法转为同样的序列。 12\"\\u01D1\".normalize() === \"\\u004F\\u030C\".normalize();// true 8.总结截取含有四字节字符的字符串不会出现乱码的方法12let nickname = \"非拉🍒非拉\";nickname.length; // 6 Array.from 方法Array.from这个方法能够将类数组转换为真实的数组，比如NodeList, argument等，同样，也包括字符串。 12Array.from(nickname); // [\"非\", \"拉\", \"🍒\", \"非\", \"拉\"]nickname.split(\"\"); // [\"非\", \"拉\", \"�\", \"�\", \"非\", \"拉\"] 使用 Array.from 把 nickname 转换后，可以看到转换成一个真实的数组了，樱桃字符占了数组中的一个位置，然后按照数组中的方法截取再进行拼接即可，而使用 split 方法拆分，则还是乱码： 123456function truncated(str, num) &#123; return Array.from(str) .slice(0, num) .join(\"\");&#125;truncated(nickname, 3); // 非拉🍒 codePointAt()方法在 ES6 之前， JS 的字符串以 16 位字符编码(UTF-16)为基础。每个 16 位序列(相当于 2 个字节)是一个编码单元(code unit)，可简称为码元，用于表示一个字符。字符串所有的属性与方法(如 length 属性与 charAt() 方法等)都是基于 16 位序列。 比如 length 方法、nickname[2]、split 方法等操作，都会产生异常。为此在 ES6 中，加强了对 Unicode 的支持，并且扩展了字符串对象。 对于 Unicode 码点大于 0xFFFF 的字符，是使用 4 个字节进行存储。ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 12345// 获取樱桃的码点\"🍒\".codePointAt(0).toString(16); // 1f352// 输出码点对应的字符(\"\\u&#123;1f352&#125;\"); // 🍒 请注意： 在之前 Unicode 编码，均在[\\u000-\\uFFFF]之间，因此可以使用类似\\u0047这样的编码；但是现在码点超过\\uFFFF的界限，若再这样使用，则获取不到对应的字符。因此在 ES6 中，码点的字符放在中括号内，类似上面的格式（所有的码点均可以使用这种格式）： 123\"\\u&#123;1f352&#125;\"; // 🍒\"\\u&#123;47&#125;\"; // G\"\\u&#123;0047&#125;\"; // G 那么就容易了：判断需要截取的位置是否正好是 4 字节的字符，如果是则延长一位截取，否则正常截取： 12345function truncated(str, num) &#123; let index = Array.from(str)[num - 1].codePointAt(0) &gt; 0xffff ? num + 1 : num; return str.slice(0, index);&#125;truncated(nickname, 3); // 非拉🍒 for-offor-in方法是遍历 key 值，for-of是遍历 value 值： 123456789101112let arr = [\"a\", \"b\", \"c\"];for (let k in arr) &#123; console.log(k); // 0 1 2&#125;for (let v of arr) &#123; console.log(v); // a b c&#125;for (let v of nickname) &#123; console.log(v); // 非 拉 🍒 非 拉&#125; 因此利用这个功能，我们也能进行截取： 123456789101112function truncated(str, num) &#123; let s = \"\"; for (let v of nickname) &#123; s += v; num--; if (num &lt;= 0) &#123; break; &#125; &#125; return s;&#125;truncated(nickname, 3); 正确输出字符串的字符个数：1234567891011function getLen(str) &#123; var len = str.length; for (var i = 0; i &lt; len; i++) &#123; var charCode = str.charCodeAt(i); if (charCode &gt;= 0xd800 &amp;&amp; charCode &lt;= 0xdbff) &#123; len--; i++; &#125; &#125; return len;&#125; 1Array.from(str).length; 9.string.lengthstring.length 返回的是什么 字符的个数还是字节数？为什么会与实际长度不一样？编码的部分详细说string.length():返回字符串的长度（以字节为单位）。是符合字符串内容的实际字节数，不一定等于其容量。 string.size()和 string.length()是同义词，并返回完全相同的值。 string.max_size()：返回字符串的最大大小，返回字符串可以达到的最大长度。 string.resize():string.resize(n)：把字符串的长度设置为 n 个字符如果 n 小于当前字符串长度 ，则只截取前 n 个字符，删除超出第 n 个字符的字符。如果大于，则在末端插入尽可能多的字符来扩展当前内容，以达到大小 n。 如果指定 c，则新元素将初始化为 c 的副本，否则为值初始化字符（空字符）。 string.capacity()：返回已分配存储的大小。当前为字符串分配的存储空间的大小，以字节表示。 此容量不一定等于字符串长度。 它可以相等或更大，额外的空间允许对象在将新字符添加到字符串时优化其操作。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"常用的正则","slug":"常用的正则","date":"2019-03-29T14:07:27.000Z","updated":"2019-08-15T10:30:14.430Z","comments":true,"path":"2019/03/29/常用的正则/","link":"","permalink":"http://yoursite.com/2019/03/29/常用的正则/","excerpt":"正则1.校验数字123456789101112131415161718数字：^\\d*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9]\\d*)+(\\.\\d&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+\\.\\d&#123;1,2&#125;$正数、负数、和小数：^(\\-)?\\d+(\\.\\d+)?$有两位小数的正实数：^\\d+\\.\\d&#123;2&#125;$有1~3位小数的正实数：^\\d+\\.\\d&#123;1,3&#125;$非零的正整数：^[1-9]\\d*$非零的负整数：^-[1-9]\\d*$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$","text":"正则1.校验数字123456789101112131415161718数字：^\\d*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9]\\d*)+(\\.\\d&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+\\.\\d&#123;1,2&#125;$正数、负数、和小数：^(\\-)?\\d+(\\.\\d+)?$有两位小数的正实数：^\\d+\\.\\d&#123;2&#125;$有1~3位小数的正实数：^\\d+\\.\\d&#123;1,3&#125;$非零的正整数：^[1-9]\\d*$非零的负整数：^-[1-9]\\d*$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 2.校验字符的表达式123456789101112汉字：^[\\u4e00-\\u9fa5]+$英文和数字：^[A-Za-z0-9]+$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+禁止输入含有~的字符：[^~\\x22]+ 3.特殊需求表达式1234567891011121314Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$国内手机号码：^1[34578]&#123;1&#125;\\d&#123;9&#125;帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z]\\w&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)IP地址：^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5]))&#123;3&#125;$xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"移动端的触屏事件","slug":"移动端的触屏事件","date":"2019-03-22T08:28:36.000Z","updated":"2019-08-15T10:32:11.938Z","comments":true,"path":"2019/03/22/移动端的触屏事件/","link":"","permalink":"http://yoursite.com/2019/03/22/移动端的触屏事件/","excerpt":"移动端的触屏事件1.原生触摸事件（touch 类事件）在移动端，原生触摸事件只有以下三种类型，其他所有的触摸事件都是由这三种事件相结合产生的，例如，上划、下滑、左滑、右滑、双击等等；","text":"移动端的触屏事件1.原生触摸事件（touch 类事件）在移动端，原生触摸事件只有以下三种类型，其他所有的触摸事件都是由这三种事件相结合产生的，例如，上划、下滑、左滑、右滑、双击等等； 这三种原生触摸事件为： touchstart：开始触摸 touchmove：触摸过程中 touchend：触摸结束 另外，还有一个触摸被系统取消的事件：touchcancel（由更高级的事件打断当前正在执行的移动端事件时，会触发该事件，我们可以在这个事件中保存当前相关的触碰事件操作的数据，以保证用户回到页面后接着刚才断开的位置继续操作）； 触摸事件下的一些相关属性 targetTouches：可获取到事件对象下的触摸点，该属性是一个类数组的结构，同时触发这个事件的手指有几个，则数组中就有几个元素。触摸点的相关坐标数据就存在这些对象中。 pageX\\pageY:坐标系原点在页面的左上角； screenX\\screenY:坐标系的原点在屏幕的左上角点（不包含操作系统在左上角的组件）； clientX\\clientY:触摸目标在视口中的坐标，原点在视口左上角(适口视用来展示 html 代码的容器)； targer:保存的是触发事件的标签，使用事件委托时可以通过该属性获取到触发该事件的标签对象； identifier:ID 值，唯一标示了手指触摸点，如果手指在屏幕上产生移动（如果有多个触摸点，则可以根据这个 id 值跟踪对应的触摸点）； event 对象：由于手机端的手指触发不是单个的，所以在 event 里面生成的与触摸有关的数据都是以数组的形式列出来的，有以下三个： touches：表示当前跟踪的触摸操作的 touch 对象的数组。当前屏幕上所有触摸点的集合列表 targetTouches：特定于事件目标的 Touch 对象的数组。绑定事件的那个结点上的触摸点的集合列表 changedTouches：表示自上次触摸以来发生了什么改变的 Touch 对象的数组。触发事件时改变的触摸点的集合 2.触碰事件（tap 类事件）触碰事件，我目前还不知道它和 touch 的区别，一般用于代替 click 事件 tap: 手指碰一下屏幕会触发 longTap: 手指长按屏幕会触发 singleTap: 手指碰一下屏幕会触发 doubleTap: 手指双击屏幕会触发 3.滑动事件（swipe 类事件）滑动事件 swipe：手指在屏幕上滑动时会触发 swipeLeft：手指在屏幕上向左滑动时会触发 swipeRight：手指在屏幕上向右滑动时会触发 swipeUp：手指在屏幕上向上滑动时会触发 swipeDown：手指在屏幕上向下滑动时会触发 4.自定义手势事件 gesture手势事件只是概念型，目前还没有浏览器原生支持，按照概念可分为 gesturestart gesturechange gestureend 三种事件 gesturestart：当有两根或多根手指放到屏幕上的时候触发 gesturechange：当有两根或多根手指在屏幕上，并且有手指移动的时候触发 gestureend：当倒数第二根手指提起的时候触发，结束 gesture 按照定义，当分别将两根手指放到屏幕上的时候，会有如下顺序的事件触发： 1、第一根手指放下，触发 touchstart 2、第二根手指放下，触发 gesturestart 3、触发第二根手指的 touchstart 4、立即触发 gesturechange 5、手指移动，持续触发 gesturechange 6、第二根手指提起，触发 gestureend，以后将不会再触发 gesturechange 7、触发第二根手指的 touchend 8、触发 touchstart（多根手指在屏幕上，提起一根，会刷新一次全局 touch，重新触发第一根手指的 touchstart） 9、提起第一根手指，触发 touchend 5.Zepto.js 库可以更好的支持，基于 CSS3","categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/移动端/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"双向数据绑定Proxy和Object.defineProperty对比","slug":"双向数据绑定Proxy和Object.defineProperty对比","date":"2019-03-11T03:52:12.000Z","updated":"2019-08-15T10:32:02.082Z","comments":true,"path":"2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/","link":"","permalink":"http://yoursite.com/2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/","excerpt":"双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在： 无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &#39;渣渣辉&#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 zone.js 避免显示调用,不展开),react 需要显示调用setState。 可精确得知变化数据：还是上面的小例子，我们劫持了属性的 setter,当属性值改变,我们可以精确获知变化的内容newVal,因此在这部分不需要额外的 diff 操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量 diff 来找出变化值,这是额外性能损耗。","text":"双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在： 无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &#39;渣渣辉&#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 zone.js 避免显示调用,不展开),react 需要显示调用setState。 可精确得知变化数据：还是上面的小例子，我们劫持了属性的 setter,当属性值改变,我们可以精确获知变化的内容newVal,因此在这部分不需要额外的 diff 操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量 diff 来找出变化值,这是额外性能损耗。 基于数据劫持双向绑定的实现思路数据劫持是双向绑定各种方案中比较流行的一种,最著名的实现就是 Vue。 基于数据劫持的双向绑定离不开Proxy与Object.defineProperty等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。 利用Proxy或Object.defineProperty生成的 Observer 针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者 解析器 Compile 解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染 Watcher 属于 Observer 和 Compile 桥梁,它将接收到的 Observer 产生的数据变化,并根据 Compile 提供的指令进行视图渲染,使得数据变化促使视图变化 在 new Vue() 后， Vue 会调用_init 函数进行初始化，也就是 init 过程，在 这个过程 Data 通过 Observer 转换成了 getter/setter 的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行getter 函数，而在当被赋值的时候会执行 setter函数。 当 render function 执行的时候，因为会读取所需对象的值，所以会触发getter函数从而将 Watcher 添加到依赖中进行依赖收集。 在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图。 基于 Object.defineProperty 双向绑定的特点Vue 通过设定对象属性的 setter/getter 方法来监听数据的变化，通过 getter 进行依赖收集，而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 在 getter 中收集依赖，在 setter 中触发依赖。 当外界通过 Watcher 读取数据时，便会触发 getter 从而将 Watcher 添加到依赖中，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 极简版的双向绑定Object.defineProperty的作用就是劫持一个对象的属性,通常我们对属性的getter和setter方法进行劫持,在对象的属性发生变化时进行特定的操作。 我们就对对象obj的text属性进行劫持,在获取此属性的值时打印&#39;get val&#39;,在更改属性值的时候对 DOM 进行操作,这就是一个极简的双向绑定。 12345678910111213141516const obj = &#123;&#125;;Object.defineProperty(obj, \"text\", &#123; get: function() &#123; console.log(\"get val\"); &#125;, set: function(newVal) &#123; console.log(\"set val:\" + newVal); document.getElementById(\"input\").value = newVal; document.getElementById(\"span\").innerHTML = newVal; &#125;&#125;);const input = document.getElementById(\"input\");input.addEventListener(\"keyup\", function(e) &#123; obj.text = e.target.value;&#125;); 升级改造我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。 原因如下: 我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。 违反开放封闭原则,我们如果了解开放封闭原则的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。 代码耦合严重,我们的数据、方法和 DOM 都是耦合在一起的，就是传说中的面条代码。 那么如何解决上述问题？ Vue 的操作就是加入了发布订阅模式，结合Object.defineProperty的劫持能力，实现了可用性很高的双向绑定。 首先，我们以发布订阅的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。 我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。 123456789101112131415161718192021222324let uid = 0;// 用于储存订阅者并发布消息class Dep &#123; constructor() &#123; // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher this.id = uid++; // 储存订阅者的数组 this.subs = []; &#125; // 触发target上的Watcher中的addDep方法,参数为dep的实例本身 depend() &#123; Dep.target.addDep(this); &#125; // 添加订阅者 addSub(sub) &#123; this.subs.push(sub); &#125; notify() &#123; // 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理 this.subs.forEach(sub =&gt; sub.update()); &#125;&#125;// 为Dep类设置一个静态属性,默认为null,工作时指向当前的WatcherDep.target = null; 现在我们需要实现监听者(Observer),用于监听属性值的变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 监听者,监听对象属性值的变化class Observer &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; // 遍历属性值并监听 walk(value) &#123; Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); &#125; // 执行监听的具体方法 convert(key, val) &#123; defineReactive(this.value, key, val); &#125;&#125;function defineReactive(obj, key, val) &#123; const dep = new Dep(); // 给当前属性的值添加监听 let chlidOb = observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: () =&gt; &#123; // 如果Dep类存在target属性，将其添加到dep实例的subs数组中 // target指向一个Watcher实例，每个Watcher都是一个订阅者 // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法 if (Dep.target) &#123; dep.depend(); &#125; return val; &#125;, set: newVal =&gt; &#123; if (val === newVal) return; val = newVal; // 对新值进行监听 chlidOb = observe(newVal); // 通知所有订阅者，数值被改变了 dep.notify(); &#125; &#125;);&#125;function observe(value) &#123; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 if (!value || typeof value !== \"object\") &#123; return; &#125; return new Observer(value);&#125; 那么接下来就简单了,我们需要实现一个订阅者(Watcher)。 12345678910111213141516171819202122232425262728293031323334353637class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.depIds = &#123;&#125;; // hash储存订阅者的id,避免重复的订阅者 this.vm = vm; // 被订阅的数据一定来自于当前Vue实例 this.cb = cb; // 当数据更新时想要做的事情 this.expOrFn = expOrFn; // 被订阅的数据 this.val = this.get(); // 维护更新之前的数据 &#125; // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用 update() &#123; this.run(); &#125; addDep(dep) &#123; // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存 // 此判断是避免同id的Watcher被多次储存 if (!this.depIds.hasOwnProperty(dep.id)) &#123; dep.addSub(this); this.depIds[dep.id] = dep; &#125; &#125; run() &#123; const val = this.get(); console.log(val); if (val !== this.val) &#123; this.val = val; this.cb.call(this.vm, val); &#125; &#125; get() &#123; // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this; const val = this.vm._data[this.expOrFn]; // 置空，用于下一个Watcher使用 Dep.target = null; return val; &#125;&#125; 那么我们最后完成 Vue,将上述方法挂载在 Vue 上。 123456789101112131415161718192021222324252627class Vue &#123; constructor(options = &#123;&#125;) &#123; // 简化了$options的处理 this.$options = options; // 简化了对data的处理 let data = (this._data = this.$options.data); // 将所有data最外层属性代理到Vue实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)); // 监听数据 observe(data); &#125; // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者 $watch(expOrFn, cb) &#123; new Watcher(this, expOrFn, cb); &#125; _proxy(key) &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get: () =&gt; this._data[key], set: val =&gt; &#123; this._data[key] = val; &#125;, &#125;); &#125; &#125;] 至此,一个简单的双向绑定算是被我们实现了。 Object.defineProperty 的缺陷 Object.defineProperty的第一个缺陷,无法监听数组变化。Vue 的文档提到了 Vue 是可以检测到数组变化的，但是只有以下八种方法,vm.items[indexOfItem] = newValue这种是无法检测的。push()、pop()、shift()、unshift()、splice()、sort()、reverse() Object.defineProperty的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 Object.keys(value).forEach(key =&gt; **this**.convert(key, value[key])); 无法检测到对象属性的添加或删除(如data.location.a=1)。 这是因为 Vue 通过Object.defineProperty来将对象的 key 转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。如果是删除属性，我们可以用vm.$delete实现，那如果是新增属性，该怎么办呢？1）可以使用 Vue.set(location, a, 1) 方法向嵌套对象添加响应式属性;2）也可以给这个对象重新赋值，比如data.location = {...data.location,a:1} Proxy 实现的双向绑定的特点Proxy 在 ES2015 规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy 是Object.defineProperty的全方位加强版 Proxy 可以直接监听对象而非属性我们还是以上文中用Object.defineProperty实现的极简版双向绑定为例,用 Proxy 进行改写。 12345678910111213141516171819202122const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");const obj = &#123;&#125;;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === \"text\") &#123; input.value = value; p.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;&#125;);input.addEventListener(\"keyup\", function(e) &#123; newObj.text = e.target.value;&#125;); 我们可以看到,Proxy 直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于Object.defineProperty。 Proxy 可以直接监听数组的变化当我们对数组进行操作(push、shift、splice 等)时，会触发对应的方法名称和length的变化，我们可以借此进行操作,以上文中Object.defineProperty无法生效的列表渲染为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const list = document.getElementById(\"list\");const btn = document.getElementById(\"btn\");// 渲染列表const Render = &#123; // 初始化 init: function(arr) &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) &#123; const li = document.createElement(\"li\"); li.textContent = arr[i]; fragment.appendChild(li); &#125; list.appendChild(fragment); &#125;, // 我们只考虑了增加的情况,仅作为示例 change: function(val) &#123; const li = document.createElement(\"li\"); li.textContent = val; list.appendChild(li); &#125;&#125;;// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, &#123; get: function(target, key, receiver) &#123; console.log(key); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key !== \"length\") &#123; Render.change(value); &#125; return Reflect.set(target, key, value, receiver); &#125;&#125;);// 初始化window.onload = function() &#123; Render.init(arr);&#125;;// push数字btn.addEventListener(\"click\", function() &#123; newArr.push(6);&#125;); 很显然,Proxy 不需要那么多 hack（即使 hack 也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于 hack。 Proxy 的其他优势Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是Object.defineProperty不具备的。 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。 当然,Proxy 的劣势就是兼容性问题,而且无法用 polyfill 磨平,因此 Vue 的作者才声明需要等到下个大版本(3.0)才能用 Proxy 重写。 基础 proxy 的双向数据绑定的实现发布订阅中心(Dep)Dep保存订阅者,并在 Observer 发生变化时通知保存在 Dep 中的订阅者,让订阅者得知变化并更新视图,这样才能保证视图与状态的同步。 12345678910111213141516171819202122232425262728293031/** * [subs description] 订阅器,储存订阅者,通知订阅者 * @type &#123;Map&#125; */export default class Dep &#123; constructor() &#123; // 我们用 hash 储存订阅者 this.subs = new Map(); &#125; // 添加订阅者 addSub(key, sub) &#123; // 取出键为 key 的订阅者 const currentSub = this.subs.get(key); // 如果能取出说明有相同的 key 的订阅者已经存在,直接添加 if (currentSub) &#123; currentSub.add(sub); &#125; else &#123; // 用 Set 数据结构储存,保证唯一值 this.subs.set(key, new Set([sub])); &#125; &#125; // 通知 notify(key) &#123; // 触发键为 key 的订阅者们 if (this.subs.get(key)) &#123; this.subs.get(key).forEach(sub =&gt; &#123; sub.update(); &#125;); &#125; &#125;&#125; 监听者的实现(Observer)我们在订阅器 Dep 中实现了一个notify方法来通知相应的订阅这们,然而notify方法到底什么时候被触发呢? 当然是当状态发生变化时,即 MVVM 中的 Modal 变化时触发通知,然而Dep 显然无法得知 Modal 是否发生了变化,因此我们需要创建一个监听者Observer来监听 Modal, 当 Modal 发生变化的时候我们就执行通知操作。 与Object.defineProperty监听属性不同, Proxy 可以监听(实际是代理)整个对象,因此就不需要遍历对象的属性依次监听了,但是如果对象的属性依然是个对象,那么 Proxy 也无法监听,所以我们实现了一个observify进行递归监听即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * [Observer description] 监听器,监听对象,触发后通知订阅 * @param &#123;[type]&#125; obj [description] 需要被监听的对象 */const Observer = obj =&gt; &#123; const dep = new Dep(); return new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // 如果订阅者存在，直接添加订阅 if (Dep.target) &#123; dep.addSub(key, Dep.target); &#125; return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; // 如果对象值没有变,那么不触发下面的操作直接返回 if (Reflect.get(receiver, key) === value) &#123; return; &#125; const res = Reflect.set(target, key, observify(value), receiver); // 当值被触发更改的时候,触发 Dep 的通知方法 dep.notify(key); return res; &#125; &#125;);&#125;;/** * 将对象转为监听对象 * @param &#123;*&#125; obj 要监听的对象 */export default function observify(obj) &#123; if (!isObject(obj)) &#123; return obj; &#125; // 深度监听 Object.keys(obj).forEach(key =&gt; &#123; obj[key] = observify(obj[key]); &#125;); return Observer(obj);&#125; 订阅者的实现(watcher)我们目前已经解决了两个问题,一个是如何得知 Modal 发生了改变(利用监听者 Observer 监听 Modal 对象),一个是如何收集订阅者并通知其变化(利用订阅器收集订阅者,并用 notify 通知订阅者)。 我们目前还差一个订阅者（Watcher） 12345678910111213141516171819202122232425262728293031// 订阅者export default class Watcher &#123; constructor(vm, exp, cb) &#123; this.vm = vm; // vm 是 vue 的实例 this.exp = exp; // 被订阅的数据 this.cb = cb; // 触发更新后的回调 this.value = this.get(); // 获取老数据 &#125; get() &#123; const exp = this.exp; let value; Dep.target = this; if (typeof exp === \"function\") &#123; value = exp.call(this.vm); &#125; else if (typeof exp === \"string\") &#123; value = this.vm[exp]; &#125; Dep.target = null; return value; &#125; // 将订阅者放入待更新队列等待批量更新 update() &#123; pushQueue(this); &#125; // 触发真正的更新操作 run() &#123; const val = this.get(); // 获取新数据 this.cb.call(this.vm, val, this.value); this.value = val; &#125;&#125; 批量更新的实现我们在上一节中实现了订阅者( Watcher),但是其中的update方法是将订阅者放入了一个待更新的队列中,而不是直接触发,原因如下: 因此这个队列需要做的是异步且去重,因此我们用 Set作为数据结构储存 Watcher 来去重,同时用Promise模拟异步更新。 1234567891011121314151617181920212223// 创建异步更新队列let queue = new Set();// 用Promise模拟nextTickfunction nextTick(cb) &#123; Promise.resolve().then(cb);&#125;// 执行刷新队列function flushQueue(args) &#123; queue.forEach(watcher =&gt; &#123; watcher.run(); &#125;); // 清空 queue = new Set();&#125;// 添加到队列export default function pushQueue(watcher) &#123; queue.add(watcher); // 下一个循环调用 nextTick(flushQueue);&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"九种实现跨域的方式","slug":"九种实现跨域的方式","date":"2019-03-07T07:00:20.000Z","updated":"2019-04-07T08:25:36.210Z","comments":true,"path":"2019/03/07/九种实现跨域的方式/","link":"","permalink":"http://yoursite.com/2019/03/07/九种实现跨域的方式/","excerpt":"基本概念同源策略是约定，它是浏览器最核心也最基本的安全功能。同源：”协议+域名+端口” 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了","text":"基本概念同源策略是约定，它是浏览器最核心也最基本的安全功能。同源：”协议+域名+端口” 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了 有三个标签是允许跨域加载资源： 123&lt;img src=XXX&gt;&lt;link href=XXX&gt;&lt;script src=XXX&gt; 跨域解决方案：JSONPJSONP 原理利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。 JSONP 优缺点JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。 JSONP 的实现流程 声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。 创建一个 script 标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show(‘我不爱你’)。 最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。 123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(\"script\"); window[callback] = function(data) &#123; resolve(data); document.body.removeChild(script); &#125;; params = &#123; ...params, callback &#125;; // wd=b&amp;callback=show let arrs = []; for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join(\"&amp;\")&#125;`; document.body.appendChild(script); &#125;);&#125;jsonp(&#123; url: \"http://localhost:3000/say\", params: &#123; wd: \"Iloveyou\" &#125;, callback: \"show\"&#125;).then(data =&gt; &#123; console.log(data);&#125;); 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show 这个地址请求数据，然后后台返回 show(‘我不爱你’)，最后会运行 show()这个函数，打印出’我不爱你’ 12345678910// server.jslet express = require(\"express\");let app = express();app.get(\"/say\", function(req, res) &#123; let &#123; wd, callback &#125; = req.query; console.log(wd); // Iloveyou console.log(callback); // show res.end(`$&#123;callback&#125;('我不爱你')`);&#125;);app.listen(3000); corsCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 简单请求使用方法为 GET、HEAD、POST 之一Content-Type 的值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一同时满足这两大条件，为简单请求 复杂请求复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest();document.cookie = \"name=xiamen\"; // cookie不能跨域xhr.withCredentials = true; // 前端设置是否带cookiexhr.open(\"PUT\", \"http://localhost:4000/getData\", true);xhr.setRequestHeader(\"name\", \"xiamen\");xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response); //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader(\"name\")); &#125; &#125;&#125;;xhr.send(); 12345//server1.jslet express = require(\"express\");let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require(\"express\");let app = express();let whitList = [\"http://localhost:3000\"]; //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin; if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader(\"Access-Control-Allow-Origin\", origin); // 允许携带哪个头访问我 res.setHeader(\"Access-Control-Allow-Headers\", \"name\"); // 允许哪个方法访问我 res.setHeader(\"Access-Control-Allow-Methods\", \"PUT\"); // 允许携带cookie res.setHeader(\"Access-Control-Allow-Credentials\", true); // 预检的存活时间 res.setHeader(\"Access-Control-Max-Age\", 6); // 允许返回的头 res.setHeader(\"Access-Control-Expose-Headers\", \"name\"); if (req.method === \"OPTIONS\") &#123; res.end(); // OPTIONS请求不做任何处理 &#125; &#125; next();&#125;);app.put(\"/getData\", function(req, res) &#123; console.log(req.headers); res.setHeader(\"name\", \"jw\"); //返回一个响应头，后台需设置 res.end(\"我不爱你\");&#125;);app.get(\"/getData\", function(req, res) &#123; console.log(req.headers); res.end(\"我不爱你\");&#125;);app.use(express.static(__dirname));app.listen(4000); postMessage是为数不多可以跨域操作的 window 属性，可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的 iframe 消息传递 上面三个场景的跨域数据传递postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 1otherWindow.postMessage(message, targetOrigin, [transfer]); 例子： 123456789101112131415161718// a.html&lt;iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt;//等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html&lt;script&gt; function load() &#123; let frame = document.getElementById(\"frame\"); frame.contentWindow.postMessage(\"我爱你\", \"http://localhost:4000\"); //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data); //我不爱你 &#125;; &#125;&lt;/script&gt; 12345// b.htmlwindow.onmessage = function(e) &#123; console.log(e.data); //我爱你 e.source.postMessage(\"我不爱你\", e.origin);&#125;; websocketWebsocket 是 HTML5 的 WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 12345678910// socket.html&lt;script&gt; let socket = new WebSocket(\"ws://localhost:3000\"); socket.onopen = function() &#123; socket.send(\"我爱你\"); //向服务器发送数据 &#125;; socket.onmessage = function(e) &#123; console.log(e.data); //接收服务器返回的数据 &#125;;&lt;/script&gt; 1234567891011// server.jslet express = require(\"express\");let app = express();let WebSocket = require(\"ws\"); //记得安装wslet wss = new WebSocket.Server(&#123; port: 3000 &#125;);wss.on(\"connection\", function(ws) &#123; ws.on(\"message\", function(data) &#123; console.log(data); ws.send(\"我不爱你\"); &#125;);&#125;); Node 中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求 转发给服务器。 拿到服务器 响应 数据。 将 响应 转发给客户端。 本地文件 index.html 文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据： 12345678910111213141516// index.html(http://127.0.0.1:5500)&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url: \"http://localhost:3000\", type: \"post\", data: &#123; name: \"xiamen\", password: \"123456\" &#125;, contentType: \"application/json;charset=utf-8\", success: function(result) &#123; console.log(result); // &#123;\"title\":\"fontend\",\"password\":\"123456\"&#125; &#125;, error: function(msg) &#123; console.log(msg); &#125; &#125;);&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require(\"http\");// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; \"Access-Control-Allow-Origin\": \"*\", \"Access-Control-Allow-Methods\": \"*\", \"Access-Control-Allow-Headers\": \"Content-Type\" &#125;); // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: \"127.0.0.1\", port: 4000, url: \"/\", method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = \"\"; serverResponse.on(\"data\", chunk =&gt; &#123; body += chunk; &#125;); serverResponse.on(\"end\", () =&gt; &#123; console.log(\"The data is \" + body); // 第四步：将响应结果转发给浏览器 response.end(body); &#125;); &#125; ) .end();&#125;);server.listen(3000, () =&gt; &#123; console.log(\"The proxyServer is running at http://localhost:3000\");&#125;); 1234567891011// server2.js(http://localhost:4000)const http = require(\"http\");const data = &#123; title: \"fontend\", password: \"123456\" &#125;;const server = http.createServer((request, response) =&gt; &#123; if (request.url === \"/\") &#123; response.end(JSON.stringify(data)); &#125;&#125;);server.listen(4000, () =&gt; &#123; console.log(\"The server is running at http://localhost:4000\");&#125;); nginx 反向代理实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。 使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。 先下载 nginx，然后将 nginx 目录下的 nginx.conf 修改，最后通过命令行 nginx -s reload 启动 nginx window.name + iframewindow.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。其中 a.html 和 b.html 是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 12345678910111213141516171819202122// a.html(http://localhost:3000/b.html)&lt;iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"&gt;&lt;/iframe&gt;&lt;script&gt; let first = true; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if (first) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById(\"iframe\"); iframe.src = \"http://localhost:3000/b.html\"; first = false; &#125; else &#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125;&lt;/script&gt; b.html 为中间代理页，与 a.html 同域，内容为空。 1234// c.html(http://localhost:4000/c.html)&lt;script&gt; window.name = \"我不爱你\";&lt;/script&gt; 通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。 具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 12345678// a.html&lt;iframe src=\"http://localhost:4000/c.html#iloveyou\"&gt;&lt;/iframe&gt;&lt;script&gt; window.onhashchange = function() &#123; //检测hash的变化 console.log(location.hash); &#125;;&lt;/script&gt; 12345// b.html&lt;script&gt; window.parent.parent.location.hash = location.hash; //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面&lt;/script&gt; 12345// c.htmlconsole.log(location.hash);let iframe = document.createElement(\"iframe\");iframe.src = \"http://localhost:3000/b.html#idontloveyou\";document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =’test.com’ 表示二级域名都相同就可以实现跨域。实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。 12345678910111213141516// a.zf1.cn:3000/a.html&lt;body&gt; helloa &lt;iframe src=\"http://b.zf1.cn:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\" &gt;&lt;/iframe&gt; &lt;script&gt; document.domain = \"zf1.cn\"; function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678// b.zf1.cn:3000/b.html&lt;body&gt; hellob &lt;script&gt; document.domain = \"zf1.cn\"; var a = 100; &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"树的diff算法（vue 2.0）","slug":"树的diff算法（vue 2.0）","date":"2019-02-22T07:37:14.000Z","updated":"2019-08-15T10:31:49.319Z","comments":true,"path":"2019/02/22/树的diff算法（vue 2.0）/","link":"","permalink":"http://yoursite.com/2019/02/22/树的diff算法（vue 2.0）/","excerpt":"树的 diff 算法（vue 2.0）模板转换成视图的过程 Vue.js 通过编译将 template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树 在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。 简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。","text":"树的 diff 算法（vue 2.0）模板转换成视图的过程 Vue.js 通过编译将 template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树 在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。 简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。 渲染函数：渲染函数是用来生成 Virtual DOM 的。Vue 推荐使用模板来构建我们的应用界面，在底层实现中 Vue 会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。 VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode 可以理解成节点描述对象，它描述了应该怎样去创建真实的 DOM 节点。 patch(也叫做 patching 算法)：虚拟 DOM 最核心的部分，它可以将 vnode 渲染成真实的 DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch 本身就有补丁、修补的意思，其实际作用是在现有 DOM 上进行修改来实现更新视图的目的。Vue 的 Virtual DOM Patching 算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。 Virtual DOM 是什么？Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。 简单来说，可以把 Virtual DOM 理解为一个简单的 JS 对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。 对于虚拟 DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了模板 → 渲染函数 → 虚拟DOM树 → 真实DOM的一个过程 Virtual DOM 作用是什么？虚拟 DOM 的最终目标是将虚拟节点渲染到视图上。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的 DOM 操作。例如，一个 ul 标签下很多个 li 标签，其中只有一个 li 有变化，这种情况下如果使用新的 ul 去替代旧的 ul,因为这些不必要的 DOM 操作而造成了性能上的浪费。 为了避免不必要的 DOM 操作，虚拟 DOM 在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行 DOM 操作，从而避免操作其他无需改动的 DOM。 其实虚拟 DOM 在 Vue.js 主要做了两件事： 提供与真实 DOM 节点所对应的虚拟节点 vnode 将虚拟节点 vnode 和旧虚拟节点 oldVnode 进行对比，然后更新视图 为何需要 Virtual DOM？ 具备跨平台的优势 由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 操作 DOM 慢，js 运行效率高。我们可以将 DOM 对比操作放在 JS 层，提高效率。 因为 DOM 操作的执行速度远不如 Javascript 的运算速度快，因此，把大量的 DOM 操作搬运到 Javascript 中，运用 patching 算法来计算出真正需要更新的节点，最大限度地减少 DOM 操作，从而显著提高性能。 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM） 提升渲染性能 Virtual DOM 的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。 为了实现高效的 DOM 操作，一套高效的虚拟 DOM diff 算法显得很有必要。我们通过 patch 的核心—-diff 算法，找出本次 DOM 需要更新的节点来更新，其他的不更新。 VNode抽象 Dom 树把真实 Dom 树抽象成一棵以 javascript 对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实 Dom 重绘到页面上呢？于是虚拟 Dom 出现了，它是真实 Dom 的一层抽象，用属性描述真实 Dom 的各个特性。当它发生变化的时候，就会去修改视图。 但是这样的 javascript 操作 Dom 进行重绘整个视图层是相当消耗性能的，我们是不是可以每次只更新它的修改呢？所以 Vue.js 将 Dom 抽象成一个以 javascript 对象为节点的虚拟 Dom 树，以 VNode 节点模拟真实 Dom，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实 Dom，只需要操作 javascript 对象，大大提升了性能。修改以后经过 diff 算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的 Dom 操作，大大提高了性能。 Vue 就使用了这样的抽象节点 VNode，它是对真实 Dom 的一层抽象，而不依赖某个平台，它可以是浏览器平台，也可以是 weex，甚至是 node 平台也可以对这样一棵抽象 Dom 树进行创建删除修改等操作，这也为前后端同构提供了可能。 VNode 基类先来看一下 Vue.js 源码中对 VNode 类的定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope functionalContext: Component | void; // only for functional component root nodes key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? constructor( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions ) &#123; /*当前节点的标签名*/ this.tag = tag; /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.data = data; /*当前节点的子节点，是一个数组*/ this.children = children; /*当前节点的文本*/ this.text = text; /*当前虚拟节点对应的真实dom节点*/ this.elm = elm; /*当前节点的名字空间*/ this.ns = undefined; /*编译作用域*/ this.context = context; /*函数化组件作用域*/ this.functionalContext = undefined; /*节点的key属性，被当作节点的标志，用以优化*/ this.key = data &amp;&amp; data.key; /*组件的option选项*/ this.componentOptions = componentOptions; /*当前节点对应的组件的实例*/ this.componentInstance = undefined; /*当前节点的父节点*/ this.parent = undefined; /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.raw = false; /*静态节点标志*/ this.isStatic = false; /*是否作为跟节点插入*/ this.isRootInsert = true; /*是否为注释节点*/ this.isComment = false; /*是否为克隆节点*/ this.isCloned = false; /*是否有v-once指令*/ this.isOnce = false; &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next https://github.com/answershuto/learnVue*/ get child(): Component | void &#123; return this.componentInstance; &#125;&#125; 这是一个最基础的 VNode 节点，作为其他派生 VNode 类的基类，里面定义了下面这些数据。 tag: 当前节点的标签名 data: 当前节点对应的对象，包含了具体的一些数据信息，是一个 VNodeData 类型，可以参考 VNodeData 类型中的数据信息 children: 当前节点的子节点，是一个数组 text: 当前节点的文本 elm: 当前虚拟节点对应的真实 dom 节点 ns: 当前节点的名字空间 context: 当前节点的编译作用域 functionalContext: 函数化组件作用域 key: 节点的 key 属性，被当作节点的标志，用以优化 componentOptions: 组件的 option 选项 componentInstance: 当前节点对应的组件的实例 parent: 当前节点的父节点 raw: 简而言之就是是否为原生 HTML 或只是普通文本，innerHTML 的时候为 true，textContent 的时候为 false isStatic: 是否为静态节点 isRootInsert: 是否作为跟节点插入 isComment: 是否为注释节点 isCloned: 是否为克隆节点 isOnce: 是否有 v-once 指令 打个比方，比如说我现在有这么一个 VNode 树 123456789101112131415&#123; tag: 'div' data: &#123; class: 'test' &#125;, children: [ &#123; tag: 'span', data: &#123; class: 'demo' &#125; text: 'hello,VNode' &#125; ]&#125; 渲染之后的结果就是这样的 123&lt;div class=\"test\"&gt; &lt;span class=\"demo\"&gt;hello,VNode&lt;/span&gt;&lt;/div&gt; 生成一个新的 VNode 的方法下面这些方法都是一些常用的构造 VNode 的方法。 createEmptyVNode 创建一个空 VNode 节点 1234567/*创建一个空VNode节点*/export const createEmptyVNode = () =&gt; &#123; const node = new VNode(); node.text = \"\"; node.isComment = true; return node;&#125;; createTextVNode 创建一个文本节点 1234/*创建一个文本节点*/export function createTextVNode(val: string | number) &#123; return new VNode(undefined, undefined, undefined, String(val));&#125; createComponent 创建一个组件节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 // plain options object: turn it into a constructor https://github.com/answershuto/learnVue if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor) &#125; // if at this stage it's not a constructor or an async component factory, // reject. /*Github:https://github.com/answershuto*/ /*如果在该阶段Ctor依然不是一个构造函数或者是一个异步组件工厂则直接返回*/ if (typeof Ctor !== 'function') &#123; if (process.env.NODE_ENV !== 'production') &#123; warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context) &#125; return &#125; // async component /*处理异步组件*/ if (isUndef(Ctor.cid)) &#123; Ctor = resolveAsyncComponent(Ctor, baseCtor, context) if (Ctor === undefined) &#123; // return nothing if this is indeed an async component // wait for the callback to trigger parent update. /*如果这是一个异步组件则会不会返回任何东西（undifiened），直接return掉，等待回调函数去触发父组件更新。s*/ return &#125; &#125; // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor) data = data || &#123;&#125; // transform component v-model data into props &amp; events if (isDef(data.model)) &#123; transformModel(Ctor.options, data) &#125; // extract props const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent(Ctor, propsData, data, context, children) &#125; // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier data.on = data.nativeOn if (isTrue(Ctor.options.abstract)) &#123; // abstract components do not keep anything // other than props &amp; listeners data = &#123;&#125; &#125; // merge component management hooks onto the placeholder node mergeHooks(data) // return a placeholder vnode const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125; ) return vnode&#125; cloneVNode 克隆一个 VNode 节点 12345678910111213141516export function cloneVNode(vnode: VNode): VNode &#123; const cloned = new VNode( vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions ); cloned.ns = vnode.ns; cloned.isStatic = vnode.isStatic; cloned.key = vnode.key; cloned.isCloned = true; return cloned;&#125; createElementcreateElement 用来创建一个虚拟节点。当 data 上已经绑定ob的时候，代表该对象已经被 Oberver 过了，所以创建一个空节点。tag 不存在的时候同样创建一个空节点。当 tag 不是一个 String 类型的时候代表 tag 是一个组件的构造类，直接用 new VNode 创建。当 tag 是 String 类型的时候，如果是保留标签，则用 new VNode 创建一个 VNode 实例，如果在 vm 的 option 的 components 找得到该 tag，代表这是一个组件，否则统一用 new VNode 创建。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// wrapper function for providing a more flexible interface// without getting yelled at by flowexport function createElement( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode &#123; /*兼容不传data的情况*/ if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children; children = data; data = undefined; &#125; /*如果alwaysNormalize为true，则normalizationType标记为ALWAYS_NORMALIZE*/ if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE; &#125; /*Github:https://github.com/answershuto*/ /*创建虚拟节点*/ return _createElement(context, tag, data, children, normalizationType);&#125;/*创建虚拟节点*/export function _createElement( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode &#123; /* 如果data未定义（undefined或者null）或者是data的__ob__已经定义（代表已经被observed，上面绑定了Oberver对象）， https://cn.vuejs.org/v2/guide/render-function.html#约束 那么创建一个空节点 */ if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== \"production\" &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify( data )&#125;\\n` + \"Always create fresh vnode data objects in each render!\", context ); return createEmptyVNode(); &#125; /*如果tag不存在也是创建一个空节点*/ if (!tag) &#123; // in case of component :is set to falsy value return createEmptyVNode(); &#125; // support single function children as default scoped slot /*默认默认作用域插槽*/ if (Array.isArray(children) &amp;&amp; typeof children[0] === \"function\") &#123; data = data || &#123;&#125;; data.scopedSlots = &#123; default: children[0] &#125;; children.length = 0; &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children); &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children); &#125; let vnode, ns; if (typeof tag === \"string\") &#123; let Ctor; /*获取tag的名字空间*/ ns = config.getTagNamespace(tag); /*判断是否是保留的标签*/ if (config.isReservedTag(tag)) &#123; // platform built-in elements /*如果是保留的标签则创建一个相应节点*/ vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); &#125; else if ( isDef((Ctor = resolveAsset(context.$options, \"components\", tag))) ) &#123; // component /*从vm实例的option的components中寻找该tag，存在则就是一个组件，创建相应节点，Ctor为组件的构造类*/ vnode = createComponent(Ctor, data, context, children, tag); &#125; else &#123; // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children /*未知的元素，在运行时检查，因为父组件可能在序列化子组件的时候分配一个名字空间*/ vnode = new VNode(tag, data, children, undefined, undefined, context); &#125; &#125; else &#123; // direct component options / constructor /*tag不是字符串的时候则是组件的构造类*/ vnode = createComponent(tag, data, context, children); &#125; if (isDef(vnode)) &#123; /*如果有名字空间，则递归所有子节点应用该名字空间*/ if (ns) applyNS(vnode, ns); return vnode; &#125; else &#123; /*如果vnode没有成功创建则创建空节点*/ return createEmptyVNode(); &#125;&#125; diff 概解1.当数据发生变化时，vue 是怎么更新节点的？周所周知，Vue 通过数据绑定来修改视图，当某个数据被修改的时候，set 方法会让闭包中的 Dep 调用 notify 通知所有订阅者 Watcher，Watcher 通过 get 方法执行 vm._update(vm._render(), hydrating)。 这里看一下_update 方法 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this /*如果已经该组件已经挂载过了则代表进入这个步骤是个更新的过程，触发beforeUpdate钩子*/ if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. /*基于后端渲染Vue.prototype.__patch__被用来作为一个入口*/ if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false /* removeOnly */, vm.$options._parentElm, vm.$options._refElm ) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; activeInstance = prevActiveInstance // update __vue__ reference /*更新新的实例对象的__vue__*/ if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. &#125;复制代码 _update 方法的第一个参数是一个 VNode 对象，在内部会将该 VNode 对象与之前旧的 VNode 对象进行patch。 要知道渲染真实 DOM 的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实 dom 上会引起整个 dom 树的重绘和重排，有没有可能我们只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？diff 算法能够帮助我们。 我们先根据真实 DOM 生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的 DOM 上，然后使oldVnode的值为Vnode。 diff 的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的 DOM打补丁。 2. virtual DOM 和真实 DOM 的区别？虚拟 dom 对应的是真实 dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。 virtual DOM 是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构。比如 dom 是这样的： 123&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 对应的 virtual DOM（伪代码）： 1234var Vnode = &#123; tag: \"div\", children: [&#123; tag: \"p\", text: \"123\" &#125;]&#125;; （温馨提示：VNode和oldVNode都是对象，一定要记住） virtual dom 很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。 3. diff 的比较方式？在采取 diff 算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。 1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;456&lt;/span&gt;&lt;/div&gt; 上面的代码会分别比较同一层的两个 div 以及第二层的 p 和 span，但是不会拿 div 和 span 作比较。在别处看到的一张很形象的图： diff 流程图当数据发生改变时，set 方法会让调用Dep.notify通知所有订阅者 Watcher，订阅者就会调用patch给真实的 DOM 打补丁，更新相应的视图。 diff 算法包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了 diff 算法具体分析1. patch来看看patch是怎么打补丁的（代码只保留核心部分） 123456789101112131415161718function patch(oldVnode, vnode) &#123; // some code if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode); &#125; else &#123; const oEl = oldVnode.el; // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl); // 父元素 createEle(vnode); // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)); // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el); // 移除以前的旧元素节点 oldVnode = null; &#125; &#125; // some code return vnode;&#125;复制代码; patch 函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode 1234567891011function sameVnode(a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 );&#125;复制代码; 不值得比较则用Vnode替换oldVnode 如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff 可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…） 2. patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？ 123456789101112131415161718patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el's children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125;复制代码 这个函数做了以下事情： 找到对应的真实 dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 其他几个点都很好理解，我们详细来讲一下 updateChildren 3. updateChildren代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125;else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125;else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125;else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125;else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125;复制代码 先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 图解 updateChildren终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。 粉红色的部分为 oldCh、黄色的部分为 vCh 我们将它们取出来并分别用 s 和 e 指针指向它们的头 child 和尾 child 现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，这句话有点绕，打个比方 如果是 oldS 和 E 匹配上了，那么真实 dom 中的第一个节点会移到最后 如果是 oldE 和 S 匹配上了，那么真实 dom 中的最后一个节点会移到最前，匹配上的两个指针向中间移动 如果四种匹配没有一对是成功的，分为两种情况 如果新旧子节点都存在 key，那么会根据oldChild的 key 生成一张 hash 表，用S的 key 与 hash 表做匹配，匹配成功就判断S和匹配节点是否为sameNode，如果是，就在真实 dom 中将成功的节点移到最前面，否则，将S生成对应的节点插入到 dom 中对应的oldS位置，oldS和S指针向中间移动。 如果没有 key,则直接将S生成新的节点插入真实DOM（ps：这下可以解释为什么 v-for 的时候需要设置 key 了，如果没有 key 那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了） 再配个图（假设下图中的所有节点都是有 key 的，且 key 为自身的值） 第一步 12oldS = a, oldE = d；S = a, E = b; oldS和S匹配，则将 dom 中的 a 节点放到第一个，已经是第一个了就不管了，此时 dom 的位置为：a b d 第二步 12oldS = b, oldE = d；S = c, E = b; oldS和E匹配，就将原本的 b 节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，此时 dom 的位置为：a d b 第三步 12oldS = d, oldE = d；S = c, E = d; oldE和E匹配，位置不变此时 dom 的位置为：a d b 第四步 123oldS++;oldE--;oldS &gt; oldE; 遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的 index 插入到真实 dom 中去，此时 dom 位置为：a c d b 一次模拟完成。 这个匹配过程的结束有两个条件： oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据 index 添加到 dom 中去（如上图） S &gt; E表示 vCh 先遍历完，那么就在真实 dom 中将区间为[oldS, oldE]的多余节点删掉 下面再举一个例子，可以像上面那样自己试着模拟一下 当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码 123if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode);&#125; 就这样层层递归下去，直到将 oldVnode 和 Vnode 中的所有子节点比对完。也将 dom 的所有补丁都打好啦。那么现在再回过去看 updateChildren 的代码会不会容易很多呢？ 4. 操作 dom这里我们只是将虚拟 DOM 映射成了真实的 DOM。那如何给这些 DOM 加入 attr、class、style 等 DOM 属性呢？ 这要依赖于虚拟 DOM 的生命钩子。虚拟 DOM 提供了如下的钩子函数，分别在不同的时期会进行调用。 1234567891011const hooks = [\"create\", \"activate\", \"update\", \"remove\", \"destroy\"];/*构建cbs回调函数，web平台上见/platforms/web/runtime/modules*/for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = []; for (j = 0; j &lt; modules.length; ++j) &#123; if (isDef(modules[j][hooks[i]])) &#123; cbs[hooks[i]].push(modules[j][hooks[i]]); &#125; &#125;&#125; 同理，也会根据不同平台有自己不同的实现，我们这里以 Web 平台为例。Web 平台的钩子函数见/platforms/web/runtime/modules。里面有对 attr、class、props、events、style 以及 transition（过渡状态）的 DOM 属性进行操作。 以 attr 为例，代码很简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* @flow */import &#123; isIE9 &#125; from \"core/util/env\";import &#123; extend, isDef, isUndef &#125; from \"shared/util\";import &#123; isXlink, xlinkNS, getXlinkProp, isBooleanAttr, isEnumeratedAttr, isFalsyAttrValue&#125; from \"web/util/index\";/*更新attr*/function updateAttrs(oldVnode: VNodeWithData, vnode: VNodeWithData) &#123; /*如果旧的以及新的VNode节点均没有attr属性，则直接返回*/ if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) &#123; return; &#125; let key, cur, old; /*VNode节点对应的Dom实例*/ const elm = vnode.elm; /*旧VNode节点的attr*/ const oldAttrs = oldVnode.data.attrs || &#123;&#125;; /*新VNode节点的attr*/ let attrs: any = vnode.data.attrs || &#123;&#125;; // clone observed objects, as the user probably wants to mutate it /*如果新的VNode的attr已经有__ob__（代表已经被Observe处理过了）， 进行深拷贝*/ if (isDef(attrs.__ob__)) &#123; attrs = vnode.data.attrs = extend(&#123;&#125;, attrs); &#125; /*遍历attr，不一致则替换*/ for (key in attrs) &#123; cur = attrs[key]; old = oldAttrs[key]; if (old !== cur) &#123; setAttr(elm, key, cur); &#125; &#125; // #4391: in IE9, setting type can reset value for input[type=radio] /* istanbul ignore if */ if (isIE9 &amp;&amp; attrs.value !== oldAttrs.value) &#123; setAttr(elm, \"value\", attrs.value); &#125; for (key in oldAttrs) &#123; if (isUndef(attrs[key])) &#123; if (isXlink(key)) &#123; elm.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else if (!isEnumeratedAttr(key)) &#123; elm.removeAttribute(key); &#125; &#125; &#125;&#125;/*设置attr*/function setAttr(el: Element, key: string, value: any) &#123; if (isBooleanAttr(key)) &#123; // set attribute for blank value // e.g. &lt;option disabled&gt;Select one&lt;/option&gt; if (isFalsyAttrValue(value)) &#123; el.removeAttribute(key); &#125; else &#123; el.setAttribute(key, key); &#125; &#125; else if (isEnumeratedAttr(key)) &#123; el.setAttribute( key, isFalsyAttrValue(value) || value === \"false\" ? \"false\" : \"true\" ); &#125; else if (isXlink(key)) &#123; if (isFalsyAttrValue(value)) &#123; el.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else &#123; el.setAttributeNS(xlinkNS, key, value); &#125; &#125; else &#123; if (isFalsyAttrValue(value)) &#123; el.removeAttribute(key); &#125; else &#123; el.setAttribute(key, value); &#125; &#125;&#125;export default &#123; create: updateAttrs, update: updateAttrs&#125;; attr 只需要在 create 以及 update 钩子被调用时更新 DOM 的 attr 属性即可。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"leetcode算法刷题笔记（三）——排序","slug":"leetcode算法刷题笔记（三）——排序","date":"2019-02-22T06:54:39.000Z","updated":"2019-04-28T15:24:34.809Z","comments":true,"path":"2019/02/22/leetcode算法刷题笔记（三）——排序/","link":"","permalink":"http://yoursite.com/2019/02/22/leetcode算法刷题笔记（三）——排序/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [56] Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.难度：Medium (34.95%)思路： 首先按 start 升序或按 end 升序排列 如果前一项的 end 大于后一项的 start，说明要 merge 因为已经做了升序排列，所以要 push 进结果的那一项的 start 一定为前一项的 start，而 end 为两项中 end 较大的那个值。","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [56] Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.难度：Medium (34.95%)思路： 首先按 start 升序或按 end 升序排列 如果前一项的 end 大于后一项的 start，说明要 merge 因为已经做了升序排列，所以要 push 进结果的那一项的 start 一定为前一项的 start，而 end 为两项中 end 较大的那个值。 12345678910111213141516171819202122var merge = function(intervals) &#123; var res = []; if (intervals.length == 0) &#123; return res; &#125; intervals.sort(function(a, b) &#123; return a.start !== b.start ? a.start - b.start : a.end - b.end; &#125;); var pre = intervals[0]; res.push(pre); for (var cur of intervals) &#123; if (pre.end &gt;= cur.start) &#123; if (cur.end &gt; pre.end) &#123; pre.end = cur.end; &#125; &#125; else &#123; res.push(cur); pre = cur; &#125; &#125; return res;&#125;; [75] Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.Note: You are not suppose to use the library’s sort function for this problem.难度：Medium (41.44%)思路：遇到 0 放在最前面，遇到 2 放在最后面，1 不动 i 从 0 开始，如果 nums[i]等于 1，则 i++。 如果 nums[i]等于 0，则把 nums[i]放到最前面 如果 nums[i]等于 2，则把 nums[i]放到最后面 1234567891011121314151617181920212223242526var sortColors = function(nums) &#123; if (nums.length == 0) &#123; return -1; &#125; var i = 0; var m = 0; var n = nums.length - 1; var temp; while (i &lt;= n) &#123; if (nums[i] == 1) &#123; i++; &#125; else if (nums[i] == 0) &#123; temp = nums[m]; nums[m] = nums[i]; nums[i] = temp; m++; i++; &#125; else &#123; temp = nums[n]; nums[n] = nums[i]; nums[i] = temp; n--; &#125; &#125; return nums;&#125;; [147] Insertion Sort ListSort a linked list using insertion sort.A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list.Algorithm of Insertion Sort:Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.难度：Medium (36.50%)思路：新开辟一个空链表，作为以排序区域，每次拿出 head 来，与以排序区域的链表的 val 进行比较，找到插入位置，插入。则未排序区域的了链表长度减一。 123456789101112131415var insertionSortList = function(head) &#123; var current = &#123; val: -Number.MAX_VALUE, next: null &#125;; while (head) &#123; var prev = current; while (prev.next &amp;&amp; prev.next.val &lt; head.val) &#123; prev = prev.next; &#125; var next = head.next; head.next = prev.next; prev.next = head; head = next; &#125; return current.next;&#125;; [148] Sort ListSort a linked list in O(n log n) time using constant space complexity.难度：Medium (34.12%)思路：归并排序的链表实现 123456789101112131415161718192021222324252627282930313233343536373839404142var sortList = function(head) &#123; if (head == null || head.next == null) &#123; return head; &#125; var fast = head; var slow = head; var pre = null; while (fast &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; return merge(sortList(head), sortList(slow));&#125;;function merge(left, right) &#123; var result = &#123;&#125;; var pre = result; while (left &amp;&amp; right) &#123; if (left.val &lt; right.val) &#123; pre.next = left; pre = pre.next; left = left.next; &#125; else &#123; pre.next = right; pre = pre.next; right = right.next; &#125; &#125; while (left) &#123; pre.next = left; pre = pre.next; left = left.next; &#125; while (right) &#123; pre.next = right; pre = pre.next; right = right.next; &#125; return result.next;&#125; [179] Largest NumberGiven a list of non negative integers, arrange them such that they form the largest number.难度：Medium (25.32%) 12345678910111213var largestNumber = function(nums) &#123; nums.sort(function(a, b) &#123; var ab = a.toString() + b.toString(); var ba = b.toString() + a.toString(); return ba - ab; &#125;); var result = nums.join(\"\"); if (parseInt(result) == 0) &#123; return \"0\"; &#125; else &#123; return result; &#125;&#125;; [242] Valid AnagramGiven two strings s and t , write a function to determine if t is an anagram of s.Note: You may assume the string contains only lowercase alphabets.难度：Easy (51.12%) 1234567891011121314151617var isAnagram = function(s, t) &#123; if (s.length != = t.length) &#123; return false; &#125; var res = new Array(26); res.fill(0); for (var i = 0; i &lt; s.length; i++) &#123; res[s.codePointAt(i) - 97]++; res[t.codePointAt(i) - 97]--; &#125; for (var i = 0; i &lt; res.length; i++) &#123; if (res[i] !== 0) &#123; return false; &#125; &#125; return true;&#125;; [274] H-IndexGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”难度：Medium (34.43%)思路：一个人在其所有学术文章中有 N 篇论文分别被引用了至少 N 次，他的 H 指数就是 N。根据这个规则，首先讲数组倒序排列，判断数组中的第 i 个，是否大于等于 i+1，如果成立，则代表，至少有 i+1 篇文章，被引用了 i+1 次，则他的 h-index 就是 i+1. 12345678910111213141516var hIndex = function(citations) &#123; if (citations.length == 0) &#123; return 0; &#125; citations.sort((a, b) =&gt; b - a); var res = citations.length; for (var i = citations.length - 1; i &gt;= 0; i--) &#123; if (citations[i] &gt;= res) &#123; return res; &#125; res--; &#125; if (res == 0) &#123; return 0; &#125;&#125;; [324] Wiggle Sort IIGiven an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….难度：Medium (27.54%)思路：将数组正序排序之后，从中间分为两个数组，每次从小数组里拿一个数，从大数组里拿一个数，组成的 新数组就是一个数大一个数小的状态。 12345678910111213141516171819202122232425262728var wiggleSort = function(nums) &#123; if (nums.length &lt;= 1) &#123; return nums; &#125; nums = nums.sort((a, b) =&gt; a - b); var mid = Math.floor((nums.length + 1) / 2); var small = nums.slice(0, mid); var big = nums.slice(mid); if (big.length &gt; small.length) &#123; return []; &#125; var i = 0; var j = small.length - 1; var k = big.length - 1; while (i &lt; nums.length &amp;&amp; j &gt;= 0 &amp;&amp; k &gt;= 0) &#123; nums[i] = small[j]; nums[i + 1] = big[k]; i = i + 2; j--; k--; &#125; while (i &lt; nums.length &amp;&amp; j &gt;= 0) &#123; nums[i] = small[j]; i++; j--; &#125; return nums;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"前端路由","slug":"前端路由","date":"2019-01-28T12:56:32.000Z","updated":"2019-08-15T10:31:34.491Z","comments":true,"path":"2019/01/28/前端路由/","link":"","permalink":"http://yoursite.com/2019/01/28/前端路由/","excerpt":"前端路由1.什么是前端路由对于用户来说，路由就是浏览器地址栏中的 url 与所见网页的对应关系。而对于 web 开发人员来说，路由更像是 url 与处理函数的对应关系。 传统的服务端路由，根据客户端请求的不同网址，返回不同的网页内容，这种情况一是会造成服务器压力增加，二是每次都重新请求，响应较慢、用户体验下降。于是，单页应用（spa,single page application）应运而生。在 url 地址改变的过程中，通过 js 来实现不同 UI 之间的切换（js 对 DOM 的操作），而不再向服务器重新请求页面，只通过 ajax 向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。其中，根据 url 地址栏的变化而展示不同的 UI，就是通过前端路由来实现的。目前主流的支持单页应用的前端框架，基本都有配套的或第三方的路由系统。","text":"前端路由1.什么是前端路由对于用户来说，路由就是浏览器地址栏中的 url 与所见网页的对应关系。而对于 web 开发人员来说，路由更像是 url 与处理函数的对应关系。 传统的服务端路由，根据客户端请求的不同网址，返回不同的网页内容，这种情况一是会造成服务器压力增加，二是每次都重新请求，响应较慢、用户体验下降。于是，单页应用（spa,single page application）应运而生。在 url 地址改变的过程中，通过 js 来实现不同 UI 之间的切换（js 对 DOM 的操作），而不再向服务器重新请求页面，只通过 ajax 向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。其中，根据 url 地址栏的变化而展示不同的 UI，就是通过前端路由来实现的。目前主流的支持单页应用的前端框架，基本都有配套的或第三方的路由系统。 2.前端路由的实现方式在 HTML5 的 history API 出现之前，前端路由主要是通过 hash 来实现的，hash 能兼容低版本的浏览器。下面分别来介绍这 2 种方式。 方法一：基于 hash（location.hash+hashchange 事件） 我们知道 location.hash 的值是 url 中#后面的内容，如http://www.163.com#netease此网址中，location.hash=’#netease’。 hash 满足以下几个特性，才使得其可以实现前端路由： url 中 hash 值的变化并不会重新加载页面，因为 hash 是用来指导浏览器行为的，对服务端是无用的，所以不会包括在 http 请求中。 hash 值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制 hash 的切换 我们可以通过 hashchange 事件，监听到 hash 值的变化，从而响应不同路径的逻辑处理。 1window.addEventListener(\"hashchange\", funcRef, false); 如此一来，我们就可以在 hashchange 事件里，根据 hash 值来更新对应的视图，但不会去重新请求页面，同时呢，也在 history 里增加了一条访问记录，用户也仍然可以通过前进后退键实现 UI 的切换。 触发 hash 值的变化有 2 种方法:一种是通过 a 标签，设置 href 属性，当标签点击之后，地址栏会改变，同时会触发 hashchange 事件 1&lt;a href=\"#kaola\"&gt;to KAOLA&lt;/a&gt; 另一种是通过 js 直接赋值给 location.hash，也会改变 url，触发 hashchange 事件。 1location.hash = \"#kaola\"; 下面展示一个通过 hash 实现的简易 Router：123456789101112131415161718192021222324function Router() &#123; this.routes = &#123;&#125;; this.currentUrl = \"\";&#125;Router.prototype.route = function(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;;&#125;;Router.prototype.refresh = function() &#123; this.currentUrl = location.hash.slice(1) || \"/\"; this.routes[this.currentUrl]();&#125;;Router.prototype.init = function() &#123; window.addEventListener(\"load\", this.refresh.bind(this), false); window.addEventListener(\"hashchange\", this.refresh.bind(this), false);&#125;;window.Router = new Router();window.Router.init();// 添加路由规则Router.route(\"/\", function() &#123; // 设置响应内容&#125;);Router.route(\"/blue\", function() &#123; // 设置响应内容&#125;); 【route vs router】route 是一条路由，是将一个 URL 路径和一个处理函数相关联，是一条 url 和函数的映射规则，如上面代码中通过原型上的 route 可以设置一条路由规则，将一个 path 和其 callback 关联起来。 而 router 则更像是一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了 URL 和函数的映射，而在当接收到一个 URL 之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的，如上面代码，Router 管理传入的 route，并且在 hash 改变的时候，根据当前的 url 响应其对应的函数。 方法二：基于 History 新 API（history.pushState()+popState 事件） HTML5 中 history 对象上新的 API，同样能实现前端的路由。通过 pushState()方法或 replaceState()方法可以修改 url 的地址，并在 popstate 事件中能监听地址的改变，不同的是，手动的进行 pushState()并不会触发 popstate 事件。 两个新增的 API：history.pushState 和 history.replaceState这两个 API 都接收三个参数： 1window.history.pushState(null, null, \"http://www.163.com\"); 状态对象（state object），一个 JavaScript 对象，与用 pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发 popstate 事件，并能在事件中使用该对象。 标题（title） ：传入一个短标题给当前 state。现在大多数浏览器不支持或者会忽略此参数，最好传入 null 代替； 地址（URL）：新的历史记录条目的地址。浏览器不会在调用 pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的 URL 不一定是绝对路径；如果是相对路径，它将以当前 URL 为基准；传入的 URL 与当前 URL 应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前 URL。 这两个 API 的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState 会增加一条新的历史记录，而 replaceState 则会替换当前的历史记录。这两个 api，加上 state 改变触发的 popstate 事件，提供了单页应该的另一种路由方式。 下面展示一个使用这种方式的简单 demo：12345678910111213141516171819202122232425&lt;p id=\"menu\"&gt; &lt;a href=\"/profile\" title=\"profile\"&gt;profile&lt;/a&gt; &lt;a href=\"/account\" title=\"account\"&gt;account&lt;/a&gt;?&lt;/p&gt;&lt;div class=\"main\" id=\"main\"&gt;&lt;/div&gt;&lt;script&gt; (function() &#123; var menubox = document.getElementById(\"menu\"); var mainbox = document.getElementById(\"main\"); menubox.addEventListener(\"click\", function(e) &#123; e.preventDefault(); var elm = e.target; var uri = elm.href; var tlt = elm.title; history.pushState(&#123; path: uri, title: tlt &#125;, null, uri); mainbox.innerHTML = \"current page is \" + tlt; &#125;); window.addEventListener(\"popstate\", function(e) &#123; var state = e.state; console.log(state); mainbox.innerHTML = \"current page is \" + state.title; // 还原UI &#125;); &#125;)();&lt;/script&gt; 当我们在历史记录中切换时就会触发 popstate 事件，可以在事件中还原当前 state 对应的 UI。对于触发 popstate 事件的方式，各浏览器实现也有差异，我们可以根据不同浏览器做兼容处理。 两种方式对比（History&amp;&amp;hash） 两种方式对比，基于 Hash 的路由，兼容性更好；基于 History API 的路由，则更正式，可以设置与当前 URL 同源的任意 URL，路径更直观。另外，基于 Hash 的路由不需要对服务器做改动，基于 History API 的路由需要对服务器做一些改造，配置不同的路由都返回相同的页面。 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。当从http://example.com/跳转到http://example.com/#/foobar或者http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问http://example.com/#/foobar的时候，实际上向服务器发起的请求是http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar的时候，实际上向服务器发起的请求也是http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于 History API 的路由，需要改造服务器端，使得访问/foobar 的时候也能返回 index.html 文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。 Vue Routervue-router 基本的路由配置如下： 123456789101112131415161718192021222324import Router from 'vue-router'import Index from 'pages/index'import Error from 'pages/error'Vue.use(Router)export default new Router(&#123; mode: 'history', // 设置路由方式 routes: [ &#123; path: '/', name: 'index', component: Index &#125;, &#123; path: '*', name: '404', component: Error &#125; ]&#125;)// 在组件中使用router视图组件&lt;router-view&gt;&lt;/router-view&gt; 可以通过 vue-router 实例来配置路由规则列表，指定路径 path 与组件 component 的对应关系。 1.模式参数在 vue-router 中是通过 mode 这一参数控制路由的实现模式的： 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 创建 VueRouter 的实例对象时，mode 以构造函数参数的形式传入。从 VueRouter 类的定义入手。一般插件对外暴露的类都是定义在源码 src 根目录下的 index.js 文件中，打开该文件，可以看到 VueRouter 类的定义，摘录与 mode 参数有关的部分如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export default class VueRouter &#123; mode: string; // 传入的字符串参数，指示history类别 history: HashHistory | HTML5History | AbstractHistory; // 实际起作用的对象属性，必须是以上三个类的枚举 fallback: boolean; // 如浏览器不支持，'history'模式需回滚为'hash'模式 constructor(options: RouterOptions = &#123;&#125;) &#123; let mode = options.mode || \"hash\"; // 默认为'hash'模式 this.fallback = mode === \"history\" &amp;&amp; !supportsPushState; // 通过supportsPushState判断浏览器是否支持'history'模式 if (this.fallback) &#123; mode = \"hash\"; &#125; if (!inBrowser) &#123; mode = \"abstract\"; // 不在浏览器环境下运行需强制为'abstract'模式 &#125; this.mode = mode; // 根据mode确定history实际的类并实例化 switch (mode) &#123; case \"history\": this.history = new HTML5History(this, options.base); break; case \"hash\": this.history = new HashHistory(this, options.base, this.fallback); break; case \"abstract\": this.history = new AbstractHistory(this, options.base); break; default: if (process.env.NODE_ENV !== \"production\") &#123; assert(false, `invalid mode: $&#123;mode&#125;`); &#125; &#125; &#125; init(app: any /* Vue component instance */) &#123; const history = this.history; // 根据history的类别执行相应的初始化操作和监听 if (history instanceof HTML5History) &#123; history.transitionTo(history.getCurrentLocation()); &#125; else if (history instanceof HashHistory) &#123; const setupHashListener = () =&gt; &#123; history.setupListeners(); &#125;; history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ); &#125; history.listen(route =&gt; &#123; this.apps.forEach(app =&gt; &#123; app._route = route; &#125;); &#125;); &#125; // VueRouter类暴露的以下方法实际是调用具体history对象的方法 push(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.push(location, onComplete, onAbort); &#125; replace(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.replace(location, onComplete, onAbort); &#125;&#125; 可以看出： 作为参数传入的字符串属性 mode 只是一个标记，用来指示实际起作用的对象属性 history 的实现类，两者对应关系如下： modehistory： ‘history’——HTML5History ‘hash’——HashHistory ‘abstract’——AbstractHistory 在初始化对应的 history 之前，会对 mode 做一些校验：若浏览器不支持 HTML5History 方式（通过 supportsPushState 变量判断），则 mode 强制设为’hash’；若不是在浏览器环境下运行，则 mode 强制设为’abstract’ VueRouter 类中的 onReady(), push()等方法只是一个代理，实际是调用的具体 history 对象的对应方法，在 init()方法中初始化时，也是根据 history 对象具体的类别执行不同操作 在浏览器环境下的两种方式，分别就是在 HTML5History，HashHistory 两个类中实现的。他们都定义在 src/history 文件夹下，继承自同目录下 base.js 文件中定义的 History 类。History 中定义的是公用和基础的方法，直接看会一头雾水，我们先从 HTML5History，HashHistory 两个类中看着亲切的 push(), replace()方法的说起。 2.HashHistory看源码前先回顾一下原理： hash（“#”）符号的本来作用是加在 URL 中指示网页中的位置： http://www.example.com/index.html#print #符号本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取。它具有如下特点： hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面 可以为 hash 的改变添加监听事件： 1window.addEventListener(\"hashchange\", funcRef, false); 每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录 利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了。 HashHistory.push()我们来看 HashHistory 中的 push()方法： 12345678910push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; pushHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;function pushHash (path) &#123; window.location.hash = path&#125; transitionTo()方法是父类中定义的是用来处理路由变化中的基础逻辑的，push()方法最主要的是对 window 的 hash 进行了直接赋值： 1window.location.hash = route.fullPath; hash 的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，我们来看父类 History 中 transitionTo()方法的这么一段： 123456789101112131415transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const route = this.router.match(location, this.current) this.confirmTransition(route, () =&gt; &#123; this.updateRoute(route) ... &#125;)&#125;updateRoute (route: Route) &#123; this.cb &amp;&amp; this.cb(route)&#125;listen (cb: Function) &#123; this.cb = cb&#125; 可以看到，当路由变化时，调用了 History 中的 this.cb 方法，而 this.cb 方法是通过 History.listen(cb)进行设置的。回到 VueRouter 类定义中，找到了在 init()方法中对其进行了设置： 12345678910init (app: any /* Vue component instance */) &#123; this.apps.push(app) history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; app._route = route &#125;) &#125;)&#125; 根据注释，app 为 Vue 组件实例，但我们知道 Vue 作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性_route，如果组件中要有这个属性，应该是在插件加载的地方，即 VueRouter 的 install()方法中混合入 Vue 对象的，查看 install.js 源码，有如下一段： 123456789101112export function install(Vue) &#123; Vue.mixin(&#123; beforeCreate() &#123; if (isDef(this.$options.router)) &#123; this._router = this.$options.router; this._router.init(this); Vue.util.defineReactive(this, \"_route\", this._router.history.current); &#125; registerInstance(this, this); &#125; &#125;);&#125; 通过 Vue.mixin()方法，全局注册一个混合，影响注册之后所有创建的每个 Vue 实例，该混合在 beforeCreate 钩子中通过 Vue.util.defineReactive()定义了响应式的_route 属性。所谓响应式属性，即当_route 值改变时，会自动调用 Vue 实例的 render()方法，更新视图。 总结一下，从设置路由改变到视图更新的流程如下：1$router.push() --&gt; HashHistory.push() --&gt; History.transitionTo() --&gt; History.updateRoute() --&gt; &#123;app._route = route&#125; --&gt; vm.render() HashHistory.replace()replace()方法与 push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由： 12345678910111213replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; replaceHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;function replaceHash (path) &#123; const i = window.location.href.indexOf('#') window.location.replace( window.location.href.slice(0, i &gt;= 0 ? i : 0) + '#' + path )&#125; 可以看出，它与 push()的实现结构上基本相似，不同点在于它不是直接对 window.location.hash 进行赋值，而是调用 window.location.replace 方法将路由进行替换。 监听地址栏以上讨论的 VueRouter.push()和 VueRouter.replace()是可以在 vue 组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此 VueRouter 还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在 HashHistory 中这一功能通过 setupListeners 实现： 12345678910setupListeners () &#123; window.addEventListener('hashchange', () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; this.transitionTo(getHash(), route =&gt; &#123; replaceHash(route.fullPath) &#125;) &#125;)&#125; 该方法设置监听了浏览器事件 hashchange，调用的函数为 replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了 replace()方法 3.HTML5HistoryHistory interface 是浏览器历史记录栈提供的接口，通过 back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。 从 HTML5 开始，History interface 提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改：12window.history.pushState(stateObject, title, URL);window.history.replaceState(stateObject, title, URL); stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本 title: 所添加记录的标题 URL: 所添加记录的 URL 这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会立即发送请求该 URL（the browser won’t attempt to load this URL after a call to pushState()），这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。 我们来看 vue-router 中的源码： 123456789101112131415161718192021222324252627282930313233343536373839push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; pushState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; replaceState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;// src/util/push-state.jsexport function pushState (url?: string, replace?: boolean) &#123; saveScrollPosition() // try...catch the pushState call to get around Safari // DOM Exception 18 where it limits to 100 pushState calls const history = window.history try &#123; if (replace) &#123; history.replaceState(&#123; key: _key &#125;, '', url) &#125; else &#123; _key = genKey() history.pushState(&#123; key: _key &#125;, '', url) &#125; &#125; catch (e) &#123; window.location[replace ? 'replace' : 'assign'](url) &#125;&#125;export function replaceState (url?: string) &#123; pushState(url, true)&#125; 代码结构以及更新视图的逻辑与 hash 模式基本类似，只不过将对 window.location.hash 直接进行赋值 window.location.replace()改为了调用 history.pushState()和 history.replaceState()方法。 在 HTML5History 中添加对修改浏览器地址栏 URL 的监听是直接在构造函数中执行的：1234567891011constructor (router: Router, base: ?string) &#123; window.addEventListener('popstate', e =&gt; &#123; const current = this.current this.transitionTo(getLocation(this.base), route =&gt; &#123; if (expectScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;)&#125; 当然了 HTML5History 用到了 HTML5 的新特特性，是需要特定浏览器版本的支持的，前文已经知道，浏览器是否支持是通过变量 supportsPushState 来检查的： 1234567891011121314151617// src/util/push-state.jsexport const supportsPushState = inBrowser &amp;&amp; (function() &#123; const ua = window.navigator.userAgent; if ( (ua.indexOf(\"Android 2.\") !== -1 || ua.indexOf(\"Android 4.0\") !== -1) &amp;&amp; ua.indexOf(\"Mobile Safari\") !== -1 &amp;&amp; ua.indexOf(\"Chrome\") === -1 &amp;&amp; ua.indexOf(\"Windows Phone\") === -1 ) &#123; return false; &#125; return window.history &amp;&amp; \"pushState\" in window.history; &#125;)(); 这两种模式都是通过浏览器接口实现的，除此之外 vue-router 还为非浏览器环境准备了一个 abstract 模式，其原理为用一个数组 stack 模拟出浏览器历史记录栈的功能。 4.vue 中两种模式比较在一般的需求场景中，hash 模式与 history 模式是差不多的，但几乎所有的文章都推荐使用 history 模式，理由竟然是：”#” 符号太丑…0_0 “ 如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档 当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据 MDN 的介绍，调用 history.pushState()相比于直接修改 hash 主要有以下优势： pushState 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL pushState 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中 pushState 通过 stateObject 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串 pushState 可额外设置 title 属性供后续使用 a 标签 hash 跳转，会改变页面路径的 hash 值，但不会重载 history 模式的一个问题 我们知道对于单页应用来讲，理想的使用场景是仅在进入应用时加载 index.html，后续在的网络操作通过 Ajax 完成，不会根据 URL 重新请求页面，但是难免遇到特殊情况，比如用户直接在地址栏中输入并回车，浏览器重启重新加载应用等。 hash 模式仅改变 hash 部分的内容，而 hash 部分是不会包含在 HTTP 请求中的： 1http://oursite.com/#/user/id // 如重新请求只会发送http://oursite.com/ 故在 hash 模式下遇到根据 URL 请求页面的情况不会有问题。 而 history 模式则会将 URL 修改得就和正常请求后端的 URL 一样 1http://oursite.com/user/id 在此情况下重新向后端发送请求，如后端没有配置对应/user/id 的路由处理，则会返回 404 错误。官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。 5.AbstractHistory‘abstract’模式，不涉及和浏览器地址的相关记录，流程跟’HashHistory’是一样的，其原理是通过数组模拟浏览器历史记录栈的功能 12345678910111213141516171819// 对于 go 的模拟 go (n: number) &#123; // 新的历史记录位置 const targetIndex = this.index + n // 超出返回了 if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) &#123; return &#125; // 取得新的 route 对象 // 因为是和浏览器无关的 这里得到的一定是已经访问过的 const route = this.stack[targetIndex] // 所以这里直接调用 confirmTransition 了 // 而不是调用 transitionTo 还要走一遍 match 逻辑 this.confirmTransition(route, () =&gt; &#123; // 更新 this.index = targetIndex this.updateRoute(route) &#125;) &#125; 6.直接加载应用文件 Tip: built files are meant to be served over an HTTP server. Opening index.html over file:// won’t work. Vue 项目通过 vue-cli 的 webpack 打包完成后，命令行会有这么一段提示。通常情况，无论是开发还是线上，前端项目都是通过服务器访问，不存在 “Opening index.html over file://“ ，但程序员都知道，需求和场景永远是千奇百怪的，只有你想不到的，没有产品经理想不到的。 本文写作的初衷就是遇到了这样一个问题：需要快速开发一个移动端的展示项目，决定采用 WebView 加载 Vue 单页应用的形式，但没有后端服务器提供，所以所有资源需从本地文件系统加载： 123456789101112131415161718192021222324// AndroidAppWrapperpublic class MainActivity extends AppCompatActivity &#123; private WebView webView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); webView = new WebView(this); webView.getSettings().setJavaScriptEnabled(true); webView.loadUrl(\"file:///android_asset/index.html\"); setContentView(webView); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; webView.canGoBack()) &#123; webView.goBack(); return true; &#125; return false; &#125;&#125; 此情此景看来是必须 “Opening index.html over file://“ 了，为此，我首先要进行了一些设置 在项目 config.js 文件中将 assetsPublicPath 字段的值改为相对路径 ‘./‘ 调整生成的 static 文件夹中图片等静态资源的位置与代码中的引用地址一致 这是比较明显的需要改动之处，但改完后依旧无法顺利加载，经过反复排查发现，项目在开发时，router 设置为了 history 模式（为了美观…0_0”），当改为 hash 模式后就可正常加载了。 为什么会出现这种情况呢？我分析原因可能如下： 当从文件系统中直接加载 index.html 时，URL 为： 1file:///android_asset/index.html 而首页视图需匹配的路径为 path: ‘/‘ : 12345678910export default new Router(&#123; mode: \"history\", routes: [ &#123; path: \"/\", name: \"index\", component: IndexView &#125; ]&#125;); 我们先来看 history 模式，在 HTML5History 中： 1234567891011121314ensureURL (push?: boolean) &#123; if (getLocation(this.base) !== this.current.fullPath) &#123; const current = cleanPath(this.base + this.current.fullPath) push ? pushState(current) : replaceState(current) &#125;&#125;export function getLocation (base: string): string &#123; let path = window.location.pathname if (base &amp;&amp; path.indexOf(base) === 0) &#123; path = path.slice(base.length) &#125; return (path || '/') + window.location.search + window.location.hash&#125; 逻辑只会确保存在 URL，path 是通过剪切的方式直接从 window.location.pathname 获取到的，它的结尾是 index.html，因此匹配不到 ‘/‘ ，故 “Opening index.html over file:// won’t work” 。 再看 hash 模式，在 HashHistory 中： 123456789101112131415161718192021222324252627282930313233343536export class HashHistory extends History &#123; constructor (router: Router, base: ?string, fallback: boolean) &#123; ... ensureSlash() &#125; // this is delayed until the app mounts // to avoid the hashchange listener being fired too early setupListeners () &#123; window.addEventListener('hashchange', () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; ... &#125;) &#125; getCurrentLocation () &#123; return getHash() &#125;&#125;function ensureSlash (): boolean &#123; const path = getHash() if (path.charAt(0) === '/') &#123; return true &#125; replaceHash('/' + path) return false&#125;export function getHash (): string &#123; const href = window.location.href const index = href.indexOf('#') return index === -1 ? '' : href.slice(index + 1)&#125; 我们看到在代码逻辑中，多次出现一个函数 ensureSlash()，当#符号后紧跟着的是’/‘，则返回 true，否则强行插入这个’/‘，故我们可以看到，即使是从文件系统打开 index.html，URL 依旧会变为以下形式： 1file:///C:/Users/dist/index.html#/ getHash()方法返回的 path 为 ‘/‘ ，可与首页视图的路由匹配。 故要想从文件系统直接加载 Vue 单页应用而不借助后端服务器，除了打包后的一些路径设置外，还需确保 vue-router 使用的是 hash 模式。 React Routerreact-router 是基于 history 模块提供的 api 进行开发的。其路由配置是通过 react component 方式进行的，路由更改触发的回调函数是我们自己写的操作 DOM 的函数；在 react 中我们不直接操作 DOM，而是管理抽象出来的 VDOM 或者说 JSX，对 react 的来说路由需要管理组件的生命周期，对不同的路由渲染不同的组件。 如下： 1234567891011121314render(( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;users&quot; component=&#123;Users&#125;&gt; &lt;Route path=&quot;/user/:userId&quot; component=&#123;User&#125;/&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; component=&#123;NoMatch&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body)// link 触发路由&lt;Link to=&#123;`/user/89757`&#125;&gt;&apos;joey&apos;&lt;/Link&gt; 以上声明了一份含有 path to component 的各个映射的路由表。Router 在 react 组件生命周期的钩子 componentWillMount （组件被挂载前）中，使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 会去 render 新的 component。 1.historyhistory 库，是 rr4 依赖的一个对 window.history 加强版的 history 库。 match源自 history 库，表示当前的 URL 与 path 的匹配的结果 123456match: &#123; path: &quot;/&quot;, // 用来匹配的 path url: &quot;/&quot;, // 当前的 URL params: &#123;&#125;, // 路径中的参数 isExact: pathname === &quot;/&quot; // 是否为严格匹配&#125; location还是源自 history 库，是 history 库基于 window.location 的一个衍生。 12345hash: &quot;&quot; // hashkey: &quot;nyi4ea&quot; // 一个 uuidpathname: &quot;/explore&quot; // URL 中路径部分search: &quot;&quot; // URL 参数state: undefined // 路由跳转时传递的 state 我们带着问题去分析源码，先逐个分析每个组件的作用，在最后会有回答，在这里先举一个 rr4 的小 DEMO 页面初始化时的渲染过程？ 点击一个 Link 跳转及渲染更新的过程？ 2.packagesrr4 将路由拆成了几个包： react-router 负责通用的路由逻辑 react-router-dom 负责浏览器的路由管理 react-router-native 负责 react-native 的路由管理 通用的部分直接从 react-router 中导入，用户只需引入 react-router-dom 或 react-router-native 即可，react-router 作为依赖存在不再需要单独引入。 Router123456789101112import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;import App from &apos;./components/App&apos;;render()&#123; return( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; ))&#125; 这是我们调用 Router 的方式，这里拿 BrowserRouter 来举例。 BrowserRouter 的源码在 react-router-dom 中，它是一个高阶组件，在内部创建一个全局的 history 对象（可以监听整个路由的变化），并将 history 作为 props 传递给 react-router 的 Router 组件（Router 组件再会将这个 history 的属性作为 context 传递给子组件） 123render() &#123; return &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125; /&gt;;&#125; 整个 Router 的核心是在 react-router 的 Router 组件中，如下，借助 context 向 Route 传递组件，这也解释了为什么 Router 要在所有 Route 的外面。 123456789101112getChildContext() &#123; return &#123; router: &#123; ...this.context.router, history: this.props.history, route: &#123; location: this.props.history.location, match: this.state.match &#125; &#125; &#125;;&#125; 这是 Router 传递给子组件的 context，事实上 Route 也会将 router 作为 context 向下传递，如果我们在 Route 渲染的组件中加入 1234567static contextTypes = &#123; router: PropTypes.shape(&#123; history: PropTypes.object.isRequired, route: PropTypes.object.isRequired, staticContext: PropTypes.object &#125;)&#125;; 来通过 context 访问 router，不过 rr4 一般通过 props 传递，将 history, location, match 作为三个独立的 props 传递给要渲染的组件，这样访问起来方便一点（实际上已经完全将 router 对象的属性完全传递了）。 在 Router 的 componentWillMount 中， 添加了 1234567891011121314151617componentWillMount() &#123; const &#123; children, history &#125; = this.props; invariant( children == null || React.Children.count(children) === 1, &quot;A &lt;Router&gt; may have only one child element&quot; ); // Do this here so we can setState when a &lt;Redirect&gt; changes the // location in componentWillMount. This happens e.g. when doing // server rendering using a &lt;sStaticRouter&gt;. this.unlisten = history.listen(() =&gt; &#123; this.setState(&#123; match: this.computeMatch(history.location.pathname) &#125;); &#125;);&#125; history.listen 能够监听路由的变化并执行回调事件。 在这里每次路由的变化执行的回调事件为 123this.setState(&#123; match: this.computeMatch(history.location.pathname)&#125;); 相比于在 setState 里做的操作，setState 本身的意义更大 —— 每次路由变化 -&gt; 触发顶层 Router 的回调事件 -&gt; Router 进行 setState -&gt; 向下传递 nextContext（context 中含有最新的 location）-&gt; 下面的 Route 获取新的 nextContext 判断是否进行渲染。 之所以把这个 subscribe 的函数写在 componentWillMount 里，就像源码中给出的注释：是为了 SSR 的时候，能够使用 Redirect。 RouteRoute 的作用是匹配路由，并传递给要渲染的组件 props。 在 Route 的 componentWillReceiveProps 中 123456componentWillReceiveProps(nextProps, nextContext) &#123; ... this.setState(&#123; match: this.computeMatch(nextProps, nextContext.router) &#125;);&#125; Route 接受上层的 Router 传入的 context，Router 中的 history 监听着整个页面的路由变化，当页面发生跳转时，history 触发监听事件，Router 向下传递 nextContext，就会更新 Route 的 props 和 context 来判断当前 Route 的 path 是否匹配 location，如果匹配则渲染，否则不渲染。 是否匹配的依据就是 computeMatch 这个函数，在下文会有分析，这里只需要知道匹配失败则 match 为 null，如果匹配成功则将 match 的结果作为 props 的一部分，在 render 中传递给传进来的要渲染的组件。 接下来看一下 Route 的 render 部分。 123456789101112131415161718render() &#123; const &#123; match &#125; = this.state; // 布尔值，表示 location 是否匹配当前 Route 的 path const &#123; children, component, render &#125; = this.props; // Route 提供的三种可选的渲染方式 const &#123; history, route, staticContext &#125; = this.context.router; // Router 传入的 context const location = this.props.location || route.location; const props = &#123; match, location, history, staticContext &#125;; if (component) return match ? React.createElement(component, props) : null; // Component 创建 if (render) return match ? render(props) : null; // render 创建 if (typeof children === &quot;function&quot;) return children(props); // 回调 children 创建 if (children &amp;&amp; !isEmptyChildren(children)) // 普通 children 创建 return React.Children.only(children); return null;&#125; rr4 提供了三种渲染组件的方法：component props，render props 和 children props，渲染的优先级也是依次按照顺序，如果前面的已经渲染后了，将会直接 return。 component (props) —— 由于使用 React.createElement 创建，所以可以传入一个 class component。 render (props) —— 直接调用 render() 展开子元素，所以需要传入 stateless function component。 children (props) —— 其实和 render 差不多，区别是不判断 match，总是会被渲染。 children（子元素）—— 如果以上都没有，那么会默认渲染子元素，但是只能有一个子元素。 这里解释一下官网的 tips，component 是使用 React.createElement 来创建新的元素，所以如果传入一个内联函数，比如 1&lt;Route path=&apos;/&apos; component=&#123;()=&gt;(&lt;div&gt;hello world&lt;/div&gt;)&#125; 的话，由于每次的 props.component 都是新创建的，所以 React 在 diff 的时候会认为进来了一个全新的组件，所以会将旧的组件 unmount，再 re-mount。这时候就要使用 render，少了一层包裹的 component 元素，render 展开后的元素类型每次都是一样的，就不会发生 re-mount 了（children 也不会发生 re-mount）。 Switch我们紧接着 Route 来看 Switch，Switch 是用来嵌套在 Route 的外面，当 Switch 中的第一个 Route 匹配之后就不会再渲染其他的 Route 了。 123456789101112131415161718192021222324252627282930render() &#123; const &#123; route &#125; = this.context.router; const &#123; children &#125; = this.props; const location = this.props.location || route.location; let match, child; React.Children.forEach(children, element =&gt; &#123; if (match == null &amp;&amp; React.isValidElement(element)) &#123; const &#123; path: pathProp, exact, strict, sensitive, from &#125; = element.props; const path = pathProp || from; child = element; match = matchPath( location.pathname, &#123; path, exact, strict, sensitive &#125;, route.match ); &#125; &#125;); return match ? React.cloneElement(child, &#123; location, computedMatch: match &#125;) : null;&#125; Switch 也是通过 matchPath 这个函数来判断是否匹配成功，一直按照 Switch 中 children 的顺序依次遍历子元素，如果匹配失败则 match 为 null，如果匹配成功则标记这个子元素和它对应的 location、computedMatch。在最后的时候使用 React.cloneElement 渲染，如果没有匹配到的子元素则返回 null。 接下来我们看下 matchPath 是如何判断 location 是否符合 path 的。 matchPathmatchPath 返回的是一个如下结构的对象 123456789101112&#123; path, // 用来进行匹配的路径，其实是直接导出的传入 matchPath 的 options 中的 path url: path === &quot;/&quot; &amp;&amp; url === &quot;&quot; ? &quot;/&quot; : url, // 整个的 URL isExact, // url 与 path 是否是 exact 的匹配 // 返回的是一个键值对的映射 // 比如你的 path 是 /users/:id，然后匹配的 pathname 是 /user/123 // 那么 params 的返回值就是 &#123;id: &apos;123&apos;&#125; params: keys.reduce((memo, key, index) =&gt; &#123; memo[key.name] = values[index]; return memo; &#125;, &#123;&#125;) &#125; 这些信息将作为匹配的参数传递给 Route 和 Switch（Switch 只是一个代理，它的作用还是渲染 Route，Switch 计算得到的 computedMatch 会传递给要渲染的 Route，此时 Route 将直接使用这个 computedMatch 而不需要再自己来计算）。 在 matchPath 内部 compilePath 时，有个 123const patternCache = &#123;&#125;;const cacheLimit = 10000;let cacheCount = 0; 作为 pathToRegexp 的缓存，因为 ES6 的 import 模块导出的是值的引用，所以将 patternCache 可以理解为一个全局变量缓存，缓存以 {option:{pattern: }} 的形式存储，之后如果需要匹配相同 pattern 和 option 的 path，则可以直接从缓存中获得正则表达式和 keys。 加缓存的原因是路由页面大部分情况下都是相似的，比如要访问 /user/123 或 /users/234，都会使用 /user/:id 这个 path 去匹配，没有必要每次都生成一个新的正则表达式。SPA 在页面整个访问的过程中都维护着这份缓存。 Link实际上我们可能写的最多的就是 Link 这个标签了，我们从它的 render 函数开始看 12345678910111213141516171819202122render() &#123; const &#123; replace, to, innerRef, ...props &#125; = this.props; // eslint-disable-line no-unused-vars invariant( this.context.router, &quot;You should not use &lt;Link&gt; outside a &lt;Router&gt;&quot; ); invariant(to !== undefined, &apos;You must specify the &quot;to&quot; property&apos;); const &#123; history &#125; = this.context.router; const location = typeof to === &quot;string&quot; ? createLocation(to, null, null, history.location) : to; const href = history.createHref(location); // 最终创建的是一个 a 标签 return ( &lt;a &#123;...props&#125; onClick=&#123;this.handleClick&#125; href=&#123;href&#125; ref=&#123;innerRef&#125; /&gt; ); &#125; 可以看到Link 最终还是创建一个 a 标签来包裹住要跳转的元素，但是如果只是一个普通的带 href 的 a 标签，那么就会直接跳转到一个新的页面而不是 SPA 了，所以在这个 a 标签的 handleClick 中会 preventDefault 禁止默认的跳转，所以这里的 href 并没有实际的作用，但仍然可以标示出要跳转到的页面的 URL 并且有更好的 html 语义。 在 handleClick 中，对没有被 “preventDefault 的 &amp;&amp; 鼠标左键点击的 &amp;&amp; 非 _blank 跳转 的&amp;&amp; 没有按住其他功能键的“ 单击进行 preventDefault，然后 push 进 history 中，这也是前面讲过的 —— 路由的变化 与 页面的跳转 是不互相关联的，rr4 在 Link 中通过 history 库的 push 调用了 HTML5 history 的 pushState，但是这仅仅会让路由变化，其他什么都没有改变。还记不记得 Router 中的 listen，它会监听路由的变化，然后通过 context 更新 props 和 nextContext 让下层的 Route 去重新匹配，完成需要渲染部分的更新。 123456789101112131415161718192021handleClick = event =&gt; &#123; if (this.props.onClick) this.props.onClick(event); if ( !event.defaultPrevented &amp;&amp; // onClick prevented default event.button === 0 &amp;&amp; // ignore everything but left clicks !this.props.target &amp;&amp; // let browser handle &quot;target=_blank&quot; etc. !isModifiedEvent(event) // ignore clicks with modifier keys ) &#123; event.preventDefault(); const &#123; history &#125; = this.context.router; const &#123; replace, to &#125; = this.props; if (replace) &#123; history.replace(to); &#125; else &#123; history.push(to); &#125; &#125;&#125;; withRouter1234567891011121314151617181920212223242526const withRouter = Component =&gt; &#123; const C = props =&gt; &#123; const &#123; wrappedComponentRef, ...remainingProps &#125; = props; return ( &lt;Route children=&#123;routeComponentProps =&gt; ( &lt;Component &#123;...remainingProps&#125; &#123;...routeComponentProps&#125; ref=&#123;wrappedComponentRef&#125; /&gt; )&#125; /&gt; ); &#125;; C.displayName = `withRouter($&#123;Component.displayName || Component.name&#125;)`; C.WrappedComponent = Component; C.propTypes = &#123; wrappedComponentRef: PropTypes.func &#125;; return hoistStatics(C, Component);&#125;;export default withRouter; withRouter 的作用是让我们在普通的非直接嵌套在 Route 中的组件也能获得路由的信息，这时候我们就要 WithRouter(wrappedComponent) 来创建一个 HOC 传递 props，WithRouter 的其实就是用 Route 包裹了 SomeComponent 的一个 HOC。 创建 Route 有三种方法，这里直接采用了传递 children props 的方法，因为这个 HOC 要原封不动的渲染 wrappedComponent（children props 比较少用得到，某种程度上是一个内部方法）。 在最后返回 HOC 时，使用了 hoistStatics 这个方法，这个方法的作用是保留 SomeComponent 类的静态方法，因为 HOC 是在 wrappedComponent 的外层又包了一层 Route，所以要将 wrappedComponent 类的静态方法转移给新的 Route，具体参见 Static Methods Must Be Copied Over。 3.理解现在回到一开始的问题，重新理解一下点击一个 Link 跳转的过程。 有两件事需要完成： 路由的改变 页面的渲染部分的改变 过程如下： 在最一开始 mount Router 的时候，Router 在 componentWillMount 中 listen 了一个回调函数，由 history 库管理，路由每次改变的时候触发这个回调函数。这个回调函数会触发 setState。 当点击 Link 标签的时候，实际上点击的是页面上渲染出来的 a 标签，然后通过 preventDefault 阻止 a 标签的页面跳转。 Link 中也能拿到 Router -&gt; Route 中通过 context 传递的 history，执行 hitsory.push(to)，这个函数实际上就是包装了一下 window.history.pushState()，是 HTML5 history 的 API，但是 pushState 之后除了地址栏有变化其他没有任何影响，到这一步已经完成了目标 1：路由的改变。 第 1 步中，路由改变是会触发 Router 的 setState 的，在 Router 那章有写道：每次路由变化 -&gt; 触发顶层 Router 的监听事件 -&gt; Router 触发 setState -&gt; 向下传递新的 nextContext（nextContext 中含有最新的 location） 下层的 Route 拿到新的 nextContext 通过 matchPath 函数来判断 path 是否与 location 匹配，如果匹配则渲染，不匹配则不渲染，完成目标 2：页面的渲染部分的改变。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"leetcode算法刷题笔记（二）——回溯问题","slug":"leetcode算法刷题笔记（二）——回溯问题","date":"2019-01-15T14:07:43.000Z","updated":"2019-04-07T08:27:27.810Z","comments":true,"path":"2019/01/15/leetcode算法刷题笔记（二）——回溯问题/","link":"","permalink":"http://yoursite.com/2019/01/15/leetcode算法刷题笔记（二）——回溯问题/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯 123456789101112131415161718192021222324252627282930313233var letterCombinations = function(digits) &#123; var res = []; var sort = []; if (digits.length == 0) &#123; return res; &#125; var phone = [ \"0\", \"1\", [\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"], [\"j\", \"k\", \"l\"], [\"m\", \"n\", \"o\"], [\"p\", \"q\", \"r\", \"s\"], [\"t\", \"u\", \"v\"], [\"w\", \"x\", \"y\", \"z\"] ]; finger(0); return res; function finger(index) &#123; if (index == digits.length) &#123; return res.push(sort.join(\"\")); &#125; var temp = phone[digits[index]]; for (var i = 0; i &lt; temp.length; i++) &#123; sort.push(temp[i]); finger(index + 1); sort.pop(); &#125; &#125;&#125;; [22] Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.难度：Medium (53.42%)考点：回溯思路： 给定 n 值，则总共有 n 个左括号，n 个右括号。 第一个添加的一定是左括号。 当添加了一个左括号之后，才会有一个右括号可以添加。所以回溯时，left-1 的同时 right+1 当已添加了 n 个左括号后，剩下的都应该添加右括号 123456789101112131415161718192021var generateParenthesis = function(n) &#123; var res = []; var left = n - 1; var right = 1; function quote(left, right, str) &#123; if (left &lt;= 0) &#123; if (right) &#123; for (var i = 0; i &lt; right; i++) &#123; str = str + \")\"; &#125; &#125; return res.push(str); &#125; quote(left - 1, right + 1, str + \"(\"); if (right &gt; 0) &#123; quote(left, right - 1, str + \")\"); &#125; &#125; quote(left, right, \"(\"); return res;&#125;; [46] PermutationsGiven a collection of distinct integers, return all possible permutations.难度：Medium (53.67%)考点：回溯思路：选择一个元素之后，则下次可选择的元素就少一个。 12345678910111213141516171819202122var permute = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [47] Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations.难度：Medium (39.35%)考点：回溯思路：思路同上题。注意筛选条件。 12345678910111213141516171819202122232425262728var permuteUnique = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; &#123; return a - b; &#125;); select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i - 1]) &#123; continue; &#125; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [60] Permutations II ☆☆The set [1,2,3,…,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:“123”“132”“213”“231”“312”“321”Given n and k, return the k^th permutation sequence.Note:Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.难度：Medium (32.42%)考点：回溯 123456789101112131415161718192021var getPermutation = function(n, k) &#123; (res = []), (pos = k - 1); var nums = []; if (n == 0) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; var numsSort = nums.reduce((a, b) =&gt; a * b); if (k &lt; 1 || k &gt; numsSort) &#123; return \"error\"; &#125; for (var j = n; j &gt;= 1; --j) &#123; numsSort /= j; res.push(nums.splice(parseInt(pos / numsSort), 1)[0]); pos %= numsSort; &#125; return res.join(\"\");&#125;; [77] ombinations ☆☆Given two integers n and k, return all possible combinations of k numbers out of 1 … n.难度：Medium (46.23%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件 12345678910111213141516171819202122232425262728var combine = function(n, k) &#123; var nums = []; var res = []; var temp = []; if (n == 0 || k &lt;= 0 || k &gt; n) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; select(0, nums); return res; function select(start, nums) &#123; if (temp.length == k) &#123; return res.push(temp.slice()); &#125; for (var i = start; i &lt; n; i++) &#123; if (temp.length &gt;= 1 &amp;&amp; temp[temp.length - 1] &gt; i) &#123; continue; &#125; temp.push(nums[i]); select(start + 1, nums); temp.pop(); &#125; &#125;&#125;; [78] SubsetsGiven a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (51.26%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件。 123456789101112131415161718192021222324252627282930313233var subsets = function(nums) &#123; var res = []; var subsets = []; var used = []; res.push(subsets.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var j = 1; j &lt;= nums.length; j++) &#123; findSubsets(0, j); &#125; return res; function findSubsets(start, k) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (subsets.length == k) &#123; return res.push(subsets.slice()); &#125; if (used[i]) &#123; continue; &#125; if (start &gt; 0 &amp;&amp; nums[i] &lt; subsets[subsets.length - 1]) &#123; continue; &#125; subsets.push(nums[i]); used[i] = true; findSubsets(start + 1, k); subsets.pop(); used[i] = false; &#125; &#125;&#125;; [79] Word SearchGiven a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.难度：Medium (30.52%)考点：回溯思路：要分四个方向分别回溯。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var exist = function(board, word) &#123; var row = board.length; var col = board[0].length; if (word.length &gt; row * col) &#123; return false; &#125; function search(i, j, n) &#123; if ( i &gt;= row || j &gt;= col || i &lt; 0 || j &lt; 0 || board[i][j] != word[n] || n &gt; word.length ) &#123; return false; &#125; if (n == word.length - 1) &#123; return true; &#125; board[i][j] = true; if (search(i + 1, j, n + 1)) &#123; return true; &#125; if (search(i - 1, j, n + 1)) &#123; return true; &#125; if (search(i, j + 1, n + 1)) &#123; return true; &#125; if (search(i, j - 1, n + 1)) &#123; return true; &#125; board[i][j] = word[n]; return false; &#125; for (var i = 0; i &lt; row; i++) &#123; for (var j = 0; j &lt; col; j++) &#123; if (search(i, j, 0)) &#123; return true; &#125; &#125; &#125; return false;&#125;; [89] Gray Code ☆☆The gray code is a binary numeral system where two successive values differ in only one bit.Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.难度：Medium (45.03%)考点：回溯思路：可根据格雷码的特性考虑解法一（普通解法）： 123456789101112131415161718192021222324252627282930var grayCode = function(n) &#123; var result = []; var graycodeFn = function(n) &#123; var graycode = []; if (n == 1) &#123; graycode[0] = \"0\"; graycode[1] = \"1\"; return graycode; &#125; var last = arguments.callee(n - 1); // arguments.callee(n-1) == graycodeFn(n-1) for (var i = last.length - 1; i &gt;= 0; --i) &#123; graycode.unshift(\"0\" + last[i]); graycode.push(\"1\" + last[i]); &#125; return graycode; &#125;; var graycode = n == 0 ? [\"0\"] : graycodeFn(n); for (var i = 0; i &lt; graycode.length; ++i) &#123; result.push(parseInt(parseInt(graycode[i], 2), 10)); // String To Number &#125; return result;&#125;; 解法二（大神解法）： 1234567var grayCode = function(n) &#123; let nums = [0], c = -1; while (c++ &lt; n - 1) nums = [...nums, ...nums.map(num =&gt; num + Math.pow(2, c)).reverse()]; return nums;&#125;; [90] Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (41.57%)考点：回溯 12345678910111213141516171819202122232425262728var subsetsWithDup = function(nums) &#123; var sub = []; var res = []; res.push(sub.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var i = 1; i &lt;= nums.length; i++) &#123; findSub(0, i); &#125; return res; function findSub(start, k) &#123; if (sub.length == k) &#123; return res.push(sub.slice()); &#125; for (var j = start; j &lt; nums.length; j++) &#123; if (j &gt; start &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; sub.push(nums[j]); findSub(j + 1, k); sub.pop(); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"}]},{"title":"浏览器内核","slug":"浏览器内核","date":"2019-01-07T13:07:44.000Z","updated":"2019-08-15T10:31:21.482Z","comments":true,"path":"2019/01/07/浏览器内核/","link":"","permalink":"http://yoursite.com/2019/01/07/浏览器内核/","excerpt":"浏览器内核浏览器内核有哪几种？Trident：IE（Internet Explorer），由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大。 但是由于微软长时间没有更新 Trident 内核，则导致了两个后果：一是 Trident 内核曾经几乎与 W3C 标准脱节（2005 年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器。","text":"浏览器内核浏览器内核有哪几种？Trident：IE（Internet Explorer），由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大。 但是由于微软长时间没有更新 Trident 内核，则导致了两个后果：一是 Trident 内核曾经几乎与 W3C 标准脱节（2005 年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器。 Trident 内核常见浏览器（1）IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）； （2）猎豹安全浏览器：1.0-4.2 版本为 Trident+Webkit，4.3 版本为 Trident+Blink； （3）360 安全浏览器 ：1.0-5.0 为 Trident，6.0 为 Trident+Webkit，7.0 为 Trident+Blink； （4）360 极速浏览器：7.5 之前为 Trident+Webkit,7.5 为 Trident+Blink； （5）傲游浏览器 ：傲游 1.x、2.x 为 IE 内核，3.x 为 IE 与 Webkit 双核； （6）搜狗高速浏览器：1.x 为 Trident，2.0 及以后版本为 Trident+Webkit； 兼容模式国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 EdgeHTML 内核Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 Gecko ([‘gekəʊ])开源内核Gecko(Firefox 内核)：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。 Firefox 内核事实上，Gecko 引擎的由来跟 IE 不无关系，前面说过 IE 没有使用 W3C 的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape 的一些员工一起创办了 Mozilla，以当时的 Mosaic 内核为基础重新编写内核，于是开发出了 Gecko。不过事实上，Gecko 内核的浏览器仍然还是 Firefox (火狐) 用户最多，所以有时也会被称为 Firefox 内核。此外 Gecko 也是一个跨平台内核，可以在 Windows、 BSD、Linux 和 Mac OS X 中使用。 WebkitSafari 浏览器只要提到 Webkit，大多数人立马想到的必然是 Chrome，结果导致如今有了把 webkit 称为 chrome 内核的错误说法，即使 chrome 的内核已经是 blink，其实 Webkit 的祖先是 Safari，也就是苹果系列产品的专属浏览器。 WebKit 是 KHTML 的分支WebKit 的前身是苹果公司使用 KDE（Linux 桌面系统）开发的 KHTML 开源引擎，可以说 WebKit 是 KHTML 的一个开源分支。 Chromium/BlinkChromium Fork webkit2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。chromium fork 自开源引擎 webkit，并提高了 WebKit 的代码可读性和编译速度。 V8 引擎谷歌公司还研发了自己的 Javascript 引擎，V8，极大地提高了 Javascript 的运算速度。 Blink 是 WebKit 的分支Google 的 Chromium 项目最初一直使用 WebKit(WebCore) 作为渲染引擎，但由于后来苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发）。 Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入 Webkit。 后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。 基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。这样以来，唯一一条维系 Google 和苹果之间技术关系的纽带就这样被切断了。 Presto ([‘prestəʊ])Opera 浏览器Presto 是 Opera 自主研发的渲染引擎，然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎。 在 Chrome 于 2013 年推出 Blink 引擎之后，Opera 也紧跟其脚步表示将转而使用 Blink 作为浏览器核心引擎。 移动端移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。 1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。 2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android 4.4 系统浏览器切换到了 Chromium，内核是 Webkit 的分支 Blink。 3、Windows Phone 8 系统浏览器内核是 Trident。 webkit 内核了解多少？（chrome 内核是 b-link）深入剖析 webkit 微信 x5 内核和别的内核有什么差别？（x5 是基于 webkit 的）认识 X5 腾讯基于优秀开源 Webkit 深度优化的浏览器渲染引擎 为抹平不同 Android 版本不同 Webview 的坑而生。但本身也带来了许多坑。 虽然官方不承认，但实际上它是基于 Chromuim 开源项目的。 webkit 内核以及 blink 内核在 x5 的使用情况 QQ 浏览器：6.2 版本及以后使用 blink 内核。 X5 tbs 1.x：版本号为 02xxxx，使用 webkit 内核。 X5 tbs 2.x：版本号为 03xxxx。使用 blink 内核。 拓展：Webkit &amp; Chromuim &amp;Chrome &amp; Blink WebKit是一个开源的项目，其前身是来源于 KDE 的 KHTML 和 KJS。该项目专注于网页内容的展示，开发出一流的网页渲染引擎。 Chromium是一个建立在 WebKit 之上的浏览器开源项目，由 Google 发起的。 Chrome是 Google 公司的浏览器产品，它基于 chromium 开源项目。可以理解为，内核是开源的，UI 是闭源的。 Blink是 Google 退出 WebKit 项目，从而自己创建的渲染引擎。但并不是全新的引擎，Blink 目前就是从 WebKit 直接复制出一个版本出来，然后将与 chromium 无关的 Ports 全部移除掉，将代码结构重新整理，就目前而言，Blink 的渲染和 WebKit 是一样，但是，以后两者将各自走不同的路。 X5 升级了截至 16 年 4 月份，x5 升级全量发布。TBS2.0 基于 Android 5.0 WebView Blink 内核（M37 版本）适配定制优化，适配 Android 全部主流平台，可以在所有 Android 手机上使用 Blink 的技术能力。具有更好的 H5/CSS3 支持和性能。TBS2.0 已经发布，将逐步在各客户端中静默升级，无需更新微信、手机 QQ、QQ 空间即可使用最新的 TBS2.0 Blink 内核。 更简洁地说，即是： 基于 Blink 内核（chrome 37 版本） 适用于 Android 全部主流平台 静默升级 PS：iOS 版本的微信 Web View 一直是 WKWebView 内核，WKWebView 的版本依赖于 iOS 的系统版本。 TBS2.0 内核详情 BLINK 版本: 基于 Chrome 37 HTML 版本: HTML5.0 XHTML 版本: xHTML Basic 1.0 | xHTML1.1 SVG 版本: SVG1.2 WML 版本: Wml 1.0 CSS 版本: CSS3 Spdy 版本: 3.1 支持的 JavaScript 版本: Ecma5 Changelog 以及 解读1.内核从 Webkit 升级至 Blink，拥有更好的支持 那么哪里可以查阅兼容性呢？ X5 CanIUse 2.内核版本号升级到 362xx 版本。可以根据 UserAgent判断当前环境是否已升级到 TBS2.0 版本,包含（TBS/03xxxx）字段。 那么怎么查看自己微信里的 TBS 版本？ 用微信打开这个页面，检查 TBS 的版本号，0362xx 表示已更新。页面的代码只有两句，为： 123// 检测页面的核心代码var resultDiv = document.getElementById(\"result\");resultDiv.innerHTML = window.navigator.userAgent; 3.CSS3 属性支持增强： 完整支持 flex 伪元素支持动画效果 filter: blur 有模糊效果 PS：更多更具体的支持情况可查阅这里 4.autoplay 属性有效，可自动播放 5.canvas 支持设置背景色 6.标准的缓存策略，支持 Spdy 3.1 7.动画性能提升 8.更好的 inspector 支持 微信远程调试解决方案——微信 web 开发者工具 手机 QQ 浏览器的远程调试解决方案 参考资料： 解读微信全面升级 X5 Blink 内核，H5 游戏行业重大利好 官方网站：腾讯浏览服务－技术指南 总结常用工具 检测是否为 x5－TBS/03xxxx x5 的各项支持情况－X5 CanIUse Android 下微信远程调试工具-微信 web 开发者工具（PS:iOS 下使用 Safari 远程调试即可） 我们可以从中了解到什么一、工具方面： 可以通过查询 UA 来检测是否为 X5－TBS/03xxxx，在线检测地址 想知道某个 CSS3 属性，或者其他 API 在 X5 是否支持的时候，可以查询X5 CanIUse 远程调试微信内页面时，在 Android 下可以使用微信远程调试工具-微信 web 开发者工具，在 iOS 下使用 Safari 远程调试即可。 二、对于开发调试页面 目前，暂时还没有查找到 X5 在微信 android 客户端的版本分布情况的数据(可能是由于 X5 tbs2.0 是今年 4 月份初才开始全量发布的)。 虽然说，X5 是静默升级，无需用户手动更新，基本上都实现升级为最新版本(业界说法)，但仍存在 X5 内核是旧版本的情况(根据是部分测试的检测 UA 结果)。希望能够在后续的日子可以获取到相关的数据。 手机同时安装了 QQ 浏览器和微信，但 QQ 浏览器内核版本不等于微信内核版本，只有在 QQ 浏览器内核为大于等于 6.2 版本才是 Blink 内核，调试页面的结果才可以替代在微信内页面调试的结果（想要不登陆微信用 QQ 浏览器来替代调试的需要注意下 X5 的版本分布情况据腾讯内部的小伙伴告知，x5 内核基本覆盖理论上达到 100%，但难免会有漏网之鱼。而根据实际数据抽样整理显示，截至 2016 年 5 月 19 日，x5 内核基本覆盖率达到 91.47%。 X5 问题汇总","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"leetcode算法刷题笔记（一）——数组","slug":"leetcode算法刷题笔记（一）——数组","date":"2018-12-18T16:07:06.000Z","updated":"2019-03-22T06:57:31.402Z","comments":true,"path":"2018/12/19/leetcode算法刷题笔记（一）——数组/","link":"","permalink":"http://yoursite.com/2018/12/19/leetcode算法刷题笔记（一）——数组/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断 1234567891011var twoSum = function(nums, target) &#123; var map = &#123;&#125;; for (i = 0; i &lt; nums.length; i++) &#123; const complement = target - nums[i]; if (complement in map) &#123; return [i, map[complement]]; &#125; map[nums[i]] = i; &#125; return -1;&#125;; [11] Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2.难度：Medium (42.93%)考点：动态规划思路： 设定 i，j 分别指向数组的头和尾 比较 i，j 所对应的位置的值，值较小的那一个移动（i++或 j–） 123456789101112131415161718var maxArea = function(height) &#123; var maxArea = 0; var i = 0; var j = height.length - 1; while (i &lt; j) &#123; const long = Math.min(height[i], height[j]); const area = long * (j - i); if (area &gt; maxArea) &#123; maxArea = area; &#125; if (height[i] &lt; height[j]) &#123; i++; &#125; else &#123; j--; &#125; &#125; return maxArea;&#125;; [15] 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.难度：Medium (23.55%)思路： 数组排序（升序） 设定三个指针，最外层循环从 0 开始，到数组的尾结束（i=0） 第二层循环，一个指向上一个指针的下一个元素（j=i+1），另一个指向数组的尾部(k=nums.length-1) 如果三个元素之和等于 0，则 push 进要返回的数组中；如果三个元素之和大于 0，说明第三个指针指向的元素过大，则第三个指针向前移(k–);如果三个元素之和小于 0，说明第二个指针指向的元素过小，则第二个指针向后移(j++); 123456789101112131415161718192021222324252627282930313233343536var threeSum = function(nums) &#123; var rtn = []; if (nums.length &lt; 3) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; 0) &#123; return rtn; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === 0) &#123; rtn.push([nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; 0) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return rtn;&#125;; [16] 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.难度：Medium (41.40%)思路：与上题类似 12345678910111213141516171819202122232425262728var threeSumClosest = function(nums, target) &#123; var sum; if (nums.length &lt; 3) &#123; return sum; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); var sum = nums[0] + nums[1] + nums[2]; var distance = Math.abs(sum - target); for (var i = 0; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (Math.abs(nums[i] + nums[j] + nums[k] - target) &lt; distance) &#123; sum = nums[i] + nums[j] + nums[k]; distance = Math.abs(sum - target); &#125; if (nums[i] + nums[j] + nums[k] === target) &#123; break; &#125; if (nums[i] + nums[j] + nums[k] &gt; target) &#123; k--; &#125; else if (nums[i] + nums[j] + nums[k] &lt; target) &#123; j++; &#125; &#125; &#125; return sum;&#125;; [18] 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.难度：Medium (29.83%)思路：思路同 3Sum，多一层循环。注意跳过相同的数（最外两层的循环变量） 1234567891011121314151617181920212223242526272829303132333435363738var fourSum = function(nums, target) &#123; var rtn = []; if (nums.length &lt; 4) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var m = 0; m &lt; nums.length - 3; m++) &#123; var complement = target - nums[m]; for (var i = m + 1; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === complement) &#123; rtn.push([nums[m], nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; complement) &#123; k--; &#125; else &#123; j++; &#125; if (i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; ++i; &#125; &#125; if (m &lt; nums.length - 1 &amp;&amp; nums[m] == nums[m + 1]) &#123; ++m; &#125; &#125; &#125; return rtn;&#125;; [26] Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.难度：Easy (39.80%)思路：两个指针，一个指针负责寻找和后一个不相等的数，另一个指针负责一步步向后移去重。 1234567891011121314151617181920var removeDuplicates = function(nums) &#123; if (nums.length == 0) &#123; return 0; &#125; var i = 0; var j = 0; for (i = 0; i &lt; nums.length - 1; ) &#123; if (nums[i] === nums[i + 1]) &#123; i++; &#125; else &#123; if (i !== j) &#123; nums[j + 1] = nums[i + 1]; &#125; j++; i++; &#125; &#125; nums = nums.slice(0, j + 1); return nums.length;&#125;; [27] Remove ElementGiven an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length.难度：Easy (43.73%)思路：找到和 val 值相等的位置，将数组最后一个元素赋值过来（去掉这个 val，数组长度减一） 12345678910111213var removeElement = function(nums, val) &#123; var i = 0; var n = nums.length; for (i = 0; i &lt; n; ) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; n--; &#125; else &#123; i++; &#125; &#125; return n;&#125;; [31] Next PermutationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place and use only constant extra memory.Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1难度：Medium (30.09%)思路： 从后向前比较相邻的两个元素，直到前一个元素小于后一个元素，停止（i）。 若已经没有了前一个元素（i=0），则该序列为递减序列，没有 Next Permutation。按照题目要求，直接反转序列。 前一个元素（j=i-1）小于后一个元素（i），找到前一个元素（j）要交换的元素，从 i 的后一个元素开始往后查找，找到最后一个比“前一个元素（j）”大的元素（k），也就是再往后的元素，就比元素 j 小了。交换 j 和 k 元素。 从 i 开始，包括 i 到序列的尾部，反转。则得出的即是 Next Permutation 1234567891011121314151617181920212223var nextPermutation = function(nums) &#123; var i = nums.length - 1; while (nums[i] &lt;= nums[i - 1]) &#123; i--; &#125; if (i !== 0) &#123; var j = i - 1; var k = i + 1; while (nums[j] &lt; nums[k]) &#123; k++; &#125; var temp = nums[k - 1]; nums[k - 1] = nums[j]; nums[j] = temp; for (var m = i, n = nums.length - 1; m &lt; n; m++, n--) &#123; var temp = nums[n]; nums[n] = nums[m]; nums[m] = temp; &#125; &#125; else &#123; nums = nums.reverse(); &#125;&#125;; [33] Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.Your algorithm’s runtime complexity must be in the order of O(log n).难度：Medium (32.68%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627var search = function(nums, target) &#123; if (nums.length == 0) &#123; return -1; &#125; var start = 0; var end = nums.length - 1; while (start &lt;= end) &#123; var middle = parseInt((start + end) / 2); if (nums[middle] == target) &#123; return middle; &#125; if (nums[middle] &gt; nums[end]) &#123; if (target &gt;= nums[start] &amp;&amp; target &lt; nums[middle]) &#123; end = middle - 1; &#125; else &#123; start = middle + 1; &#125; &#125; else &#123; if (target &gt; nums[middle] &amp;&amp; target &lt;= nums[end]) &#123; start = middle + 1; &#125; else &#123; end = middle - 1; &#125; &#125; &#125; return -1;&#125;; [34] Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].难度：Medium (33.06%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627282930var searchRange = function(nums, target) &#123; if (nums.length == 0) &#123; return [-1, -1]; &#125; var startFind = 0; var endFind = nums.length - 1; var start; var end; while (startFind &lt;= endFind) &#123; var mid = parseInt((startFind + endFind) / 2); if (nums[mid] == target) &#123; start = mid; end = mid; while (nums[start - 1] == target || nums[end + 1] == target) &#123; if (nums[start - 1] == target) &#123; start--; &#125; if (nums[end + 1] == target) &#123; end++; &#125; &#125; return [start, end]; &#125; else if (nums[mid] &lt; target) &#123; startFind = mid + 1; &#125; else &#123; endFind = mid - 1; &#125; &#125; return [-1, -1];&#125;; [35] Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.难度：Easy (40.50%) 123456789101112var searchInsert = function(nums, target) &#123; if (nums.length == 0) &#123; return 0; &#125; let out = nums.indexOf(target); if (out == -1) &#123; let i = 0; for (; target &gt; nums[i]; i++) &#123;&#125; out = i; &#125; return out;&#125;; [39] Combination SumGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (46.97%)考点：递归 12345678910111213141516171819202122232425262728var combinationSum = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); sarch(0, target); function sarch(start, target) &#123; if (start == candidates.length) &#123; return; &#125; if (target == 0) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0) &#123; return; &#125; solution.push(candidates[start]); sarch(start, target - candidates[start]); solution.pop(); sarch(start + 1, target); &#125; return rt;&#125;; [40] Combination Sum IIGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.Each number in candidates may only be used once in the combination.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (40.37%)考点：递归注意：限制边界条件，过滤重复的结果 12345678910111213141516171819202122232425262728var combinationSum2 = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); search(0, target); return rt; function search(start, target) &#123; if (target === 0 &amp;&amp; start === candidates.length) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0 || start === candidates.length) &#123; return; &#125; solution.push(candidates[start]); search(start + 1, target - candidates[start]); solution.pop(); if (solution[solution.length - 1] !== candidates[start]) &#123; search(start + 1, target); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"webpack基础知识（二）","slug":"webpack基础知识（二）","date":"2018-12-05T07:12:28.000Z","updated":"2019-04-08T04:39:59.993Z","comments":true,"path":"2018/12/05/webpack基础知识（二）/","link":"","permalink":"http://yoursite.com/2018/12/05/webpack基础知识（二）/","excerpt":"代码分离代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。","text":"代码分离代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。 入口起点(entry points)问题： 如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中。 这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。 防止重复(prevent duplication)CommonsChunkPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。使用这个插件，可将重复的 lodash 模块去除。需要注意的是，CommonsChunkPlugin 插件将 lodash 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小。 以下是由社区提供的，一些对于代码分离很有帮助的插件和 loaders： ExtractTextPlugin: 用于将 CSS 从主应用程序中分离。 bundle-loader: 用于分离代码和延迟加载生成的 bundle。 promise-loader: 类似于 bundle-loader ，但是使用的是 promises。 CommonsChunkPlugin 插件还可以通过使用显式的 vendor chunks 功能，从应用程序代码中分离 vendor 模块。 动态导入(dynamic imports)当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。 懒加载懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。 缓存我们使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的 /dist 目录，然后把打包后的内容放置在此目录中。只要 /dist 目录中的内容部署到服务器上，客户端（通常是浏览器）就能够访问网站此服务器的网站及其资源。而最后一步获取资源是比较耗费时间的。因此我们使用缓存技术。以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。所以需要通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。 输出文件的文件名(Output Filenames)通过使用 output.filename 进行文件名替换，可以确保浏览器获取到修改后的文件。[hash] 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 [chunkhash] 替换，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。 提取模板(Extracting Boilerplate)CommonsChunkPlugin 可以用于将模块分离到单独的文件中，还能够在每次修改后的构建结果中，将 webpack 的样板(boilerplate)和 manifest 提取出来。通过指定 entry 配置中未用到的名称，此插件会自动将我们需要的内容提取到单独的包中： 12345678910111213141516171819202122const path = require('path');+ const webpack = require('webpack'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; entry: './src/index.js', plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123; title: 'Caching'- &#125;)+ &#125;),+ new webpack.optimize.CommonsChunkPlugin(&#123;+ name: 'manifest'+ &#125;) ], output: &#123; filename: '[name].[chunkhash].js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用客户端的长效缓存机制，可以通过命中缓存来消除请求，并减少向服务器获取资源，同时还能保证客户端代码和服务器端代码版本一致。 模块标识符(Module Identifiers)每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。 可以使用两个插件来解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建。 library可以通过以下方式暴露 library： 变量：作为一个全局变量，通过 script 标签来访问（libraryTarget:’var’）。 this：通过 this 对象访问（libraryTarget:’this’）。 window：通过 window 对象访问，在浏览器中（libraryTarget:’window’）。 UMD：在 AMD 或 CommonJS 的 require 之后可访问（libraryTarget:’umd’）。如果设置了 library 但没设置 libraryTarget，则 libraryTarget 默认为 var shimming一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 \\$）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方。 shimming 全局变量使用 ProvidePlugin 后，能够在通过 webpack 编译的每个模块中，通过访问一个变量来获取到 package 包。如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package。我们还可以使用 ProvidePlugin 暴露某个模块中单个导出值，只需通过一个“数组路径”进行配置（例如 [module, child, …children?]） src/index.js 12345678910 function component() &#123; var element = document.createElement('div');- element.innerHTML = _.join(['Hello', 'webpack'], ' ');+ element.innerHTML = join(['Hello', 'webpack'], ' '); return element; &#125; document.body.appendChild(component()); webpack.config.js 12345678910111213141516 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ new webpack.ProvidePlugin(&#123;- _: 'lodash'+ join: ['lodash', 'join'] &#125;) ] &#125;; 这样，无论 join 方法在何处调用，我们都只会得到的是 lodash 中提供的 join 方法。与 tree shaking 配合，能够很好的将 lodash 库中的其他没用到的部分去除。 细粒度 shimming一些传统的模块依赖的 this 指向的是 window 对象。当模块运行在 CommonJS 环境下这将会变成一个问题，也就是说此时的 this 指向的是 module.exports。此时，可以通过使用 imports-loader 覆写 this： 1234567891011121314151617181920212223 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: require.resolve('index.js'),+ use: 'imports-loader?this=&gt;window'+ &#125;+ ]+ &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 全局 exports使用 exports-loader，将一个全局变量作为一个普通的模块来导出。 12345678910111213141516171819202122232425262728 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: require.resolve('index.js'), use: 'imports-loader?this=&gt;window'- &#125;+ &#125;,+ &#123;+ test: require.resolve('globals.js'),+ use: 'exports-loader?file,parse=helpers.parse'+ &#125; ] &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 渐进式网络应用程序渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的。 添加 Workbox 注册 Service Worker 停止服务器并刷新页面。如果浏览器能够支持 Service Worker，你应该可以看到你的应用程序还在正常运行。然而，服务器已经停止了服务，此刻是 Service Worker 在提供服务。 构建性能chunks减少编译的整体大小，以提高构建性能。尽量保持 chunks 小巧。 使用 更少/更小 的库。 在多页面应用程序中使用 CommonsChunksPlugin。 在多页面应用程序中以 async 模式使用 CommonsChunksPlugin 。 移除不使用的代码。 只编译你当前正在开发部分的代码。 最小化入口 chunkwebpack 只会在文件系统中生成已经更新的 chunk 。对于某些配置选项(HMR, [name]/[chunkhash] in output.chunkFilename, [hash])来说，除了更新的 chunks 无效之外，入口 chunk 也不会生效。应当在生成入口 chunk 时，尽量减少入口 chunk 的体积，以提高性能。下述代码块将只提取包含 runtime 的 chunk ，其他 chunk 都作为子模块: 1234new CommonsChunkPlugin(&#123; name: \"manifest\", minChunks: Infinity&#125;); Worker Poolthread-loader 可以将非常消耗资源的 loaders 转存到 worker pool 中 持久化缓存使用 cache-loader 启用持久化缓存。使用 package.json 中的 “postinstall” 清除缓存目录。 Dlls使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。 公共路径(public path)webpack 提供一个非常有用的配置，该配置能帮助你为项目中的所有资源指定一个基础路径。它被称为公共路径(publicPath)。webpack 提供一个全局变量供你设置，它名叫 webpack_public_path 1__webpack_public_path__ = process.env.ASSET_PATH;","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识（一）","slug":"webpack基础知识（一）","date":"2018-11-25T04:03:08.000Z","updated":"2019-04-08T04:39:56.589Z","comments":true,"path":"2018/11/25/webpack基础知识（一）/","link":"","permalink":"http://yoursite.com/2018/11/25/webpack基础知识（一）/","excerpt":"基本概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的，会以正确顺序执行的 bundle。","text":"基本概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的，会以正确顺序执行的 bundle。 依赖图(dependency graph)任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有 依赖关系 。这使得 webpack 可以接收非代码资源(non-code asset)（例如图像或 web 字体），并且可以把它们作为 _依赖_ 提供给你的应用程序。 webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些 入口起点 开始，webpack 递归地构建一个 依赖图 ，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载。 入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 123module.exports = &#123; entry: \"./path/to/my/entry/file.js\"&#125;; 入口配置支持： 单个入口语法注：向 entry 传入一个「文件路径(file path)数组」时将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。 对象语法这是应用程序中定义入口的最可扩展的方式。 出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 123456789const path = require(\"path\");module.exports = &#123; entry: \"./path/to/my/entry/file.js\", output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"my-first-webpack.bundle.js\" &#125;&#125;; filename 用于输出文件的文件名。目标输出目录 path 的绝对路径。 注：如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 设定 HtmlWebpackPlugin，虽然在 dist/ 文件夹我们已经有 index.html 这个文件，然而 HtmlWebpackPlugin 还是会默认生成 index.html 文件。这就是说，它会用新生成的 index.html 文件，把我们的原来的替换。 使用 source map当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112const path = require(\"path\");const config = &#123; output: &#123; filename: \"my-first-webpack.bundle.js\" &#125;, module: &#123; rules: [&#123; test: /\\.txt$/, use: \"raw-loader\" &#125;] &#125;&#125;;module.exports = config; 在你的应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览 内联：在每个 import 语句中显式指定 loader。可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 CLI：在 shell 命令中指定它们。 loader 特性： loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 插件(plugins)loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。插件目的在于解决 loader 无法实现的其他事。 1234567891011const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // 通过 npm 安装const webpack = require(\"webpack\"); // 用于访问内置插件const config = &#123; module: &#123; rules: [&#123; test: /\\.txt$/, use: \"raw-loader\" &#125;] &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: \"./src/index.html\" &#125;)]&#125;;module.exports = config; 用法：用 require（）引入由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 模式提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。通过选择 development 或 production 之中的一个，来设置 mode 参数，可以启用相应模式下的 webpack 内置的优化 用法： 只在配置中提供 mode 选项： 123module.exports = &#123; mode: \"production\"&#125;; 从 CLI 参数中传递： 1webpack --mode=production 模块热替换(hot module replacement)模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 tree shaking通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。 如果所有代码都不包含副作用，我们就可以简单地将 package.json 的 “sideEffects” 属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。注：「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。 如果你的代码确实有一些副作用，那么可以改为提供一个数组： 123456&#123; \"name\": \"your-project\", \"sideEffects\": [ \"./src/some-side-effectful-file.js\" ]&#125; 数组方式支持相关文件的相对路径、绝对路径和 glob 模式。它在内部使用 micromatch。 注意，任何导入的文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 css-loader 并导入 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除。 从 webpack 4 开始，也可以通过 “mode” 配置选项轻松切换到压缩输出，只需设置为 “production”。","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"React组件","slug":"React组件","date":"2018-11-11T04:10:52.000Z","updated":"2019-03-22T06:57:04.956Z","comments":true,"path":"2018/11/11/React组件/","link":"","permalink":"http://yoursite.com/2018/11/11/React组件/","excerpt":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上）","text":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上） 自动绑定每个方法的上下文都会指向该组件的实例——自动绑定 this 为当前组件。React 会对这种引用进行缓存，达到 CPU 内存最优。（使用 ES6 class 或纯函数时，自动绑定不复存在，需要手动绑定 this） bind 绑定绑定事件处理器内的 this，并可以向事件处理器中传参 构造器内声明好处：仅需进行一次绑定 箭头函数箭头函数自动绑定了定义此函数作用域的 this，因此不需要再用 bind 绑定 注意：React 中使用 DOM 原生事件，一定要在组件卸载时手动移除，否则内存泄漏。使用合成事件则不需要。 React 合成事件与 JS 原生事件对比原生 DOM 事件传播 3 个阶段：事件捕获阶段、目标对象本身的事件处理程序调用，以及事件冒泡。 事件捕获阶段会优先调用结构树最外层的元素上绑定的事件侦听器，依次向内调用，一直调用到目标元素上的事件监听器为止。 1e.addEventListener(\"click\", () =&gt; &#123;&#125;, false); 第三个参数，若传 true，为元素 e 注册捕获事件处理程序，并且在事件捕获阶段调用。 事件冒泡与事件捕获相反，它会从目标元素向外传播，由内而外。React 的合成事件仅支持事件冒泡阻止原生事件冒泡用 e.preventDefault() React 受控组件更新 state 的流程 可以通过在初始 state 中设置表单的默认值 每当表单的值发生变化时，调用 onchange 事件处理器 事件处理器通过合成事件对象 e 拿到改变后的状态，并更行应用的 state setState 触发视图的重新渲染，完成表单的组件值更新 React 非受控组件是一种反模式，他的值不受组件自身的 state 或 props 控制。通常需要为其添加 ref prop 来访问渲染后的底层 DOM","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"浏览器缓存位置","slug":"浏览器缓存位置","date":"2018-11-01T15:10:55.000Z","updated":"2019-08-15T10:31:10.153Z","comments":true,"path":"2018/11/01/浏览器缓存位置/","link":"","permalink":"http://yoursite.com/2018/11/01/浏览器缓存位置/","excerpt":"浏览器缓存位置缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache","text":"浏览器缓存位置缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1.Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 2.Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源, 例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快, 内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如&lt;link rel=&quot;prefetch&quot;&gt;）下载的资源。众所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。 3.Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先； 当前系统内存使用率高的话，文件优先存储进硬盘。 4.Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存, 但是 Edge 和 Safari 浏览器支持相对比较差； 可以推送 no-cache 和 no-store 的资源； 一旦连接被关闭，Push Cache 就被释放； 多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接； Push Cache 中的缓存只能被使用一次； 浏览器可以拒绝接受已经存在的资源推送； 你可以给其他域名推送资源。 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 http 状态码与缓存策略200 from memory cache不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当 kill 进程后，也就是浏览器关闭以后，数据将不存在。 但是这种方式只能缓存派生资源 200 from disk cache不访问服务器，直接读缓存，从磁盘中读取缓存，当 kill 进程时，数据还是存在。 这种方式也只能缓存派生资源 304 Not Modified访问服务器，发现数据没有 更新，服务器返回此状态码。然后从缓存中读取数据。 三级缓存原理 先去内存看，如果有，直接加载 如果内存没有，择取硬盘获取，如果有直接加载 如果硬盘也没有，那么就进行网络请求 加载到的资源缓存到硬盘和内存 常见缓存情况 第一个现象： 访问-&gt; 200 -&gt; 退出浏览器 再进来-&gt; 200(from disk cache) -&gt; 刷新 -&gt; 200(from memory cache) 总结: 会不会是 chrome 很聪明的判断既然已经从 disk 拿来了， 第二次就内存拿吧 快。（笑哭) 第二个现象: 只要图片是 base64 都是 from memroy cache。 总结: 解析渲染图片这么费劲的事情，还是做一次然后放到内存吧。 用的时候直接拿 第三个现象(以 js css 为例): 个人在做静态测试的发现，大型的 js css 文件都是直接 disk cache 总结: chrome 会不会说 我擦 你这么大 太 JB 占地方了。 你就去硬盘里呆着吧。 慢就慢点吧。 第四个现象: 隐私模式下，几乎都是 from memroy cache. 总结: 隐私模式 是吧。 我不能暴露你东西。还是放到内存吧。 你关，我死。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"Proxy","slug":"Proxy","date":"2018-10-27T03:07:46.000Z","updated":"2019-03-22T07:02:55.682Z","comments":true,"path":"2018/10/27/Proxy/","link":"","permalink":"http://yoursite.com/2018/10/27/Proxy/","excerpt":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。","text":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。 下面是一个拦截读取属性行为的例子。 123456789101112var proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125; &#125;);proxy.time; // 35proxy.name; // 35proxy.title; // 35 上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。注意，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。如果 handler 没有设置任何拦截，那就等同于直接通向原对象。同一个拦截器函数，可以设置拦截多个操作。 12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === \"prototype\") &#123; return Object.prototype; &#125; return \"Hello, \" + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123; value: args[1] &#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2); // 1new fproxy(1, 2); // &#123;value: 2&#125;fproxy.prototype === Object.prototype; // truefproxy.foo === \"Hello, foo\"; // true Proxy 支持的拦截操作一览Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。 set(target, propKey, value, receiver)拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)拦截 propKey in proxy 的操作，返回一个布尔值。 deleteProperty(target, propKey)拦截 delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)拦截 Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)拦截 Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)拦截 Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例），其中最后一个参数可选。 12345678910111213141516var person = &#123; name: \"张三\"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError('Property \"' + property + '\" does not exist.'); &#125; &#125;&#125;);proxy.name; // \"张三\"proxy.age; // 抛出一个错误 get 方法可以继承。 123456789101112let proto = new Proxy( &#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(\"GET \" + propertyKey); return target[propertyKey]; &#125; &#125;);let obj = Object.create(proto);obj.foo; // \"GET foo\" 上面代码中，拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效。利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 1234567891011121314151617181920212223242526272829303132var pipe = (function() &#123; return function(value) &#123; var funcStack = []; var oproxy = new Proxy( &#123;&#125;, &#123; get: function(pipeObject, fnName) &#123; if (fnName === \"get\") &#123; return funcStack.reduce(function(val, fn) &#123; return fn(val); &#125;, value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125; ); return oproxy; &#125;;&#125;)();var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n .toString() .split(\"\") .reverse() .join(\"\") | 0;pipe(3).double.pow.reverseInt.get; // 63 下面是一个 get 方法的第三个参数的例子 1234567891011const proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property, receiver) &#123; return receiver; &#125; &#125;);const d = Object.create(proxy);d.a === d; // true 上面代码中，d 对象本身没有 a 属性，所以读取 d.a 的时候，会去 d 的原型 proxy 对象找。这时，receiver 就指向 d，代表原始的读操作所在的那个对象。如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。 123456789101112131415161718192021const target = Object.defineProperties( &#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125; &#125;);const handler = &#123; get(target, propKey) &#123; return \"abc\"; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo;// TypeError: Invariant check failed set()set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。利用 set 方法，可以进行数据验证，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。 12345678910111213141516171819202122const handler = &#123; get(target, key) &#123; invariant(key, \"get\"); return target[key]; &#125;, set(target, key, value) &#123; invariant(key, \"set\"); target[key] = value; return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;const target = &#123;&#125;;const proxy = new Proxy(target, handler);proxy._prop;// Error: Invalid attempt to get private \"_prop\" propertyproxy._prop = \"c\";// Error: Invalid attempt to set private \"_prop\" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。下面是 set 方法第四个参数的例子。 1234567891011const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = receiver; &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);const myObj = &#123;&#125;;Object.setPrototypeOf(myObj, proxy);myObj.foo = \"bar\";myObj.foo === myObj; // true 上面代码中，设置 myObj.foo 属性的值时，myObj 并没有 foo 属性，因此引擎会到 myObj 的原型链去找 foo 属性。myObj 的原型对象 proxy 是一个 Proxy 实例，设置它的 foo 属性会触发 set 方法。这时，第四个参数 receiver 就指向原始赋值行为所在的对象 myObj。如果目标对象自身的某个属性，不可写且不可配置，那么 set 方法将不起作用。 123456789101112131415const obj = &#123;&#125;;Object.defineProperty(obj, \"foo\", &#123; value: \"bar\", writable: false&#125;);const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = \"baz\"; &#125;&#125;;const proxy = new Proxy(obj, handler);proxy.foo = \"baz\";proxy.foo; // \"bar\" apply()apply 方法拦截函数的调用、call 和 apply 操作。apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345678910111213var target = function() &#123; return \"I am the target\";&#125;;var handler = &#123; apply: function() &#123; return \"I am the proxy\"; &#125;&#125;;var p = new Proxy(target, handler);p();// \"I am the proxy\" 上面代码中，变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串。另外，直接调用 Reflect.apply 方法，也会被拦截。 has()has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。has 方法可以接受两个参数，分别是目标对象、需查询的属性名。下面的例子使用 has 方法隐藏某些属性，不被 in 运算符发现。 1234567891011var handler = &#123; has(target, key) &#123; if (key[0] === \"_\") &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: \"foo\", prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);\"_prop\" in proxy; // false 如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。 12345678910var obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false; &#125;&#125;);\"a\" in p; // TypeError is thrown 上面代码中，obj 对象禁止扩展，结果使用 has 拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则 has 方法就不得“隐藏”（即返回 false）目标对象的该属性。has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性。另外，虽然 for…in 循环也用到了 in 运算符，但是 has 拦截对 for…in 循环不生效。 construct()construct 方法用于拦截 new 命令，下面是拦截对象的写法。 12345var handler = &#123; construct(target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct 方法可以接受三个参数。target：目标对象。args：构造函数的参数对象。newTarget：创造实例对象时，new 命令作用的构造函数。construct 方法返回的必须是一个对象，否则会报错。 12345678910var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, args) &#123; console.log(\"called: \" + args.join(\", \")); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);new p(1).value;// \"called: 1\"// 10 1234567var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, argumentsList) &#123; return 1; &#125;&#125;);new p(); // 报错 deleteProperty()deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。 12345678910111213141516var handler = &#123; deleteProperty(target, key) &#123; invariant(key, \"delete\"); return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;var target = &#123; _prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);delete proxy._prop;// Error: Invalid attempt to delete private \"_prop\" property deleteProperty 方法拦截了 delete 操作符，删除第一个字符为下划线的属性会报错。注意，目标对象自身的不可配置（configurable）的属性，不能被 deleteProperty 方法删除，否则报错。 defineProperty()defineProperty 方法拦截了 Object.defineProperty 操作。 12345678var handler = &#123; defineProperty(target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = \"bar\"; // 不会生效 defineProperty 方法返回 false，导致添加新属性总是无效。注意，如果目标对象不可扩展（extensible），则 defineProperty 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则 defineProperty 方法不得改变这两个设置。 getOwnPropertyDescriptor()getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者 undefined。 12345678910111213141516var handler = &#123; getOwnPropertyDescriptor(target, key) &#123; if (key[0] === \"_\") &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: \"bar\", baz: \"tar\" &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, \"wat\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"_foo\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"baz\");// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名会返回 undefined。 getPrototypeOf()getPrototypeOf 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 12345678910var proto = &#123;&#125;;var p = new Proxy( &#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125; &#125;);Object.getPrototypeOf(p) === proto; // true getPrototypeOf 方法的返回值必须是对象或者 null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf 方法必须返回目标对象的原型对象。 isExtensible()isExtensible 方法拦截 Object.isExtensible 操作 12345678910111213var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; console.log(\"called\"); return true; &#125; &#125;);Object.isExtensible(p);// \"called\"// true 该方法只能返回布尔值，否则返回值会被自动转为布尔值。这个方法有一个强限制，它的返回值必须与目标对象的 isExtensible 属性保持一致，否则就会抛出错误。 1234567891011var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; return false; &#125; &#125;);Object.isExtensible(p); // 报错Object.isExtensible(proxy) === Object.isExtensible(target); //true ownKeys()ownKeys 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for…in 循环 12345678910111213141516let target = &#123; a: 1, b: 2, c: 3&#125;;let handler = &#123; ownKeys(target) &#123; return [\"a\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// [ 'a' ] 注意，使用 Object.keys 方法时，有三类属性会被 ownKeys 方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 123456789101112131415161718192021222324let target = &#123; a: 1, b: 2, c: 3, [Symbol.for(\"secret\")]: \"4\"&#125;;Object.defineProperty(target, \"key\", &#123; enumerable: false, configurable: true, writable: true, value: \"static\"&#125;);let handler = &#123; ownKeys(target) &#123; return [\"a\", \"d\", Symbol.for(\"secret\"), \"key\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// ['a'] 上面代码中，ownKeys 方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for(‘secret’)）、不可遍历的属性（key），结果都被自动过滤掉。 123456789101112131415161718192021222324//ownKeys方法还可以拦截Object.getOwnPropertyNames()var p = new Proxy( &#123;&#125;, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\", \"c\"]; &#125; &#125;);Object.getOwnPropertyNames(p);// [ 'a', 'b', 'c' ]//for...in循环也受到ownKeys方法的拦截const obj = &#123; hello: \"world\" &#125;;const proxy = new Proxy(obj, &#123; ownKeys: function() &#123; return [\"a\", \"b\"]; &#125;&#125;);for (let key in proxy) &#123; console.log(key); // 没有任何输出&#125; 上面代码中，ownkeys 指定只返回 a 和 b 属性，由于 obj 没有这两个属性，因此 for…in 循环不会有任何输出。ownKeys 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。 12345678910var obj = &#123;&#125;;var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [123, true, undefined, null, &#123;&#125;, []]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 123 is not a valid property name 如果目标对象自身包含不可配置的属性，则该属性必须被 ownKeys 方法返回，否则报错。 123456789101112131415var obj = &#123;&#125;;Object.defineProperty(obj, \"a\", &#123; configurable: false, enumerable: true, value: 10&#125;);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a' 如果目标对象是不可扩展的（non-extensition），这时 ownKeys 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。 1234567891011121314var obj = &#123; a: 1&#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible preventExtensions()preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy)为 false），proxy.preventExtensions 才能返回 true，否则会报错。 1234567891011121314151617181920212223242526var p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125; &#125;);Object.preventExtensions(p); // 报错//为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensionsvar p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; console.log(\"called\"); Object.preventExtensions(target); return true; &#125; &#125;);Object.preventExtensions(p);// \"called\"// true setPrototypeOf()setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。 12345678910var handler = &#123; setPrototypeOf(target, proto) &#123; throw new Error(\"Changing the prototype is forbidden\"); &#125;&#125;;var proto = &#123;&#125;;var target = function() &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden 上面代码中，只要修改 target 的原型对象，就会报错。注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf 方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable 方法返回一个可取消的 Proxy 实例 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo; // 123revoke();proxy.foo; // TypeError: Revoked Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。Proxy.revocable 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function() &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m(); // falseproxy.m(); // true","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"浏览器缓存机制","slug":"浏览器缓存机制","date":"2018-10-20T07:23:45.000Z","updated":"2019-08-15T10:30:59.885Z","comments":true,"path":"2018/10/20/浏览器缓存机制/","link":"","permalink":"http://yoursite.com/2018/10/20/浏览器缓存机制/","excerpt":"浏览器缓存机制概念浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。（浏览器缓存分为强缓存和协商缓存）","text":"浏览器缓存机制概念浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。（浏览器缓存分为强缓存和协商缓存） 浏览器缓存机制要素： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识； 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。 九种浏览器缓存：http 缓存http 缓存是基于 HTTP 协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件。主要是针对重复的 http 请求，在有缓存的情况下判断过程主要分 3 步：判断 expires，如果未过期，直接读取 http 缓存文件，不发 http 请求，否则进入下一步；判断是否含有 etag，有则带上 if-none-match 发送请求，未修改返回 304，修改返回 200，否则进入下一步；判断是否含有 last-modified，有则带上 if-modified-since 发送请求，无效返回 200，有效返回 304，否则直接向服务器请求 websql它是将数据以数据库的形式存储在客户端，根据需求去读取；跟 Storage 的区别是： Storage 和 Cookie 都是以键值对的形式存在的。 indexDBIndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。同步 API 本来是要用于仅供 Web Workers 内部使用，但是还没有被任何浏览器所实现。异步 API 在 Web Workers 内部和外部都可以使用，另外浏览器可能对 indexDB 有 50M 大小的限制，一般用户保存大量用户数据并要求数据之间有搜索需要的场景。 Cookie指一般网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。cookie 一般通过 http 请求中在头部一起发送到服务器端。一条 cookie 记录主要由键、值、域、过期时间、大小组成，一般用于保存用户的认证信息。cookie 最大长度和域名个数由不同浏览器决定。不同域名之间的 cookie 信息是独立的，如果需要设置共享可以在服务器端设置 cookie 的 path 和 domain 来实现共享。浏览器端也可以通过 document.cookie 来获取 cookie，并通过 js 浏览器端也可以方便地读取/设置 cookie 的值。（Cookie 只能存储少量的数据，每个 Cookie 的大小不超过 4KB。RFC 标准不允许浏览器保存超过 300 个 Cookie，为每个 web 服务器保存的 Cookie 数不超过 20 个。JavaScript 中使用 Cookie 不会采用任何加密机制，因此它们是不安全的。） LocalstoragelocalStorage 是 html5 的一种新的本地缓存方案，目前用的比较多，一般用来存储 ajax 返回的数据，加快下次页面打开时的渲染速度。 SessionstoragesessionStorage 和 localstorage 类似，但是浏览器关闭则会全部删除，api 和 localstorage 相同，实际项目中使用较少。 application cacheapplication cahce 是将大部分图片资源、js、css 等静态资源放在 manifest 文件配置中。当页面打开时通过 manifest 文件来读取本地文件或是请求服务器文件。在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。并在下一次生效。离线的情况下，浏览器就直接使用离线存储的资源。 cacheStorageCacheStorage 是在 ServiceWorker 的规范中定义的。CacheStorage 可以保存每个 serverWorker 申明的 cache 对象，cacheStorage 有 open、match、has、delete、keys 五个核心方法，可以对 cache 对象的不同匹配进行不同的响应。 flash 缓存这种方式基本不用，这一方法主要基于 flash 有读写浏览器端本地目录的功能，同时也可以向 js 提供调用的 api，则页面可以通过 js 调用 flash 去读写特定的磁盘目录，达到本地数据缓存的目的。 cookie 背景：早期 Web 开发面临的最大问题之一是如何管理状态。简言之，服务器端没有办法知道两个请求是否来自于同一个浏览器。那时的办法是在请求的页面中插入一个 token，并且在下一次请求中将这个 token 返回（至服务器）。这就需要在 form 中插入一个包含 token 的隐藏表单域，或着在 URL 的 qurey 字符串中传递该 token。这两种办法都强调手工操作并且极易出错。 内容：键、值、域、过期时间、大小 是否生效：expires 指定了 cookie 何时不会再被发送到服务器端的，因此该 cookie 可能会被浏览器删掉。（过期时间）在没有 expires 选项时，cookie 的寿命仅限于单一的会话中。浏览器的关闭意味这一次会话的结束，所以会话 cookie 只存在于浏览器保持打开的状态之下。如果 expires 选项设置了一个过去的时间点，那么这个 cookie 会被立即删除。 存在哪里：cookie 的值被存储在名为 Cookie 的 HTTP 消息头中，并且只包含了 cookie 的值，其它的选项全部被去除。 存放形式：Cookies 是纯文本形式。几乎所有的实现方式都对 cookie 的值进行了一些列的 URL 编码（但不是必须）。原始的文档中指示仅有三种类型的字符必须进行编码：分号，逗号，和空格。 不同域名之间的 cookie 信息是独立的，不会冲突。浏览器会对 domain 的值与请求所要发送至的域名，做一个尾部比较（即从字符串的尾部开始比较），并且在匹配后发送一个 Cookie 消息头。domain 设置的值必须是发送 Set-Cookie 消息头的域名。与 domain 选项相同的是，path 指明了在发 Cookie 消息头之前必须在请求资源中存在一个 URL 路径。这个比较是通过将 path 属性值与请求的 URL 从头开始逐字符串比较完成的。如果字符匹配，则发送 Cookie 消息头。只有在 domain 选项核实完毕之后才会对 path 属性进行比较。path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。path 值越详细则 cookie 越靠前。domain-path 越详细则 cookie 字符串越靠前。可以通过设置 Cookie 的 path 属性来修改 Cookie 的作用域，如果把 path 设为“/”，就等同于让 Cookie 拥有了 localStorage 的作用域，即整个文档源。 默认情况下，Cookie 对于创建它的页面，以及与该页面同目录或子目录下的其他 web 页面可见。在 a.example.com 下的一个页面设置了 Cookie，将其 path 设为“/”，并将 domain 设为“.example.com”，这样该 Cookie 就对 example.com 域下的所有页面可见。 创建和存储 Cookie：对 Cookie 的所有操作都要通过读写 document 对象的 Cookie 属性来完成。Cookie 的值都是以键值对的形式存储。同样的，如果要设置 path、domain 等属性，只须以如下形式追加到 Cookie 值的后面: ;path=path 1234567891011//创建一个名字Cookie，同时设置它的过期时间function setCookie(c_name, value, expiredays) &#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); //encodeURIComponent() 对 URI 进行编码 document.cookie = c_name + \"=\" + encodeURIComponent(value) + (expiredays == null ? \"\" : \";expires=\" + exdate.toGMTString());&#125; 读取 Cookie：使用 document.cookie 可以获取到 Cookie 的值，不过这个值是一个字符串，为了更好地查看 Cookie 的值，往往会采用 split()方法将 Cookie 中的名值对分离出来。 12345678910111213141516171819202122function getCookie() &#123; // 初始化要返回的对象 var cookie = &#123;&#125;; var all = document.cookie; if (all === null) &#123; return cookie; &#125; //分离出Cookie的各个属性 var list = all.split(\";\"); for (var i = 0; i &lt; list.length; i++) &#123; // 查询出等号所在的位置 var p = list[i].indexOf(\"=\"); // 分离出名字和值 var name = list[i].substring(0, p); var value = list[i].substring(p + 1); //对值进行解码 value = decodeURIComponent(value); // 将名值对存储到对象中 cookie[name] = value; &#125; return cookie;&#125; Localstorage 和 sessionstorageLocalstorage 和 sessionstorage 是做什么的？localstorage 怎么清除它？在代码层面怎么清除？setitem 的是什么数据类型？getitem 的值是什么数据类型？ 怎么清除 12localStorage.removeItem(key); //删除该域名下单条记录localStorage.clear(); //删除该域名下所有记录 存储格式：所有的数据都是以文本格式保存。其中 value 需为可转化为字符串的对象。localStorage 对象的键和值只能是字符串，假设我们要保存一个对象到 localStorage 中，可以使用拼接的方式。当然也可以借助 JSON 类，将对象转换成字符串保存，然后在取出来的时候将 json 字符串转换成真正可用的 json 对象格式 数据共享：不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-10-14T07:55:35.000Z","updated":"2019-03-19T13:43:39.901Z","comments":true,"path":"2018/10/14/箭头函数/","link":"","permalink":"http://yoursite.com/2018/10/14/箭头函数/","excerpt":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。","text":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function(v) &#123; return v;&#125;; 参数部分如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 1234567891011var f = () =&gt; 5;// 等同于var f = function() &#123; return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 返回对象由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 1234let foo = () =&gt; &#123; a: 1;&#125;;foo(); // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句 a: 1。这时，a 可以被解释为语句的标签，因此实际执行的语句是 1;，然后函数就结束了，没有返回值。箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + \" \" + last;// 等同于function full(person) &#123; return person.first + \" \" + person.last;&#125; 简化回调函数箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1, 2, 3].map(function(x) &#123; return x * x;&#125;);// 箭头函数写法[1, 2, 3].map(x =&gt; x * x); rest 参数与箭头函数结合123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5);// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5);// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。上面四点中，第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(\"id:\", this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this 应该指向全局对象 window，这时应该输出 21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是 42。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。 123456789101112131415161718192021222324252627282930function insert(value) &#123; return &#123; into: function(array) &#123; return &#123; after: function(afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;; &#125; &#125;;&#125;insert(2) .into([1, 3]) .after(1); //[1, 2, 3]//使用箭头函数改写let insert = value =&gt; (&#123; into: array =&gt; (&#123; after: afterValue =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;)&#125;);insert(2) .into([1, 3]) .after(1); //[1, 2, 3] 改写 λ 演算123456// λ演算的写法fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))// ES6的写法var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v)));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"this和super关键字","slug":"this和super关键字","date":"2018-09-24T10:41:35.000Z","updated":"2019-03-22T06:55:53.017Z","comments":true,"path":"2018/09/24/this和super关键字/","link":"","permalink":"http://yoursite.com/2018/09/24/this和super关键字/","excerpt":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身","text":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身 12345678910var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向obj对象obj.getA(); 作为普通函数调用作为普通函数调用时，this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。 1234567891011var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向window对象var getA = obj.getA;getA(); 这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。 构造器调用构造器调用时，this 指向返回的对象。用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。 12345678910111213var a = 10;var b = 20;function Point(x, y) &#123; this.x = x; this.y = y;&#125;var a = new Point(1, 2);console.log(a.x); // 1console.log(x); // 10var b = new Point(1, 2);console.log(a === b); // false call apply bind当函数通过 call()和 apply()方法绑定时，this 指向两个方法的第一个参数对象上，若第一个参数不是对象，JS 内部会尝试将其转化为对象然后再指向它。通过 bind 方法绑定后，无论其在什么情况下被调用，函数将被永远绑定在其第一个参数对象上，bind 绑定后返回的是一个函数。 call, apply 的用途 改变 this 的指向 Function.prototype.bind 12345678Function.prototype.bind = function() &#123; var self = this; var context = [].shift.call(arguments); var args = [].slice.call(arguments); return function() &#123; return self.apply(context, args.concat([].slice.call(arguments))); &#125;;&#125;; 三者区别call 只能一个一个传入参数apply 可直接传入参数数组bind 会返回一个新的函数 super 关键字关键字 super，指向当前对象的原型对象。 12345678910111213const proto = &#123; foo: \"hello\"&#125;;const obj = &#123; foo: \"world\", find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find(); // \"hello\" 上面代码中，对象 obj 的 find 方法之中，通过 super.foo 引用了原型对象 proto 的 foo 属性。注意，super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;;// 报错const obj = &#123; foo: function() &#123; return super.foo; &#125;&#125;; 上面三种 super 的用法都会报错，因为对于 JavaScript 引擎来说，这里的 super 都没有用在对象的方法之中。第一种写法是 super 用在属性里面，第二种和第三种写法是 super 用在一个函数里面，然后赋值给 foo 属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。JavaScript 引擎内部，super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)（方法）。 1234567891011121314151617const proto = &#123; x: \"hello\", foo() &#123; console.log(this.x); &#125;&#125;;const obj = &#123; x: \"world\", foo() &#123; super.foo(); &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.foo(); // \"world\" 上面代码中，super.foo 指向原型对象 proto 的 foo 方法，但是绑定的 this 却还是当前对象 obj，因此输出的就是 world。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"常用git命令","slug":"常用git命令","date":"2018-09-16T03:50:00.000Z","updated":"2019-03-19T13:43:41.209Z","comments":true,"path":"2018/09/16/常用git命令/","link":"","permalink":"http://yoursite.com/2018/09/16/常用git命令/","excerpt":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库","text":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库 git status 查看状态“.” 代表文件夹中所有文件 git add [file1][file2]添加指定文件到暂存区 git commit在第一行写入这次修改记录。将缓存区文件放入提交区。git commit -m [‘message’]git commit -amend修改上次记录信息 git log查看提交记录vim ~/.zshrc 配置文件中可自定义操作source ~/.zshrc 修改配置文件后 source 保存生效 git config查看当前 git 配置git config -h查看帮助信息vim ~/.gitconfig 自定义 git 命令，修改个人名字邮箱等信息cat .git/config 本地配置 touch .gitignore 忽略一些文件 12.vscodenode_modules 写入 gitignore 后即可忽略 node_modules 文件更多信息查看gitignore git diff现实暂存区和工作区的差异 git checkout –a放弃 a 的变更依照提交区恢复工作区的文件，丢弃工作区的变更 git reset HEAD –a从暂存区恢复到工作区 git stash把工作区和暂存区的文件都存入 stash 中git stash list查看 stash 中的文件git stash pop恢复 stash 中的文件到工作区（pop=apply+drop） git reset HEAD\b^后退一步（几个^代表后退几步）git reset HEAD~[number]抛弃了 number 个 commit git reflog查看近期的 log 记录git reset [版本号]回退到版本号为……的 commit 分支操作 git branch develop创建 develop 分支,但依然停留在当前分支git branch -v查看分支 git checkout develop切换进入 develop 分支git checkout -b feature创建并切换进入 feature 分支 合并分支a. 先进入要合并的分支（checkout develop）在执行 git merge feature 即可把 feature 合并到 develop 分支上b. git merge feature develop可达到同样的效果 改变基线git rebase -i [提交记录号]将 HEAD 指向记录号所在位置 远程仓库 git remote add origin [SSH 地址]创建远程仓库连接 git push -u origin develop上传 develop 分支到远程仓库上（远程无项目可直接 push，有项目先 merge 再 push） git pull origin feature拉取远程 feature 分支（pull=fetch+merge） git brach -d feature删除 feature 分支 git push origin :feature删除远程 feature 分支 git tag [标签号]git push origin [标签号]打标签 git remote remove origin取消本地目录下关联的远程仓库 git clone [url]下载一个项目和它的整个代码历史 打 tag vim package.json(vim package-lock.json)可以查看 version 号 npm version -h查看这一个 tag 即将提升的版本号（大版本或者小版本） npm version patch提升 patch 这个小版本（v0.2.2） git tag –list查看 tag 的列表 git push origin masterpush 代码 git push origin v0.2.3push tag","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"跨域请求：JSONP&&CORS","slug":"跨域请求：JSONP&&CORS","date":"2018-09-03T09:28:34.000Z","updated":"2019-08-15T10:30:47.660Z","comments":true,"path":"2018/09/03/跨域请求：JSONP&&CORS/","link":"","permalink":"http://yoursite.com/2018/09/03/跨域请求：JSONP&&CORS/","excerpt":"JSONPJSONP 是 JSON with Padding 的略称。它是一个非官方的协议，它允许在服务器端集成 Script tags 返回至客户端，通过 javascript callback 的形式实现跨域访问（这仅仅是 JSONP 简单的实现形式） JSONP 的简单实现模式：创建一个回调函数，然后在远程服务上调用这个函数并且将 JSON 数据形式作为参数传递，完成回调。 我们知道script，link，img 等标签引入外部资源，都是GET请求的，那么就决定了 JSONP 一定是 GET的。","text":"JSONPJSONP 是 JSON with Padding 的略称。它是一个非官方的协议，它允许在服务器端集成 Script tags 返回至客户端，通过 javascript callback 的形式实现跨域访问（这仅仅是 JSONP 简单的实现形式） JSONP 的简单实现模式：创建一个回调函数，然后在远程服务上调用这个函数并且将 JSON 数据形式作为参数传递，完成回调。 我们知道script，link，img 等标签引入外部资源，都是GET请求的，那么就决定了 JSONP 一定是 GET的。 原生 JS 实现 JSONP 的步骤：客户端 定义获取数据后调用的回调函数 动态生成对服务端 JS 进行引用的代码 设置url为提供jsonp服务的url地址，并在该url中设置相关callback参数 创建script标签，并设置其src属性 把script标签加入head，此时调用开始。 服务端将客户端发送的callback参数作为函数名来包裹住JSON数据，返回数据至客户端。 例子：客户端代码： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data) &#123; alert( \"你查询的航班结果是：票价 \" + data.price + \" 元，\" + \"余票 \" + data.tickets + \" 张。\" ); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler\"; // 创建script标签，设置其属性 var script = document.createElement(\"script\"); script.setAttribute(\"src\", url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(\"head\")[0].appendChild(script); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 编码实现动态查询，而这也正是 JSONP 客户端实现的核心部分，本例中的重点也就在于如何完成 JSONP 调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是 CA1998 次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 12345flightHandler(&#123; code: \"CA1998\", price: 1780, tickets: 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，JSONP 的执行全过程顺利完成！ CORS跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 1.两种请求浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 2.简单请求 基本流程 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送 Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 withCredentials 属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在 AJAX 请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。 3.非简单请求 预检请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的 JavaScript 脚本。 12345var url = \"http://api.alice.com/cors\";var xhr = new XMLHttpRequest();xhr.open(\"PUT\", url, true);xhr.setRequestHeader(\"X-Custom-Header\", \"value\");xhr.send(); 上面代码中，HTTP 请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的 HTTP 头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的 HTTP 回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他 CORS 相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应 一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常 CORS 请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 4.与 JSONP 的比较CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。 JSONP 只支持GET请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"正则的扩展","slug":"正则的扩展","date":"2018-08-29T08:56:12.000Z","updated":"2019-03-19T13:43:42.770Z","comments":true,"path":"2018/08/29/正则的扩展/","link":"","permalink":"http://yoursite.com/2018/08/29/正则的扩展/","excerpt":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。","text":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 12345var regex = new RegExp(\"xyz\", \"i\");// 等价于var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; ES6 中，如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/gi, \"i\").flags;// \"i\" 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和 split()。ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 点字符点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。 1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true Unicode 字符表示法ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别当中的大括号，否则会被解读为量词。 12345/\\u&#123;61&#125;/.test(\"a\") / // falsea /u.test(\"a\") / // true 𠮷 / u.test(\"𠮷\"); // true 量词使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。 1234/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true 预定义模式\\S 是预定义模式，匹配所有非空白字符。只有加了 u 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。 12/^\\S$/.test('𠮷') // false/^\\S$/u.test('𠮷') // true i 修饰符有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B 与\\u212A 都是大写的 K。不加 u 修饰符，就无法识别非规范的 K 字符。 123/[a-z]/i.test(\"\\u212A\") / // false [a - z] / iu.test(\"\\u212A\"); // true RegExp.prototype.unicode 属性正则实例对象新增 unicode 属性，表示是否设置了 u 修饰符 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode; // falser2.unicode; // true 上面代码中，正则表达式是否设置了 u 修饰符，可以从 unicode 属性看出来。 y 修饰符ES6 为正则表达式添加了 y 修饰符，叫做“粘连”（sticky）修饰符。y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = \"aaa_aa_a\";var r1 = /a+/g;var r2 = /a+/y;r1.exec(s); // [\"aaa\"]r2.exec(s); // [\"aaa\"]r1.exec(s); // [\"aa\"]r2.exec(s); // null 单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。 12\"a1a2a3\".match(/a\\d/y); // [\"a1\"]\"a1a2a3\".match(/a\\d/gy); // [\"a1\", \"a2\", \"a3\"] RegExp.prototype.sticky 属性与 y 修饰符相匹配，ES6 的正则实例对象多了 sticky 属性，表示是否设置了 y 修饰符。 12var r = /hello\\d/y;r.sticky; // true RegExp.prototype.flags 属性ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。 12345678910// ES5 的 source 属性// 返回正则表达式的正文/abc/gi.source / // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 abc / ig.flags;// 'gi' s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 u 修饰符解决；另一个是行终止符。行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator）ES2018 引入 s 修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test(\"foo\\nbar\"); // true 这被称为 dotAll 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。/s 修饰符和多行修饰符/m 不冲突，两者一起使用的情况下，.匹配所有字符，而^和\\$匹配每一行的行首和行尾。 后行断言”先行断言“指的是，x 只有在 y 前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。”先行否定断言“指的是，x 只有不在 y 前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。“后行断言”正好与“先行断言”相反，x 只有在 y 后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\\$)\\d+/。”后行否定断言“则与”先行否定断言“相反，x 只有不在 y 后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\\$)\\d+/。 123const RE_DOLLAR_PREFIX = /(?&lt;=\\$)foo/g;\"$foo %foo foo\".replace(RE_DOLLAR_PREFIX, \"bar\");// '$bar %foo foo' “后行断言”的实现，需要先匹配/(?&lt;=y)x/的 x，然后再回到左边，匹配 y 的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。首先，后行断言的组匹配，与正常情况下结果是不一样的。 12/(?&lt;=(\\d+)(\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]/^(\\d+)(\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 Unicode 属性类ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。\\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。这两种类只对 Unicode 有效，所以使用的时候一定要加上 u 修饰符。如果不加 u 修饰符，正则表达式使用\\p 和\\P 会报错，ECMAScript 预留了这两个类。 123456789101112131415// 匹配所有空格\\p&#123;White_Space&#125;// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w[\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W[^\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配 Emoji/\\p&#123;Emoji_Modifier_Base&#125;\\p&#123;Emoji_Modifier&#125;?|\\p&#123;Emoji_Presentation&#125;|\\p&#123;Emoji&#125;\\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 具名组匹配正则表达式使用圆括号进行组匹配。 123456const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 正则表达式里面有三组圆括号。使用 exec 方法，就可以将这三组匹配结果提取出来。组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如 matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 “具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在 exec 方法返回结果的 groups 属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。 解构赋值和替换具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。字符串替换时，使用\\$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;\"2015-01-02\".replace(re, \"$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;\");// '02/01/2015' 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法或者数字引用（\\1）的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;RE_TWICE.test(\"abc!abc!abc\"); // trueRE_TWICE.test(\"abc!abc!ab\"); // false String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用 g 修饰符或 y 修饰符，在循环里面逐一取出。或者使用 String.prototype.matchAll 方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = \"test1test2test3\";// g 修饰符加不加都可以const regex = /t(e)(st(\\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于 string.matchAll(regex)返回的是遍历器，所以可以用 for…of 循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。遍历器转为数组是非常简单的，使用…运算符和 Array.from 方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)];// 转为数组方法二Array.from(string.matchAll(regex));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"柯里化&&闭包","slug":"柯里化&&闭包","date":"2018-08-16T00:30:22.000Z","updated":"2019-08-15T10:30:33.593Z","comments":true,"path":"2018/08/16/柯里化&&闭包/","link":"","permalink":"http://yoursite.com/2018/08/16/柯里化&&闭包/","excerpt":"柯里化闭包实现multi(2)(3)(4)=24 1234567function multi(a) &#123; return function(b) &#123; return function(c) &#123; return a * b * c; &#125;; &#125;;&#125;","text":"柯里化闭包实现multi(2)(3)(4)=24 1234567function multi(a) &#123; return function(b) &#123; return function(c) &#123; return a * b * c; &#125;; &#125;;&#125; 函数柯里化函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。 函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 普通版把固定的函数变成柯里化。如果传入的参数个数小于 fn 所需要的形参个数，就继续执行 curry 函数接收参数，如果参数达到 fn 所需要的形参个数，就执行柯里化了的函数。 1234567891011121314151617181920function curry(fn, args) &#123; var length = fn.length; var args = args || []; return function() &#123; newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length &lt; length) &#123; return curry.call(this, fn, newArgs); &#125; else &#123; return fn.apply(this, newArgs); &#125; &#125;;&#125;function multiFn(a, b, c) &#123; return a * b * c;&#125;var multi = curry(multiFn);multi(2)(3)(4);multi(2, 3, 4);multi(2)(3, 4);multi(2, 3)(4); 优化版不需要事先知道函数形参个数。可以任意参数个数调用。（重写 valueOf 函数） 12345678910111213function multi() &#123; var args = Array.prototype.slice.call(arguments); var fn = function() &#123; var newArgs = args.concat(Array.prototype.slice.call(arguments)); return multi.apply(this, newArgs); &#125;; fn.valueOf = function() &#123; return args.reduce(function(a, b) &#123; return a * b; &#125;); &#125;; return fn;&#125; 闭包1234567var func = [];for (var i = 0; i &lt; 10; i++) &#123; func[i] = function() &#123; return i; &#125;;&#125;console.log(func[6]); //10 改成 12345678910var func = [];for (var i = 0; i &lt; 10; i++) &#123; func[i] = (function() &#123; return (function() &#123; return i; &#125;)(); &#125;)();&#125;console.log(func[6]); //6","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"字符串的扩展","slug":"字符串的扩展","date":"2018-08-09T03:20:29.000Z","updated":"2019-03-19T13:43:48.706Z","comments":true,"path":"2018/08/09/字符串的扩展/","link":"","permalink":"http://yoursite.com/2018/08/09/字符串的扩展/","excerpt":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。","text":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12345678\"\\u0061\";// \"a\"\"\\uD842\\uDFB7\";// \"𠮷\"\"\\u20BB7\";// \" 7\" 如果直接在\\u 后面跟上超过 0xFFFF 的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7。ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 codePointAt()codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。例如，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点（codePointAt 方法返回的是码点的十进制值）。 1234567891011121314var s = \"𠮷\";s.length; // 2s.charAt(0); // ''s.charAt(1); // ''s.charCodeAt(0); // 55362s.charCodeAt(1); // 57271let a = \"𠮷a\";a.codePointAt(0); // 134071a.codePointAt(1); // 57271a.codePointAt(2); // 97 codePointAt 方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷 a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的 20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt 方法的结果与 charCodeAt 方法相同。 String.fromCodePoint()ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 0xFFFF）。ES6 提供了 String.fromCodePoint 方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。且如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回。 1234String.fromCodePoint(0x20bb7);// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === \"x\\uD83D\\uDE80y\";// true 字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被 for…of 循环遍历,并且遍历器最大的优点是可以识别大于 0xFFFF 的码点。 1234567891011for (let codePoint of \"foo\") &#123; console.log(codePoint);&#125;// \"f\"// \"o\"// \"o\"for (let i of text) &#123; console.log(i);&#125;// \"𠮷\" at()ES5 对字符串对象提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符。字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符。 12\"abc\".at(0); // \"a\"\"𠮷\".at(0); // \"𠮷\" normalize()在字符排序或比较时，会出现一种情况，就是“等效”。 规范的等效是指，无论从哪个角度看，两个序列的码位都是没有区别的。 兼容关系，两个互相兼容的码位序列看起来不同，但是在特定的情况下可以相互交换使用。例如 Ǒ（\\u01D1）和 O（\\u004F） ˇ（\\u030C）两个字符的组合（\\u004F\\u030C），在视觉和语义上其实是等效的。 ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12\"\\u01D1\".normalize() === \"\\u004F\\u030C\".normalize();// true 不过，normalize 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 includes(), startsWith(), endsWith()includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。 12345let s = \"Hello world!\";s.startsWith(\"world\", 6); // trues.endsWith(\"Hello\", 5); // trues.includes(\"Hello\", 6); // false repeat()repeat 方法返回一个新字符串，表示将原字符串重复 n 次。参数如果是小数，会被取整。如果 repeat 的参数是负数或者 Infinity，会报错。参数 NaN 等同于 0。如果 repeat 的参数是字符串，则会先转换成数字。 1234567891011121314\"x\".repeat(3); // \"xxx\"\"hello\".repeat(2); // \"hellohello\"\"na\".repeat(0); // \"\"\"na\".repeat(2.9); // \"nana\"\"na\".repeat(Infinity);// RangeError\"na\".repeat(-1);// RangeError\"na\".repeat(NaN); // \"\"\"na\".repeat(\"na\"); // \"\"\"na\".repeat(\"3\"); // \"nanana\" padStart()，padEnd()如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。 1234567891011\"x\".padStart(4, \"ab\"); // 'abax'\"x\".padEnd(5, \"ab\"); // 'xabab'\"xxx\".padStart(2, \"ab\"); // 'xxx'\"xxx\".padEnd(2, \"ab\"); // 'xxx'\"abc\".padStart(10, \"0123456789\");// '0123456abc'\"x\".padStart(4); // ' x'\"x\".padEnd(4); // 'x ' matchAll()matchAll 方法返回一个正则表达式在当前字符串的所有匹配 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。嵌入变量，需要将变量名写在\\${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。如果模板字符串中的变量没有声明，将报错。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.``In JavaScript this is // 多行字符串 not legal.`;console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`;let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 所有模板字符串的空格和换行，都是被保留的，比如”&lt; ul&gt;”标签前面会有一个换行。如果你不想要这个换行，可以使用 trim 方法消除它。如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = \"return \" + \"`Hello $&#123;name&#125;!`\";let func = new Function(\"name\", str);func(\"Jack\"); // \"Hello Jack!\"// 写法二let str = \"(name) =&gt; `Hello $&#123;name&#125;!`\";let func = eval.call(null, str);func(\"Jack\"); // \"Hello Jack!\" 标签模板模板字符串，紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`;// 等同于tag([\"Hello \", \" world \", \"\"], 15, 50); 上面代码中，模板字符串前面有一个标识名 tag，它是一个函数。整个表达式的返回值，就是 tag 函数处理模板字符串后的返回值。函数 tag 依次会接收到多个参数。tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。tag 函数的其他参数，都是模板字符串各个变量被替换后的值。 “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg .replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。 标签模板的另一个应用，就是多语言转换（国际化处理）。多语言转换（国际化处理）。可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性。保存的是转义后的原字符串。 1234567tag`First line\\nSecond line`;function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"&#125; String.raw()ES6 还为原生的 String 对象，提供了一个 raw 方法。String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。如果原字符串的斜杠已经转义，那么 String.raw 会进行再次转义。 12345678String.raw`Hi\\n$&#123;2 + 3&#125;!`;// 返回 \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 返回 \"Hi\\\\u000A!\"String.raw`Hi\\\\n`;// 返回 \"Hi\\\\\\\\n\"","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"递归与尾递归","slug":"递归与尾递归","date":"2018-07-23T10:15:56.000Z","updated":"2019-08-15T10:30:08.340Z","comments":true,"path":"2018/07/23/递归与尾递归/","link":"","permalink":"http://yoursite.com/2018/07/23/递归与尾递归/","excerpt":"递归的问题函数的递归调用是通过栈来实现的，每一次函数调用都会把当前函数的状态，如变量，返回地址保存在栈中一直到函数返回才能出栈。因为程序运行时，栈的大小一般很有限（在 chrome 中运行下面的代码可以计算出 chrome 给每个线程的栈大小），因此如果递归调用的层次如果过多，将会使栈区溢出。","text":"递归的问题函数的递归调用是通过栈来实现的，每一次函数调用都会把当前函数的状态，如变量，返回地址保存在栈中一直到函数返回才能出栈。因为程序运行时，栈的大小一般很有限（在 chrome 中运行下面的代码可以计算出 chrome 给每个线程的栈大小），因此如果递归调用的层次如果过多，将会使栈区溢出。 尾递归尾递归就是函数最后的语句是调用函数自身，但调用自己的时候，已经不再需要上一个函数的环境了。 123456function factorial(n,a)&#123; if(n&lt;=0) return 0; if(n == 1) return a; return factorial(n-1,a*n); 相比较之前一般形式的递归代码，有两个不同的地方： 递归调用时，把 n 当做参数传给了递归函数，无需等待递归调用返回后参与计算。 最终的计算结果在最后一次递归调用后产生，无需回溯。 我们通过这种形式，解决了需要函数回跳才能计算的问题，但最后产生的计算结果仍然需要层层的回调，但这种代码的形式对于普通的递归来说，编译器更容易对其进行优化。这种特殊的递归叫做尾递归，从递归代码形式上看，它自身的调用是函数的最后一个操作。尾递归的目的是为了优化，而优化的目标是减少栈的空间。 尾递归是递归的一种优化 按照尾递归的定义，尾递归就至少必须解决一般递归的两个问题： 不能重复计算 重复利用栈空间 然而尾递归是为编译器优化的目的，所以还要依赖于编译器的实现，如果一种语言不支持尾递归，那么尾递归也就仅仅是个形式上递归了，JavaScript 就是这样的语言，因为它无法优化栈空间的利用。 实际上尾递归一直被看作一种编译技巧，特别是对于函数式编程语言来说，尾递归的编译器实现做当做的一种必须的标准 es6 中的尾调用优化尾调用被识别出来，重复利用了已存在的栈结构来进行递归，移除了之前函数调用的本地变量和状态。 如果使用了BABEL，它会直接、自递归地处理尾调用。 爆栈问题解决递归改循环","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"变量的解构赋值","slug":"变量的解构赋值","date":"2018-07-16T04:05:20.000Z","updated":"2019-03-19T13:43:53.897Z","comments":true,"path":"2018/07/16/变量的解构赋值/","link":"","permalink":"http://yoursite.com/2018/07/16/变量的解构赋值/","excerpt":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。","text":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 解构不成功如果解构不成功，变量的值就等于 undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo 的值都会等于 undefined。 不完全解构等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x; // 1y; // 2let [a, [b], d] = [1, [2, 3], 4];a; // 1b; // 2d; // 4 等号右边不是数组如果等号的右边不是数组，那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo; // truelet [x, y = \"b\"] = [\"a\"]; // x='a', y='b'let [x, y = \"b\"] = [\"a\", undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效。null 不严格等于 undefined。所以，如果数组成员是 null，默认值则不会生效。 12345let [x = 1] = [undefined];x; // 1let [x = 1] = [null];x; // null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1let [x = y, y = 1] = []; // ReferenceError: y is not defined 上式之所以会报错，是因为 x 用 y 做默认值时，y 还没有声明。 对象的解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1234567891011121314let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\"bar; // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // undefinedlet &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"let obj = &#123; first: \"hello\", last: \"world\" &#125;;let &#123; first: f, last: l &#125; = obj;f; // 'hello'l; // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"foo; // error: foo is not defined 上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。 解构失败如果解构失败，变量的值等于 undefined。 12let &#123; foo &#125; = &#123; bar: \"baz\" &#125;;foo; // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 1234// 报错let &#123; foo: &#123; bar &#125;&#125; = &#123; baz: \"baz\" &#125;; 上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因为 foo 这时等于 undefined，再取子属性就会报错。 默认值对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于 undefined。 12345var &#123; x = 3 &#125; = &#123; x: undefined &#125;;x; // 3var &#123; x = 3 &#125; = &#123; x: null &#125;;x; // null 上面代码中，属性 x 等于 null，因为 null 与 undefined 不严格相等，所以是个有效的赋值，导致默认值 3 不会生效。 字符串的解构赋值字符串被转换成了一个类似数组的对象。 123456789const [a, b, c, d, e] = \"hello\";a; // \"h\"b; // \"e\"c; // \"l\"d; // \"l\"e; // \"o\"let &#123; length: len &#125; = \"hello\";len; // 5 数值和布尔值的解构赋值等号右边是数值和布尔值，则会先转为对象。解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值1234567function add([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。 12345678function move(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"var，let和const声明及区别","slug":"var，let和const声明及区别","date":"2018-07-04T03:29:59.000Z","updated":"2018-07-27T03:57:38.924Z","comments":true,"path":"2018/07/04/var，let和const声明及区别/","link":"","permalink":"http://yoursite.com/2018/07/04/var，let和const声明及区别/","excerpt":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。","text":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。例如：123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 事实上，在预编译阶段，JavaScript引擎会将上面的函数修改为下面这样：12345678910111213fuction getValue(condition)&#123; var value; if(condition)&#123; value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 变量value的声明会被提升至函数顶部，而初始化操作依然留在原处执行。这样，就意味着，在函数的其他部分，else子句中或者if-else外，也能访问到value变量，而由于此时value变量并未被初始化赋值，所以访问到值为undefined。 块级声明ES6中引入块级作用域来强化对变量生命周期的控制。块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（词法作用域）存在于： 函数内部 块中（字符{和}之间的区域） let声明let声明的用法与var相同。用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。let声明不会被提升，因此通常将let声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //变量value在此处不存在 return null; &#125; //变量value在此处不存在&#125; let声明后，不会被提升至函数顶部。因此执行流离开if块之后，value立刻被销毁，如果condition的值为false，就永远不会声明并初始化value。并且，假设作用域中已经存在了某个标识符，此时再用let关键字声明它，就会抛出错误： 123var count=30;//抛出语法错误let count=40; 在同一作用域中不能用let重复定义已经存在的标识符，所以此处使用let声明会抛出错误。但如果当前作用域内内嵌另一个作用域，就可在内嵌的作用域中使用let声明同名变量。 例如： 12345var count=30;if(condition)&#123; //不会抛出错误 let count=40;&#125; 此时，if内部块中的count会遮蔽全局作用域中的count，而var声明的count只能在if块外访问到。 const声明使用const声明的是常量，其值一旦被设定后不可更改。因此每个通过const声明的常量必须在声明的同时被初始化。12345//有效的常量const max=30;//语法错误，常量未初始化const name; const和let声明都是块级标识符，所以常量也只在当前的代码块内有效，一旦执行到代码块外会被立即销毁。并且，常量也不会被提升至作用域顶部。同样，与let相似，在同一作用域用const声明已经存在的标识符，也会导致语法错误。 如上所述，const定义的值一旦被设定后不可更改，无论在严格模式还是非严格模式下，都不可以为const定义的常量再赋值，否则会抛出语法错误：123const max=50;//抛出语法错误max=30; 然而，与其他语言中的常量不同的是，JavaScript中的常量，如果是对象，则对象的值可以修改，也就是const声明不允许修改绑定，但允许修改值这也意味着，const声明对象后，可以修改对象的属性。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。1234567891011const person=&#123; name:\"Nicholas\";&#125;;//可以修改对象属性的值person.name=\"Greg\";//抛出语法错误person=&#123; name:\"Greg\";&#125;; 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 临时死区（Temporal Dead Zone）临时死区常被描述let和const的不提升的效果。JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到var声明时），要么将声明放到TDZ中（遇到let和const声明时）。访问TDZ中的变量会触发运行错误。只有在执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。1234if(condition)&#123; console.log(typeof value);//引用错误！ let value=\"blue\";&#125; 但在let声明的作用域外对该变量使用typeof则不会报错：12345console.log(typeof value); //\"undefined\"if(condition)&#123; let value=\"blue\";&#125; typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中，也就意味着不存在value这个绑定，typeof操作最终返回”undefined”。 循环中的块级作用域绑定先看这段代码：1234567891011var funcs=[];for(var i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出10次数字10&#125;); 预想结果是输出数字0～9，但是因为循环里的每次迭代同时共享着i，循环内部创建的函数全部都保存了对相同变量的引用。循环结束时变量i的值为10，所以每次调用console.log（i）时都会输出数字10。而使用let声明，每次迭代循环都会创建一个新变量，并以之前的迭代中同名变量的值将其初始化，得到预期的效果。1234567891011var funcs=[];for(let i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出0，1，2，……，9&#125;); 当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。const也是同样，但在循环中不能修改const声明的变量，否则会抛出错误。 全局作用域绑定当var被用在全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。这意味着，用var很可能会无意中覆盖一个已经存在的全局属性。例如：123//在浏览器中var RegExp=\"Hello!\";console.log(window.RegExp); //\"Hello!\" 全局对象定义在RegExp定义在window上，但不能幸免被var覆盖，成为window的属性。但如果在全局作用域中使用let或者const，会在全局作用域下创建一个新的绑定，但该绑定不会添加全局对象的属性。用let或const不能覆盖全局变量，只能遮蔽它。1234//在浏览器中let RegExp=\"Hello!\";console.log(RegExp); //\"Hello!\"console.log(window.RegExp===RegExp); //false 这里let声明的RegExp创建了一个绑定并遮蔽了全局的RegExp变量，但window.RegExp和RegExp并不相同，说明它不会破坏全局作用域，不会为全局对象创建属性。 ES6声明变量的六种方法ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]}