{"meta":{"title":"01不是包子脸","subtitle":"小01的程序猿成长之路","description":null,"author":"Linyi Li","url":"http://yoursite.com"},"pages":[{"title":"About","date":"2018-06-20T16:00:00.000Z","updated":"2019-04-07T08:28:59.618Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 ProfileCease to struggle and you cease to live. 大家好，我是『01』。一个不承认自己是包子脸的小仙女～哈哈哈哈～ 作为一只程序猿，虽然我比较菜，但是我在努力成长啊。这个博客，想记录一路走来的点点滴滴。 希望我们，都能有自己的一技之长，能在社会上的某个方面成为独当一面的佼佼者。 生命不止，奋斗不息。 Social Info : 01 : 01"},{"title":"Categories","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:37:46.747Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:36:30.431Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"QUIC","slug":"QUIC","date":"2019-08-15T17:52:20.000Z","updated":"2019-08-15T17:52:43.196Z","comments":true,"path":"2019/08/16/QUIC/","link":"","permalink":"http://yoursite.com/2019/08/16/QUIC/","excerpt":"QUICQUIC 概述Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。 QUIC 协议内置了 TLS 栈，实现了自己的传输加密层，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的：","text":"QUICQUIC 概述Quic 全称 quick udp internet connection [1]，“快速 UDP 互联网连接”，（和英文 quick 谐音，简称“快”）是由 google 提出的使用 udp 进行多路并发传输的协议。 QUIC 协议内置了 TLS 栈，实现了自己的传输加密层，而没有使用现有的 TLS 1.2。同时 QUIC 还包含了部分 HTTP/2 的实现，因此 QUIC 的地位看起来是这样的： 从图上可以看出，QUIC 底层通过 UDP 协议替代了 TCP，上层只需要一层用于和远程服务器交互的 HTTP/2 API。这是因为 QUIC 协议已经包含了多路复用和连接管理，HTTP API 只需要完成 HTTP 协议的解析即可。 QUIC 优势 减少了 TCP 三次握手及 TLS 握手时间。 改进的拥塞控制。 避免队头阻塞的多路复用。 连接迁移。 前向冗余纠错。（目前默认的冗余量是 10%，既每发送 10 个数据包，其冗余数据就可以重新构建一个丢失的数据包） 为什么需要 QUIC 协议历史悠久导致中间设备僵化。 TCP 协议本来是支持端口、选项及特性的增加和修改。但是由于 TCP 协议和知名端口（80、443）及选项使用的历史太悠久，中间设备已经依赖于这些潜规则，所以对这些内容的修改很容易遭到中间环节的干扰而失败。 依赖于操作系统的实现导致协议本身僵化。 TCP 是由操作系统在内核西方栈层面实现的，应用程序只能使用，不能直接修改。虽然应用程序的更新迭代非常快速和简单。但是 TCP 的迭代却非常缓慢，原因就是操作系统升级很麻烦。服务端系统不依赖用户升级，但是由于操作系统升级涉及到底层软件和运行库的更新，所以也比较保守和缓慢。 建立连接的握手延迟大。 不管是 HTTP1.0/1.1 还是 HTTPS，HTTP2，都使用了 TCP 进行传输。HTTPS 和 HTTP2 还需要使用 TLS 协议来进行安全传输。这就出现了两个握手延迟： TCP 三次握手导致的 TCP 连接建立的延迟。 TLS 完全握手需要至少 2 个 RTT 才能建立，简化握手需要 1 个 RTT 的握手延迟。 对于很多短连接场景，这样的握手延迟影响很大，且无法消除。 队头阻塞。 队头阻塞主要是 TCP 协议的可靠性机制引入的。TCP 使用序列号来标识数据的顺序，数据必须按照顺序处理，如果前面的数据丢失，后面的数据就算到达了也不会通知应用层来处理。 另外 TLS 协议层面也有一个队头阻塞，因为 TLS 协议都是按照 record 来处理数据的，如果一个 record 中丢失了数据，也会导致整个 record 无法正确处理。 QUIC 协议选择了 UDP，因为 UDP 本身没有连接的概念，不需要三次握手，优化了连接建立的握手延迟，同时在应用程序层面实现了 TCP 的可靠性，TLS 的安全性和 HTTP2 的并发性，只需要用户端和服务端的应用程序支持 QUIC 协议，完全避开了操作系统和中间设备的限制。 QUIC 详解1. QUIC 核心特性连接建立延时低0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势。那什么是 0RTT 建连呢？这里面有两层含义。 传输层 0RTT 就能建立连接。 加密层 0RTT 就能建立加密连接。 比如上图左边是 HTTPS 的一次完全握手的建连过程，需要 3 个 RTT。就算是 Session Resumption[14]，也需要至少 2 个 RTT。 而 QUIC 呢？由于建立在 UDP 的基础上，同时又实现了 0RTT 的安全握手，所以在大部分情况下，只需要 0 个 RTT 就能实现数据发送，在实现前向加密的基础上，并且 0RTT 的成功率相比 TLS 的 Sesison Ticket[13] 要高很多。 2. 改进的拥塞控制TCP 的拥塞控制实际上包含了四个算法：慢启动，拥塞避免，快速重传，快速恢复。 QUIC 协议当前默认使用了 TCP 协议的 Cubic 拥塞控制算法，同时也支持 CubicBytes, Reno, RenoBytes, BBR, PCC 等拥塞控制算法。 从拥塞算法本身来看，QUIC 只是按照 TCP 协议重新实现了一遍，那么 QUIC 协议到底改进在哪些方面呢？主要有如下几点： 可插拔 什么叫可插拔呢？就是能够非常灵活地生效，变更和停止。体现在如下方面： 应用程序层面就能实现不同的拥塞控制算法，不需要操作系统，不需要内核支持。这是一个飞跃，因为传统的 TCP 拥塞控制，必须要端到端的网络协议栈支持，才能实现控制效果。而内核和操作系统的部署成本非常高，升级周期很长，这在产品快速迭代，网络爆炸式增长的今天，显然有点满足不了需求。 即使是单个应用程序的不同连接也能支持配置不同的拥塞控制。就算是一台服务器，接入的用户网络环境也千差万别，结合大数据及人工智能处理，我们能为各个用户提供不同的但又更加精准更加有效的拥塞控制。比如 BBR 适合，Cubic 适合。 应用程序不需要停机和升级就能实现拥塞控制的变更，我们在服务端只需要修改一下配置，reload 一下，完全不需要停止服务就能实现拥塞控制的切换。 STGW 在配置层面进行了优化，我们可以针对不同业务，不同网络制式，甚至不同的 RTT，使用不同的拥塞控制算法。 单调递增的 Packet Number TCP 为了保证可靠性，使用了基于字节序号的 Sequence Number 及 Ack 来确认消息的有序到达。 QUIC 同样是一个可靠的协议，它使用 Packet Number 代替了 TCP 的 sequence number，并且每个 Packet Number 都严格递增，也就是说就算 Packet N 丢失了，重传的 Packet N 的 Packet Number 已经不是 N，而是一个比 N 大的值。而 TCP 呢，重传 segment 的 sequence number 和原始的 segment 的 Sequence Number 保持不变，也正是由于这个特性，引入了 Tcp 重传的歧义问题。 ​ 图 2 Tcp 重传歧义性 如上图所示，超时事件 RTO 发生后，客户端发起重传，然后接收到了 Ack 数据。由于序列号一样，这个 Ack 数据到底是原始请求的响应还是重传请求的响应呢？不好判断。 如果算成原始请求的响应，但实际上是重传请求的响应（上图左），会导致采样 RTT 变大。如果算成重传请求的响应，但实际上是原始请求的响应，又很容易导致采样 RTT 过小。 由于 Quic 重传的 Packet 和原始 Packet 的 Pakcet Number 是严格递增的，所以很容易就解决了这个问题。 ​ 图 3 Quic 重传没有歧义性 如上图所示，RTO 发生后，根据重传的 Packet Number 就能确定精确的 RTT 计算。如果 Ack 的 Packet Number 是 N+M，就根据重传请求计算采样 RTT。如果 Ack 的 Pakcet Number 是 N，就根据原始请求的时间计算采样 RTT，没有歧义性。 但是单纯依靠严格递增的 Packet Number 肯定是无法保证数据的顺序性和可靠性。QUIC 又引入了一个 Stream Offset 的概念。 即一个 Stream 可以经过多个 Packet 传输，Packet Number 严格递增，没有依赖。但是 Packet 里的 Payload 如果是 Stream 的话，就需要依靠 Stream 的 Offset 来保证应用数据的顺序。如错误! 未找到引用源。所示，发送端先后发送了 Pakcet N 和 Pakcet N+1，Stream 的 Offset 分别是 x 和 x+y。 假设 Packet N 丢失了，发起重传，重传的 Packet Number 是 N+2，但是它的 Stream 的 Offset 依然是 x，这样就算 Packet N + 2 是后到的，依然可以将 Stream x 和 Stream x+y 按照顺序组织起来，交给应用程序处理。 ​ 图 4 Stream Offset 保证有序性 不允许 Reneging 什么叫 Reneging 呢？就是接收方丢弃已经接收并且上报给 SACK 选项的内容。TCP 协议不鼓励这种行为，但是协议层面允许这样的行为。主要是考虑到服务器资源有限，比如 Buffer 溢出，内存不够等情况。 Reneging 对数据重传会产生很大的干扰。因为 Sack 都已经表明接收到了，但是接收端事实上丢弃了该数据。 QUIC 在协议层面禁止 Reneging，一个 Packet 只要被 Ack，就认为它一定被正确接收，减少了这种干扰。 更多的 Ack 块 TCP 的 Sack 选项能够告诉发送方已经接收到的连续 Segment 的范围，方便发送方进行选择性重传。 由于 TCP 头部最大只有 60 个字节，标准头部占用了 20 字节，所以 Tcp Option 最大长度只有 40 字节，再加上 Tcp Timestamp option 占用了 10 个字节 [25]，所以留给 Sack 选项的只有 30 个字节。 每一个 Sack Block 的长度是 8 个，加上 Sack Option 头部 2 个字节，也就意味着 Tcp Sack Option 最大只能提供 3 个 Block。 但是 Quic Ack Frame 可以同时提供 256 个 Ack Block，在丢包率比较高的网络下，更多的 Sack Block 可以提升网络的恢复速度，减少重传量。 Ack Delay 时间 Tcp 的 Timestamp 选项存在一个问题，它只是回显了发送方的时间戳，但是没有计算接收端接收到 segment 到发送 Ack 该 segment 的时间。这个时间可以简称为 Ack Delay。 这样就会导致 RTT 计算误差。如下图： 可以认为 TCP 的 RTT 计算： 而 Quic 计算如下： 当然 RTT 的具体计算没有这么简单，需要采样，参考历史数值进行平滑计算，参考如下公式 [9]。 3.基于 stream 和 connecton 级别的流量控制QUIC 的流量控制类似 HTTP2，即在 Connection 和 Stream 级别提供了两种流量控制。为什么需要两类流量控制呢？主要是因为 QUIC 支持多路复用。 Stream 可以认为就是一条 HTTP 请求。 Connection 可以类比一条 TCP 连接。多路复用意味着在一条 Connetion 上会同时存在多条 Stream。既需要对单个 Stream 进行控制，又需要针对所有 Stream 进行总体控制。 QUIC 实现流量控制的原理比较简单： 通过 window_update 帧告诉对端自己可以接收的字节数，这样发送方就不会发送超过这个数量的数据。 通过 BlockFrame 告诉对端由于流量控制被阻塞了，无法发送数据。 QUIC 的流量控制和 TCP 有点区别，TCP 为了保证可靠性，窗口左边沿向右滑动时的长度取决于已经确认的字节数。如果中间出现丢包，就算接收到了更大序号的 Segment，窗口也无法超过这个序列号。 但 QUIC 不同，就算此前有些 packet 没有接收到，它的滑动只取决于接收到的最大偏移字节数。 ​ 图 5 Quic Flow Control 针对 Stream： 针对 Connection： 同样地，STGW 也在连接和 Stream 级别设置了不同的窗口数。 最重要的是，我们可以在内存不足或者上游处理性能出现问题时，通过流量控制来限制传输速率，保障服务可用性。 4.没有队头阻塞的多路复用QUIC 的多路复用和 HTTP2 类似。在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (stream)。但是 QUIC 的多路复用相比 HTTP2 有一个很大的优势。 QUIC 一个连接上的多个 stream 之间没有依赖。这样假如 stream2 丢了一个 udp packet，也只会影响 stream2 的处理。不会影响 stream2 之前及之后的 stream 的处理。 这也就在很大程度上缓解甚至消除了队头阻塞的影响。 多路复用是 HTTP2 最强大的特性，能够将多条请求在一条 TCP 连接上同时发出去。但也恶化了 TCP 的一个问题，队头阻塞，如下图示： ​ 图 6 HTTP2 队头阻塞 HTTP2 在一个 TCP 连接上同时发送 4 个 Stream。其中 Stream1 已经正确到达，并被应用层读取。但是 Stream2 的第三个 tcp segment 丢失了，TCP 为了保证数据的可靠性，需要发送端重传第 3 个 segment 才能通知应用层读取接下去的数据，虽然这个时候 Stream3 和 Stream4 的全部数据已经到达了接收端，但都被阻塞住了。 不仅如此，由于 HTTP2 强制使用 TLS，还存在一个 TLS 协议层面的队头阻塞 [12]。 ​ 图 7 TLS 队头阻塞 Record 是 TLS 协议处理的最小单位，最大不能超过 16K，一些服务器比如 Nginx 默认的大小就是 16K。由于一个 record 必须经过数据一致性校验才能进行加解密，所以一个 16K 的 record，就算丢了一个字节，也会导致已经接收到的 15.99K 数据无法处理，因为它不完整。 那 QUIC 多路复用为什么能避免上述问题呢？ QUIC 最基本的传输单元是 Packet，不会超过 MTU 的大小，整个加密和认证过程都是基于 Packet 的，不会跨越多个 Packet。这样就能避免 TLS 协议存在的队头阻塞。 Stream 之间相互独立，比如 Stream2 丢了一个 Pakcet，不会影响 Stream3 和 Stream4。不存在 TCP 队头阻塞。（QUIC 协议直接通过底层使用 UDP 协议天然的避免了该问题。由于 UDP 协议没有严格的顺序，当一个数据包遇到问题需要重传时，只会影响该数据包对应的资源，其他独立的资源（如其他 css、js 文件）不会受到影响） ​ 图 8 QUIC 多路复用时没有队头阻塞的问题 当然，并不是所有的 QUIC 数据都不会受到队头阻塞的影响，比如 QUIC 当前也是使用 Hpack 压缩算法 [10]，由于算法的限制，丢失一个头部数据时，可能遇到队头阻塞。 总体来说，QUIC 在传输大量数据时，比如视频，受到队头阻塞的影响很小。 5.加密认证的报文TCP 协议头部没有经过任何加密和认证，所以在传输过程中很容易被中间网络设备篡改，注入和窃听。比如修改序列号、滑动窗口。这些行为有可能是出于性能优化，也有可能是主动攻击。 但是 QUIC 的 packet 可以说是武装到了牙齿。除了个别报文比如 PUBLIC_RESET 和 CHLO，所有报文头部都是经过认证的，报文 Body 都是经过加密的。 这样只要对 QUIC 报文任何修改，接收端都能够及时发现，有效地降低了安全风险。 如下图所示，红色部分是 Stream Frame 的报文头部，有认证。绿色部分是报文内容，全部经过加密。 6.连接迁移一条 TCP 连接是由四元组标识的（源 IP，源端口，目的 IP，目的端口）。什么叫连接迁移呢？就是当其中任何一个元素发生变化时，这条连接依然维持着，能够保持业务逻辑不中断。当然这里面主要关注的是客户端的变化，因为客户端不可控并且网络环境经常发生变化，而服务端的 IP 和端口一般都是固定的。 比如大家使用手机在 WIFI 和 4G 移动网络切换时，客户端的 IP 肯定会发生变化，需要重新建立和服务端的 TCP 连接。 又比如大家使用公共 NAT 出口时，有些连接竞争时需要重新绑定端口，导致客户端的端口发生变化，同样需要重新建立 TCP 连接。 针对 TCP 的连接变化，MPTCP 其实已经有了解决方案，但是由于 MPTCP 需要操作系统及网络协议栈支持，部署阻力非常大，目前并不适用。 所以从 TCP 连接的角度来讲，这个问题是无解的。 那 QUIC 是如何做到连接迁移呢？很简单，任何一条 QUIC 连接不再以 IP 及端口四元组标识，而是以一个 64 位的随机数作为 ID 来标识，这样就算 IP 或者端口发生变化时，只要 ID 不变，这条连接依然维持着，上层业务逻辑感知不到变化，不会中断，也就不需要重连。 由于这个 ID 是客户端随机产生的，并且长度有 64 位，所以冲突概率非常低。 7.其他亮点此外，QUIC 还能实现前向冗余纠错，在重要的包比如握手消息发生丢失时，能够根据冗余信息还原出握手消息。 QUIC 还能实现证书压缩，减少证书传输量，针对包头进行验证等。 QUIC 协议实践Chrome 浏览器从 2014 年开始已经实验性的支持了 QUIC 协议。可以通过在 Chrome 浏览器中输入chrome://net-internals/#quic查看是否已经支持 QUIC 协议。如果还未支持，可以在chrome://flags/#enable-quic中进行开启。 开始 Chrome 浏览器对 QUIC 协议的支持之后，可以在chrome://net-internals/#quic中查看到当前浏览器的 QUIC 一些连接。当然目前只有 Google 服务才支持 QUIC 协议（如 YouTube、 Google.com）。 1. 关于防火墙通常系统管理员会关注防火墙的 TCP 规则，而忽略 UDP 规则。如果要在防火墙之后使用 QUIC 协议，除了传统 web 服务需要开放的80/TCP、443/TCP之外，针对 QUIC 还需要开放443/UDP的访问。 2.服务端使用 QUIC 协议目前支持 QUIC 协议的 web 服务只有 0.9 版本以后的Caddy。其他常用 web 服务如 nginx、apache 等都未开始支持。curl 表达了对 QUIC 协议支持的兴趣。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"TCP","slug":"TCP","date":"2019-08-11T13:15:33.000Z","updated":"2019-08-15T17:34:10.586Z","comments":true,"path":"2019/08/11/TCP/","link":"","permalink":"http://yoursite.com/2019/08/11/TCP/","excerpt":"TCP TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment） IP 在第三层——Network 层（在第三层上的数据叫 Packet） ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame） 我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。","text":"TCP TCP 在网络 OSI 的七层模型中的第四层——Transport 层（第四层的数据叫 Segment） IP 在第三层——Network 层（在第三层上的数据叫 Packet） ARP 在第二层——Data Link 层（在第二层上的数据叫 Frame） 我们程序的数据首先会打到 TCP 的 Segment 中，然后 TCP 的 Segment 会打到 IP 的 Packet 中，然后再打到以太网 Ethernet 的 Frame 中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。 TCP 头格式 你需要注意这么几点： TCP 的包是没有 IP 地址的，那是 IP 层上的事。但是有源端口和目标端口。 一个 TCP 连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说 TCP 协议，所以，这里我只说四元组。 注意上图中的四个非常重要的东西： Sequence Number是包的序号，用来解决网络包乱序（reordering）问题。 Acknowledgement Number就是 ACK——用于确认收到，用来解决不丢包的问题。 Window 又叫 Advertised-Window，也就是著名的滑动窗口（Sliding Window），用于解决流控的。 TCP Flag ，也就是包的类型，主要是用于操控 TCP 的状态机的。 TCP 状态机其实，网络上的传输是没有连接的，包括 TCP 也是一样的。而 TCP 所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP 的状态变换是非常重要的。 “TCP 协议的状态机”和 “TCP 建链接”、“TCP 断链接”、“传数据” 的对照图 很多人会问，为什么建链接要 3 次握手，断链接需要 4 次挥手？ 对于建链接的 3 次握手，主要是要初始化 Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的 Sequence Number（缩写为 ISN：Inital Sequence Number）——所以叫 SYN，全称 Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP 会用这个序号来拼接数据）。 对于 4 次挥手，其实你仔细看是 2 次，因为 TCP 是全双工的，所以，发送方和接收方都需要 Fin 和 Ack。只不过，有一方是被动的，所以看上去就成了所谓的 4 次挥手。如果两边同时断连接，那就会就进入到 CLOSING 状态，然后到达 TIME_WAIT 状态。下图是双方同时断连接的示意图（你同样可以对照着 TCP 状态机看）： 数据传输中的 Sequence Number下图是从 Wireshark 中截了个我在访问 coolshell.cn 时的有数据传输的图给你看一下，SeqNum 是怎么变的。（使用 Wireshark 菜单中的 Statistics -&gt;Flow Graph… ） 你可以看到，SeqNum 的增加是和传输的字节数相关的。上图中，三次握手后，来了两个 Len:1440 的包，而第二个包的 SeqNum 就成了 1441。然后第一个 ACK 回的是 1441，表示第一个 1440 收到了。 注意：如果你用 Wireshark 抓包程序看 3 次握手，你会发现 SeqNum 总是为 0，不是这样的，Wireshark 为了显示更友好，使用了 Relative SeqNum——相对序号，你只要在右键菜单中的 protocol preference 中取消掉就可以看到“Absolute SeqNum”了 TCP 重传机制TCP 要保证所有的数据包都可以到达，所以，必需要有重传机制。 注意，接收端给发送端的 Ack 确认只会确认最后一个连续的包，比如，发送端发了 1,2,3,4,5 一共五份数据，接收端收到了 1，2，于是回 ack 3，然后收到了 4（注意此时 3 没收到），此时的 TCP 会怎么办？我们要知道，因为正如前面所说的，SeqNum 和 Ack 是以字节数为单位，所以 ack 的时候，不能跳着确认，只能确认最大的连续收到的包，不然，发送端就以为之前的都收到了。 超时重传机制一种是不回 ack，死等 3，当发送方发现收不到 3 的 ack 超时后，会重传 3。一旦接收方收到 3 后，会 ack 回 4——意味着 3 和 4 都收到了。 但是，这种方式会有比较严重的问题，那就是因为要死等 3，所以会导致 4 和 5 即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到 Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致 4 和 5 的重传。 对此有两种选择： 一种是仅重传 timeout 的包。也就是第 3 份数据。 另一种是重传 timeout 后所有的数据，也就是第 3，4，5 这三份数据。 这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等 timeout，timeout 可能会很长（在下篇会说 TCP 是怎么动态地计算出 timeout 的） 快速重传机制于是，TCP 引入了一种叫Fast Retransmit 的算法，不以时间驱动，而以数据驱动重传。也就是说，如果，包没有连续到达，就 ack 最后那个可能被丢了的包，如果发送方连续收到 3 次相同的 ack，就重传。Fast Retransmit 的好处是不用等 timeout 了再重传。 比如：如果发送方发出了 1，2，3，4，5 份数据，第一份先到送了，于是就 ack 回 2，结果 2 因为某些原因没收到，3 到达了，于是还是 ack 回 2，后面的 4 和 5 都到了，但是还是 ack 回 2，因为 2 还是没有收到，于是发送端收到了三个 ack=2 的确认，知道了 2 还没有到，于是就马上重转 2。然后，接收端收到了 2，此时因为 3，4，5 都收到了，于是 ack 回 6。示意图如下： Fast Retransmit 只解决了一个问题，就是 timeout 的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2 呢还是重传#2，#3，#4，#5 呢？因为发送端并不清楚这连续的 3 个 ack(2)是谁传回来的？也许发送端发了 20 份数据，是#6，#10，#20 传来的呢。这样，发送端很有可能要重传从 2 到 20 的这堆数据（这就是某些 TCP 的实际的实现）。可见，这是一把双刃剑。 SACK 方法另外一种更好的方式叫：Selective Acknowledgment (SACK)（参看RFC 2018），这种方式需要在 TCP 头里加一个 SACK 的东西，ACK 还是 Fast Retransmit 的 ACK，SACK 则是汇报收到的数据碎版。参看下图： 这样，在发送端就可以根据回传的 SACK 来知道哪些数据到了，哪些没有到。于是就优化了 Fast Retransmit 的算法。当然，这个协议需要两边都支持。在 Linux 下，可以通过tcp_sack参数打开这个功能（Linux 2.4 后默认打开）。 这里还需要注意一个问题——接收方 Reneging，所谓 Reneging 的意思就是接收方有权把已经报给发送端 SACK 里的数据给丢了。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。所以，发送方也不能完全依赖 SACK，还是要依赖 ACK，并维护 Time-Out，如果后续的 ACK 没有增长，那么还是要把 SACK 的东西重传，另外，接收端这边永远不能把 SACK 的包标记为 Ack。 注意：SACK 会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆 SACK 的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。 Duplicate SACK – 重复收到数据的问题Duplicate SACK 又称 D-SACK，其主要使用了 SACK 来告诉发送方有哪些数据被重复接收了。RFC-2883 里有详细描述和示例。下面举几个例子（来源于RFC-2883） D-SACK 使用了 SACK 的第一个段来做标志， 如果 SACK 的第一个段的范围被 ACK 所覆盖，那么就是 D-SACK 如果 SACK 的第一个段的范围被 SACK 的第二个段覆盖，那么就是 D-SACK 示例一：ACK 丢包下面的示例中，丢了两个 ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个 SACK=3000-3500，因为 ACK 都到了 4000 意味着收到了 4000 之前的所有数据，所以这个 SACK 就是 D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是 ACK 包。 123456Transmitted Received ACK SentSegment Segment (Including SACK Blocks)3000-3499 3000-3499 3500 (ACK dropped)3500-3999 3500-3999 4000 (ACK dropped)3000-3499 3000-3499 4000, SACK=3000-3500 --------- 示例二，网络延误下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到 ACK，而后面到达的三个包触发了“Fast Retransmit 算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个 SACK=1000-1500，因为 ACK 已到了 3000，所以，这个 SACK 是 D-SACK——标识收到了重复的包。 这个案例下，发送端知道之前因为“Fast Retransmit 算法”触发的重传不是因为发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延时了。 12345678910Transmitted Received ACK SentSegment Segment (Including SACK Blocks)500-999 500-999 10001000-1499 (delayed)1500-1999 1500-1999 1000, SACK=1500-20002000-2499 2000-2499 1000, SACK=1500-25002500-2999 2500-2999 1000, SACK=1500-30001000-1499 1000-1499 3000 1000-1499 3000, SACK=1000-1500 --------- 可见，引入了 D-SACK，有这么几个好处： 1）可以让发送方知道，是发出去的包丢了，还是回来的 ACK 包丢了。 2）是不是自己的 timeout 太小了，导致重传。 3）网络上出现了先发的包后到的情况（又称 reordering） 4）网络上是不是把我的数据包给复制了。 知道这些东西可以很好得帮助 TCP 了解网络情况，从而可以更好的做网络上的流控。 Linux 下的 tcp_dsack 参数用于开启这个功能（Linux 2.4 后默认打开） TCP 的 RTT 算法从前面的 TCP 重传机制我们知道 Timeout 的设置对于重传非常重要。 设长了，重发就慢，丢了老半天才重发，没有效率，性能差； 设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。 而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP 引入了 RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置 Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下 t0，然后接收端再把这个 ack 回来时再记一个 t1，于是 RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。 经典算法RFC793 中定义的经典算法是这样的： 1）首先，先采样 RTT，记下最近好几次的 RTT 值。 2）然后做平滑计算 SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在 0.8 到 0.9 之间，这个算法英文叫 Exponential weighted moving average，中文叫：加权移动平均） SRTT = ( α * SRTT ) + ((1- α) * RTT) 3）开始计算 RTO。公式如下： RTO = min [ UBOUND, max [ LBOUND, (β * SRTT) ] ] 其中： UBOUND 是最大的 timeout 时间，上限值 LBOUND 是最小的 timeout 时间，下限值 β 值一般在 1.3 到 2.0 之间。 Karn / Partridge 算法但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和 ack 回来的时间做 RTT 样本值，还是用重传的时间和 ACK 回来的时间做 RTT 样本值？ 这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示： 情况（a）是 ack 没回来，所以重传。如果你计算第一次发送和 ACK 的时间，那么，明显算大了。 情况（b）是 ack 回来慢了，但是导致了重传，但刚重传不一会儿，之前 ACK 就回来了。如果你是算重传的时间和 ACK 回来的时间的差，就会算短了。 所以 1987 年的时候，搞了一个叫Karn / Partridge Algorithm，这个算法的最大特点是——忽略重传，不把重传的 RTT 做采样（你看，你不需要去解决不存在的问题）。 但是，这样一来，又会引发一个大 BUG——如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的 RTO 很小），于是，因为重转的不算，所以，RTO 就不会被更新，这是一个灾难。 于是 Karn 算法用了一个取巧的方式——只要一发生重传，就对现有的 RTO 值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的 RTT 也不靠谱。 Jacobson / Karels 算法前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果 RTT 有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988 年，又有人推出来了一个新的算法，这个算法叫 Jacobson / Karels Algorithm（参看RFC6289）。这个算法引入了最新的 RTT 的采样和平滑过的 SRTT 的差距做因子来计算。 公式如下：（其中的 DevRTT 是 Deviation RTT 的意思） SRTT = S**RTT** + α (**RTT** – S**RTT**) —— 计算平滑 RTT DevRTT = (1-β**)***DevRTT + β***(|**RTT-SRTT**|)** ——计算平滑 RTT 和真实的差距（加权移动平均） RTO= µ * SRTT + ∂ *DevRTT —— 神一样的公式 （其中：在 Linux 下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的 TCP 协议中（Linux 的源代码在：tcp_rtt_estimator）。 TCP 滑动窗口需要说明一下，如果你不了解 TCP 的滑动窗口这个事，你等于不了解 TCP 协议。我们都知道，TCP 必需要解决的可靠传输以及包乱序（reordering）的问题，所以，TCP 必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。 所以，TCP 引入了一些技术和设计来做网络流控，Sliding Window 是其中一个技术。 前面我们说过，TCP 头里有一个字段叫 Window，又叫 Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。 为了说明滑动窗口，我们需要先看一下 TCP 缓冲区的一些数据结构： 上图中，我们可以看到： 接收端 LastByteRead 指向了 TCP 缓冲区中读到的位置，NextByteExpected 指向的地方是收到的连续包的最后一个位置，LastByteRcved 指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。 发送端的 LastByteAcked 指向了被接收端 Ack 过的位置（表示成功发送确认），LastByteSent 表示发出去了，但还没有收到成功确认的 Ack，LastByteWritten 指向的是上层应用正在写的地方。 于是： 接收端在给发送端回 ACK 中会汇报自己的 AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1; 而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。 下面我们来看一下发送方的滑动窗口示意图： 上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口） #1 已收到 ack 确认的数据。 #2 发还没收到 ack 的。 #3 在窗口中还没有发出的（接收方还有空间）。 #4 窗口以外的数据（接收方没空间） 下面是个滑动后的示意图（收到 36 的 ack，并发出了 46-51 的字节）： 下面我们来看一个接受端控制发送端的图示： Zero Window上图，我们可以看到一个处理缓慢的 Server（接收端）是怎么把 Client（发送端）的 TCP Sliding Window 给降成 0 的。此时，你一定会问，如果 Window 变成 0 了，TCP 会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿 Window size 可用了，怎么通知发送端呢？ 解决这个问题，TCP 使用了 Zero Window Probe 技术，缩写为 ZWP，也就是说，发送端在窗口变成 0 后，会发 ZWP 的包给接收方，让接收方来 ack 他的 Window 尺寸，一般这个值会设置成 3 次，第次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后还是 0 的话，有的 TCP 实现就会发 RST 把链接断了。 注意：只要有等待的地方都可能出现 DDoS 攻击，Zero Window 也不例外，一些攻击者会在和 HTTP 建好链发完 GET 请求后，就把 Window 设置为 0，然后服务端就只能等待进行 ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下Wikipedia 的 SockStress 词条） 另外，Wireshark 中，你可以使用 tcp.analysis.zero_window 来过滤包，然后使用右键菜单里的 follow TCP stream，你可以看到 ZeroWindowProbe 及 ZeroWindowProbeAck 的包。 Silly Window SyndromeSilly Window Syndrome 翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走 Receive Windows 里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的 window，而我们的发送方会义无反顾地发送这几个字节。 要知道，我们的 TCP+IP 头有 40 个字节，为了几个字节，要达上这么大的开销，这太不经济了。 另外，你需要知道网络上有个 MTU，对于以太网来说，MTU 是 1500 字节，除去 TCP+IP 头的 40 个字节，真正的数据传输可以有 1460，这就是所谓的 MSS（Max Segment Size）注意，TCP 的 RFC 定义这个 MSS 的默认值是 536，这是因为 RFC 791里说了任何一个 IP 设备都得最少接收 576 尺寸的大小（实际上来说 576 是拨号的网络的 MTU，而 576 减去 IP 头的 20 个字节就是 536）。 如果你的网络包可以塞满 MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽。（大于 MTU 的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个 MTU 就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。 所以，Silly Windows Syndrome 这个现像就像是你本来可以坐 200 人的飞机里只做了一两个人。 要解决这个问题也不难，就是避免对小的 window size 做出响应，直到有足够大的 window size 再响应，这个思路可以同时实现在 sender 和 receiver 两端。 如果这个问题是由 Receiver 端引起的，那么就会使用 David D Clark’s 方案。在 receiver 端，如果收到的数据导致 window size 小于某个值，可以直接 ack(0)回 sender，这样就把 window 给关闭了，也阻止了 sender 再发数据过来，等到 receiver 端处理了一些数据后 windows size 大于等于了 MSS，或者，receiver buffer 有一半为空，就可以把 window 打开让 send 发送数据过来。 如果这个问题是由 Sender 端引起的，那么就会使用著名的 Nagle’s algorithm。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的 ack 回包，他才会发数据，否则就是在攒数据。 另外，Nagle 算法默认是打开的，所以，对于一些需要小包场景的程序——比如像 telnet 或 ssh 这样的交互性比较强的程序，你需要关闭这个算法。你可以在 Socket 设置 TCP_NODELAY 选项来关闭这个算法（关闭 Nagle 算法没有全局参数，需要根据每个应用自己的特点来关闭） 1setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char*)&amp;value,sizeof(int)); 另外，网上有些文章说 TCP_CORK 的 socket option 是也关闭 Nagle 算法，这不对。TCP_CORK 其实是更新激进的 Nagle 算汉，完全禁止小包发送，而 Nagle 算法没有禁止小包发送，只是禁止了大量的小包发送。最好不要两个选项都设置。 TCP 的拥塞处理 – Congestion Handling上面我们知道了，TCP 通过 Sliding Window 来做流控（Flow Control），但是 TCP 觉得这还不够，因为 Sliding Window 需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP 的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型 4 层以上的事，TCP 的还应该更聪明地知道整个网络上的事。 具体一点，我们知道 TCP 通过一个 timer 采样了 RTT 并计算 RTO，但是，如果网络上的延时突然增加，那么，TCP 对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的 TCP 连接都这么行事，那么马上就会形成“网络风暴”，TCP 这个协议就会拖垮整个网络。这是一个灾难。 所以，TCP 不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此 TCP 的设计理念是：TCP 不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。 拥塞控制主要是四个算法：1）慢启动，2）拥塞避免，3）拥塞发生，4）快速恢复。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注: 1988 年，TCP-Tahoe 提出了 1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传 1990 年，TCP Reno 在 Tahoe 的基础上增加了 4）快速恢复 慢热启动算法 – Slow Start首先，我们来看一下 TCP 的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。 慢启动的算法如下(cwnd 全称 Congestion Window)： 1）连接建好的开始先初始化 cwnd = 1，表明可以传一个 MSS 大小的数据。 2）每当收到一个 ACK，cwnd++; 呈线性上升 3）每当过了一个 RTT，cwnd = cwnd*2; 呈指数让升 4）还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”（后面会说这个算法） 所以，我们可以看到，如果网速很快的话，ACK 也会返回得快，RTT 也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。 一篇 Google 的论文《An Argument for Increasing TCP’s Initial Congestion Window》Linux 3.0 后采用了这篇论文的建议——把 cwnd 初始化成了 10 个 MSS。而 Linux 3.0 以前，比如 2.6，Linux 采用了RFC3390，cwnd 是跟 MSS 的值来变的，如果 MSS&lt; 1095，则 cwnd = 4；如果 MSS&gt;2190，则 cwnd=2；其它情况下，则是 3。 拥塞避免算法 – Congestion Avoidance前面说过，还有一个 ssthresh（slow start threshold），是一个上限，当 cwnd &gt;= ssthresh 时，就会进入“拥塞避免算法”。一般来说 ssthresh 的值是 65535，单位是字节，当 cwnd 达到这个值时后，算法如下： 1）收到一个 ACK 时，cwnd = cwnd + 1/cwnd 2）当每过一个 RTT 时，cwnd = cwnd + 1 这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。 拥塞状态时的算法前面我们说过，当丢包的时候，会有两种情况： 1）等到 RTO 超时，重传数据包。TCP 认为这种情况太糟糕，反应也很强烈。 sshthresh = cwnd /2 cwnd 重置为 1 进入慢启动过程 2）Fast Retransmit 算法，也就是在收到 3 个 duplicate ACK 时就开启重传，而不用等到 RTO 超时。 TCP Tahoe 的实现和 RTO 超时一样。 TCP Reno 的实现是： cwnd = cwnd /2 sshthresh = cwnd 进入快速恢复算法——Fast Recovery 上面我们可以看到 RTO 超时后，sshthresh 会变成 cwnd 的一半，这意味着，如果 cwnd&lt;=sshthresh 时出现的丢包，那么 TCP 的 sshthresh 就会减了一半，然后等 cwnd 又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP 是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。 快速恢复算法 – Fast RecoveryTCP Reno这个算法定义在RFC5681。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有 3 个 Duplicated Acks 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。 注意，正如前面所说，进入 Fast Recovery 之前，cwnd 和 sshthresh 已被更新： cwnd = cwnd /2 sshthresh = cwnd 然后，真正的 Fast Recovery 算法如下： cwnd = sshthresh + 3 * MSS （3 的意思是确认有 3 个数据包被收到了） 重传 Duplicated ACKs 指定的数据包 如果再收到 duplicated Acks，那么 cwnd = cwnd +1 如果收到了新的 Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。 如果你仔细思考一下上面的这个算法，你就会知道，上面这个算法也有问题，那就是——它依赖于 3 个重复的 Acks。注意，3 个重复的 Acks 并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到 RTO 超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成 TCP 的传输速度呈级数下降，而且也不会触发 Fast Recovery 算法了。 通常来说，正如我们前面所说的，SACK 或 D-SACK 的方法可以让 Fast Recovery 或 Sender 在做决定时更聪明一些，但是并不是所有的 TCP 的实现都支持 SACK（SACK 需要两端都支持），所以，需要一个没有 SACK 的解决方案。而通过 SACK 进行拥塞控制的算法是 FACK（后面会讲） TCP New Reno于是，1995 年，TCP New Reno（参见 RFC 6582 ）算法提出来，主要就是在没有 SACK 的支持下改进 Fast Recovery 算法的—— 当 sender 这边收到了 3 个 Duplicated Acks，进入 Fast Retransimit 模式，开发重传重复 Acks 指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的 Ack 会把整个已经被 sender 传输出去的数据 ack 回来。如果没有的话，说明有多个包丢了。我们叫这个 ACK 为 Partial ACK。 一旦 Sender 这边发现了 Partial ACK 出现，那么，sender 就可以推理出来有多个包被丢了，于是乎继续重传 sliding window 里未被 ack 的第一个包。直到再也收不到了 Partial Ack，才真正结束 Fast Recovery 这个过程 我们可以看到，这个“Fast Recovery 的变更”是一个非常激进的玩法，他同时延长了 Fast Retransmit 和 Fast Recovery 的过程。 算法示意图下面我们来看一个简单的图示以同时看一下上面的各种算法的样子： FACK 算法FACK 全称 Forward Acknowledgment 算法，论文地址在这里（PDF）Forward Acknowledgement: Refining TCP Congestion Control 这个算法是其于 SACK 的，前面我们说过 SACK 是使用了 TCP 扩展字段 Ack 了有哪些数据收到，哪些数据没有收到，他比 Fast Retransmit 的 3 个 duplicated acks 好处在于，前者只知道有包丢了，不知道是一个还是多个，而 SACK 可以准确的知道有哪些包丢了。 所以，SACK 可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK 用来做重传过程中的拥塞流控。 这个算法会把 SACK 中最大的 Sequence Number 保存在snd.fack这个变量中，snd.fack 的更新由 ack 带秋，如果网络一切安好则和 snd.una 一样（snd.una 就是还没有收到 ack 的地方，也就是前面 sliding window 里的 category #2 的第一个地方） 然后定义一个awnd = snd.nxt – snd.fack（snd.nxt 指向发送端 sliding window 中正在要被发送的地方——前面 sliding windows 图示的 category#3 第一个位置），这样 awnd 的意思就是在网络上的数据。（所谓 awnd 意为：actual quantity of data outstanding in the network） 如果需要重传数据，那么，awnd = snd.nxt – snd.fack + retran_data，也就是说，awnd 是传出去的数据 + 重传的数据。 然后触发 Fast Recovery 的条件是： ( ( snd.fack – snd.una ) &gt; (3*MSS) ) || (dupacks == 3) ) 。这样一来，就不需要等到 3 个 duplicated acks 才重传，而是只要 sack 中的最大的一个数据和 ack 的数据比较长了（3 个 MSS），那就触发重传。在整个重传过程中 cwnd 不变。直到当第一次丢包的 snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd 线性上涨。 我们可以看到如果没有 FACK 在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的 window 的大小，而需要几个 RTT 的时间才会完成恢复，而 FACK 会比较激进地来干这事。 但是，FACK 如果在一个网络包会被 reordering 的网络里会有很大的问题。 其它拥塞控制算法简介TCP Vegas 拥塞控制算法这个算法 1994 年被提出，它主要对 TCP Reno 做了些修改。这个算法通过对 RTT 的非常重的监控来计算一个基准 RTT。然后通过这个基准 RTT 来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加 cwnd 的大小。如果这个计算出来的 RTT 大于了 Timeout 后，那么，不等 ack 超时就直接重传。（Vegas 的核心思想是用 RTT 的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《TCP Vegas: End to End Congestion Avoidance on a Global Internet》这篇论文给了 Vegas 和 New Reno 的对比： 关于这个算法实现，你可以参看 Linux 源码：/net/ipv4/tcp_vegas.h， /net/ipv4/tcp_vegas.c HSTCP(High Speed TCP) 算法这个算法来自RFC 3649（Wikipedia 词条）。其对最基础的算法进行了更改，他使得 Congestion Window 涨得快，减得慢。其中： 拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd 丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd 注：α(cwnd)和 β(cwnd)都是函数，如果你要让他们和标准的 TCP 一样，那么让 α(cwnd)=1，β(cwnd)=0.5 就可以了。 对于 α(cwnd)和 β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看 Linux 源码：/net/ipv4/tcp_highspeed.c TCP BIC 算法2004 年，产内出 BIC 算法。现在你还可以查得到相关的新闻《Google：美科学家研发 BIC-TCP 协议 速度是 DSL 六千倍》 BIC 全称Binary Increase Congestion control，在 Linux 2.6.8 中是默认拥塞控制算法。BIC 的发明者发这么多的拥塞控制算法都在努力找一个合适的 cwnd – Congestion Window，而且 BIC-TCP 的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以 BIC 这个算法主要用的是 Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看 Linux 源码：/net/ipv4/tcp_bic.c TCP WestWood 算法westwood 采用和 Reno 相同的慢启动算法、拥塞避免算法。westwood 的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个 RTT 时间，会测量一次带宽，测量带宽的公式很简单，就是这段 RTT 内成功被 ack 了多少字节。因为，这个带宽和用 RTT 计算 RTO 一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送 X 个字节，而 RTT 是一个数据发出去后确认需要的时候，所以，X _ RTT 应该是我们缓冲区大小。所以，在这个算法中，ssthresh 的值就是 est_BD _ min-RTT(最小的 RTT 值)，如果丢包是 Duplicated ACKs 引起的，那么如果 cwnd &gt; ssthresh，则 cwin = ssthresh。如果是 RTO 引起的，cwnd = 1，进入慢启动。 关于这个算法实现，你可以参看 Linux 源码： /net/ipv4/tcp_westwood.c 四次挥手优化——三次挥手123456789#三次挥手 -- 客户端发起断开连接请求 客户端序列号为 3495051432#fin seq = 349505143200:05:30.157325 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [F.], seq 3495051432, ack 485492629, win 115, options [nop,nop,TS val 1695781058 ecr 629900122], length 0#三次挥手 -- 服务器端发起断开连接请求#ack = 3495051432 + 1 = 3495051433 注意 因为服务器端也没有东西要发送了，所以也要关闭连接，因此同时发送了fin信号，seq = 48549262900:05:30.157562 IP VM_0_6_centos.webcache &gt; 221.122.42.100.58706: Flags [F.], seq 485492629, ack 3495051433, win 235, options [nop,nop,TS val 629900162 ecr 1695781058], length 0#三次挥手 -- 客户端应答#ack = 485492629 + 1 = 48549263000:05:30.196710 IP 221.122.42.100.58706 &gt; VM_0_6_centos.webcache: Flags [.], ack 485492630, win 115, options [nop,nop,TS val 1695781097 ecr 629900162], length 0 这是因为关闭连接有两种方式，当一方关闭连接，另外一方没有数据发送时，马上关闭连接，也就将第二步的 ack 与第三步的 fin 合并为一步了","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"promise","slug":"promise","date":"2019-08-05T11:44:02.000Z","updated":"2019-08-15T17:34:42.058Z","comments":true,"path":"2019/08/05/promise/","link":"","permalink":"http://yoursite.com/2019/08/05/promise/","excerpt":"promise创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）方法一： 创建一个用 Promise 把 XHR 处理包装起来的名为 getURL 的函数。","text":"promise创建 XHR 的 promise 对象（Promise 包装 XHR[ajax]处理）方法一： 创建一个用 Promise 把 XHR 处理包装起来的名为 getURL 的函数。 1234567891011121314151617181920212223242526function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;// 运行示例var URL = \"http://httpbin.org/get\";getURL(URL) .then(function onFulfilled(value) &#123; console.log(value); &#125;) .catch(function onRejected(error) &#123; console.error(error); &#125;); 方法二： 12345678910111213141516171819202122232425function ajaxPromise(url, data, callback) &#123; return new Promise(function(resolve, reject) &#123; $.ajax(&#123; url: url, type: data == null ? \"GET\" : \"POST\", dataType: \"json\", data: data == null ? \"\" : JSON.stringify(data), async: true, contentType: \"application/json\", success: function(res) &#123; callback(res); resolve(); &#125;, error: function(XMLHttpRequest, textStatus, errorThrown) &#123; if (XMLHttpRequest.status == \"401\") &#123; window.parent.location = \"/enterprise/enterprise_login.html\"; self.location = \"/enterprise/enterprise_login.html\"; &#125; else &#123; alert(XMLHttpRequest.responseText); &#125; reject(); &#125; &#125;); &#125;);&#125; 调用 1234567891011ajaxPromise('/prefix/entity1/action1',null, function(res)&#123; //do something on response&#125;).then( ajaxPromise('/prefix/entity2/action2', someData, function(res)&#123; //do something on response &#125;).then( initVue() ;).then( //do something else) promise 的实现和原理（用 js）promise 实现原理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210// 判断变量否为functionconst isFunction = variable =&gt; typeof variable === \"function\";// 定义Promise的三种状态常量const PENDING = \"PENDING\";const FULFILLED = \"FULFILLED\";const REJECTED = \"REJECTED\";class MyPromise &#123; constructor(handle) &#123; if (!isFunction(handle)) &#123; throw new Error(\"MyPromise must accept a function as a parameter\"); &#125; // 添加状态 this._status = PENDING; // 添加状态 this._value = undefined; // 添加成功回调函数队列 this._fulfilledQueues = []; // 添加失败回调函数队列 this._rejectedQueues = []; // 执行handle try &#123; handle(this._resolve.bind(this), this._reject.bind(this)); &#125; catch (err) &#123; this._reject(err); &#125; &#125; // 添加resovle时执行的函数 _resolve(val) &#123; const run = () =&gt; &#123; if (this._status !== PENDING) return; // 依次执行成功队列中的函数，并清空队列 const runFulfilled = value =&gt; &#123; let cb; while ((cb = this._fulfilledQueues.shift())) &#123; cb(value); &#125; &#125;; // 依次执行失败队列中的函数，并清空队列 const runRejected = error =&gt; &#123; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(error); &#125; &#125;; /* 如果resolve的参数为Promise对象，则必须等待该Promise对象状态改变后, 当前Promsie的状态才会改变，且状态取决于参数Promsie对象的状态 */ if (val instanceof MyPromise) &#123; val.then( value =&gt; &#123; this._value = value; this._status = FULFILLED; runFulfilled(value); &#125;, err =&gt; &#123; this._value = err; this._status = REJECTED; runRejected(err); &#125; ); &#125; else &#123; this._value = val; this._status = FULFILLED; runFulfilled(val); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); &#125; // 添加reject时执行的函数 _reject(err) &#123; if (this._status !== PENDING) return; // 依次执行失败队列中的函数，并清空队列 const run = () =&gt; &#123; this._status = REJECTED; this._value = err; let cb; while ((cb = this._rejectedQueues.shift())) &#123; cb(err); &#125; &#125;; // 为了支持同步的Promise，这里采用异步调用 setTimeout(run, 0); &#125; // 添加then方法 then(onFulfilled, onRejected) &#123; const &#123; _value, _status &#125; = this; // 返回一个新的Promise对象 return new MyPromise((onFulfilledNext, onRejectedNext) =&gt; &#123; // 封装一个成功时执行的函数 let fulfilled = value =&gt; &#123; try &#123; if (!isFunction(onFulfilled)) &#123; onFulfilledNext(value); &#125; else &#123; let res = onFulfilled(value); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; // 封装一个失败时执行的函数 let rejected = error =&gt; &#123; try &#123; if (!isFunction(onRejected)) &#123; onRejectedNext(error); &#125; else &#123; let res = onRejected(error); if (res instanceof MyPromise) &#123; // 如果当前回调函数返回MyPromise对象，必须等待其状态改变后在执行下一个回调 res.then(onFulfilledNext, onRejectedNext); &#125; else &#123; //否则会将返回结果直接作为参数，传入下一个then的回调函数，并立即执行下一个then的回调函数 onFulfilledNext(res); &#125; &#125; &#125; catch (err) &#123; // 如果函数执行出错，新的Promise对象的状态为失败 onRejectedNext(err); &#125; &#125;; switch (_status) &#123; // 当状态为pending时，将then方法回调函数加入执行队列等待执行 case PENDING: this._fulfilledQueues.push(fulfilled); this._rejectedQueues.push(rejected); break; // 当状态已经改变时，立即执行对应的回调函数 case FULFILLED: fulfilled(_value); break; case REJECTED: rejected(_value); break; &#125; &#125;); &#125; // 添加catch方法 catch(onRejected) &#123; return this.then(undefined, onRejected); &#125; // 添加静态resolve方法 static resolve(value) &#123; // 如果参数是MyPromise实例，直接返回这个实例 if (value instanceof MyPromise) return value; return new MyPromise(resolve =&gt; resolve(value)); &#125; // 添加静态reject方法 static reject(value) &#123; return new MyPromise((resolve, reject) =&gt; reject(value)); &#125; // 添加静态all方法 static all(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; /** * 返回值的集合 */ let values = []; let count = 0; for (let [i, p] of list.entries()) &#123; // 数组参数如果不是MyPromise实例，先调用MyPromise.resolve this.resolve(p).then( res =&gt; &#123; values[i] = res; count++; // 所有状态都变成fulfilled时返回的MyPromise状态就变成fulfilled if (count === list.length) resolve(values); &#125;, err =&gt; &#123; // 有一个被rejected时返回的MyPromise状态就变成rejected reject(err); &#125; ); &#125; &#125;); &#125; // 添加静态race方法 static race(list) &#123; return new MyPromise((resolve, reject) =&gt; &#123; for (let p of list) &#123; // 只要有一个实例率先改变状态，新的MyPromise的状态就跟着改变 this.resolve(p).then( res =&gt; &#123; resolve(res); &#125;, err =&gt; &#123; reject(err); &#125; ); &#125; &#125;); &#125; finally(cb) &#123; return this.then( value =&gt; MyPromise.resolve(cb()).then(() =&gt; value), reason =&gt; MyPromise.resolve(cb()).then(() =&gt; &#123; throw reason; &#125;) ); &#125;&#125; promise.race 和超时处理函数 timeoutPromise(比较对象promise, ms) 接收两个参数，第一个是需要使用超时机制的 promise 对象，第二个参数是超时时间，它返回一个由 Promise.race 创建的相互竞争的 promise 对象。 1234567891011function delayPromise(ms) &#123; return new Promise(function(resolve) &#123; setTimeout(resolve, ms); &#125;);&#125;function timeoutPromise(promise, ms) &#123; var timeout = delayPromise(ms).then(function() &#123; throw new Error(\"Operation timed out after \" + ms + \" ms\"); &#125;); return Promise.race([promise, timeout]);&#125; 例子： 1234567891011121314151617181920212223242526function delayPromise(ms) &#123; return new Promise(function(resolve) &#123; setTimeout(resolve, ms); &#125;);&#125;function timeoutPromise(promise, ms) &#123; var timeout = delayPromise(ms).then(function() &#123; throw new Error(\"Operation timed out after \" + ms + \" ms\"); &#125;); return Promise.race([promise, timeout]);&#125;// 运行示例var taskPromise = new Promise(function(resolve) &#123; // 随便一些什么处理 var delay = Math.random() * 2000; setTimeout(function() &#123; resolve(delay + \"ms\"); &#125;, delay);&#125;);timeoutPromise(taskPromise, 1000) .then(function(value) &#123; console.log(\"taskPromise在规定时间内结束 : \" + value); &#125;) .catch(function(error) &#123; console.log(\"发生超时\", error); &#125;); 虽然在发生超时的时候抛出了异常，但是这样的话我们就不能区分这个异常到底是普通的错误还是超时错误了。 为了能区分这个 Error 对象的类型，我们再来定义一个Error 对象的子类 TimeoutError。 定制 Error 对象 1234567891011121314151617//TimeoutError.jsfunction copyOwnFrom(target, source) &#123; Object.getOwnPropertyNames(source).forEach(function(propName) &#123; Object.defineProperty( target, propName, Object.getOwnPropertyDescriptor(source, propName) ); &#125;); return target;&#125;function TimeoutError() &#123; var superInstance = Error.apply(null, arguments); copyOwnFrom(this, superInstance);&#125;TimeoutError.prototype = Object.create(Error.prototype);TimeoutError.prototype.constructor = TimeoutError; 我们定义了 TimeoutError 类和构造函数，这个类继承了 Error 的 prototype。 它的使用方法和普通的 Error 对象一样，使用 throw 语句即可，如下所示。 1234567var promise = new Promise(function() &#123; throw TimeoutError(\"timeout\");&#125;);promise.catch(function(error) &#123; console.log(error instanceof TimeoutError); // true&#125;); 应用 取消 XHR 操作本身的话并不难，只需要调用 XMLHttpRequest 对象的 abort() 方法就可以了。 为了能在外部调用 abort() 方法，我们先对之前本节出现的 getURL 进行简单的扩展，cancelableXHR 方法除了返回一个包装了 XHR 的 promise 对象之外，还返回了一个用于取消该 XHR 请求的abort方法。 大体的流程就像下面这样。 通过 cancelableXHR 方法取得包装了 XHR 的 promise 对象和取消该 XHR 请求的方法 在 timeoutPromise 方法中通过 Promise.race 让 XHR 的包装 promise 和超时用 promise 进行竞争。 XHR 在超时前返回结果的话 和正常的 promise 一样，通过 then 返回请求结果 发生超时的时候 抛出 throw TimeoutError 异常并被 catch catch 的错误对象如果是 TimeoutError 类型的话，则调用 abort 方法取消 XHR 请求 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273function copyOwnFrom(target, source) &#123; Object.getOwnPropertyNames(source).forEach(function(propName) &#123; Object.defineProperty( target, propName, Object.getOwnPropertyDescriptor(source, propName) ); &#125;); return target;&#125;function TimeoutError() &#123; var superInstance = Error.apply(null, arguments); copyOwnFrom(this, superInstance);&#125;TimeoutError.prototype = Object.create(Error.prototype);TimeoutError.prototype.constructor = TimeoutError;function delayPromise(ms) &#123; return new Promise(function(resolve) &#123; setTimeout(resolve, ms); &#125;);&#125;function timeoutPromise(promise, ms) &#123; var timeout = delayPromise(ms).then(function() &#123; return Promise.reject( new TimeoutError(\"Operation timed out after \" + ms + \" ms\") ); &#125;); return Promise.race([promise, timeout]);&#125;function cancelableXHR(URL) &#123; var req = new XMLHttpRequest(); var promise = new Promise(function(resolve, reject) &#123; req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.onabort = function() &#123; reject(new Error(\"abort this request\")); &#125;; req.send(); &#125;); var abort = function() &#123; // 如果request还没有结束的话就执行abort // https://developer.mozilla.org/en/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest if (req.readyState !== XMLHttpRequest.UNSENT) &#123; req.abort(); &#125; &#125;; return &#123; promise: promise, abort: abort &#125;;&#125;var object = cancelableXHR(\"http://httpbin.org/get\");// maintimeoutPromise(object.promise, 1000) .then(function(contents) &#123; console.log(\"Contents\", contents); &#125;) .catch(function(error) &#123; if (error instanceof TimeoutError) &#123; object.abort(); return console.log(error); &#125; console.log(\"XHR Error :\", error); &#125;); promise.all 和顺序处理 在 重复使用多个 then 的方法 中的实现方法如下。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; // [] 用来保存初始化的值 var pushValue = recordValue.bind(null, []); return request .comment() .then(pushValue) .then(request.people) .then(pushValue);&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); 使用这种写法的话那么随着 request 中元素数量的增加，我们也需要不断增加对 then 方法的调用 将处理内容统一放到数组里，再配合 for 循环进行处理 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; // [] 用来保存初始化值 var pushValue = recordValue.bind(null, []); // 返回promise对象的函数的数组 var tasks = [request.comment, request.people]; var promise = Promise.resolve(); // 开始的地方 for (var i = 0; i &lt; tasks.length; i++) &#123; var task = tasks[i]; promise = promise.then(task).then(pushValue); &#125; return promise;&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); promise = promise.then(task).then(pushValue); 的代码就是通过不断对 promise 进行处理，不断的覆盖 promise 变量的值，以达到对 promise 对象的累积处理效果。 但是这种方法需要 promise 这个临时变量，从代码质量上来说显得不那么简洁。 Promise chain 和 reduce 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; var pushValue = recordValue.bind(null, []); var tasks = [request.comment, request.people]; return tasks.reduce(function(promise, task) &#123; return promise.then(task).then(pushValue); &#125;, Promise.resolve());&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); Array.prototype.reduce 的第二个参数用来设置盛放计算结果的初始值。在这个例子中， Promise.resolve() 会赋值给 promise，此时的 task 为 request.comment 。 在 reduce 中第一个参数中被 return 的值，则会被赋值为下次循环时的 promise 。也就是说，通过返回由 then 创建的新的 promise 对象，就实现了和 for 循环类似的 Promise chain 了。 使用 reduce 和 for 循环不同的地方是 reduce 不再需要临时变量 promise 了，因此也不用编写 promise = promise.then(task).then(pushValue); 这样冗长的代码了，这是非常大的进步。 定义进行顺序处理的函数 12345678910function sequenceTasks(tasks) &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; var pushValue = recordValue.bind(null, []); return tasks.reduce(function(promise, task) &#123; return promise.then(task).then(pushValue); &#125;, Promise.resolve());&#125; 需要注意的一点是，和 Promise.all 等不同，这个函数接收的参数是一个函数的数组。为什么传给这个函数的不是一个 promise 对象的数组呢？这是因为 promise 对象创建的时候，XHR 已经开始执行了，因此再对这些 promise 对象进行顺序处理的话就不能正常工作了。 重写上例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950function sequenceTasks(tasks) &#123; function recordValue(results, value) &#123; results.push(value); return results; &#125; var pushValue = recordValue.bind(null, []); return tasks.reduce(function(promise, task) &#123; return promise.then(task).then(pushValue); &#125;, Promise.resolve());&#125;function getURL(URL) &#123; return new Promise(function(resolve, reject) &#123; var req = new XMLHttpRequest(); req.open(\"GET\", URL, true); req.onload = function() &#123; if (req.status === 200) &#123; resolve(req.responseText); &#125; else &#123; reject(new Error(req.statusText)); &#125; &#125;; req.onerror = function() &#123; reject(new Error(req.statusText)); &#125;; req.send(); &#125;);&#125;var request = &#123; comment: function getComment() &#123; return getURL(\"http://azu.github.io/promises-book/json/comment.json\").then( JSON.parse ); &#125;, people: function getPeople() &#123; return getURL(\"http://azu.github.io/promises-book/json/people.json\").then( JSON.parse ); &#125;&#125;;function main() &#123; return sequenceTasks([request.comment, request.people]);&#125;// 运行示例main() .then(function(value) &#123; console.log(value); &#125;) .catch(function(error) &#123; console.error(error); &#125;); 如何实现 Promise.all ?12345678910111213141516171819202122232425262728Promise.all = function(promises) &#123; return new Promise((resolve, reject) =&gt; &#123; let index = 0; let result = []; if (promises.length === 0) &#123; resolve(result); &#125; else &#123; function processValue(i, data) &#123; result[i] = data; if (++index === promises.length) &#123; resolve(result); &#125; &#125; for (let i = 0; i &lt; promises.length; i++) &#123; //promises[i] 可能是普通值 Promise.resolve(promises[i]).then( data =&gt; &#123; processValue(i, data); &#125;, err =&gt; &#123; reject(err); return; &#125; ); &#125; &#125; &#125;);&#125;; 如何实现 Promise.finally ?不管成功还是失败，都会走到 finally 中,并且 finally 之后，还可以继续 then。并且会将值原封不动的传递给后面的 then. 1234567891011121314Promise.prototype.finally = function(callback) &#123; return this.then( value =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; return value; &#125;); &#125;, err =&gt; &#123; return Promise.resolve(callback()).then(() =&gt; &#123; throw err; &#125;); &#125; );&#125;; 常见问题 输出结果：success 解题思路：Promise 状态一旦改变，无法在发生变更。 1234567891011121314const promise = new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; resolve(\"success\"); reject(\"error\"); &#125;, 1000);&#125;);promise.then( res =&gt; &#123; console.log(res); &#125;, err =&gt; &#123; console.log(err); &#125;); 输出结果：1 解题思路：Promise 的 then 方法的参数期望是函数，传入非函数则会发生值穿透。 1234Promise.resolve(1) .then(2) .then(Promise.resolve(3)) .then(console.log); 结果是：3 4 6 8 7 5 2 1 优先级关系如下：process.nextTick &gt; promise.then &gt; setTimeout &gt; setImmediate 123456789101112131415161718setImmediate(function() &#123; console.log(1);&#125;, 0);setTimeout(function() &#123; console.log(2);&#125;, 0);new Promise(function(resolve) &#123; console.log(3); resolve(); console.log(4);&#125;).then(function() &#123; console.log(5);&#125;);console.log(6);process.nextTick(function() &#123; console.log(7);&#125;);console.log(8); V8 实现中，两个队列各包含不同的任务： macrotasks: script(整体代码),setTimeout, setInterval, setImmediate, I/O, UI renderingmicrotasks: process.nextTick, Promises, Object.observe, MutationObserver 实现一个简单的 Promise 1234567891011121314151617181920212223242526272829303132333435function Promise(fn) &#123; var status = \"pending\"; function successNotify() &#123; status = \"fulfilled\"; //状态变为fulfilled toDoThen.apply(undefined, arguments); //执行回调 &#125; function failNotify() &#123; status = \"rejected\"; //状态变为rejected toDoThen.apply(undefined, arguments); //执行回调 &#125; function toDoThen() &#123; setTimeout(() =&gt; &#123; // 保证回调是异步执行的 if (status === \"fulfilled\") &#123; for (let i = 0; i &lt; successArray.length; i++) &#123; successArray[i].apply(undefined, arguments); //执行then里面的回掉函数 &#125; &#125; else if (status === \"rejected\") &#123; for (let i = 0; i &lt; failArray.length; i++) &#123; failArray[i].apply(undefined, arguments); //执行then里面的回掉函数 &#125; &#125; &#125;); &#125; var successArray = []; var failArray = []; fn.call(undefined, successNotify, failNotify); return &#123; then: function(successFn, failFn) &#123; successArray.push(successFn); failArray.push(failFn); return undefined; // 此处应该返回一个Promise &#125; &#125;;&#125; 解题思路：Promise 中的 resolve 和 reject 用于改变 Promise 的状态和传参，then 中的参数必须是作为回调执行的函数。因此，当 Promise 改变状态之后会调用回调函数，根据状态的不同选择需要执行的回调函数。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"JS引擎执行机制","slug":"JS引擎执行机制","date":"2019-07-30T05:13:29.000Z","updated":"2019-08-15T17:30:25.130Z","comments":true,"path":"2019/07/30/JS引擎执行机制/","link":"","permalink":"http://yoursite.com/2019/07/30/JS引擎执行机制/","excerpt":"JS 引擎执行机制(1) JS 是单线程语言 (2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop","text":"JS 引擎执行机制(1) JS 是单线程语言 (2) JS 的 Event Loop 是 JS 的执行机制。深入了解 JS 的执行,就等于深入了解 JS 里的 event loop JS 为什么是单线程的? 为什么需要异步? 单线程又是如何实现异步的呢? JS 最初被设计用在浏览器中,那么想象一下,如果浏览器中的 JS 是多线程的。 场景描述: 那么现在有 2 个线程,process1 process2,由于是多线程的 JS,所以他们对同一个 dom,同时进行操作。process1 删除了该 dom,而 process2 编辑了该 dom,同时下达 2 个矛盾的命令,浏览器究竟该如何执行呢? JS 为什么需要异步? 如果 JS 中不存在异步,只能自上而下执行,如果上一行解析时间很长,那么下面的代码就会被阻塞。对于用户而言,阻塞就意味着”卡死”,这样就导致了很差的用户体验 JS 单线程又是如何实现异步的呢? 是通过的事件循环(event loop),理解了 event loop 机制,就理解了 JS 的执行机制 JS 中的 event loopevent loop（1）JS 里的一种分类方式,就是将任务分为: 同步任务和异步任务 JS 的执行机制是： 首先判断 JS 是同步还是异步,同步就进入主线程,异步就进入 event table 异步任务在 event table 中注册函数,当满足触发条件后,被推入 event queue 同步任务进入主线程后一直执行,直到主线程空闲时,才会去 event queue 中查看是否有可执行的异步任务,如果有就推入主线程中 event loop（2）准确的划分方式是: macro-task(宏任务)：包括整体代码 script，setTimeout，setInterval micro-task(微任务)：Promise.then，process.nextTick JS 的执行机制是： 执行一个宏任务,过程中如果遇到微任务,就将其放到微任务的【事件队列】里 当前宏任务执行完成后,会查看微任务的【事件队列】,并将里面全部的微任务依次执行完 重复以上 2 步骤,结合 event loop(1) event loop(2) ,就是更为准确的 JS 执行机制了。 理解 JavaScript 的 async/awaitasync 和 await 在干什么先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。 async 函数返回的是一个 Promise 对象。 如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。 await 等待的是一个表达式。 这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。 await 等到了要等的，然后呢？ await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。 如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。 如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。 这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。 await 等待的表达式详解await 等的是右侧「表达式」的结果 await 是从右向左执行的 12345678910async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;async1();console.log(\"script start\"); 先执行 async2 后，发现有 await 关键字，于是让出线程，阻塞代码 右侧表达式的结果: 如果不是 promise , await 会阻塞后面的代码，先执行 async 外面的同步代码，同步代码执行完，再回到 async 内部，把这个非 promise 的东西，作为 await 表达式的结果 如果它等到的是一个 promise 对象，await 也会暂停 async 后面的代码，先执行 async 外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果。 async/await 的优势在于处理 then 链单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了。 Async/await 代码清晰很多，几乎跟同步代码一样。 Promise 方案的死穴—— 链式调用参数传递太麻烦 async/await 和 promise 的执行顺序例子1234567891011121314151617181920async function async1() &#123; console.log(\"async1 start\"); await async2(); console.log(\"async1 end\");&#125;async function async2() &#123; console.log(\"async2\");&#125;console.log(\"script start\");setTimeout(function() &#123; console.log(\"setTimeout\");&#125;, 0);async1();new Promise(function(resolve) &#123; console.log(\"promise1\"); resolve();&#125;).then(function() &#123; console.log(\"promise2\");&#125;);console.log(\"script end\"); 12345678script startasync1 startasync2promise1script endpromise2async1 endsetTimeout 宏任务和微任务的慨念，在我脑海中宏任务和为微任务如图所示 也就是「宏任务」、「微任务」都是队列。 一段代码执行时，会先执行宏任务中的同步代码， 如果执行中遇到 setTimeout 之类宏任务，那么就把这个 setTimeout 内部的函数推入「宏任务的队列」中，下一轮宏任务执行时调用。 如果执行中遇到 promise.then()之类的微任务，就会推入到「当前宏任务的微任务队列」中，在本轮宏任务的同步代码执行都完成后，依次执行所有的微任务 1、2、3 例子分析执行顺序直接打印同步代码 console.log(‘script start’)12// 首先是2个函数声明，虽然有async关键字，但不是调用我们就不看。然后首先是打印同步代码console.log(\"script start\"); 将 setTimeout 放入宏任务队列默认所包裹的代码，其实可以理解为是第一个宏任务，所以这里是宏任务 2 调用 async1，打印 同步代码 console.log( ‘async1 start’ )我们说过看到带有 async 关键字的函数，不用害怕，它的仅仅是把 return 值包装成了 promise，其他并没有什么不同的地方。所以就很普通的打印 console.log( ‘async1 start’ ) 分析一下 await async2()前文提过 await，1.它先计算出右侧的结果，2.然后看到 await 后，中断 async 函数 先得到 await 右侧表达式的结果。执行 async2()，打印同步代码 console.log(‘async2’), 并且 return Promise.resolve(undefined) await 后，中断 async 函数，先执行 async 外的同步代码 目前就直接打印 console.log(‘async2’) 被阻塞后，要执行 async 之外的代码执行 new Promise()，Promise 构造函数是直接调用的同步代码，所以 console.log( ‘promise1’ ) 代码运行到 promise.then()代码运行到 promise.then()，发现这个是微任务，所以暂时不打印，只是推入当前宏任务的微任务队列中。 注意：这里只是把 promise2 推入微任务队列，并没有执行。微任务会在当前宏任务的同步代码执行完毕，才会依次执行 打印同步代码 console.log(‘script end’)执行完这个同步代码后，「async 外的代码」终于走了一遍 下面该回到 await 表达式那里，执行 await Promise.resolve(undefined)了 回到 async 内部，执行 await Promise.resolve(undefined)这部分可能不太好理解，我尽量表达我的想法。 对于 await Promise.resolve(undefined) 如何理解呢？ 根据 MDN 原话我们知道 如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。 在我们这个例子中，就是 Promise.resolve(undefined)正常处理完成，并返回其处理结果。那么 await async2()就算是执行结束了。 目前这个 promise 的状态是 fulfilled，等其处理结果返回就可以执行 await 下面的代码了。 那何时能拿到处理结果呢？ 回忆平时我们用 promise，调用 resolve 后，何时能拿到处理结果？是不是需要在 then 的第一个参数里，才能拿到结果。 （调用 resolve 时，会把 then 的参数推入微任务队列，等主线程空闲时，再调用它） 所以这里的 await Promise.resolve() 就类似于 1Promise.resolve(undefined).then(undefined =&gt; &#123;&#125;); 把 then 的第一个回调参数 (undefined) =&gt; {} 推入微任务队列。 then 执行完，才是 await async2()执行结束。 await async2()执行结束，才能继续执行后面的代码 如图 此时当前宏任务 1 都执行完了，要处理微任务队列里的代码。微任务队列，先进选出的原则， 执行微任务 1，打印 promise2 执行微任务 2，没什么内容.. 但是微任务 2 执行后，await async2()语句结束，后面的代码不再被阻塞，所以打印 console.log(‘async1 end’) 宏任务 1 执行完成后,执行宏任务 2宏任务 2 的执行比较简单，就是打印 console.log(‘setTimeout’)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS事件机制","slug":"JS事件机制","date":"2019-07-24T07:22:00.000Z","updated":"2019-08-15T17:30:42.316Z","comments":true,"path":"2019/07/24/JS事件机制/","link":"","permalink":"http://yoursite.com/2019/07/24/JS事件机制/","excerpt":"JS 事件机制js 里一般的阻止事件默认行为怎么做？event.preventDefault()可以取消默认事件 event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。","text":"JS 事件机制js 里一般的阻止事件默认行为怎么做？event.preventDefault()可以取消默认事件 event.stopPropagation()起到阻止捕获和冒泡阶段中当前事件的进一步传播。 1234567891011function cancelHandler(event) &#123; var event = event || window.event; //兼容IE //取消事件相关的默认行为 if (event.preventDefault) //标准技术 event.preventDefault(); if (event.returnValue) //兼容IE9之前的IE event.returnValue = false; return false; //用于处理使用对象属性注册的处理程序&#125; 冒泡的机制是什么？下面代码输出顺序是什么？（2-&gt;button-&gt;1） 触发顺序：button-&gt;1-&gt;2 12345678910111213141516171819202122232425&lt;div&gt;&lt;button&gt;aaa&lt;/button&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"1\"); &#125;, false ); document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"2\"); &#125;, false ); document.getElementById(\"button\").addEventListener( \"click\", function() &#123; console.log(\"button\"); &#125;, false );&lt;/script&gt; 触发顺序：2-&gt;button-&gt;1 12345678910111213141516171819202122232425&lt;div&gt;&lt;button&gt;aaa&lt;/button&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"1\"); &#125;, false ); document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"2\"); &#125;, true ); document.getElementById(\"button\").addEventListener( \"click\", function() &#123; console.log(\"button\"); &#125;, false );&lt;/script&gt; 触发顺序：2-&gt;button-&gt;1 12345678910111213141516171819202122232425&lt;div&gt;&lt;button&gt;aaa&lt;/button&gt;&lt;/div&gt;&lt;script&gt; document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"1\"); &#125;, false ); document.getElementById(\"div\").addEventListener( \"click\", function() &#123; console.log(\"2\"); &#125;, true ); document.getElementById(\"button\").addEventListener( \"click\", function() &#123; console.log(\"button\"); &#125;, true );&lt;/script&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS静态作用域","slug":"JS静态作用域","date":"2019-07-11T03:01:34.000Z","updated":"2019-08-15T17:30:55.566Z","comments":true,"path":"2019/07/11/JS静态作用域/","link":"","permalink":"http://yoursite.com/2019/07/11/JS静态作用域/","excerpt":"JS 静态作用域js 的作用域和别的编程语言的作用域有什么区别作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。","text":"JS 静态作用域js 的作用域和别的编程语言的作用域有什么区别作用域作用域是指程序源代码中定义变量的区域。 作用域规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。 JavaScript 采用词法作用域(lexical scoping)，也就是静态作用域。 静态作用域与动态作用域因为 JavaScript 采用的是词法作用域，函数的作用域在函数定义的时候就决定了。 而与词法作用域相对的是动态作用域，函数的作用域是在函数调用的时候才决定的。 让我们认真看个例子就能明白之间的区别： 1234567891011121314var value = 1;function foo() &#123; console.log(value);&#125;function bar() &#123; var value = 2; foo();&#125;bar();// 结果是 ??? 假设 JavaScript 采用静态作用域，让我们分析下执行过程： 执行 foo 函数，先从 foo 函数内部查找是否有局部变量 value，如果没有，就根据书写的位置，查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。 假设 JavaScript 采用动态作用域，让我们分析下执行过程： 执行 foo 函数，依然是从 foo 函数内部查找是否有局部变量 value。如果没有，就从调用函数的作用域，也就是 bar 函数内部查找 value 变量，所以结果会打印 2。 前面我们已经说了，JavaScript 采用的是静态作用域，所以这个例子的结果是 1。 最后，让我们看一个《JavaScript 权威指南》中的例子： 123456789101112131415161718var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f();&#125;checkscope();var scope = \"global scope\";function checkscope() &#123; var scope = \"local scope\"; function f() &#123; return scope; &#125; return f;&#125;checkscope()(); 猜猜两段代码各自的执行结果是多少？ 这里直接告诉大家结果，两段代码都会打印：local scope。 原因也很简单，因为 JavaScript 采用的是词法作用域，函数的作用域基于函数创建的位置。 而引用《JavaScript 权威指南》的回答就是： JavaScript 函数的执行用到了作用域链，这个作用域链是在函数定义的时候创建的。嵌套的函数 f() 定义在这个作用域链里，其中的变量 scope 一定是局部变量，不管何时何地执行函数 f()，这种绑定在执行 f() 时依然有效。 bash 就是动态作用域","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"https中间人攻击及防御","slug":"https中间人攻击及防御","date":"2019-07-03T06:51:26.000Z","updated":"2019-08-15T17:31:09.842Z","comments":true,"path":"2019/07/03/https中间人攻击及防御/","link":"","permalink":"http://yoursite.com/2019/07/03/https中间人攻击及防御/","excerpt":"https 中间人攻击及防御HTTPS 也不是绝对安全的，在 HTTPS 握手的过程中，如果实施不当，还是会存在漏洞，很容被中间人攻击； 什么是中间人攻击中间人攻击（Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。","text":"https 中间人攻击及防御HTTPS 也不是绝对安全的，在 HTTPS 握手的过程中，如果实施不当，还是会存在漏洞，很容被中间人攻击； 什么是中间人攻击中间人攻击（Man-in-the-middle attack，缩写：MITM）是指攻击者与通讯的两端分别建立独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方直接对话，但事实上整个会话都被攻击者完全控制。在中间人攻击中，攻击者可以拦截通讯双方的通话并插入新的内容。 如何进行中间人攻击的呢？攻击一：SSLSniff攻击者在网关截获 SSL 会话，替换服务器公钥证书，将公钥PKey换成自己的公钥PKey，欺骗客户端。客户端使用PKey加密信息并发送会话，中间人用私钥Skey解密客户端返回会话，从而劫持会话。同时，中间人用PKey加密明文会话并返回服务器 过程如下： Attacker截获了客户端的say hello，可以把publicKey_attacker返回给客户端，取得客户端的信任，至此Attacker与客户端建立了安全连接。 Attacker冒充客户端向服务器发送say hello，至此Attacker与服务器建立了安全连接。 这种攻击会存在一个问题会被感知到，就是Attacker的证书是伪造的不受信任的证书，所以客户端可以确认是否需要真的连接该服务器，不过如果有内鬼的话，伪造的受信任的证书的话，就当我啥也没说； 攻击二：SSLStrip这种攻击相对于攻击一复杂一点，但是也更加厉害，几乎可以在客户端无感知的情况下实施攻击，并且不需要伪造证书；简单来说就是这样：Attacker在客户端与服务器建立连接时，在Attacker与服务器之间形成 HTTPS 连接，而在客户端与Attacker之间形成HTTP连接，即将 SSL 层从原 HTTPS 连接中“剥离”。这样，既避免了在客户端验证证书时难以避免的弹框问题，又能够劫持 HTTP 明文数据，并同时保证客户端HTTP数据的传输，达到欺骗服务器与客户端的效果。 过程如下： 用户在浏览器地址栏中输入网址时，多数会采用直接输入网址的方式，而忽略了传输所采用的协议。例如，在登录 gmail 过程中，大多数用户会直接在地址栏中输入www.gmail.com，向Google服务器发送一个 HTTP 连接请求，而不是输入https：//www.gmail.com， 向服务器发送一个HTTPS连接请求。因此，用户通常接触到 HTTPS 的方式有两种：一种是 Web 上的连接，比如当用户在 gmail 上输入用户名和密码后，点击的登录键，将用户的用户名和密码以HTTPS的形式POST到服务器。另一种是通过 HTTP 的 302 状态。 当客户端向 gmail 提出 HTTP 连接请求时，gmail 服务器会返回一个REDIRECT网址，https：//www.google.com/accounts/ServiceLogin?service=mail...，用户端在接收到这个 URL 后，将页面重定位到该网页，并请求 HTTPS 连接。 从另外一个角度讲，用户通常是通过HTTP向服务器发起HTTPS连接的。而HTTP本身是以明文的形式对外传送，并不能保证数据的安全。因此，可以考虑通过对 HTTP 进行劫持，来实现对 HTTPS 劫持的目的。 客户端向服务器发起HTTP连接请求； 中间人 MITM 监听客户端与服务器的HTTP数据； 服务器返回给客户端的 HTTP 数据包被在客户端与服务器之间的中间人截获。中间人解析原 HTTP 数据包，将其中&lt;a href=”https：//...”&gt;替换成&lt;a href=”http//...”&gt;，将 Location： https：//... 替换成Location：http://..，同时记录下所修改的 URL，并保存； 中间人将修改后的HTTP数据发送给客户端； 客户端向服务器发起HTTP连接请求； 中间人计算机解析客户端的HTTP连接请求，并与保存文件相比较。当发现存在有已修改过的HTTP URL时，将其替换成原HTTPS URL，并发送给服务器； 与服务器保持HTTPS连接，回到步骤 3； 与客户端保持HTTP连接，回到步骤 4。 效果就是： 服务器认为 HTTPS 是安全的。对于客户端而言，由于中间人 MITM 与客户端 Client 之间是 HTTP 连接，因此并不会对证书进行认证； HSTS:为了解决这个问题，IETF（互联网工程任务小组）引入了一个策略，叫做 HSTS (HTTP Strict Transport Security, HTTP 严格传输安全)。HSTS 的作用是强制客户端与服务端建立安全的 HTTPS 连接，而非不安全的 HTTP 连接。如果一个站点启用了 HSTS 策略，那么客户端在第一次与该站点建立连接之后，在未来的一段时间内（由一个 HTTP 头部控制，这个头部为：Strict-Transport-Security），客户端与该站点的所有连接都会直接使用 HTTPS，即使客户端访问的是 HTTP，也会直接在客户端重定向到 HTTPS 连接。 假设 https://example.com 的响应头部含有 Strict-Transport-Security: max-age=31536000; includeSubDomains，这意味着： 在未来的 1 年时间里（即 31536000 秒中），只要浏览器向 example.com 或者其子域名发送请求，必须采用 HTTPS 来发起连接。即使用户在地址栏里写的是 http://example.com，那也直接重写为 https://example.com 并直接发起 HTTPS 连接。 在接下去的一年中，如果服务器提供的 HTTPS 证书无效（不论是域名对不上还是自签名还是不在有效期内），用户都无法访问该站点。 如果站点没有启用 HSTS，用户可以忽略证书无效的警告，继续建立连接，而如果站点启用了 HSTS，那么用户即使想冒风险，浏览器也不会继续访问。 HSTS 可以很大程度上防止 SSLTrip 攻击，不过这样还是有个问题，那就是要启用 HSTS，浏览器至少要和服务器建立一次 HTTPS 连接，如果中间人一直阻止浏览器与服务器建立 HTTPS 连接，那么 HSTS 就失效了。解决这个问题有个办法，那就是将 HSTS 站点列表内置到浏览器中，这样只要浏览器离线判断该站点启用了 HSTS，就会跳过原先的 HTTP 重定向，直接发起 HTTPS 请求。 如何防御中间人攻击？中间人攻击是一个（缺乏）相互认证的攻击；由于客户端与服务器之间在 SSL 握手的过程中缺乏相互认证而造成的漏洞 防御中间人攻击的方案通常基于以下几种技术 公钥基础建设 PKI，更强力的相互认证 使用 PKI 相互认证机制，客户端验证服务器，服务器验证客户端；上述两个例子中都是只验证服务器，这样就造成了 SSL 握手环节的漏洞，而如果使用相互认证的的话，基本可以保证 延迟测试 使用复杂加密哈希函数进行计算以造成数十秒的延迟；如果双方通常情况下都要花费 20 秒来计算，并且整个通讯花费了 60 秒计算才到达对方，这就能表明存在第三方中间人。 https 通信安全性的保证通信过程的安全性自下而上就是这样保证的： 双方通信内容的安全性是靠公钥加密、私钥解密来保证的，这一安全性由非对称加密的特性，即由公钥加密的信息只能使用对应的私钥才能解开来保证。由于私钥不会传递，只有拥有者知道，所以安全性就由公钥的正确性来保证。 公钥由对方在通信初始所提供，但是这时很容易被中间人替换掉，为了保证公钥的正确性，所以在发送公钥的时候也会提供对应的数字证书，用于验证这个公钥是对方的而不是中间人的。那么安全性就是由数字证书的正确性来保证了。 数字证书是由上级 CA 签发给个人 / 组织的，上级 CA 用自己的私钥给个人证书进行签名，保证证书中的公钥不被篡改，而接受者需要用上级 CA 证书中的公钥来解密个人数字证书中的数字签名来验证证书中的公钥是否是正确的。那么安全性就是由上级 CA 证书的正确性保证的了。（数字签名保证了数字证书没有被篡改） 但是，上级 CA 证书也是由其上级 CA 签发的，这种信任关系一直到根证书。根证书没有上级 CA 为其签名，而是自签名的，也就是说，它自身为自身签名，保证正确性。所以根证书就是这个信任链最重要的部分。如果根证书泄露的话，其签名的所有证书及使用其签名的证书所签名的证书的安全性将不复存在。现在，安全性就是靠系统根证书的私钥不被泄露或者其公钥不被篡改来保证的了。 根证书不应该通过网络分发，因为通过网络分发的话，可能会被中间人攻击。一般根证书都通过操作系统或者浏览器分发，在操作系统中会内置很多根证书，但是最初的操作系统也不能通过网络分发，因为中间人可以修改操作系统中的根证书。所以要保证安全只能靠最原始的方法，当面交流。硬件厂商会和证书签发机构合作，在电脑、手机等设备出厂的时候在其操作系统中内置签发机构的根证书，再将这些设备分发出去，这样，这些设备的用户就可以安全地进行信息交换了。所以，安全性就依赖于这些设备在分发到消费者手中之前不会被恶意修改来保证了。 至此，整个信任链就建立起来了，只需要有一台设备上安装了可以信任的根证书，就可以用来分发更多安全的操作系统了。之后的所有信任链都是安全的了。","categories":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/categories/HTTP/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"http://yoursite.com/tags/HTTP/"}]},{"title":"CSRF攻击","slug":"CSRF攻击","date":"2019-06-18T12:05:23.000Z","updated":"2019-08-15T17:26:56.351Z","comments":true,"path":"2019/06/18/CSRF攻击/","link":"","permalink":"http://yoursite.com/2019/06/18/CSRF攻击/","excerpt":"CSRF 攻击1.什么是 CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 一个典型的 CSRF 攻击有着如下的流程：","text":"CSRF 攻击1.什么是 CSRFCSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。 一个典型的 CSRF 攻击有着如下的流程： 受害者登录 a.com，并保留了登录凭证（Cookie）。 攻击者引诱受害者访问了 b.com。 b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。 a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。 a.com 以受害者的名义执行了 act=xx。 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。 2.常见的攻击类型 GET 类型的 CSRF GET 类型的 CSRF 利用非常简单，只需要一个 HTTP 请求，一般会这样利用： 1&lt;img src=\"http://bank.example/withdraw?amount=10000&amp;for=hacker\" /&gt; 在受害者访问含有这个 img 的页面后，浏览器会自动向http://bank.example/withdraw?account=xiaoming&amp;amount=10000&amp;for=hacker发出一次 HTTP 请求。bank.example 就会收到包含受害者登录信息的一次跨域请求。 POST 类型的 CSRF 这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单，如： 12345678&lt;form action=\"http://bank.example/withdraw\" method=\"POST\"&gt; &lt;input type=\"hidden\" name=\"account\" value=\"xiaoming\" /&gt; &lt;input type=\"hidden\" name=\"amount\" value=\"10000\" /&gt; &lt;input type=\"hidden\" name=\"for\" value=\"hacker\" /&gt;&lt;/form&gt;&lt;script&gt; document.forms[0].submit();&lt;/script&gt; 访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。 POST 类型的攻击通常比 GET 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面。 链接类型的 CSRF 链接类型的 CSRF 并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如： 1234567&lt;a href=\"http://test.com/csrf/withdraw.php?amount=1000&amp;for=hacker\" taget=\"_blank\"&gt; 重磅消息！！ &lt;a/&gt;&lt;/a&gt; 由于之前用户登录了信任的网站 A，并且保存登录状态，只要用户主动访问上面的这个 PHP 页面，则表示攻击成功。 3.CSRF 的特点 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。 攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。 跨站请求可以用各种方式：图片 URL、超链接、CORS、Form 提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。 CSRF 通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。 4.防护策略CSRF 通常从第三方网站发起，被攻击的网站无法防止攻击发生，只能通过增强自己网站针对 CSRF 的防护能力来提升安全性。 上文中讲了CSRF 的两个特点： CSRF（通常）发生在第三方域名。 CSRF 攻击者不能获取到 Cookie 等信息，只是使用。 针对这两点，我们可以专门制定防护策略，如下： 阻止不明外域的访问 同源检测 Samesite Cookie 提交时要求附加本域才能获取的信息 CSRF Token 双重 Cookie 验证 同源检测既然 CSRF 大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。 我们如何判断请求是否来自外域呢？ 在 HTTP 协议中，每一个异步请求都会携带两个 Header，用于标记来源域名： Origin Header Referer Header 这两个 Header 在浏览器发起请求时，大多数情况会自动带上，并且不能由前端自定义内容。服务器可以通过解析这两个 Header 中的域名，确定请求的来源域。 1. 使用 Origin Header 确定来源域名在部分与 CSRF 有关的请求中，请求的 Header 中会携带 Origin 字段。字段内包含请求的域名（不包含 path 及 query）。 如果 Origin 存在，那么直接使用 Origin 中的字段确认来源域名就可以。 但是 Origin 在以下两种情况下并不存在： IE11 同源策略： IE 11 不会在跨站 CORS 请求上添加 Origin 标头，Referer 头将仍然是唯一的标识。最根本原因是因为 IE 11 对同源的定义和其他浏览器有不同，有两个主要的区别，可以参考MDN Same-origin_policy#IE_Exceptions 302 重定向： 在 302 重定向之后 Origin 不包含在重定向的请求中，因为 Origin 可能会被认为是其他来源的敏感信息。对于 302 重定向的情况来说都是定向到新的服务器上的 URL，因此浏览器不想将 Origin 泄漏到新的服务器上。 2. 使用 Referer Header 确定来源域名根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，记录了该 HTTP 请求的来源地址。对于 Ajax 请求，图片和 script 等资源请求，Referer 为发起请求的页面地址。对于页面跳转，Referer 为打开页面历史记录的前一个页面地址。因此我们使用 Referer 中链接的 Origin 部分可以得知请求的来源域名。 这种方法并非万无一失，Referer 的值是由浏览器提供的，虽然 HTTP 协议上有明确的要求，但是每个浏览器对于 Referer 的具体实现可能有差别，并不能保证浏览器自身没有安全漏洞。使用验证 Referer 值的方法，就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不是很安全。在部分情况下，攻击者可以隐藏，甚至修改自己请求的 Referer。 2014 年，W3C 的 Web 应用安全工作组发布了 Referrer Policy 草案，对浏览器该如何发送 Referer 做了详细的规定。截止现在新版浏览器大部分已经支持了这份草案，我们终于可以灵活地控制自己网站的 Referer 策略了。新版的 Referrer Policy 规定了五种 Referer 策略：No Referrer、No Referrer When Downgrade、Origin Only、Origin When Cross-origin、和 Unsafe URL。之前就存在的三种策略：never、default 和 always，在新标准里换了个名称。他们的对应关系如下： 根据上面的表格因此需要把 Referrer Policy 的策略设置成 same-origin，对于同源的链接和引用，会发送 Referer，referer 值为 Host 不带 Path；跨域访问则不携带 Referer。例如：aaa.com引用bbb.com的资源，不会发送 Referer。 设置 Referrer Policy 的方法有三种： 在 CSP 设置 页面头部增加 meta 标签 a 标签增加 referrerpolicy 属性 攻击者可以在自己的请求中隐藏 Referer。 另外在以下情况下 Referer 没有或者不可信： IE6、7 下使用 window.location.href=url 进行界面的跳转，会丢失 Referer。 IE6、7 下使用 window.open，也会缺失 Referer。 HTTPS 页面跳转到 HTTP 页面，所有浏览器 Referer 都丢失。 点击 Flash 上到达另外一个网站的时候，Referer 的情况就比较杂乱，不太可信。 无法确认来源域名情况当 Origin 和 Referer 头文件不存在时该怎么办？如果 Origin 和 Referer 都不存在，建议直接进行阻止，特别是如果您没有使用随机 CSRF Token（参考下方）作为第二次检查。 如何阻止外域请求通过 Header 的验证，我们可以知道发起请求的来源域名，这些来源域名可能是网站本域，或者子域名，或者有授权的第三方域名，又或者来自不可信的未知域名。 CSRF 大多数情况下来自第三方域名，但并不能排除本域发起。如果攻击者有权限在本域发布评论（含链接、图片等，统称 UGC），那么它可以直接在本域发起攻击，这种情况下同源策略无法达到防护的作用。 综上所述：同源验证是一个相对简单的防范方法，能够防范绝大多数的 CSRF 攻击。但这并不是万无一失的，对于安全性要求较高，或者有较多用户输入内容的网站，我们就要对关键的接口做额外的防护措施。 CSRF Token我们可以要求所有的用户请求都携带一个 CSRF 攻击者无法获取到的 Token。服务器通过校验请求是否携带正确的 Token，来把正常的请求和攻击的请求区分开，也可以防范 CSRF 的攻击。 CSRF Token 的防护策略分为三个步骤： 将 CSRF Token 输出到页面中 首先，用户打开页面的时候，服务器需要给这个用户生成一个 Token，该 Token 通过加密算法对数据进行加密，一般 Token 都包括随机字符串和时间戳的组合，显然在提交时 Token 不能再放在 Cookie 中了，否则又会被攻击者冒用。因此，为了安全起见 Token 最好还是存在服务器的 Session 中，之后在每次页面加载时，使用 JS 遍历整个 DOM 树，对于 DOM 中所有的 a 和 form 标签后加入 Token。这样可以解决大部分的请求，但是对于在页面加载之后动态生成的 HTML 代码，这种方法就没有作用，还需要程序员在编码时手动添加 Token。 页面提交的请求携带这个 Token 对于 GET 请求，Token 将附在请求地址之后，这样 URL 就变成 http://url?csrftoken=tokenvalue。 而对于 POST 请求来说，要在 form 的最后加上： 1&lt;input type=\"”hidden”\" name=\"”csrftoken”\" value=\"”tokenvalue”\" /&gt; ​ 这样，就把 Token 以参数的形式加入请求了。 服务器验证 Token 是否正确 当用户从客户端得到了 Token，再次提交给服务器的时候，服务器需要判断 Token 的有效性，验证过程是先解密 Token，对比加密字符串以及时间戳，如果加密字符串一致且时间未过期，那么这个 Token 就是有效的。 这种方法要比之前检查 Referer 或者 Origin 要安全一些，Token 可以在产生并放于 Session 之中，然后在每次请求时把 Token 从 Session 中拿出，与请求中的 Token 进行比对，但这种方法的比较麻烦的在于如何把 Token 以参数的形式加入请求。 分布式校验 在大型网站中，使用 Session 存储 CSRF Token 会带来很大的压力。访问单台服务器 session 是同一个。但是现在的大型网站中，我们的服务器通常不止一台，可能是几十台甚至几百台之多，甚至多个机房都可能在不同的省份，用户发起的 HTTP 请求通常要经过像 Ngnix 之类的负载均衡器之后，再路由到具体的服务器上，由于 Session 默认存储在单机服务器内存中，因此在分布式环境下同一个用户发送的多次 HTTP 请求可能会先后落到不同的服务器上，导致后面发起的 HTTP 请求无法拿到之前的 HTTP 请求存储在服务器中的 Session 数据，从而使得 Session 机制在分布式环境下失效，因此在分布式集群中 CSRF Token 需要存储在 Redis 之类的公共存储空间。 由于使用 Session 存储，读取和验证 CSRF Token 会引起比较大的复杂度和性能问题，目前很多网站采用 Encrypted Token Pattern 方式。这种方法的 Token 是一个计算出来的结果，而非随机生成的字符串。这样在校验时无需再去读取存储的 Token，只用再次计算一次即可。 这种 Token 的值通常是使用 UserID、时间戳和随机数，通过加密的方法生成。这样既可以保证分布式服务的 Token 一致，又能保证 Token 不容易被破解。 在 token 解密成功之后，服务器可以访问解析值，Token 中包含的 UserID 和时间戳将会被拿来被验证有效性，将 UserID 与当前登录的 UserID 进行比较，并将时间戳与当前时间进行比较。 双重 Cookie 验证使用双重提交 Cookie。利用 CSRF 攻击不能获取到用户 Cookie 的特点，我们可以要求 Ajax 和表单请求携带一个 Cookie 中的值。 双重 Cookie 采用以下流程： 在用户访问网站页面时，向请求域名注入一个 Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。 在前端向后端发起请求时，取出 Cookie，并添加到 URL 的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。 后端接口验证 Cookie 中的字段与 URL 参数中的字段是否一致，不一致则拒绝。 此方法相对于 CSRF Token 就简单了许多。可以直接通过前后端拦截的的方法自动化实现。后端校验也更加方便，只需进行请求中字段的对比，而不需要再进行查询和存储 Token。 由于任何跨域都会导致前端无法获取 Cookie 中的字段（包括子域名之间），于是发生了如下情况： 如果用户访问的网站为www.a.com，而后端的 api 域名为api.a.com。那么在www.a.com下，前端拿不到api.a.com的 Cookie，也就无法完成双重 Cookie 认证。 于是这个认证 Cookie 必须被种在a.com下，这样每个子域都可以访问。 任何一个子域都可以修改a.com下的 Cookie。 某个子域名存在漏洞被 XSS 攻击（例如upload.a.com）。虽然这个子域下并没有什么值得窃取的信息。但攻击者修改了a.com下的 Cookie。 攻击者可以直接使用自己配置的 Cookie，对 XSS 中招的用户再向www.a.com下，发起 CSRF 攻击。 总结 用双重 Cookie 防御 CSRF 的优点： 无需使用 Session，适用面更广，易于实施。 Token 储存于客户端中，不会给服务器带来压力。 相对于 Token，实施成本更低，可以在前后端统一拦截校验，而不需要一个个接口和页面添加。 缺点： Cookie 中增加了额外的字段。 如果有其他漏洞（例如 XSS），攻击者可以注入 Cookie，那么该防御方式失效。 难以做到子域名的隔离。 为了确保 Cookie 传输安全，采用这种防御方式最好确保用整站 HTTPS 的方式，如果还没切 HTTPS 的使用这种方式也会有风险。 Samesite Cookie 属性Set-Cookie 响应头新增 Samesite 属性，它用来标明这个 Cookie 是个“同站 Cookie”，同站 Cookie 只能作为第一方 Cookie，不能作为第三方 Cookie，Samesite 有两个属性值，分别是 Strict 和 Lax Samesite=Strict这种称为严格模式，表明这个 Cookie 在任何情况下都不可能作为第三方 Cookie，绝无例外。比如说 b.com 设置了如下 Cookie： 123Set-Cookie: foo=1; Samesite=StrictSet-Cookie: bar=2; Samesite=LaxSet-Cookie: baz=3 我们在 a.com 下发起对 b.com 的任意请求，foo 这个 Cookie 都不会被包含在 Cookie 请求头中，但 bar 会。举个实际的例子就是，假如淘宝网站用来识别用户登录与否的 Cookie 被设置成了 Samesite=Strict，那么用户从百度搜索页面甚至天猫页面的链接点击进入淘宝后，淘宝都不会是登录状态，因为淘宝的服务器不会接受到那个 Cookie，其它网站发起的对淘宝的任意请求都不会带上那个 Cookie。 Samesite=Lax这种称为宽松模式，比 Strict 放宽了点限制：假如这个请求是这种请求（改变了当前页面或者打开了新页面）且同时是个 GET 请求，则这个 Cookie 可以作为第三方 Cookie。 当用户从 a.com 点击链接进入 b.com 时，foo 这个 Cookie 不会被包含在 Cookie 请求头中，但 bar 和 baz 会，也就是说用户在不同网站之间通过链接跳转是不受影响了。但假如这个请求是从 a.com 发起的对 b.com 的异步请求，或者页面跳转是通过表单的 post 提交触发的，则 bar 也不会发送。 生成 Token 放到 Cookie 中并且设置 Cookie 的 Samesite 我们应该如何使用 SamesiteCookie如果 SamesiteCookie 被设置为 Strict，浏览器在任何跨域请求中都不会携带 Cookie，新标签重新打开也不携带，所以说 CSRF 攻击基本没有机会。 但是跳转子域名或者是新标签重新打开刚登陆的网站，之前的 Cookie 都不会存在。尤其是有登录的网站，那么我们新打开一个标签进入，或者跳转到子域名的网站，都需要重新登录。对于用户来讲，可能体验不会很好。 如果 SamesiteCookie 被设置为 Lax，那么其他网站通过页面跳转过来的时候可以使用 Cookie，可以保障外域连接打开页面时用户的登录状态。但相应的，其安全性也比较低。 另外一个问题是 Samesite 的兼容性不是很好，现阶段除了从新版 Chrome 和 Firefox 支持以外，Safari 以及 iOS Safari 都还不支持，现阶段看来暂时还不能普及。 而且，SamesiteCookie 目前有一个致命的缺陷：不支持子域。例如，种在 topic.a.com 下的 Cookie，并不能使用 a.com 下种植的 SamesiteCookie。这就导致了当我们网站有多个子域名时，不能使用 SamesiteCookie 在主域名存储用户登录信息。每个子域名都需要用户重新登录一次。 总之，SamesiteCookie 是一个可能替代同源验证的方案，但目前还并不成熟，其应用场景有待观望。 5.防止网站被利用（防止攻击的发生）CSRF 的攻击可以来自： 攻击者自己的网站。 有文件上传漏洞的网站。 第三方论坛等用户内容。 被攻击网站自己的评论功能等。 如何防止自己的网站被利用成为攻击的源头呢？ 严格管理所有的上传接口，防止任何预期之外的上传内容（例如 HTML）。 添加 Header X-Content-Type-Options: nosniff 防止黑客上传 HTML 内容的资源（例如图片）被解析为网页。 对于用户上传的图片，进行转存或者校验。不要直接使用用户填写的图片链接。 当前用户打开其他用户填写的链接时，需告知风险（这也是很多论坛不允许直接在内容中发布外域链接的原因之一，不仅仅是为了用户留存，也有安全考虑）。 6.CSRF 其他防范措施CSRF 测试CSRFTester 是一款 CSRF 漏洞的测试工具，CSRFTester 工具的测试原理大概是这样的，使用代理抓取我们在浏览器中访问过的所有的连接以及所有的表单等信息，通过在 CSRFTester 中修改相应的表单等信息，重新提交，相当于一次伪造客户端请求，如果修改后的测试请求成功被网站服务器接受，则说明存在 CSRF 漏洞，当然此款工具也可以被用来进行 CSRF 攻击。CSRFTester 使用方法大致分下面几个步骤： 步骤 1：设置浏览器代理 CSRFTester 默认使用 Localhost 上的端口 8008 作为其代理，如果代理配置成功，CSRFTester 将为您的浏览器生成的所有后续 HTTP 请求生成调试消息。 步骤 2：使用合法账户访问网站开始测试 我们需要找到一个我们想要为 CSRF 测试的特定业务 Web 页面。找到此页面后，选择 CSRFTester 中的“开始录制”按钮并执行业务功能；完成后，点击 CSRFTester 中的“停止录制”按钮；正常情况下，该软件会全部遍历一遍当前页面的所有请求。 步骤 3：通过 CSRF 修改并伪造请求 之后，我们会发现软件上有一系列跑出来的记录请求，这些都是我们的浏览器在执行业务功能时生成的所有 GET 或者 POST 请求。通过选择列表中的某一行，我们现在可以修改用于执行业务功能的参数，可以通过点击对应的请求修改 query 和 form 的参数。当修改完所有我们希望诱导用户 form 最终的提交值，可以选择开始生成 HTML 报告。 步骤 4：拿到结果如有漏洞进行修复 首先必须选择“报告类型”。报告类型决定了我们希望受害者浏览器如何提交先前记录的请求。目前有 5 种可能的报告：表单、iFrame、IMG、XHR 和链接。一旦选择了报告类型，我们可以选择在浏览器中启动新生成的报告，最后根据报告的情况进行对应的排查和修复。 CSRF 监控对于一个比较复杂的网站系统，某些项目、页面、接口漏掉了 CSRF 防护措施是很可能的。 一旦发生了 CSRF 攻击，我们如何及时的发现这些攻击呢？ CSRF 攻击有着比较明显的特征： 跨域请求。 GET 类型请求 Header 的 MIME 类型大概率为图片，而实际返回 Header 的 MIME 类型为 Text、JSON、HTML。 我们可以在网站的代理层监控所有的接口请求，如果请求符合上面的特征，就可以认为请求有 CSRF 攻击嫌疑。我们可以提醒对应的页面和项目负责人，检查或者 Review 其 CSRF 防护策略。 个人用户 CSRF 安全的建议经常上网的个人用户，可以采用以下方法来保护自己： 使用网页版邮件的浏览邮件或者新闻也会带来额外的风险，因为查看邮件或者新闻消息有可能导致恶意代码的攻击。 尽量不要打开可疑的链接，一定要打开时，使用不常用的浏览器。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"XSS攻击","slug":"XSS攻击","date":"2019-06-13T10:29:55.000Z","updated":"2019-08-15T17:50:38.774Z","comments":true,"path":"2019/06/13/XSS攻击/","link":"","permalink":"http://yoursite.com/2019/06/13/XSS攻击/","excerpt":"XSS 攻击1.什么是 XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。","text":"XSS 攻击1.什么是 XSSCross-Site Scripting（跨站脚本攻击）简称 XSS，是一种代码注入攻击。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。 为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。 XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 在处理输入时，以下内容都不可信： 来自用户的 UGC 信息 来自第三方的链接 URL 参数 POST 参数 Referer （可能来自不可信的来源） Cookie （可能来自其他子域注入） 2.XSS 分类根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。 存储型 XSS存储型 XSS 的攻击步骤： 攻击者将恶意代码提交到目标网站的数据库中。 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。 反射型 XSS反射型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。 反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。 由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。 POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。 DOM 型 XSSDOM 型 XSS 的攻击步骤： 攻击者构造出特殊的 URL，其中包含恶意代码。 用户打开带有恶意代码的 URL。 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。 DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 3.XSS 的预防XSS 攻击有两大要素： 攻击者提交恶意代码。 浏览器执行恶意代码。 输入过滤输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。 对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。 输入过滤并非完全可靠，我们就要通过“防止浏览器执行恶意代码”来防范 XSS。这部分分为两类： 防止 HTML 中出现注入。 防止 JavaScript 执行时，执行恶意代码。 预防存储型和反射型 XSS 攻击预防这两种漏洞，有两种常见做法： 改成纯前端渲染，把代码和数据分隔开。 纯前端渲染的过程： 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。 然后浏览器执行 HTML 中的 JavaScript。 JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。 在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（.innerText），还是属性（.setAttribute），还是样式（.style）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。 但纯前端渲染还需注意避免 DOM 型 XSS 漏洞 对 HTML 做充分转义。 转义应该在输出 HTML 时进行，而不是在提交用户输入时。 常用的模板引擎，如 doT.js、ejs、FreeMarker 等，对于 HTML 转义通常只有一个规则，就是把 &amp; &lt; &gt; &quot; &#39; / 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善： 预防 DOM 型 XSS 攻击 在使用 .innerHTML、.outerHTML、document.write() 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 .textContent、.setAttribute() 等。 如果用 Vue/React 技术栈，并且不使用 v-html/dangerouslySetInnerHTML 功能，就在前端 render 阶段避免 innerHTML、outerHTML 的 XSS 隐患。 DOM 中的内联事件监听器，如 location、onclick、onerror、onload、onmouseover 等，&lt;a&gt; 标签的 href 属性，JavaScript 的 eval()、setTimeout()、setInterval() 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。 4.其他 XSS 防范措施Content Security Policy严格的 CSP 在 XSS 的防范中可以起到以下的作用： 禁止加载外域代码，防止复杂的攻击逻辑。 禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。 禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。 禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。 合理使用上报可以及时发现 XSS，利于尽快修复问题。 输入内容长度控制对于不受信任的输入，都应该限定一个合理的长度。虽然无法完全防止 XSS 发生，但可以增加 XSS 攻击的难度。 其他安全措施 HTTP-only Cookie: 禁止 JavaScript 读取某些敏感 Cookie，攻击者完成 XSS 注入后也无法窃取此 Cookie。 验证码：防止脚本冒充用户提交危险操作。 5.XSS 漏洞总结漏洞总结 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。 在标签的 href、src 等属性中，包含 javascript: 等可执行代码。 在 onload、onerror、onclick 等事件中，注入不受控制代码。 在 style 属性和标签中，包含类似 background-image:url(&quot;javascript:...&quot;); 的代码（新版本浏览器已经可以防范）。 在 style 属性和标签中，包含类似 expression(...) 的 CSS 表达式代码（新版本浏览器已经可以防范）。 总之，如果开发者没有将用户输入的文本进行合适的过滤，就贸然插入到 HTML 中，这很容易造成注入漏洞。攻击者可以利用漏洞，构造出恶意的代码指令，进而利用恶意代码危害数据安全。 内联 JSON 也是不安全的： 当 JSON 中包含 U+2028 或 U+2029 这两个字符时，不能作为 JavaScript 的字面量使用，否则会抛出语法错误。 当 JSON 中包含字符串 &lt;/script&gt; 时，当前的 script 标签将会被闭合，后面的字符串内容浏览器会按照 HTML 进行解析；通过增加下一个 &lt;script&gt; 标签等方法就可以完成注入。 6.减少漏洞产生的原则 利用模板引擎开启模板引擎自带的 HTML 转义功能。例如：在 ejs 中，尽量使用 &lt;%= data %&gt; 而不是 &lt;%- data %&gt;；在 FreeMarker 中，确保引擎版本高于 2.3.24，并且选择正确的 freemarker.core.OutputFormat。 避免内联事件尽量不要使用 onLoad=&quot;onload(&#39;&#39;)&quot;、onClick=&quot;go(&#39;&#39;)&quot; 这种拼接内联事件的写法。在 JavaScript 中通过 .addEventlistener() 事件绑定会更安全。 避免拼接 HTML前端采用拼接 HTML 的方法比较危险，如果框架允许，使用 createElement、setAttribute 之类的方法实现。或者采用比较成熟的渲染框架，如 Vue/React 等。 时刻保持警惕在插入位置为 DOM 属性、链接等位置时，要打起精神，严加防范。 增加攻击难度，降低攻击后果通过 CSP、输入长度配置、接口安全措施等方法，增加攻击的难度，降低攻击的后果。 主动检测和发现可使用 XSS 攻击字符串和自动扫描工具寻找潜在的 XSS 漏洞。 7.vue react 框架对 xss 的防护有做什么？ VUE 尽量使用插值表达式(双花括号)，它会把要显示的内容转为字符串。 如果使用v-html，要保证来自服务端的渲染数据都是安全的。 在使用第三方 UI 组件库的的时候，要检查一下它们渲染页面的方式，是否使用了v-html REACT XSS 防御措施就是对任何用户输入的信息进行处理，只允许合法值，其它值一概过滤掉 所有的用户输入都需要经过 HTML 实体编码，React 已经做了，它会在运行时动态创建 DOM 节点然后填入文本内容 (也可以强制设置 HTML 内容，不过这样比较危险) 序列化某些状态并且传给客户端的时候，也进行 HTML 实体编码，可以使用 Yahoo 的 Serialize JavaScript 中的 serialize 方法替换 JSON.stringify 方法，Serialize JavaScript 中的方法会自动将 HTML 和 JavaScript 代码进行转码，GitHub 访问地址 : https://github.com/yahoo/serialize-javascript 默认情况下，React DOM 在重新渲染页面时将所有进行转码，官方宣称在 React 应用中确保不会注入任何没显式编写的数据，所有的数据在页面渲染之前都会被转换成字符串，这防止 XSS 进攻 8.xss 攻击后果？恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。 而由于直接在用户的终端执行，恶意代码能够直接获取用户的信息，或者利用这些信息冒充用户向网站发起攻击者定义的请求。 9.需要转义的字符？ escapeHTML() 按照如下规则进行转义： 连 javascript: 这样的字符串如果出现在特定的位置也会引发 XSS 攻击。 %20javascript:alert(&#39;XSS&#39;) 经过 URL 解析后变成 javascript:alert(&#39;XSS&#39;)，这个字符串以空格开头。这样攻击者可以绕过后端的关键词规则，又成功的完成了注入。 插入 JSON 的地方不能使用 escapeHTML()，因为转义 &quot; 后，JSON 格式会被破坏。 要实现一个 escapeEmbedJSON() 函数，对内联 JSON 进行转义。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"ES6 的新特性总结","slug":"ES6 的新特性总结","date":"2019-06-01T14:23:01.000Z","updated":"2019-08-15T17:31:24.050Z","comments":true,"path":"2019/06/01/ES6 的新特性总结/","link":"","permalink":"http://yoursite.com/2019/06/01/ES6 的新特性总结/","excerpt":"ES6 的新特性1. 数组的拓展数组的方法 array.concat(array1, array2,…arrayN)合并多个数组，返回合并后的新数组，原数组没有变化。 array.every(callback[, thisArg])检测数组中的每一个元素是否都通过了 callback 测试，全部通过返回 true，否则返回 false。 array.filter(callback[, thisArg])返回一个新数组，包含通过 callback 函数测试的所有元素。(callback 定义，三个参数： element:当前元素值；index：当前元素下标； array:当前数组) array.find(callback[, thisArg])返回通过 callback 函数测试的第一个元素，否则返回 undefined，callback 函数定义同上。","text":"ES6 的新特性1. 数组的拓展数组的方法 array.concat(array1, array2,…arrayN)合并多个数组，返回合并后的新数组，原数组没有变化。 array.every(callback[, thisArg])检测数组中的每一个元素是否都通过了 callback 测试，全部通过返回 true，否则返回 false。 array.filter(callback[, thisArg])返回一个新数组，包含通过 callback 函数测试的所有元素。(callback 定义，三个参数： element:当前元素值；index：当前元素下标； array:当前数组) array.find(callback[, thisArg])返回通过 callback 函数测试的第一个元素，否则返回 undefined，callback 函数定义同上。 array.findIndex(callback[, thisArg])返回通过 callback 函数测试的第一个元素的索引，否则返回-1，callback 函数定义同上。 array.includes(searchElement, fromIndex)includes() 方法用来判断一个数组是否包含一个指定的值，返回 true 或 false。searchElement：要查找的元素；fromIndex：开始查找的索引位置。 array.indexOf(searchElement[, fromIndex = 0])返回在数组中可以找到一个给定元素的第一个索引，如果不存在，则返回-1。searchElement：要查找的元素；fromIndex：开始查找的索引位置。 array.join(separator=&#39;,&#39;)将数组中的元素通过 separator 连接成字符串，并返回该字符串，separator 默认为”,”。 array.map(callback[, thisArg])返回一个新数组，新数组中的每个元素都是调用 callback 函数后返回的结果。注意：如果没有 return 值，则新数组会插入一个 undefined 值。array.map 由于不具有过滤的功能，因此 array 调用 map 函数时，如果 array 中的数据并不是每一个都会 return，则必须先 filter，然后再 map，即 map 调用时必须是对数组中的每一个元素都有效。 array.pop() 与 array.shift()pop 为从数组中删除最后一个元素，并返回最后一个元素的值，原数组的最后一个元素被删除。数组为空时返回 undefined。shift 删除数组的第一个元素，并返回第一个元素，原数组的第一个元素被删除。数组为空返回 undefined。 array.push(element1, element2, ....elementN) 与 array.unshift(element1, element2, ...elementN)push 是将一个或多个元素添加到数组的末尾，并返回新数组的长度; unshift 将一个或多个元素添加到数组的开头，并返回新数组的长度。唯一的区别就是插入的位置不同。 array.reduce(callback[, initialValue])对数组中的每个元素（从左到右）执行 callback 函数累加，将其减少为单个值。 array.reverse()将数组中元素的位置颠倒。 array.slice(begin, end)返回一个新数组，包含原数组从 begin 到 end(不包含 end)索引位置的所有元素。 array.some(callback[, thisArg])判断数组中是否包含可以通过 callback 测试的元素，与 every 不同的是，这里只要某一个元素通过测试，即返回 true。callback 定义同上。 array.sort([compareFunction])对数组中的元素进行排序，compareFunction 不存在时，元素按照转换为的字符串的诸个字符的 Unicode 位点进行排序，慎用！请使用时一定要加 compareFunction 函数，而且该排序是不稳定的。 array.splice(start[, deleteCount, item1, item2, ...])通过删除现有元素和/或添加新元素来更改一个数组的内容。start:指定修改的开始位置；deleteCount：从 start 位置开始要删除的元素个数；item…：要添加进数组的元素,从 start 位置开始。返回值是由被删除的元素组成的一个数组。如果只删除了一个元素，则返回只包含一个元素的数组。如果没有删除元素，则返回空数组。如果 deleteCount 大于 start 之后的元素的总数，则从 start 后面的元素都将被删除（含第 start 位）。 注：push、 shift、 pop、 unshift、 reverse、 sort、 splice 方法会对原来的数组进行修改，其他的数组操作方法只有返回值不同，对原数组都没有影响，即原数组不变。 ES6 中对数组的扩展 Array.from() : 将伪数组对象或可遍历对象转换为真数组 Array.of(v1, v2, v3) : 将一系列值转换成数组。 当使用单个数值参数来调用 Array 构造器时，数组的长度属性会被设置为该参数。 如果使用多个参数(无论是否为数值类型)来调用，这些参数也会成为目标数组的项。数组的这种行为既混乱又有风险，因为有时可能不会留意所传参数的类型。 Array.of( )方法总会创建一个包含所有传入参数的数组，而不管参数的数量与类型 1234567let items = Array.of(1, 2);console.log(items.length); // 2console.log(items[0]); // 1console.log(items[1]); // 2items = Array.of(2);console.log(items.length); // 1console.log(items[0]); // 2 Array.of 基本上可以用来替代 Array()或 newArray()，并且不存在由于参数不同而导致的重载，而且他们的行为非常统一。 数组实例的 find() 和 findIndex() find 方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为 true 的成员，然后返回该成员。如果没有符合条件的成员，则返回 undefined。 1[1, 4, -5, 10].find(n =&gt; n &lt; 0); // -5 findIndex 方法的用法与 find 方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;); // 2 数组实例的 includes() Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值。该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为 3），则会重置为从 0 开始。 1234[1, 2, 3] .includes(2) // true [(1, 2, 3)].includes(3, -1); // true[1, 2, 3, 5, 1].includes(1, 2); // true 没有该方法之前，我们通常使用数组的 indexOf 方法，检查是否包含某个值。它内部使用严格相等运算符（===）进行判断，这会导致对 NaN 的误判。 123[NaN] .indexOf(NaN) // -1 [NaN].includes(NaN); // true 数组实例的 entries()，keys() 和 values() 它们都返回一个遍历器对象，可以用 for…of 循环进行遍历，唯一的区别是 keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of [\"a\", \"b\"].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of [\"a\", \"b\"].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of [\"a\", \"b\"].entries()) &#123; console.log(index, elem);&#125;// 0 \"a\"// 1 \"b\" 2. 箭头函数 缩减代码和改变 this 指向 使用注意点： 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。 3. rest 参数 用于获取函数的多余参数，这样就不需要使用 arguments 对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 注意点： 每个函数最多只能声明一个 rest 参数，而且 rest 参数必须是最后一个参数，否则报错。 rest 参数不能用于对象字面量 setter 之中 4. 展开运算符剩余参数允许你把多个独立的参数合并到一个数组中；而扩展运算符则允许将一个数组分割，并将各个项作为分离的参数传给函数。 5. 解构赋值—-更方便的数据访问6. 模板字符串用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量和函数，需要将变量名写在\\${}之中。 7. class 类8. promise9. Iterator 和 for…of 循环JavaScript 原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6 添加了 Map 和 Set。 任何数据结构只要部署 Iterator 接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator 的作用： 为各种数据结构，提供一个统一的、简便的访问接口； 使得数据结构的成员能够按某种次序排列 ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费。 原生具备 iterator 接口的数据(可用 for of 遍历) Array set 容器 map 容器 String 函数的 arguments 对象 NodeList 对象 几种遍历方式比较 for of 循环不仅支持数组、大多数伪数组对象，也支持字符串遍历，此外还支持 Map 和 Set 对象遍历 for in 循环可以遍历字符串、对象、数组，不能遍历 Set/Map forEach 循环不能遍历字符串、对象,可以遍历 Set/Map 10. ES6 模块化其模块功能主要由两个命令构成：export 和 import。export 命令用于规定模块的对外接口，import 命令用于输入其他模块提供的功能。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"}]},{"title":"CSS元素居中","slug":"CSS元素居中","date":"2019-05-23T10:06:01.000Z","updated":"2019-08-15T17:33:40.096Z","comments":true,"path":"2019/05/23/CSS元素居中/","link":"","permalink":"http://yoursite.com/2019/05/23/CSS元素居中/","excerpt":"CSS 元素居中1.水平居中 行内元素水平居中 利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。","text":"CSS 元素居中1.水平居中 行内元素水平居中 利用 text-align: center 可以实现在块级元素内部的行内元素水平居中。此方法对 inline、inline-block、inline-table 和 inline-flex 元素水平居中都有效。 1234.parent &#123; //在父容器设置 text-align: center;&#125; 此外，如果块级元素内部包着也是一个块级元素，我们可以先将其由块级元素改变为行内块元素，再通过设置行内块元素居中以达到水平居中。 1234567891011&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; text-align: center; &#125; .child &#123; display: inline-block; &#125;&lt;/style&gt; 块级元素的水平居中 这种情形可以有多种实现方式，下面我们详细介绍: ① 将该块级元素左右外边距 margin-left 和 margin-right 设置为 auto1234.child &#123; width: 100px; //确保该块级元素定宽 margin: 0 auto;&#125; ② 使用 table+margin先将子元素设置为块级表格来显示（类似），再将其设置水平居中 display:table 在表现上类似 block 元素，但是宽度为内容宽。 123456789&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; ③ 使用 absolute+transform先将父元素设置为相对定位，再将子元素设置为绝对定位，向右移动子元素，移动距离为父容器的一半，最后通过向左移动子元素的一半宽度以达到水平居中。 12345678910111213&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .child &#123; position: absolute; left: 50%; transform: translateX(-50%); &#125; .parent &#123; position: relative; &#125;&lt;/style&gt; 不过 transform 属于 css3 内容，兼容性存在一定问题，高版本浏览器需要添加一些前缀 ④ 使用 flex+justify-content通过 CSS3 中的布局利器 flex 中的 justify-content 属性来达到水平居中。 123456789&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; justify-content: center; &#125;&lt;/style&gt; ⑤ 使用 flex+margin通过 flex 将父容器设置为为 Flex 布局，再设置子元素居中。 1234567891011&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;child&quot;&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; margin:0 auto; &#125;&lt;/style&gt; 多块级元素水平居中 ① 利用 flex 布局利用弹性布局(flex)，实现水平居中，其中 justify-content 用于设置弹性盒子元素在主轴（默认横轴）方向上的对齐方式，本例中设置子元素水平居中显示。 1234#container &#123; display: flex; justify-content: center;&#125; ② 利用 inline-block将要水平排列的块状元素设为 display:inline-block，然后在父级元素上设置 text-align:center，达到与上面的行内元素的水平居中一样的效果。 123456.container &#123; text-align: center;&#125;.inline-block &#123; display: inline-block;&#125; 浮动元素水平居中 对于定宽的浮动元素，通过子元素设置 relative + 负 margin 对于不定宽的浮动元素，父子容器都用相对定位 通用方法(不管是定宽还是不定宽)：flex 布局 ① 定宽的非浮动元素通过子元素设置 relative + 负 margin,原理见下图： 注意：样式设置在浮动元素本身 123456.child &#123; position:relative; left:50%; margin-left:-250px; &#125;&lt;div class=\"parent\"&gt; &lt;span class=\"child\" style=\"float: left;width: 500px;\" &gt;我是要居中的浮动元素&lt;/span &gt;&lt;/div&gt; ② 不定宽的浮动元素通过父子容器都相对定位，偏移位移见下图：注意：要清除浮动，给外部元素加上 float。这里的父元素就是外部元素 123456&lt;div class=\"box\"&gt; &lt;p&gt;我是浮动的&lt;/p&gt; &lt;p&gt;我也是居中的&lt;/p&gt;&lt;/div&gt;.box&#123; float:left; position:relative; left:50%; &#125; p&#123; float:left;position:relative; right:50%; &#125; ③ 通用办法 flex 布局(不管是定宽还是不定宽)利用弹性布局(flex)的 justify-content 属性，实现水平居中。 12345.parent &#123; display:flex; justify-content:center; &#125; .chlid&#123; float: left; width:200px;//有无宽度不影响居中 &#125;&lt;div class=\"parent\"&gt; &lt;span class=\"chlid\"&gt;我是要居中的浮动元素&lt;/span&gt;&lt;/div&gt; 绝对定位元素水平居中 这种方式非常独特，通过子元素绝对定位，外加 margin: 0 auto 来实现。 123456&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;让绝对定位的元素水平居中对齐。&lt;/div&gt;&lt;/div&gt;.parent&#123; position:relative; &#125; .child&#123; position: absolute; /*绝对定位*/ width:200px; height:100px; background: yellow; margin: 0 auto; /*水平居中*/ left: 0;/*此处不能省略，且为0*/ right: 0;/*此处不能省略，且为0*/ &#125; 2.垂直居中 单行内联元素垂直居中 12345678&lt;div id=\"box\"&gt;&lt;span&gt;单行内联元素垂直居中。&lt;/span&gt;。&lt;/div&gt;&lt;style&gt; #box &#123; height: 120px; line-height: 120px; border: 2px dashed #f69c55; &#125;&lt;/style&gt; 多行内联元素垂直居中 ① 利用 flex 布局（flex）利用 flex 布局实现垂直居中，其中 flex-direction: column 定义主轴方向为纵向。这种方式在较老的浏览器存在兼容性问题。 12345678910111213141516&lt;div class=\"parent\"&gt; &lt;p&gt; Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. Dance like nobody is watching, code like everybody is. &lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; height: 140px; display: flex; flex-direction: column; justify-content: center; border: 2px dashed #f69c55; &#125;&lt;/style&gt; ② 利用表布局（table）利用表布局的 vertical-align: middle 可以实现子元素的垂直居中 123456789101112131415161718&lt;div class=\"parent\"&gt; &lt;p class=\"child\"&gt; The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know. The more technology you learn, the more you realize how little you know. &lt;/p&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table; height: 140px; border: 2px dashed #f69c55; &#125; .child &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 块级元素垂直居中 ① 使用 absolute+负 margin(已知高度宽度)通过绝对定位元素距离顶部 50%，并设置 margin-top 向上偏移元素高度的一半，就可以实现了。 12345&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;固定高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; height:100px; margin-top: -50px; &#125; ② 使用 absolute+transform当垂直居中的元素的高度和宽度未知时，可以借助 CSS3 中的 transform 属性向 Y 轴反向偏移 50%的方法实现垂直居中。但是部分浏览器存在兼容性的问题。 12345&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%;transform: translateY(-50%); &#125; ③ 使用 flex+align-items通过设置 flex 布局中的属性 align-items，使子元素垂直居中。 1234&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;未知高度的块级元素垂直居中。&lt;/div&gt;&lt;/div&gt;.parent &#123; display:flex; align-items:center; &#125; ④ 使用 table-cell+vertical-align通过将父元素转化为一个表格单元格显示（类似 和 ），再通过设置 vertical-align 属性，使表格单元格内容垂直居中。 123456789&lt;div class=\"parent\"&gt; &lt;div class=\"child\"&gt;Demo&lt;/div&gt;&lt;/div&gt;&lt;style&gt; .parent &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; 3.水平垂直居中12345678// html部分(这部分不做变化,下面例子直接共用)&lt;body&gt; &lt;div id=\"container\"&gt; &lt;div id=\"center\" style=\"width: 100px;height: 100px;background-color: #666\"&gt; center &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 绝对定位与负边距实现（已知高度宽度） 这种方式需要知道被垂直居中元素的高和宽，才能计算出 margin 值，兼容所有浏览器。 12345678910// css部分#container &#123; position: relative;&#125;#center &#123; position: absolute; top: 50%; left: 50%; margin: -50px 0 0 -50px;&#125; 绝对定位与 margin:auto（已知高度宽度） 这种方式无需知道被垂直居中元素的高和宽，但不能兼容低版本的 IE 浏览器。 123456789101112#container &#123; position: relative; height: 100px; //必须有个高度&#125;#center &#123; position: absolute; top: 0; left: 0; right: 0; bottom: 0; margin: auto; //注意此处的写法&#125; 绝对定位+transform(未知元素的高宽) 利用 Css3 的 transform，可以轻松的在未知元素的高宽的情况下实现元素的垂直居中。CSS3 的 transform 固然好用，但在项目的实际运用中必须考虑兼容问题，大量的 hack 代码可能会导致得不偿失。 123456789#container &#123; position: relative;&#125;#center &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);&#125; flex 布局 利用 flex 布局，其中 justify-content 用于设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式；而 align-items 属性定义 flex 子项在 flex 容器的当前行的侧轴（纵轴）方向上的对齐方式。不能兼容低版本的 IE 浏览器。 1234567#container &#123; //直接在父容器设置即可 height: 100vh; //必须有高度 display: flex; justify-content: center; align-items: center;&#125; flex/grid 与 margin:auto(最简单写法) 容器元素设为 flex 布局或是 grid 布局，子元素只要写 margin: auto 即可,不能兼容低版本的 IE 浏览器。 1234567#container &#123; height: 100vh; //必须有高度 display: grid;&#125;#center &#123; margin: auto;&#125;","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS多列布局","slug":"CSS多列布局","date":"2019-05-08T03:25:33.000Z","updated":"2019-08-15T17:33:24.266Z","comments":true,"path":"2019/05/08/CSS多列布局/","link":"","permalink":"http://yoursite.com/2019/05/08/CSS多列布局/","excerpt":"1.单列布局常见的单列布局有两种： header,content 和 footer 等宽的单列布局 header 与 footer 等宽,content 略窄的单列布局","text":"1.单列布局常见的单列布局有两种： header,content 和 footer 等宽的单列布局 header 与 footer 等宽,content 略窄的单列布局 第一种：对于第一种，先通过对 header,content,footer 统一设置 width：1000px;或者 max-width：1000px(这两者的区别是当屏幕小于 1000px 时，前者会出现滚动条，后者则不会，显示出实际宽度);然后设置 margin:auto 实现居中即可得到。 123&lt;div class=\"header\"&gt;&lt;/div&gt;&lt;div class=\"content\"&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 123456789101112131415161718.header &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: blue;&#125;.content &#123; margin: 0 auto; max-width: 960px; height: 400px; background-color: aquamarine;&#125;.footer &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua;&#125; 第二种：对于第二种，header、footer 的内容宽度不设置，块级元素充满整个屏幕，但 header、content 和 footer 的内容区设置同一个 width，并通过 margin:auto 实现居中。 12345&lt;div class=\"header\"&gt; &lt;div class=\"nav\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=\"content\"&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324.header &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: blue;&#125;.nav &#123; margin: 0 auto; max-width: 800px; background-color: darkgray; height: 50px;&#125;.content &#123; margin: 0 auto; max-width: 800px; height: 400px; background-color: aquamarine;&#125;.footer &#123; margin: 0 auto; max-width: 960px; height: 100px; background-color: aqua;&#125; 2.两列自适应布局两列自适应布局是指一列由内容撑开，另一列撑满剩余宽度的布局方式 float+overflow:hidden如果是普通的两列布局，浮动+普通元素的 margin便可以实现，但如果是自适应的两列布局，利用float+overflow:hidden便可以实现，这种办法主要通过 overflow 触发 BFC,而 BFC 不会重叠浮动元素。由于设置 overflow:hidden 并不会触发 IE6-浏览器的 haslayout 属性，所以需要设置 zoom:1 来兼容 IE6-浏览器。具体代码如下： 123456789&lt;div class=\"parent\" style=\"background-color: lightgrey;\"&gt; &lt;div class=\"left\" style=\"background-color: lightblue;\"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\" style=\"background-color: lightgreen;\"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112.parent &#123; overflow: hidden; zoom: 1;&#125;.left &#123; float: left; margin-right: 20px;&#125;.right &#123; overflow: hidden; zoom: 1;&#125; 注意点:如果侧边栏在右边时，注意渲染顺序。即在 HTML 中，先写侧边栏后写主内容 Flex 布局Flex 布局，也叫弹性盒子布局，区区简单几行代码就可以实现各种页面的的布局。 12345678//html部分同上.parent &#123; display: flex;&#125;.right &#123; margin-left: 20px; flex: 1;&#125; grid 布局Grid 布局，是一个基于网格的二维布局系统，目的是用来优化用户界面设计。 123456//html部分同上.parent &#123; display: grid; grid-template-columns: auto 1fr; grid-gap: 20px;&#125; 3.三栏布局特征：中间列自适应宽度，旁边两侧固定宽度 圣杯布局 特点 比较特殊的三栏布局，同样也是两边固定宽度，中间自适应，唯一区别是 dom 结构必须是先写中间列部分，这样实现中间列可以优先加载。 1234567&lt;article class=\"container\"&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;圣杯布局&lt;/h2&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 12345678910111213141516171819202122232425262728.container &#123; padding-left: 220px; //为左右栏腾出空间 padding-right: 220px;&#125;.left &#123; float: left; width: 200px; height: 400px; background: red; margin-left: -100%; position: relative; left: -220px;&#125;.center &#123; float: left; width: 100%; height: 500px; background: yellow;&#125;.right &#123; float: left; width: 200px; height: 400px; background: blue; margin-left: -200px; position: relative; right: -220px;&#125; 实现步骤 三个部分都设定为左浮动，否则左右两边内容上不去，就不可能与中间列同一行。然后设置 center 的宽度为 100%(实现中间列内容自适应)，此时，left 和 right 部分会跳到下一行 通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行 通过设置父容器的 padding-left 和 padding-right，让左右两边留出间隙。 通过设置相对定位，让 left 和 right 部分移动到两边。 缺点 center 部分的最小宽度不能小于 left 部分的宽度，否则会 left 部分掉到下一行 如果其中一列内容高度拉长(如下图)，其他两列的背景并不会自动填充。(借助等高布局正 padding+负 margin 可解决，下文会介绍) 双飞翼布局 特点 同样也是三栏布局，在圣杯布局基础上进一步优化，解决了圣杯布局错乱问题，实现了内容与布局的分离。而且任何一栏都可以是最高栏，不会出问题。 1234567&lt;article class=\"container\"&gt; &lt;div class=\"center\"&gt; &lt;div class=\"inner\"&gt;双飞翼布局&lt;/div&gt; &lt;/div&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 1234567891011121314151617181920212223242526.container &#123; min-width: 600px; //确保中间内容可以显示出来，两倍left宽+right宽&#125;.left &#123; float: left; width: 200px; height: 400px; background: red; margin-left: -100%;&#125;.center &#123; float: left; width: 100%; height: 500px; background: yellow;&#125;.center .inner &#123; margin: 0 200px; //新增部分&#125;.right &#123; float: left; width: 200px; height: 400px; background: blue; margin-left: -200px;&#125; 实现步骤(前两步与圣杯布局一样) 三个部分都设定为左浮动，然后设置 center 的宽度为 100%，此时，left 和 right 部分会跳到下一行； 通过设置 margin-left 为负值让 left 和 right 部分回到与 center 部分同一行； center 部分增加一个内层 div，并设 margin: 0 200px； 缺点多加一层 dom 树节点，增加渲染树生成的计算量。 两种布局实现方式对比: 两种布局方式都是把主列放在文档流最前面，使主列优先加载。 两种布局方式在实现上也有相同之处，都是让三列浮动，然后通过负外边距形成三列布局。 两种布局方式的不同之处在于如何处理中间主列的位置：圣杯布局是利用父容器的左、右内边距+两个从列相对定位；双飞翼布局是把主列嵌套在一个新的父级块中利用主列的左、右外边距进行布局调整 浮动布局1234567891011&lt;article class=\"left-right-center\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt; // 右栏部分要写在中间内容之前 &lt;div class=\"center\"&gt; &lt;h2&gt;浮动解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt;&lt;/article&gt; 12345678910111213.layout.float .left &#123; float: left; width: 300px; background: red;&#125;.layout.float .center &#123; background: yellow;&#125;.layout.float .right &#123; float: right; width: 300px; background: blue;&#125; 这种布局方式，dom 结构必须是先写浮动部分，然后再中间块，否则右浮动块会掉到下一行。浮动布局的优点就是比较简单，兼容性也比较好。但浮动布局是有局限性的，浮动元素脱离文档流，要做清除浮动，这个处理不好的话，会带来很多问题，比如父容器高度塌陷等。 绝对布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;绝对定位解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 123456789101112131415161718.layout.absolute .left-center-right &gt; div &#123; position: absolute; //三块都是绝对定位&#125;.layout.absolute .left &#123; left: 0; width: 300px; background: red;&#125;.layout.absolute .center &#123; right: 300px; left: 300px; //离左右各三百 background: yellow;&#125;.layout.absolute .right &#123; right: 0; width: 300px; background: blue;&#125; 绝对定位布局优点就是快捷，设置很方便，而且也不容易出问题。缺点就是，容器脱离了文档流，后代元素也脱离了文档流，高度未知的时候，会有问题，这就导致了这种方法的有效性和可使用性是比较差的。 flexbox 布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;flexbox解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 123456789101112131415.layout.flexbox .left-center-right &#123; display: flex;&#125;.layout.flexbox .left &#123; width: 300px; background: red;&#125;.layout.flexbox .center &#123; background: yellow; flex: 1;&#125;.layout.flexbox .right &#123; width: 300px; background: blue;&#125; flexbox 布局是 css3 里新出的一个，它就是为了解决上述两种方式的不足出现的，是比较完美的一个。目前移动端的布局也都是用 flexbox。 flexbox 的缺点就是 IE10 开始支持，但是 IE10 的是-ms 形式的。 表格布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;表格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 12345678910111213141516171819.layout.table .left-center-right &#123; display: table; height: 150px; width: 100%;&#125;.layout.table .left-center-right &gt; div &#123; display: table-cell;&#125;.layout.table .left &#123; width: 300px; background: red;&#125;.layout.table .center &#123; background: yellow;&#125;.layout.table .right &#123; width: 300px; background: blue;&#125; 表格布局的兼容性很好(见下图)，在 flex 布局不兼容的时候，可以尝试表格布局。当内容溢出时会自动撑开父元素。 表格布局也是有缺陷:① 无法设置栏边距；② 对 seo 不友好；③ 当其中一个单元格高度超出的时候，两侧的单元格也是会跟着一起变高的，然而有时候这并不是我们想要的效果。 网格布局12345678910&lt;article class=\"left-center-right\"&gt; &lt;div class=\"left\"&gt;&lt;/div&gt; &lt;div class=\"center\"&gt; &lt;h2&gt;网格布局解决方案&lt;/h2&gt; 1.这是三栏布局的浮动解决方案； 2.这是三栏布局的浮动解决方案； 3.这是三栏布局的浮动解决方案； 4.这是三栏布局的浮动解决方案； 5.这是三栏布局的浮动解决方案； 6.这是三栏布局的浮动解决方案； &lt;/div&gt; &lt;div class=\"right\"&gt;&lt;/div&gt;&lt;/article&gt; 123456789101112131415.layout.grid .left-center-right &#123; display: grid; width: 100%; grid-template-columns: 300px auto 300px; grid-template-rows: 150px; //行高&#125;.layout.grid .left &#123; background: red;&#125;.layout.grid .center &#123; background: yellow;&#125;.layout.grid .right &#123; background: blue;&#125; CSS Grid 是创建网格布局最强大和最简单的工具。就像表格一样，网格布局可以让 Web 设计师根据元素按列或行对齐排列，但他和表格不同，网格布局没有内容结构，从而使各种布局不可能与表格一样。例如，一个网格布局中的子元素都可以定位自己的位置，这样他们可以重叠和类似元素定位。 但网格布局的兼容性不好。IE10+上支持，而且也仅支持部分属性。 4.等高布局等高布局是指子元素在父元素中高度相等的布局方式。接下来我们介绍常见几种实现方式： 利用正 padding+负 margin 我们通过等高布局便可解决圣杯布局的第二点缺点，因为背景是在 padding 区域显示的，设置一个大数值的 padding-bottom，再设置相同数值的负的 margin-bottom，并在所有列外面加上一个容器，并设置 overflow:hidden 把溢出背景切掉。这种可能实现多列等高布局，并且也能实现列与列之间分隔线效果，结构简单，兼容所有浏览器。新增代码如下： 1234567891011.center,.left,.right &#123; padding-bottom: 10000px; margin-bottom: -10000px;&#125;.container &#123; padding-left: 220px; padding-right: 220px; overflow: hidden; //把溢出背景切掉&#125; 利用背景图片 这种方法是我们实现等高列最早使用的一种方法，就是使用背景图片，在列的父元素上使用这个背景图进行 Y 轴的铺放，从而实现一种等高列的假象。实现方法简单，兼容性强，不需要太多的 css 样式就可以轻松实现,但此方法不适合流体布局等高列的布局。 在制作样式之前需要一张类似下面的背景图： 12345&lt;div class=\"”container\" clearfix”&gt; &lt;div class=\"”left”\"&gt;&lt;/div&gt; &lt;div class=\"”content”\"&gt;&lt;/div&gt; &lt;div class=\"”right”\"&gt;&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617.container &#123; background: url(\"column.png\") repeat-y; width: 960px; margin: 0 auto;&#125;.left &#123; float: left; width: 220px;&#125;.content &#123; float: left; width: 480px;&#125;.right &#123; float: left; width: 220px;&#125; 模仿表格布局 这是一种非常简单，易于实现的方法。不过兼容性不好，在 ie6-7 无法正常运行。 12345678910111213141516171819&lt;div class=\"container table\"&gt; &lt;div class=\"containerInner tableRow\"&gt; &lt;div class=\"column tableCell cell1\"&gt; &lt;div class=\"left aside\"&gt; .... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column tableCell cell2\"&gt; &lt;div class=\"content section\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;div class=\"column tableCell cell3\"&gt; &lt;div class=\"right aside\"&gt; ... &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324.table &#123; width: auto; min-width: 1000px; margin: 0 auto; padding: 0; display: table;&#125;.tableRow &#123; display: table-row;&#125;.tableCell &#123; display: table-cell; width: 33%;&#125;.cell1 &#123; background: #f00; height: 800px;&#125;.cell2 &#123; background: #0f0;&#125;.cell3 &#123; background: #00f;&#125; 使用边框和定位 这种方法是使用边框和绝对定位来实现一个假的高度相等列的效果。结构简单，兼容各浏览器，容易掌握。假设你需要实现一个两列等高布局，侧栏高度要和主内容高度相等。 1234&lt;div id=\"wrapper\"&gt; &lt;div id=\"mainContent\"&gt;...&lt;/div&gt; &lt;div id=\"sidebar\"&gt;...&lt;/div&gt;&lt;/div&gt; 123456789101112131415161718#wrapper &#123; width: 960px; margin: 0 auto;&#125;#mainContent &#123; border-right: 220px solid #dfdfdf; position: absolute; width: 740px; height: 800px; background: green;&#125;#sidebar &#123; background: #dfdfdf; margin-left: 740px; position: absolute; height: 800px; width: 220px;&#125; 5.粘连布局 特点 有一块内容&lt;main&gt;，当&lt;main&gt;的高康足够长的时候，紧跟在&lt;main&gt;后面的元素&lt;footer&gt;会跟在&lt;main&gt;元素的后面。 当&lt;main&gt;元素比较短的时候(比如小于屏幕的高度),我们期望这个&lt;footer&gt;元素能够“粘连”在屏幕的底部 具体代码如下： 12345678&lt;div id=\"wrap\"&gt; &lt;div class=\"main\"&gt; main &lt;br /&gt; main &lt;br /&gt; main &lt;br /&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id=\"footer\"&gt;footer&lt;/div&gt; 123456789101112131415161718192021222324* &#123; margin: 0; padding: 0;&#125;html,body &#123; height: 100%; //高度一层层继承下来&#125;#wrap &#123; min-height: 100%; background: pink; text-align: center; overflow: hidden;&#125;#wrap .main &#123; padding-bottom: 50px;&#125;#footer &#123; height: 50px; line-height: 50px; background: deeppink; text-align: center; margin-top: -50px;&#125; 实现步骤 footer 必须是一个独立的结构，与 wrap 没有任何嵌套关系 wrap 区域的高度通过设置 min-height，变为视口高度 footer 要使用 margin 为负来确定自己的位置 在 main 区域需要设置 padding-bottom。这也是为了防止负 margin 导致 footer 覆盖任何实际内容。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS常用布局方式","slug":"CSS常用布局方式","date":"2019-05-02T07:44:43.000Z","updated":"2019-08-15T16:33:47.257Z","comments":true,"path":"2019/05/02/CSS常用布局方式/","link":"","permalink":"http://yoursite.com/2019/05/02/CSS常用布局方式/","excerpt":"CSS 常用布局方式1.静态布局（固定布局）布局特点不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。","text":"CSS 常用布局方式1.静态布局（固定布局）布局特点不管浏览器尺寸具体是多少，网页布局始终按照最初写代码时的布局来显示。常规的 pc 的网站都是静态（定宽度）布局的，也就是设置了 min-width，这样的话，如果小于这个宽度就会出现滚动条，如果大于这个宽度则内容居中外加背景，这种设计常见于 pc 端。 设计方法 PC：居中布局，所有样式使用绝对宽度/高度(px)，设计一个 Layout，在屏幕宽高有调整时，使用横向和竖向的滚动条来查阅被遮掩部分； 12345.wrap &#123; width: 640px; overflow: hidden; margin: 0 auto;&#125; ​ 有固定的版型大小，例如 640px，然后设置 margin：0 auto；来居中。小于 640 时出现滚动条。 移动设备：另外建立移动网站，单独设计一个布局，使用不同的域名如 wap.或 m.。在 &lt;viewport meta&gt; 标签上设置 width，页面的各个元素也采用px作为单位。通过用 JS 动态修改标签的initial-scale使得页面等比缩放，从而刚好占满整个屏幕。 实现方法 普通/文档流 布局 Float 布局 绝对布局 优缺点优点：这种布局方式对设计师和 CSS 编写者来说都是最简单的，亦没有兼容性问题。 缺点：显而易见，不能根据用户的屏幕尺寸做出不同的展现。当前，大部分门户网站、大部分企业的 PC 宣传站点都采用了这种布局方式。固定像素尺寸的网页是匹配固定像素尺寸显示器的最简单办法。但这种方法不是一种完全兼容未来网页的制作方法，我们需要一些适应未知设备的方法。 窄屏幕滚动条体验很差 宽屏有大片空白，不利于空间利用 2.流式布局流式布局（Liquid）的特点（也叫”Fluid”) 是页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。网页中主要的划分区域的尺寸使用百分数（搭配 min-、max-属性使用），例如，设置网页主体的宽度为 80%，min-width 为 960px。图片也作类似处理（width:100%, max-width 一般设定为图片本身的尺寸，防止被拉伸而失真）。 布局特点屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。【这就导致如果屏幕太大或者太小都会导致元素无法正常显示。 设计方法使用%百分比定义宽度，而高度大都是用 px 来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。 这种布局方式在 Web 前端开发的早期历史上，用来应对不同尺寸的 PC 屏幕（那时屏幕尺寸的差异不会太大），在当今的移动端开发也是常用布局方式。流式布局目的是在不同大小的设备上满屏呈现同样网页。它是用于解决类似的设备不同分辨率之间的兼容(一般分辨率差异较少)。 百分比能够设置的属性是 width、height、padding、margin。其他属性比如 border、font-size 不能用百分比设置的。 如果用百分比写 width，那么指的是父元素 width 的百分之多少。 如果用百分比写 height，那么指的是父元素 height 的百分之多少。 如果用百分比写 padding，那么指的是父元素 width 的百分之多少，无论是水平的 padding 还是竖直的 padding。 如果用百分比写 margin，那么指的是父元素 width 的百分之多少，无论是水平的 margin 还是竖直的 margin。 不能用百分比写 border 的宽度 实现方法 允许网页宽度自动调整：&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; 不使用绝对尺寸（包括容器/字体/图片），使用百分比、em、rem、vw、vh 等 可使用 flex 等弹性盒子（不要使用 px 定尺寸） 优缺点优点：页面左右满屏。 但缺点明显： 主要的问题**是如果屏幕尺度跨度太大，那么在相对其原始设计而言过小或过大的屏幕上不能正常显示。因为宽度使用%百分比定义，但是高度和文字大小等大都是用 px 来固定，所以在大屏幕的手机下显示效果会变成有些页面元素宽度被拉的很长，但是高度、文字大小还是和原来一样（即，这些东西无法变得“流式”），显示非常不协调 使用百分比定义，所以在大屏幕的手机/Pad 下（或者横屏下）显示效果会变成有些页面元素被拉的很大，但是内容数量却不变，显得稀疏不紧凑，空间利用率低下。 如果文字也按照百分比放大，则整体效果会非常不协调（老人机效果）。 例子https://www.trip.com/flightsh5/status/ 3.自适应布局自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。改变屏幕分辨率可以切换不同的静态局部（页面元素位置发生改变），但在每个静态布局中，页面元素不随窗口大小的调整发生变化。可以把自适应布局看作是静态布局的一个合集。 布局特点屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。 设计方法使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。 实现方式 静态布局方法 分辨率 detector（media query/server-side detector/UA） 优缺点优点：自适应布局页面里面元素的位置会变化，很好的解决了流式布局中的大屏空间利用率不高弊端。 缺点：单个布局容器无法灵活伸缩，未触发布局切换的情况下，容器仍然容易出现静态布局中提到的问题。 例子www.baidu.com/ 自适应设计（AWD）自适应设计是通过服务端检测设备类型、从 site 的不同版本中选择最合适该设备类型的设计布局/尺寸的版本进行展示。它可以使用到所有（包括响应式布局）布局方案。 实现方式： server-side detection different versions to different devices 对于 PC: 可使用流式布局； 对于 Mobile: 可使用流式布局。推荐一个 Rem 解决方案： 设置元素（可以包括字体等）大小为 rem （rem 是以跟元素font-size为基准的单位） 按照屏幕宽度的不同，JS 动态设置 &lt;html&gt; 的 font-size 大小，元素同样会按照屏幕宽度等比例放大缩小 举个栗子：www.trip.com/ 4.响应式布局（媒体查询）随着 CSS3 出现了媒体查询技术，又出现了响应式设计的概念。响应式设计的目标是确保一个页面在所有终端上（各种尺寸的 PC、手机、手表、冰箱的 Web 浏览器等等）都能显示出令人满意的效果，对 CSS 编写者而言，在实现上不拘泥于具体手法，但通常是糅合了流式布局+弹性布局，再搭配媒体查询技术使用。——分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。即：创建多个流体式布局，分别对应一个屏幕分辨率范围。改变屏幕分辨率可以通过 CSS Media query 实时地切换不同的布局（页面元素位置可能发生改变），在每个布局中，页面元素会随窗口大小的调整发生流式布局中的自动尺寸变化。可以把响应式布局看作是流式布局和自适应布局设计理念的融合。 响应式几乎已经成为优秀页面布局的标准。 布局特点每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。 设计方法媒体查询+流式布局。通常使用 @media 媒体查询和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。 实现方式 流式布局 CSS media query 优缺点优点：适应 pc 和移动端，如果足够耐心，效果完美。融合了流式布局和自适应布局的优势。 缺点： 媒体查询是有限的，也就是可以枚举出来的，只能适应主流的宽高。 要匹配足够多的屏幕大小，工作量不小，设计也需要多个版本。 CSS 代码繁琐，对于特定的设备有较多冗余，适用于对于各个终端（特别是移动端）性能要求不高的 Blog Dos 站点。 响应式页面在头部会加上这一段代码： 12&lt;meta name=\"applicable-device\" content=\"pc,mobile\" /&gt;&lt;meta http-equiv=\"Cache-Control\" content=\"no-transform \" /&gt; 例子elevenbeans.github.io/ 响应式设计（RWD）响应式设计基于响应式布局，使用同一套页面在各种各样不同大小的设备上进行大小合适、布局（甚至功能）合理的展现。 响应式设计会根据识别屏幕宽度对于展示的具体内容块进行位置调整，甚至展示和隐藏。 实现方式： 响应式布局 特性检测 （用于网页功能的渐进增强） 举个栗子：elevenbeans.github.io/， RWD 和 AWD 的异同相同点： 均针对不同的分辨率/device 采用不同的样式和布局达到页面展示最优 布局方式本质没有差别（AWD 也 including responsive layout） 不同点： 前者强调同一套页面多端兼容展示，而后者给出多套页面，对于不同 device 进行了分类处理 前者是通过 CSS Media query 进行分辨率检测，可以实时的响应浏览器尺寸变化，改变元素尺寸/布局，而后者一般是 server side detection，一次性渲染既定布局和样式 媒体查询用法 开始在 html 中写入 Media 在 html 头部添加以下代码，用来显示兼容移动设备的显示效果 1234&lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1,minimum-scale=1,maximum-scale=1,user-scalable=no\"/&gt; 参数详解： width=device-width ：宽度等于当前设备的宽度 initial-scale=1 ：初始的缩放比例。（默认为 1） minimum-scale=1 ：允许用户缩放到的最小比例。（默认为 1） maximum-scale=1 ：允许用户缩放到的最大比例。（默认为 1） user-scalable=no ：用户是否可以手动缩放（默认为 no） 引入包含 Media 的 css 文件我们在媒体查询外面写的第一条规则，是“基本的”样式，它适用于任何设备。在此基础上，我们再为不同视口、不同能力的设备，渐进增加不同的视觉效果和功能。(IE6、7、8 不支持媒体查询，也为了防止手机端的某些浏览器不支持媒体查询，所以不要把所有的选择器都放在媒体查询里面。) 123456789101112131415161718body &#123; background-color: grey;&#125;@media screen and (min-width: 1200px) &#123; body &#123; background-color: pink; &#125;&#125;@media screen and (min-width: 700px) and (max-width: 1200px) &#123; body &#123; background-color: blue; &#125;&#125;@media screen and (max-width: 700px) &#123; body &#123; background-color: orange; &#125;&#125; 媒体类型 | 值 | 描述 || :——— | :——————————————————————– || all | 用于所有设备 || aural | 已废弃。用于语音和声音合成器 || braille | 已废弃。 应用于盲文触摸式反馈设备 || embossed | 已废弃。 用于打印的盲人印刷设备 || handheld | 已废弃。 用于掌上设备或更小的装置，如 PDA 和小型电话 || print | 用于打印机和打印预览 || projection | 已废弃。 用于投影设备 || screen | 用于电脑屏幕，平板电脑，智能手机等。 || speech | 应用于屏幕阅读器等发声设备 || tty | 已废弃。 用于固定的字符网格，如电报、终端设备和对字符有限制的便携设备 || tv | 已废弃。 用于电视和网络电视 | 逻辑操作符 and操作符用来把多个媒体属性组合成一条媒体查询，对成链式的特征进行请求，只有当每个属性都为真时，结果才为真。 not操作符用来对一条媒体查询的结果进行取反。 only操作符仅在媒体查询匹配成功的情况下被用于应用一个样式，这对于防止让选中的样式在老式浏览器中被应用到。 也可以将多个媒体查询以逗号分隔放在一起；只要其中任何一个为真，整个媒体语句就返回真。相当于or操作符。 若使用了not或only操作符，必须明确指定一个媒体类型。 媒体功能 | 值 | 描述 | 值 | 媒体 | 是否接受 min/max 前缀 || :—————— | :——————————————————————————- | ———————– | ————– | ——————— || aspect-ratio | 定义输出设备中的页面可见区域宽度与高度的比率 | | visual/tactile | 是 || color | 定义输出设备每一组彩色原件的个数。如果不是彩色设备，则值等于 0 | | visual | 是 || color-index | 定义在输出设备的彩色查询表中的条目数。如果没有使用彩色查询表，则值等于 0 | | visual | 是 || device-aspect-ratio | 定义输出设备的屏幕可见宽度与高度的比率。 | | visual/tactile | 是 || device-height | 定义输出设备的屏幕可见高度。 | | visual/tactile | 是 || device-width | 定义输出设备的屏幕可见宽度。 | | visual/tactile | 是 || grid | 用来查询输出设备是否使用栅格或点阵。 | | all | 否 || height | 定义输出设备中的页面可见区域高度。 | | visual/tactile | 是 || monochrome | 定义在一个单色框架缓冲区中每像素包含的单色原件个数。如果不是单色设备，则值等于 0 | | visual | 是 || orientation | 定义输出设备中的页面可见区域高度是否大于或等于宽度。 | landscape|portrait | visual | 否 || resolution | 定义设备的分辨率。如：96dpi, 300dpi, 118dpcm | | bitmap | 是 || scan | 定义电视类设备的扫描工序。 | progressive|interlace | tv | 否 || width | 定义输出设备中的页面可见区域宽度。 | | visual/tactile | 是 | 5.弹性布局（flex）Flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。引入弹性盒布局模型的目的是提供一种更加有效的方式来对一个容器中的子元素进行排列、对齐和分配空白空间（他会根据页面的剩余宽度自动分配空间）。 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。 容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束位置叫做cross end。 项目默认沿主轴排列。单个项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size。 容器的属性基本语法： 123.box &#123; display: flex; /* 或者 inline-flex */&#125; 上述写法，定义了一个 flex 容器，根据设值的不同可以是块状容器或内联容器。这使得直接子结点拥有了一个 flex 上下文。 flex-direction flex-wrap flex-flow justify-content align-items align-content 1.flex-direction属性决定主轴的方向（即项目的排列方向）。 row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 2.flex-wrap默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 nowrap（默认）：不换行。 wrap：换行，第一行在上方。 wrap-reverse：换行，第一行在下方。 3.flex-flowflex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 123.box &#123; flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125; 4.justify-content定义了项目在主轴上的对齐方式。 flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 5.align-items定义项目在交叉轴上如何对齐。 flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为 auto，将占满整个容器的高度。 6.align-content定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性 order flex-grow flex-shrink flex-basis flex align-self 1.order定义项目的排列顺序。数值越小，排列越靠前，默认为 0。 123.item &#123; order: &lt;integer&gt;;&#125; 2.flex-grow定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 如果所有项目的flex-grow属性都为 1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为 2，其他项目都为 1，则前者占据的剩余空间将比其他项多一倍。 3.flex-shrink定义了项目的缩小比例，默认为 1，即如果空间不足，该项目将缩小。 如果所有项目的flex-shrink属性都为 1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为 0，其他项目都为 1，则空间不足时，前者不缩小。 负值对该属性无效。 4.flex-basis定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如 350px），则项目将占据固定空间。 5.flexflex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 6.align-self允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。 该属性可能取 6 个值，除了 auto，其他都与 align-items 属性完全一致。 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; 兼容性 Chrome Safari Firefox Opera IE Android iOS 21+ 6.1+ 22+ 12.1+ 11+ 4.4+ 7.1+ Flexbox 需要一些特定的前缀以支持大多数的浏览器。甚至还存在完全不同的属性名称或属性值。这就需要Autoprefixer或类似的 CSS 后处理器的辅助，具体内容请参考相关文档。 6.REM 布局rem/em 区别rem:当前页面中元素的 REM 单位的样式值都是针对于 HTML 元素的 font-size 的值进行动态计算的 em:表示父元素的字号的倍数。(特例：在 text-indent 属性中，表示文字宽度)em 单位不仅仅可以用来设置字号，还可以设置任何盒模型的属性，比如 width、height、padding、margin、border。 rem 作用于非根元素时，相对于根元素字体大小；rem 作用于根元素字体大小时，相对于其出初始字体大小（16px）。 rem 有一点优势就是可以和媒体查询配合，实现响应式布局： 使用 em 或 rem 单位进行相对布局，相对%百分比更加灵活，同时可以支持浏览器的字体大小调整和缩放等的正常显示，因为 em 是相对父级元素的原因没有得到推广。【中国站点制作网页的时候，习惯用 CSS 强制定义字体大小，保证每个人都看到一致的效果，包括网易、搜狐这些门户网站在内的大部分站点，用的都是绝对单位 px（像素）。但是，如果从网站易用性方面考虑，字体大小应该是可变的，一些视力不是那么好的人需要放大字体才能看得清页面内容。然而，占据大部分浏览器市场的 IE 无法调整那些使用 px 作为单位的字体大小。国外人士非常重视网站的易用性，相当一部分外国站点已经使用 em 作为字体单位。 布局特点包裹文字的各元素的尺寸采用 em/rem 做单位，而页面的主要划分区域的尺寸仍使用百分数或 px 做单位（同「流式布局」或「静态/固定布局」）。早期浏览器不支持整个页面按比例缩放，仅支持网页内文字尺寸的放大，这种情况下。使用 em/rem 做单位，可以使包裹文字的元素随着文字的缩放而缩放。 浏览器的默认字体高度一般为16px，即 1em:16px，但是 1:16 的比例不方便计算，为了使单位 em/rem 更直观，CSS 编写者常常将页面跟节点字体设为 62.5%，比如选择用 rem 控制字体时，先需要设置根节点 html 的字体大小，因为浏览器默认字体大小 16px*62.5%=10px。这样 1rem 便是 10px，方便了计算。 设计思想 一般不要给元素设置具体的宽度,但是对于一些小图标可以设定具体宽度值 高度值可以设置固定值,设计稿有多大,我们就严格写多大 所有设置的固定值都用 REM 做单位(首先在 HTML 中设置一个基准值：PX 和 REM 的对应比例,然后在效果图上获取 PX 值,布局的时候转化为 REM 值) JS 获取真实屏幕的宽度,让其除以设计稿的宽度,算出比例,把之前的基准值按照比例进行重新的设定,这样项目就可以在移动端自适应了 优点更能适应缩进/以字体单位 padding 或 margin／浏览器设置字体尺寸等情况（因为 em/rem 相对于字体大小，会同步改变）。例如：p{ text-indent: 2em; }。 123p &#123; text-indent: 2em;&#125; rem 单位对于（根据屏幕尺寸）调整页面的各元素的尺寸、文字大小时比较好用 Rem 布局的 js 实现1234// px转rem，方便模拟小程序 rpxpx2rem($px) &#123; $px / 750 * 10 * 1rem;&#125; 123456789101112131415161718192021222324252627282930313233343536if remlayout script. (function flexible (window, document) &#123; var docEl = document.documentElement var dpr = window.devicePixelRatio || 1 function setBodyFontSize () &#123; if (document.body) &#123; document.body.style.fontSize = (12 * dpr) + 'px' &#125; else &#123; document.addEventListener('DOMContentLoaded', setBodyFontSize) &#125; &#125; setBodyFontSize() function setRemUnit () &#123; var rem = docEl.clientWidth / 10 docEl.style.fontSize = rem + 'px' &#125; setRemUnit() window.addEventListener('resize', setRemUnit) window.addEventListener('pageshow', function (e) &#123; if (e.persisted) &#123; setRemUnit() &#125; &#125;) if (dpr &gt;= 2) &#123; var fakeBody = document.createElement('body') var testElement = document.createElement('div') testElement.style.border = '.5px solid transparent' fakeBody.appendChild(testElement) docEl.appendChild(fakeBody) if (testElement.offsetHeight === 1) &#123; docEl.classList.add('hairlines') &#125; docEl.removeChild(fakeBody) &#125; &#125;(window, document)) 对比三种方式（响应式&amp;&amp;REM&amp;&amp;viewport）响应式的优缺点优点：兼容性好，@media 在 ie9 以上是支持的，PC 和 MOBILE 是同一套代码的，不用分开。 缺点：要写得 css 相对另外两个多很多，而且各个断点都要做好。css 样式会稍微大点，更麻烦。 REM 优缺点优点：能维持能整体的布局效果，移动端兼容性好，不用写多个 css 代码，而且还可以利用@media 进行优化。 缺点：开头要引入一段 js 代码，单位都要改成 rem(font-size 可以用 px)，计算 rem 比较麻烦(可以引用预处理器，但是增加了编译过程，相对麻烦了点)。pc 和 mobile 要分开。 设置 viewport 中的 width1&lt;meta name=\"viewport\" content=\"width=750\" /&gt; 优点：和 REM 相同，而且不用写 rem，直接使用 px，更加快捷。 缺点：效果可能没 rem 的好，图片可能会相对模糊，而且无法使用@media 进行断点，不同 size 的手机上显示，高度间距可能会相差很大。 7.Grid 布局（BOOTSTRAP 布局）网格布局（Grid）是最强大的 CSS 布局方案。 它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。 Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是一维布局。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是二维布局。Grid 布局远比 Flex 布局强大。 采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。容器里面的水平区域称为”行”（row），垂直区域为”列”（column）。行和列的交叉区域，称为”单元格”（cell）。划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。 容器的属性1.displaydisplay: grid指定一个容器采用网格布局。 默认情况下，容器元素都是块级元素，但也可以设成行内元素。display: inline-grid; 注意，设为网格布局以后，容器子元素（项目）的float、display: inline-block、display: table-cell、vertical-align和column-*等设置都将失效。 2.grid-template-columns 属性， grid-template-rows 属性容器指定了网格布局以后，接着就要划分行和列。grid-template-columns属性定义每一列的列宽，grid-template-rows属性定义每一行的行高。 12345.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px;&#125; 除了使用绝对单位，也可以使用百分比 repeat()：接受两个参数，第一个参数是重复的次数（上例是 3），第二个参数是所要重复的值。重复某种模式也是可以的。 1grid-template-columns: repeat(2, 100px 20px 80px); auto-fill 关键字：有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用auto-fill关键字表示自动填充。 1234.container &#123; display: grid; grid-template-columns: repeat(auto-fill, 100px);&#125; fr 关键字：为了方便表示比例关系，网格布局提供了fr关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为1fr和2fr，就表示后者是前者的两倍。（fr可以与绝对长度的单位结合使用） minmax()：minmax()函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。 1grid-template-columns: 1fr 1fr minmax(100px, 1fr); 上面代码中，minmax(100px, 1fr)表示列宽不小于100px，不大于1fr。 auto 关键字：表示由浏览器自己决定长度 网格线的名称：grid-template-columns属性和grid-template-rows属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。（网格布局允许同一根线有多个名字，比如[fifth-line row-5]。） 12345.container &#123; display: grid; grid-template-columns: [c1] 100px [c2] 100px [c3] auto [c4]; grid-template-rows: [r1] 100px [r2] 100px [r3] auto [r4];&#125; 3.grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性 grid-row-gap属性设置行与行的间隔（行间距） grid-column-gap属性设置列与列的间隔（列间距）。 grid-gap属性是grid-column-gap和grid-row-gap的合并简写形式：grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;;(如果grid-gap省略了第二个值，浏览器认为第二个值等于第一个值。) 根据最新标准，上面三个属性名的grid-前缀已经删除，grid-column-gap和grid-row-gap写成column-gap和row-gap，grid-gap写成gap。 4.grid-template-areas 属性网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。 1234grid-template-areas: \"header header header\" \"main main sidebar\" \"footer footer footer\"; 区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为区域名-start，终止网格线自动命名为区域名-end。 5.grid-auto-flow 属性划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。 这个顺序由grid-auto-flow属性决定，默认值是row，即”先行后列”。 也可以将它设成column，变成”先列后行”。 设为row dense，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。 column dense，表示”先列后行”，并且尽量填满空格。 6.justify-items 属性， align-items 属性， place-items 属性 justify-items属性设置单元格内容的水平位置（左中右） align-items属性设置单元格内容的垂直位置（上中下）。 这两个属性的写法完全相同，都可以取下面这些值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-items属性是align-items属性和justify-items属性的合并简写形式。（如果省略第二个值，则浏览器认为与第一个值相等。） 1place-items: &lt;align-items&gt; &lt;justify-items&gt;; 7.justify-content 属性， align-content 属性， place-content 属性 justify-content属性是整个内容区域在容器里面的水平位置（左中右） align-content属性是整个内容区域的垂直位置（上中下）。 这两个属性的写法完全相同，都可以取下面这些值。 只是将水平方向改成垂直方向。） start - 对齐容器的起始边框。 end - 对齐容器的结束边框。 center - 容器内部居中。 stretch - 项目大小没有指定时，拉伸占据整个网格容器。 space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。 space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。 space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。 place-content属性是align-content属性和justify-content属性的合并简写形式。（如果省略第二个值，浏览器就会假定第二个值等于第一个值。） 1place-content: &lt;align-content&gt; &lt;justify-content&gt;; 8.grid-auto-columns 属性， grid-auto-rows 属性有时候，一些项目的指定位置，在现有网格的外部。比如网格只有 3 列，但是某一个项目指定在第 5 行。这时，浏览器会自动生成多余的网格，以便放置项目。 grid-auto-columns属性和grid-auto-rows属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与grid-template-columns和grid-template-rows完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。 划分好的网格是 3 行 x 3 列，但是，8 号项目指定在第 4 行，9 号项目指定在第 5 行。 123456.container &#123; display: grid; grid-template-columns: 100px 100px 100px; grid-template-rows: 100px 100px 100px; grid-auto-rows: 50px;&#125; 上面代码指定新增的行高统一为 50px（原始的行高为 100px）。 9.grid-template 属性， grid 属性grid-template属性是grid-template-columns、grid-template-rows和grid-template-areas这三个属性的合并简写形式。 grid属性是grid-template-rows、grid-template-columns、grid-template-areas、 grid-auto-rows、grid-auto-columns、grid-auto-flow这六个属性的合并简写形式。 项目属性1.grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。 grid-column-start属性：左边框所在的垂直网格线 grid-column-end属性：右边框所在的垂直网格线 grid-row-start属性：上边框所在的水平网格线 grid-row-end属性：下边框所在的水平网格线 1234.item-1 &#123; grid-column-start: 2; grid-column-end: 4;&#125; 这四个属性的值还可以使用span关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。 使用这四个属性，如果产生了项目的重叠，则使用z-index属性指定项目的重叠顺序。 2.grid-column 属性， grid-row 属性 grid-column属性是grid-column-start和grid-column-end的合并简写形式 grid-row属性是grid-row-start属性和grid-row-end的合并简写形式。 这两个属性之中，也可以使用span关键字，表示跨越多少个网格。斜杠以及后面的部分可以省略，默认跨越一个网格。 1234567891011.item-1 &#123; background: #b03532; grid-column: 1 / 3; grid-row: 1 / 3;&#125;/* 等同于 */.item-1 &#123; background: #b03532; grid-column: 1 / span 2; grid-row: 1 / span 2;&#125; 3.grid-area 属性grid-area属性指定项目放在哪一个区域。 123.item-1 &#123; grid-area: e;&#125; grid-area属性还可用作grid-row-start、grid-column-start、grid-row-end、grid-column-end的合并简写形式，直接指定项目的位置。 123.item &#123; grid-area: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;&#125; 4.justify-self 属性， align-self 属性， place-self 属性 justify-self属性设置单元格内容的水平位置（左中右），跟justify-items属性的用法完全一致，但只作用于单个项目。 align-self属性设置单元格内容的垂直位置（上中下），跟align-items属性的用法完全一致，也是只作用于单个项目。 这两个属性都可以取下面四个值。 start：对齐单元格的起始边缘。 end：对齐单元格的结束边缘。 center：单元格内部居中。 stretch：拉伸，占满单元格的整个宽度（默认值）。 place-self属性是align-self属性和justify-self属性的合并简写形式。 1place-self: &lt;align-self&gt; &lt;justify-self&gt;; 兼容性 对比 Bootstrap 标签会更加简洁：相比Bootstrap，使用 grid 会使你的 HTML 更加干净。Bootstrap需要创建的标签，每个 row 都需要一个&lt;div&gt;标签，使用了 class name 来指定布局(col-xs-2)。grid 用来布局看起来更简单，丑陋的类名和每行所需的额外的 div 标签一去不复返了，简简单单一个 container 和里面的 item。与Bootstrap不同的是，随着布局复杂度的增加，Grid 布局标签的复杂度将不会增加太多。 更灵活：用CSS Grid的话会非常简单，我们只需要添加一个media query就可以重新排列布局。而如果想在Bootstrap中做同样的事情，就必须得修改 HTML 了，需要调整标签的顺序。 不再限死 12 列：Bootstrap的 grid 系统分为了 12 列，如果你想要一个 5 列的布局就会纠结，或是 7 列、9 列、任何不会合为 12 列的。CSS Grid就没有任何限制，你可以让 grid 正好有你想要的数量。 浏览器支持：全球 75%的网站流量支持CSS Grid 结论： 如果只做 pc 端，那么静态布局（定宽度）是最好的选择； 如果做移动端，且设计对高度和元素间距要求不高，那么弹性布局（rem+js）是最好的选择，一份 css+一份 js 调节 font-size 搞定； 如果 pc，移动要兼容，而且要求很高那么响应式布局还是最好的选择，前提是设计根据不同的高宽做不同的设计，响应式根据媒体查询做不同的布局.","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS3新特性","slug":"CSS3新特性","date":"2019-04-28T04:37:08.000Z","updated":"2019-08-15T16:29:09.967Z","comments":true,"path":"2019/04/28/CSS3新特性/","link":"","permalink":"http://yoursite.com/2019/04/28/CSS3新特性/","excerpt":"CSS3 新特性1. 选择器CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。 element1~element2: 选择前面有 element1 元素的每个 element2 元素。 [attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。 [attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。 [attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。 E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。 E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。 E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。 E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。 E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。 E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。 E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。 E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。 E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。 :root: 选择文档的根元素。 E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。 E:target: 选择当前活动的 E 元素。 E:enabled: 选择每个启用的 E 元素。 E:disabled: 选择每个禁用的 E 元素。 E:checked: 选择每个被选中的 E 元素。 E:not(selector): 选择非 selector 元素的每个元素。 E::selection: 选择被用户选取的元素部分。","text":"CSS3 新特性1. 选择器CSS3 中新添加了很多选择器，解决了很多之前需要用 javascript 才能解决的布局问题。 element1~element2: 选择前面有 element1 元素的每个 element2 元素。 [attribute^=value] ：选择某元素 attribute 属性是以 value 开头的。 [attribute$=value]：选择某元素 attribute 属性是以 value 结尾的。 [attribute*=value]：选择某元素 attribute 属性包含 value 字符串的。 E:first-of-type: 选择属于其父元素的首个 E 元素的每个 E 元素。 E:last-of-type: 选择属于其父元素的最后 E 元素的每个 E 元素。 E:only-of-type: 选择属于其父元素唯一的 E 元素的每个 E 元素。 E:only-child: 选择属于其父元素的唯一子元素的每个 E 元素。 E:nth-child(n): 选择属于其父元素的第 n 个子元素的每个 E 元素。 E:nth-last-child(n): 选择属于其父元素的倒数第 n 个子元素的每个 E 元素。 E:nth-of-type(n): 选择属于其父元素第 n 个 E 元素的每个 E 元素。 E:nth-last-of-type(n): 选择属于其父元素倒数第 n 个 E 元素的每个 E 元素。 E:last-child: 选择属于其父元素最后一个子元素每个 E 元素。 :root: 选择文档的根元素。 E:empty: 选择没有子元素的每个 E 元素（包括文本节点)。 E:target: 选择当前活动的 E 元素。 E:enabled: 选择每个启用的 E 元素。 E:disabled: 选择每个禁用的 E 元素。 E:checked: 选择每个被选中的 E 元素。 E:not(selector): 选择非 selector 元素的每个元素。 E::selection: 选择被用户选取的元素部分。 2. Transition,Transform 和 Animation这三个特性是 CSS3 新增的和动画相关的特性。 Transition Transition 可以在当元素从一种样式变换为另一种样式时为元素添加效果，而不用使用 Flash 动画或 JavaScript。Transition 有如下属性： transition-property: 规定应用过渡的 CSS 属性的名称。 transition-duration: 规定完成过渡效果需要多长时间。 transition-delay: 规定过渡效果何时开始，默认是 0。 transition-timing-function: 规定过渡效果的时间曲线，默认是”ease”，还有 linear、ease-in、ease-out、ease-in-out 和 cubic-bezier 等过渡类型。 transition: 简写属性，用于在一个属性中设置四个过渡属性。 Transform Transform 用来向元素应用各种 2D 和 3D 转换，该属性允许我们对元素进行旋转、缩放、移动或倾斜等操作。 变换类型： none: 定义不进行转换。 matrix(n,n,n,n,n,n): 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n): 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y): 定义 2D 位移转换。 translate3d(x,y,z): 定义 3D 位移转换。 translateX(x): 定义位移转换，只是用 X 轴的值。 translateY(y): 定义位移转换，只是用 Y 轴的值。 translateZ(z): 定义 3D 位移转换，只是用 Z 轴的值。 scale(x,y): 定义 2D 缩放转换。 scale3d(x,y,z): 定义 3D 缩放转换。 scaleX(x): 通过设置 X 轴的值来定义缩放转换。 scaleY(y): 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z): 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle): 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle): 定义 3D 旋转。 rotateX(angle): 定义沿着 X 轴的 3D 旋转。 rotateY(angle): 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle): 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle): 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle): 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle): 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n): 为 3D 转换元素定义透视视图。 Animation Animation 让 CSS 拥有了可以制作动画的功能。使用 CSS3 的 Animation 制作动画我们可以省去复杂的 js 代码。 3. 边框CSS3 新增了三个边框属性，分别是 border-radius、box-shadow 和 border-image。 border-radius 可以创建圆角边框 box-shadow 可以为元素添加阴影 border-image 可以使用图片来绘制边框。 4. 背景CSS3 新增了几个关于背景的属性，分别是 background-clip、background-origin、background-size 和 background-break。 background-clip background-clip 属性用于确定背景画区，有以下几种可能的属性： background-clip: border-box; 背景从 border 开始显示 background-clip: padding-box; 背景从 padding 开始显示 background-clip: content-box; 背景显 content 区域开始显示 background-clip: no-clip; 默认属性，等同于 border-box 通常情况，背景都是覆盖整个元素的，利用这个属性可以设定背景颜色或图片的覆盖范围。 background-origin background-clip 属性用于确定背景的位置，它通常与 background-position 联合使用，可以从 border、padding、content 来计算 background-position（就像 background-clip）。 background-origin: border-box; 从 border 开始计算 background-position background-origin: padding-box; 从 padding 开始计算 background-position background-origin: content-box; 从 content 开始计算 background-position background-size background-size 属性常用来调整背景图片的大小，主要用于设定图片本身。有以下可能的属性： background-size: contain; 缩小图片以适合元素（维持像素长宽比） background-size: cover; 扩展元素以填补元素（维持像素长宽比） background-size: 100px 100px; 缩小图片至指定的大小 background-size: 50% 100%; 缩小图片至指定的大小，百分比是相对包 含元素的尺寸 background-break CSS3 中，元素可以被分成几个独立的盒子（如使内联元素 span 跨越多行），background-break 属性用来控制背景怎样在这些不同的盒子中显示。 background-break: continuous; 默认值。忽略盒之间的距离（也就是像元素没有分成多个盒子，依然是一个整体一样） background-break: bounding-box; 把盒之间的距离计算在内； background-break: each-box; 为每个盒子单独重绘背景。 5. 文字效果 word-wrap CSS3 中，word-wrap 属性允许您允许文本强制文本进行换行，即这意味着会对单词进行拆分。所有主流浏览器都支持 word-wrap 属性。 text-overflow 它与 word-wrap 是协同工作的，word-wrap 设置或检索当当前行超过指定容器的边界时是否断开转行，而 text-overflow 则设置或检索当当前行超过指定容器的边界时如何显示。对于“text-overflow”属性，有“clip”和“ellipsis”两种可供选择。 text-shadow CSS3 中，text-shadow 可向文本应用阴影。能够规定水平阴影、垂直阴影、模糊距离，以及阴影的颜色。 text-decoration CSS3 里面开始支持对文字的更深层次的渲染，具体有三个属性可供设置： text-fill-color: 设置文字内部填充颜色 text-stroke-color: 设置文字边界填充颜色 text-stroke-width: 设置文字边界宽度 6. 渐变CSS3 新增了渐变效果，包括 linear-gradient(线性渐变)和 radial-gradient(径向渐变)。 7. @font-face 特性通过 CSS3，web 设计师可以使用他们喜欢的任意字体。当您您找到或购买到希望使用的字体时，可将该字体文件存放到 web 服务器上，它会在需要时被自动下载到用户的计算机上。字体是在 CSS3 @font-face 规则中定义的。Firefox、Chrome、Safari 以及 Opera 支持 .ttf(True Type Fonts)和 .otf(OpenType Fonts)类型的字体。IE9+ 支持新的@font-face 规则，但是仅支持 .eot 类型的字体(Embedded OpenType)。 在新的@font-face 规则中，必须首先定义字体的名称（比如 myFont），然后指向该字体文件。如需为 HTML 元素使用字体，请通过 font-family 属性来引用字体的名称 (myFont) 8. 多列布局通过 CSS3，能够创建多个列来对文本进行布局，IE10 和 Opera 支持多列属性。Firefox 需要前缀-moz-，Chrome 和 Safari 需要前缀-webkit-。主要有如下三个属性： column-count: 规定元素应该被分隔的列数。 column-gap: 规定列之间的间隔。 column-rule: 设置列之间的宽度、样式和颜色规则 9. 用户界面CSS3 中，新的用户界面特性包括重设元素尺寸、盒尺寸以及轮廓等。Firefox、Chrome 以及 Safari 支持 resize 属性。IE、Chrome、Safari 以及 Opera 支持 box-sizing 属性。Firefox 需要前缀-moz-。所有主流浏览器都支持 outline-offset 属性，除了 IE。 resize resize 属性规定是否可由用户调整元素尺寸。如果希望此属性生效，需要设置元素的 overflow 属性，值可以是 auto、hidden 或 scroll。 box-sizing box-sizing 属性可设置的值有 content-box、border-box 和 inherit。 content-box: padding 和 border 不被包含在定义的 width 和 height 之内。对象的实际宽度等于设置的 width 值和 border、padding 之和，即 (Element width = width + border + padding)，此属性表现为标准模式下的盒模型。 border-box: padding 和 border 被包含在定义的 width 和 height 之内。对象的实际宽度就等于设置的 width 值，即使定义有 border 和 padding 也不会改变对象的实际宽度，即 (Element width = width)，此属性表现为怪异模式下的盒模型。 outline-offset outline-offset 属性对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓。","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"BFC","slug":"BFC","date":"2019-04-10T00:11:20.000Z","updated":"2019-08-15T16:25:07.250Z","comments":true,"path":"2019/04/10/BFC/","link":"","permalink":"http://yoursite.com/2019/04/10/BFC/","excerpt":"BFCBFC 的定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。通俗地讲，BFC 是一个容器，用于管理块级元素。","text":"BFCBFC 的定义：BFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与（在下面有解释）， 它规定了内部的 Block-level Box 如何布局，并且与这个区域外部毫不相干。通俗地讲，BFC 是一个容器，用于管理块级元素。 触发 BFC 的方式（以下任意一条就可以） 根元素，即 HTML 元素 float 的值不为 none（为 left或right） overflow 的值不为 visible（为hidden或auto或scroll） display 的值为table-cell、table-caption、inline-flex、flex和inline-block之一 position 的值不为 static 或者 releative 中任何一个(为absolute或fixed) BFC 的布局规则 内部的 Box 会在垂直方向，一个接一个地放置。 Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠（margin 重叠三个条件:同属于一个 BFC;相邻;块级元素），两个相邻的 BFC 上下 margin 不会重叠 每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC 的区域不会与 float box 重叠。非浮动元素不会覆盖浮动元素的位置。 BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。（触发 BFC，回流的局部渲染） 计算 BFC 的高度时，浮动元素也参与计算（清除浮动 haslayout） margin 不会传递给父级（父级触发了 BFC） 对比普通文档流的布局规则 浮动的元素是不会被父级计算高度 非浮动元素会覆盖浮动元素的位置 margin 会传递给父级 两个相邻的元素上下 margin 会重叠 BFC 有哪些作用： 自适应两栏布局（规则 4） 可以阻止元素被浮动元素覆盖（规则 4） 可以包含浮动元素——清除内部浮动（规则 6） 分属于不同的 BFC 时可以阻止 margin 重叠（规则 2）","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"字符编码：Unicode与Javascript","slug":"字符编码：Unicode与Javascript","date":"2019-04-06T11:08:55.000Z","updated":"2019-08-15T16:23:35.837Z","comments":true,"path":"2019/04/06/字符编码：Unicode与Javascript/","link":"","permalink":"http://yoursite.com/2019/04/06/字符编码：Unicode与Javascript/","excerpt":"字符编码：Unicode 与 Javascript1.ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从00000000到11111111。 上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了 128 个字符的编码，比如空格SPACE是 32（二进制00100000），大写的字母A是 65（二进制01000001）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为0。","text":"字符编码：Unicode 与 Javascript1.ASCII 码我们知道，计算机内部，所有信息最终都是一个二进制值。每一个二进制位（bit）有0和1两种状态，因此八个二进制位就可以组合出 256 种状态，这被称为一个字节（byte）。也就是说，一个字节一共可以用来表示 256 种不同的状态，每一个状态对应一个符号，就是 256 个符号，从00000000到11111111。 上个世纪 60 年代，美国制定了一套字符编码，对英语字符与二进制位之间的关系，做了统一规定。这被称为 ASCII 码，一直沿用至今。 ASCII 码一共规定了 128 个字符的编码，比如空格SPACE是 32（二进制00100000），大写的字母A是 65（二进制01000001）。这 128 个符号（包括 32 个不能打印出来的控制符号），只占用了一个字节的后面 7 位，最前面的一位统一规定为0。 2.非 ASCII 编码英语用 128 个符号编码就够了，但是用来表示其他语言，128 个符号是不够的。比如，在法语中，字母上方有注音符号，它就无法用 ASCII 码表示。于是，一些欧洲国家就决定，利用字节中闲置的最高位编入新的符号。比如，法语中的é的编码为 130（二进制10000010）。这样一来，这些欧洲国家使用的编码体系，可以表示最多 256 个符号。 这里就又出现了新的问题。不同的国家有不同的字母，因此，哪怕它们都使用 256 个符号的编码方式，代表的字母却不一样。比如，130 在法语编码中代表了é，在希伯来语编码中却代表了字母Gimel (ג)，在俄语编码中又会代表另一个符号。但是不管怎样，所有这些编码方式中，0–127 表示的符号是一样的，不一样的只是 128–255 的这一段。 至于亚洲国家的文字，使用的符号就更多了，汉字就多达 10 万左右。一个字节只能表示 256 种符号，肯定是不够的，就必须使用多个字节表达一个符号。比如，简体中文常见的编码方式是 GB2312，使用两个字节表示一个汉字，所以理论上最多可以表示 256 x 256 = 65536 个符号。 中文编码的问题需要专文讨论，此处不涉及。这里只指出，虽然都是用多个字节表示一个符号，但是 GB 类的汉字编码与后文的 Unicode 和 UTF-8 是毫无关系的。 3.UnicodeUnicode 源于一个很简单的想法：将全世界所有的字符包含在一个集合里，计算机只要支持这一个字符集，就能显示所有的字符，再也不会有乱码了。 Unicode 当然是一个很大的集合，现在的规模可以容纳 100 多万个符号。每个符号的编码都不一样，比如，U+0639表示阿拉伯字母Ain，U+0041表示英语的大写字母A，U+4E25表示汉字严。具体的符号对应表，可以查询unicode.org，或者专门的汉字对应表。 码点它从 0 开始，为每个符号指定一个编号，这叫做”码点”（code point）。比如，码点 0 的符号就是 null（表示所有二进制位都是 0）。 1U+0000 = null 上式中，U+表示紧跟在后面的十六进制数是 Unicode 的码点。 目前，Unicode 的最新版本是 7.0 版，一共收入了 109449 个符号，其中的中日韩文字为 74500 个。可以近似认为，全世界现有的符号当中，三分之二以上来自东亚文字。比如，中文”好”的码点是十六进制的 597D。 分区（基本平面&amp;&amp;辅助平面）这么多符号，Unicode 不是一次性定义的，而是分区定义。每个区可以存放 65536 个（216）字符，称为一个平面（plane）。目前，一共有 17 个（25）平面，也就是说，整个 Unicode 字符集的大小现在是 221。 最前面的 65536 个字符位，称为基本平面（缩写 BMP），它的码点范围是从 0 一直到 216-1，写成 16 进制就是从 U+0000 到 U+FFFF。所有最常见的字符都放在这个平面，这是 Unicode 最先定义和公布的一个平面。 剩下的字符都放在辅助平面（缩写 SMP），码点范围从 U+010000 一直到 U+10FFFF。 问题需要注意的是，Unicode 只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何存储。 比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有 15 位（100111000100101），也就是说，这个符号的表示至少需要 2 个字节。表示其他更大的符号，可能需要 3 个字节或者 4 个字节，甚至更多。 如何才能区别 Unicode 和 ASCII ？计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？ 我们已经知道，英文字母只用一个字节表示就够了，如果 Unicode 统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储来说是极大的浪费，文本文件的大小会因此大出二三倍，这是无法接受的。 4.UTF-32 与 UTF-8UTF-32最直观的编码方法是，每个码点使用四个字节表示，字节内容一一对应码点。这种编码方法就叫做 UTF-32。比如，码点 0 就用四个字节的 0 表示，码点 597D 就在前面加两个字节的 0。 123U+0000 = 0x0000 0000U+597D = 0x0000 597D UTF-32 的优点转换规则简单直观，查找效率高。 缺点浪费空间，同样内容的英语文本，它会比 ASCII 编码大四倍。这个缺点很致命，导致实际上没有人使用这种编码方法，HTML 5 标准就明文规定，网页不得编码成 UTF-32。 UTF-8UTF-8 是一种变长的编码方法，字符长度从 1 个字节到 4 个字节不等。越是常用的字符，字节越短，最前面的 128 个字符，只使用 1 个字节表示，与 ASCII 码完全相同。 由于 UTF-8 这种节省空间的特性，导致它成为互联网上最常见的网页编码。 UTF-8 的编码规则很简单，只有二条： 1）对于单字节的符号，字节的第一位设为0，后面 7 位为这个符号的 Unicode 码。因此对于英语字母，UTF-8 编码和 ASCII 码是相同的。 2）对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。 编码规则： 1234567Unicode符号范围 | UTF-8编码方式(十六进制) | （二进制）----------------------+---------------------------------------------0000 0000-0000 007F | 0xxxxxxx0000 0080-0000 07FF | 110xxxxx 10xxxxxx0000 0800-0000 FFFF | 1110xxxx 10xxxxxx 10xxxxxx0001 0000-0010 FFFF | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 跟据上表，解读 UTF-8 编码非常简单。如果一个字节的第一位是0，则这个字节单独就是一个字符；如果第一位是1，则连续有多少个1，就表示当前字符占用多少个字节。 下面，还是以汉字严为例，演示如何实现 UTF-8 编码。 严的 Unicode 是4E25（100111000100101），根据上表，可以发现4E25处在第三行的范围内（0000 0800 - 0000 FFFF），因此严的 UTF-8 编码需要三个字节，即格式是1110xxxx 10xxxxxx 10xxxxxx。然后，从严的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。这样就得到了，严的 UTF-8 编码是11100100 10111000 10100101，转换成十六进制就是E4B8A5。 5.UTF-16UTF-16 编码介于 UTF-32 与 UTF-8 之间，同时结合了定长和变长两种编码方法的特点。 它的编码规则很简单：基本平面的字符占用 2 个字节，辅助平面的字符占用 4 个字节。也就是说，UTF-16 的编码长度要么是 2 个字节（U+0000 到 U+FFFF），要么是 4 个字节（U+010000 到 U+10FFFF）。 于是就有一个问题，当我们遇到两个字节，怎么看出它本身是一个字符，还是需要跟其他两个字节放在一起解读？ 在基本平面内，从 U+D800 到 U+DFFF 是一个空段，即这些码点不对应任何字符。因此，这个空段可以用来映射辅助平面的字符。 具体来说，辅助平面的字符位共有 220 个，也就是说，对应这些字符至少需要 20 个二进制位。UTF-16 将这 20 位拆成两半，前 10 位映射在 U+D800 到 U+DBFF（空间大小 210），称为高位（H），后 10 位映射在 U+DC00 到 U+DFFF（空间大小 210），称为低位（L）。这意味着，一个辅助平面的字符，被拆成两个基本平面的字符表示。 编码规则 所以，当我们遇到两个字节，发现它的码点在 U+D800 到 U+DBFF 之间，就可以断定，紧跟在后面的两个字节的码点，应该在 U+DC00 到 U+DFFF 之间，这四个字节必须放在一起解读。 Unicode 码点与 UTF-16 转码 首先区分这是基本平面字符，还是辅助平面字符。如果是前者，直接将码点转为对应的十六进制形式，长度为两字节。 1U+597D = 0x597D 如果是辅助平面字符，Unicode 3.0 版给出了转码公式。 123H = Math.floor((c - 0x10000) / 0x400) + 0xd800;L = ((c - 0x10000) % 0x400) + 0xdc00; 6.JavaScript 用的是 UCS-2JavaScript 语言采用 Unicode 字符集，但是只支持一种编码方法。UCS-2！ 互联网还没出现的年代，曾经有两个团队，不约而同想搞统一字符集。一个是 1988 年成立的 Unicode 团队，另一个是 1989 年成立的 UCS 团队。等到他们发现了对方的存在，很快就达成一致：世界上不需要两套统一字符集 1991 年 10 月，两个团队决定合并字符集。也就是说，从今以后只发布一套字符集，就是 Unicode，并且修订此前发布的字符集，UCS 的码点将与 Unicode 完全一致。 两者的关系简单说，就是 UTF-16 取代了 UCS-2，或者说 UCS-2 整合进了 UTF-16。 在 JavaScript 语言出现的时候，还没有 UTF-16 编码。 由于 JavaScript 只能处理 UCS-2 编码，造成所有字符在这门语言中都是 2 个字节，如果是 4 个字节的字符，会当作两个双字节的字符处理。JavaScript 的字符函数都受到这一点的影响，无法返回正确结果。 以字符为例，它的 UTF-16 编码是 4 个字节的 0xD834 DF06。问题就来了，4 个字节的编码不属于 UCS-2，JavaScript 不认识，只会把它看作单独的两个字符 U+D834 和 U+DF06。前面说过，这两个码点是空的，所以 JavaScript 会认为是两个空字符组成的字符串！ 上面代码表示，JavaScript 认为字符的长度是 2，取到的第一个字符是空字符，取到的第一个字符的码点是 0xDB34。这些结果都不正确！ 解决这个问题，必须对码点做一个判断，然后手动调整。下面是正确的遍历字符串的写法。 12345678while (++index &lt; length) &#123; // ... if (charCode &gt;= 0xd800 &amp;&amp; charCode &lt;= 0xdbff) &#123; output.push(character + string.charAt(++index)); &#125; else &#123; output.push(character); &#125;&#125; 上面代码表示，遍历字符串的时候，必须对码点做一个判断，只要落在 0xD800 到 0xDBFF 的区间，就要连同后面 2 个字节一起读取。 类似的问题存在于所有的 JavaScript 字符操作函数。 String.prototype.replace() String.prototype.substring() String.prototype.slice() … 上面的函数都只对 2 字节的码点有效。要正确处理 4 字节的码点，就必须逐一部署自己的版本，判断一下当前字符的码点范围。 7.ES6ECMAScript 6（简称 ES6），大幅增强了 Unicode 支持，基本上解决了这个问题。 （1）正确识别字符 ES6 可以自动识别 4 字节的码点。因此，遍历字符串就简单多了。 123for (let s of string) &#123; // ...&#125; 但是，为了保持兼容，length 属性还是原来的行为方式。为了得到字符串的正确长度，可以用下面的方式。 1Array.from(string).length; （2）码点表示法 JavaScript 允许直接用码点表示 Unicode 字符，写法是”反斜杠+u+码点”。 1\"好\" === \"\\u597D\"; // true 但是，这种表示法对 4 字节的码点无效。ES6 修正了这个问题，只要将码点放在大括号内，就能正确识别。 （3）字符串处理函数 ES6 新增了几个专门处理 4 字节码点的函数。 String.fromCodePoint()：从 Unicode 码点返回对应字符 String.prototype.codePointAt()：从字符返回对应的码点 String.prototype.at()：返回字符串给定位置的字符 （4）正则表达式 ES6 提供了 u 修饰符，对正则表达式添加 4 字节码点的支持。 （5）Unicode 正规化 有些字符除了字母以外，还有附加符号。比如，汉语拼音的 Ǒ，字母上面的声调就是附加符号。对于许多欧洲语言来说，声调符号是非常重要的。 Unicode 提供了两种表示方法。一种是带附加符号的单个字符，即一个码点表示一个字符，比如 Ǒ 的码点是 U+01D1；另一种是将附加符号单独作为一个码点，与主体字符复合显示，即两个码点表示一个字符，比如 Ǒ 可以写成 O（U+004F） + ˇ（U+030C）。 1234567// 方法一\"\\u01D1\";// 'Ǒ'// 方法二\"\\u004F\\u030C\";// 'Ǒ' 这两种表示方法，视觉和语义都完全一样，理应作为等同情况处理。但是，JavaScript 无法辨别。 12\"\\u01D1\" === \"\\u004F\\u030C\";//false ES6 提供了 normalize 方法，允许“Unicode 正规化”，即将两种方法转为同样的序列。 12\"\\u01D1\".normalize() === \"\\u004F\\u030C\".normalize();// true 8.总结截取含有四字节字符的字符串不会出现乱码的方法12let nickname = \"非拉🍒非拉\";nickname.length; // 6 Array.from 方法Array.from这个方法能够将类数组转换为真实的数组，比如NodeList, argument等，同样，也包括字符串。 12Array.from(nickname); // [\"非\", \"拉\", \"🍒\", \"非\", \"拉\"]nickname.split(\"\"); // [\"非\", \"拉\", \"�\", \"�\", \"非\", \"拉\"] 使用 Array.from 把 nickname 转换后，可以看到转换成一个真实的数组了，樱桃字符占了数组中的一个位置，然后按照数组中的方法截取再进行拼接即可，而使用 split 方法拆分，则还是乱码： 123456function truncated(str, num) &#123; return Array.from(str) .slice(0, num) .join(\"\");&#125;truncated(nickname, 3); // 非拉🍒 codePointAt()方法在 ES6 之前， JS 的字符串以 16 位字符编码(UTF-16)为基础。每个 16 位序列(相当于 2 个字节)是一个编码单元(code unit)，可简称为码元，用于表示一个字符。字符串所有的属性与方法(如 length 属性与 charAt() 方法等)都是基于 16 位序列。 比如 length 方法、nickname[2]、split 方法等操作，都会产生异常。为此在 ES6 中，加强了对 Unicode 的支持，并且扩展了字符串对象。 对于 Unicode 码点大于 0xFFFF 的字符，是使用 4 个字节进行存储。ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 12345// 获取樱桃的码点\"🍒\".codePointAt(0).toString(16); // 1f352// 输出码点对应的字符(\"\\u&#123;1f352&#125;\"); // 🍒 请注意： 在之前 Unicode 编码，均在[\\u000-\\uFFFF]之间，因此可以使用类似\\u0047这样的编码；但是现在码点超过\\uFFFF的界限，若再这样使用，则获取不到对应的字符。因此在 ES6 中，码点的字符放在中括号内，类似上面的格式（所有的码点均可以使用这种格式）： 123\"\\u&#123;1f352&#125;\"; // 🍒\"\\u&#123;47&#125;\"; // G\"\\u&#123;0047&#125;\"; // G 那么就容易了：判断需要截取的位置是否正好是 4 字节的字符，如果是则延长一位截取，否则正常截取： 12345function truncated(str, num) &#123; let index = Array.from(str)[num - 1].codePointAt(0) &gt; 0xffff ? num + 1 : num; return str.slice(0, index);&#125;truncated(nickname, 3); // 非拉🍒 for-offor-in方法是遍历 key 值，for-of是遍历 value 值： 123456789101112let arr = [\"a\", \"b\", \"c\"];for (let k in arr) &#123; console.log(k); // 0 1 2&#125;for (let v of arr) &#123; console.log(v); // a b c&#125;for (let v of nickname) &#123; console.log(v); // 非 拉 🍒 非 拉&#125; 因此利用这个功能，我们也能进行截取： 123456789101112function truncated(str, num) &#123; let s = \"\"; for (let v of nickname) &#123; s += v; num--; if (num &lt;= 0) &#123; break; &#125; &#125; return s;&#125;truncated(nickname, 3); 正确输出字符串的字符个数：1234567891011function getLen(str) &#123; var len = str.length; for (var i = 0; i &lt; len; i++) &#123; var charCode = str.charCodeAt(i); if (charCode &gt;= 0xd800 &amp;&amp; charCode &lt;= 0xdbff) &#123; len--; i++; &#125; &#125; return len;&#125; 1Array.from(str).length; 9.string.lengthstring.length 返回的是什么 字符的个数还是字节数？为什么会与实际长度不一样？编码的部分详细说string.length():返回字符串的长度（以字节为单位）。是符合字符串内容的实际字节数，不一定等于其容量。 string.size()和 string.length()是同义词，并返回完全相同的值。 string.max_size()：返回字符串的最大大小，返回字符串可以达到的最大长度。 string.resize():string.resize(n)：把字符串的长度设置为 n 个字符如果 n 小于当前字符串长度 ，则只截取前 n 个字符，删除超出第 n 个字符的字符。如果大于，则在末端插入尽可能多的字符来扩展当前内容，以达到大小 n。 如果指定 c，则新元素将初始化为 c 的副本，否则为值初始化字符（空字符）。 string.capacity()：返回已分配存储的大小。当前为字符串分配的存储空间的大小，以字节表示。 此容量不一定等于字符串长度。 它可以相等或更大，额外的空间允许对象在将新字符添加到字符串时优化其操作。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"常用的正则","slug":"常用的正则","date":"2019-03-29T14:07:27.000Z","updated":"2019-08-15T10:30:14.430Z","comments":true,"path":"2019/03/29/常用的正则/","link":"","permalink":"http://yoursite.com/2019/03/29/常用的正则/","excerpt":"正则1.校验数字123456789101112131415161718数字：^\\d*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9]\\d*)+(\\.\\d&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+\\.\\d&#123;1,2&#125;$正数、负数、和小数：^(\\-)?\\d+(\\.\\d+)?$有两位小数的正实数：^\\d+\\.\\d&#123;2&#125;$有1~3位小数的正实数：^\\d+\\.\\d&#123;1,3&#125;$非零的正整数：^[1-9]\\d*$非零的负整数：^-[1-9]\\d*$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$","text":"正则1.校验数字123456789101112131415161718数字：^\\d*$n位的数字：^\\d&#123;n&#125;$至少n位的数字：^\\d&#123;n,&#125;$m-n位的数字：^\\d&#123;m,n&#125;$零和非零开头的数字：^(0|[1-9][0-9]*)$非零开头的最多带两位小数的数字：^([1-9]\\d*)+(\\.\\d&#123;1,2&#125;)?$带1-2位小数的正数或负数：^(\\-)?\\d+\\.\\d&#123;1,2&#125;$正数、负数、和小数：^(\\-)?\\d+(\\.\\d+)?$有两位小数的正实数：^\\d+\\.\\d&#123;2&#125;$有1~3位小数的正实数：^\\d+\\.\\d&#123;1,3&#125;$非零的正整数：^[1-9]\\d*$非零的负整数：^-[1-9]\\d*$非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非负浮点数：^\\d+(\\.\\d+)?$ 或 ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$非正浮点数：^((-\\d+(\\.\\d+)?)|(0+(\\.0+)?))$ 或 ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$正浮点数：^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 或 ^(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*))$负浮点数：^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 或 ^(-(([0-9]+\\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\\.[0-9]+)|([0-9]*[1-9][0-9]*)))$浮点数：^(-?\\d+)(\\.\\d+)?$ 或 ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 2.校验字符的表达式123456789101112汉字：^[\\u4e00-\\u9fa5]+$英文和数字：^[A-Za-z0-9]+$长度为3-20的所有字符：^.&#123;3,20&#125;$由26个英文字母组成的字符串：^[A-Za-z]+$由26个大写英文字母组成的字符串：^[A-Z]+$由26个小写英文字母组成的字符串：^[a-z]+$由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$由数字、26个英文字母或者下划线组成的字符串：^\\w+$中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+禁止输入含有~的字符：[^~\\x22]+ 3.特殊需求表达式1234567891011121314Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?InternetURL：[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$国内手机号码：^1[34578]&#123;1&#125;\\d&#123;9&#125;帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z]\\w&#123;4,15&#125;$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w&#123;5,17&#125;$强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.*\\d)(?=.*[a-z])(?=.*[A-Z]).&#123;8,10&#125;$日期格式：^\\d&#123;4&#125;-\\d&#123;1,2&#125;-\\d&#123;1,2&#125;一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$腾讯QQ号：[1-9][0-9]&#123;4,&#125; (腾讯QQ号从10000开始)IP地址：\\d+\\.\\d+\\.\\d+\\.\\d+ (提取IP地址时有用)IP地址：^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5]))&#123;3&#125;$xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\\\.[x|X][m|M][l|L]$","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"移动端的触屏事件","slug":"移动端的触屏事件","date":"2019-03-22T08:28:36.000Z","updated":"2019-08-15T10:32:11.938Z","comments":true,"path":"2019/03/22/移动端的触屏事件/","link":"","permalink":"http://yoursite.com/2019/03/22/移动端的触屏事件/","excerpt":"移动端的触屏事件1.原生触摸事件（touch 类事件）在移动端，原生触摸事件只有以下三种类型，其他所有的触摸事件都是由这三种事件相结合产生的，例如，上划、下滑、左滑、右滑、双击等等；","text":"移动端的触屏事件1.原生触摸事件（touch 类事件）在移动端，原生触摸事件只有以下三种类型，其他所有的触摸事件都是由这三种事件相结合产生的，例如，上划、下滑、左滑、右滑、双击等等； 这三种原生触摸事件为： touchstart：开始触摸 touchmove：触摸过程中 touchend：触摸结束 另外，还有一个触摸被系统取消的事件：touchcancel（由更高级的事件打断当前正在执行的移动端事件时，会触发该事件，我们可以在这个事件中保存当前相关的触碰事件操作的数据，以保证用户回到页面后接着刚才断开的位置继续操作）； 触摸事件下的一些相关属性 targetTouches：可获取到事件对象下的触摸点，该属性是一个类数组的结构，同时触发这个事件的手指有几个，则数组中就有几个元素。触摸点的相关坐标数据就存在这些对象中。 pageX\\pageY:坐标系原点在页面的左上角； screenX\\screenY:坐标系的原点在屏幕的左上角点（不包含操作系统在左上角的组件）； clientX\\clientY:触摸目标在视口中的坐标，原点在视口左上角(适口视用来展示 html 代码的容器)； targer:保存的是触发事件的标签，使用事件委托时可以通过该属性获取到触发该事件的标签对象； identifier:ID 值，唯一标示了手指触摸点，如果手指在屏幕上产生移动（如果有多个触摸点，则可以根据这个 id 值跟踪对应的触摸点）； event 对象：由于手机端的手指触发不是单个的，所以在 event 里面生成的与触摸有关的数据都是以数组的形式列出来的，有以下三个： touches：表示当前跟踪的触摸操作的 touch 对象的数组。当前屏幕上所有触摸点的集合列表 targetTouches：特定于事件目标的 Touch 对象的数组。绑定事件的那个结点上的触摸点的集合列表 changedTouches：表示自上次触摸以来发生了什么改变的 Touch 对象的数组。触发事件时改变的触摸点的集合 2.触碰事件（tap 类事件）触碰事件，我目前还不知道它和 touch 的区别，一般用于代替 click 事件 tap: 手指碰一下屏幕会触发 longTap: 手指长按屏幕会触发 singleTap: 手指碰一下屏幕会触发 doubleTap: 手指双击屏幕会触发 3.滑动事件（swipe 类事件）滑动事件 swipe：手指在屏幕上滑动时会触发 swipeLeft：手指在屏幕上向左滑动时会触发 swipeRight：手指在屏幕上向右滑动时会触发 swipeUp：手指在屏幕上向上滑动时会触发 swipeDown：手指在屏幕上向下滑动时会触发 4.自定义手势事件 gesture手势事件只是概念型，目前还没有浏览器原生支持，按照概念可分为 gesturestart gesturechange gestureend 三种事件 gesturestart：当有两根或多根手指放到屏幕上的时候触发 gesturechange：当有两根或多根手指在屏幕上，并且有手指移动的时候触发 gestureend：当倒数第二根手指提起的时候触发，结束 gesture 按照定义，当分别将两根手指放到屏幕上的时候，会有如下顺序的事件触发： 1、第一根手指放下，触发 touchstart 2、第二根手指放下，触发 gesturestart 3、触发第二根手指的 touchstart 4、立即触发 gesturechange 5、手指移动，持续触发 gesturechange 6、第二根手指提起，触发 gestureend，以后将不会再触发 gesturechange 7、触发第二根手指的 touchend 8、触发 touchstart（多根手指在屏幕上，提起一根，会刷新一次全局 touch，重新触发第一根手指的 touchstart） 9、提起第一根手指，触发 touchend 5.Zepto.js 库可以更好的支持，基于 CSS3","categories":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/categories/移动端/"}],"tags":[{"name":"移动端","slug":"移动端","permalink":"http://yoursite.com/tags/移动端/"}]},{"title":"双向数据绑定Proxy和Object.defineProperty对比","slug":"双向数据绑定Proxy和Object.defineProperty对比","date":"2019-03-11T03:52:12.000Z","updated":"2019-08-15T10:32:02.082Z","comments":true,"path":"2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/","link":"","permalink":"http://yoursite.com/2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/","excerpt":"双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在： 无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &#39;渣渣辉&#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 zone.js 避免显示调用,不展开),react 需要显示调用setState。 可精确得知变化数据：还是上面的小例子，我们劫持了属性的 setter,当属性值改变,我们可以精确获知变化的内容newVal,因此在这部分不需要额外的 diff 操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量 diff 来找出变化值,这是额外性能损耗。","text":"双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在： 无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &#39;渣渣辉&#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 zone.js 避免显示调用,不展开),react 需要显示调用setState。 可精确得知变化数据：还是上面的小例子，我们劫持了属性的 setter,当属性值改变,我们可以精确获知变化的内容newVal,因此在这部分不需要额外的 diff 操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量 diff 来找出变化值,这是额外性能损耗。 基于数据劫持双向绑定的实现思路数据劫持是双向绑定各种方案中比较流行的一种,最著名的实现就是 Vue。 基于数据劫持的双向绑定离不开Proxy与Object.defineProperty等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。 利用Proxy或Object.defineProperty生成的 Observer 针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者 解析器 Compile 解析模板中的Directive(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染 Watcher 属于 Observer 和 Compile 桥梁,它将接收到的 Observer 产生的数据变化,并根据 Compile 提供的指令进行视图渲染,使得数据变化促使视图变化 在 new Vue() 后， Vue 会调用_init 函数进行初始化，也就是 init 过程，在 这个过程 Data 通过 Observer 转换成了 getter/setter 的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行getter 函数，而在当被赋值的时候会执行 setter函数。 当 render function 执行的时候，因为会读取所需对象的值，所以会触发getter函数从而将 Watcher 添加到依赖中进行依赖收集。 在修改对象的值的时候，会触发对应的setter， setter通知之前依赖收集得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图。 基于 Object.defineProperty 双向绑定的特点Vue 通过设定对象属性的 setter/getter 方法来监听数据的变化，通过 getter 进行依赖收集，而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 在 getter 中收集依赖，在 setter 中触发依赖。 当外界通过 Watcher 读取数据时，便会触发 getter 从而将 Watcher 添加到依赖中，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。 极简版的双向绑定Object.defineProperty的作用就是劫持一个对象的属性,通常我们对属性的getter和setter方法进行劫持,在对象的属性发生变化时进行特定的操作。 我们就对对象obj的text属性进行劫持,在获取此属性的值时打印&#39;get val&#39;,在更改属性值的时候对 DOM 进行操作,这就是一个极简的双向绑定。 12345678910111213141516const obj = &#123;&#125;;Object.defineProperty(obj, \"text\", &#123; get: function() &#123; console.log(\"get val\"); &#125;, set: function(newVal) &#123; console.log(\"set val:\" + newVal); document.getElementById(\"input\").value = newVal; document.getElementById(\"span\").innerHTML = newVal; &#125;&#125;);const input = document.getElementById(\"input\");input.addEventListener(\"keyup\", function(e) &#123; obj.text = e.target.value;&#125;); 升级改造我们很快会发现，这个所谓的双向绑定貌似并没有什么乱用。。。 原因如下: 我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。 违反开放封闭原则,我们如果了解开放封闭原则的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。 代码耦合严重,我们的数据、方法和 DOM 都是耦合在一起的，就是传说中的面条代码。 那么如何解决上述问题？ Vue 的操作就是加入了发布订阅模式，结合Object.defineProperty的劫持能力，实现了可用性很高的双向绑定。 首先，我们以发布订阅的角度看我们第一部分写的那一坨代码,会发现它的监听、发布和订阅都是写在一起的,我们首先要做的就是解耦。 我们先实现一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它。 123456789101112131415161718192021222324let uid = 0;// 用于储存订阅者并发布消息class Dep &#123; constructor() &#123; // 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher this.id = uid++; // 储存订阅者的数组 this.subs = []; &#125; // 触发target上的Watcher中的addDep方法,参数为dep的实例本身 depend() &#123; Dep.target.addDep(this); &#125; // 添加订阅者 addSub(sub) &#123; this.subs.push(sub); &#125; notify() &#123; // 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理 this.subs.forEach(sub =&gt; sub.update()); &#125;&#125;// 为Dep类设置一个静态属性,默认为null,工作时指向当前的WatcherDep.target = null; 现在我们需要实现监听者(Observer),用于监听属性值的变化。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950// 监听者,监听对象属性值的变化class Observer &#123; constructor(value) &#123; this.value = value; this.walk(value); &#125; // 遍历属性值并监听 walk(value) &#123; Object.keys(value).forEach(key =&gt; this.convert(key, value[key])); &#125; // 执行监听的具体方法 convert(key, val) &#123; defineReactive(this.value, key, val); &#125;&#125;function defineReactive(obj, key, val) &#123; const dep = new Dep(); // 给当前属性的值添加监听 let chlidOb = observe(val); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: () =&gt; &#123; // 如果Dep类存在target属性，将其添加到dep实例的subs数组中 // target指向一个Watcher实例，每个Watcher都是一个订阅者 // Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法 if (Dep.target) &#123; dep.depend(); &#125; return val; &#125;, set: newVal =&gt; &#123; if (val === newVal) return; val = newVal; // 对新值进行监听 chlidOb = observe(newVal); // 通知所有订阅者，数值被改变了 dep.notify(); &#125; &#125;);&#125;function observe(value) &#123; // 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听 if (!value || typeof value !== \"object\") &#123; return; &#125; return new Observer(value);&#125; 那么接下来就简单了,我们需要实现一个订阅者(Watcher)。 12345678910111213141516171819202122232425262728293031323334353637class Watcher &#123; constructor(vm, expOrFn, cb) &#123; this.depIds = &#123;&#125;; // hash储存订阅者的id,避免重复的订阅者 this.vm = vm; // 被订阅的数据一定来自于当前Vue实例 this.cb = cb; // 当数据更新时想要做的事情 this.expOrFn = expOrFn; // 被订阅的数据 this.val = this.get(); // 维护更新之前的数据 &#125; // 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用 update() &#123; this.run(); &#125; addDep(dep) &#123; // 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存 // 此判断是避免同id的Watcher被多次储存 if (!this.depIds.hasOwnProperty(dep.id)) &#123; dep.addSub(this); this.depIds[dep.id] = dep; &#125; &#125; run() &#123; const val = this.get(); console.log(val); if (val !== this.val) &#123; this.val = val; this.cb.call(this.vm, val); &#125; &#125; get() &#123; // 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者 Dep.target = this; const val = this.vm._data[this.expOrFn]; // 置空，用于下一个Watcher使用 Dep.target = null; return val; &#125;&#125; 那么我们最后完成 Vue,将上述方法挂载在 Vue 上。 123456789101112131415161718192021222324252627class Vue &#123; constructor(options = &#123;&#125;) &#123; // 简化了$options的处理 this.$options = options; // 简化了对data的处理 let data = (this._data = this.$options.data); // 将所有data最外层属性代理到Vue实例上 Object.keys(data).forEach(key =&gt; this._proxy(key)); // 监听数据 observe(data); &#125; // 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者 $watch(expOrFn, cb) &#123; new Watcher(this, expOrFn, cb); &#125; _proxy(key) &#123; Object.defineProperty(this, key, &#123; configurable: true, enumerable: true, get: () =&gt; this._data[key], set: val =&gt; &#123; this._data[key] = val; &#125;, &#125;); &#125; &#125;] 至此,一个简单的双向绑定算是被我们实现了。 Object.defineProperty 的缺陷 Object.defineProperty的第一个缺陷,无法监听数组变化。Vue 的文档提到了 Vue 是可以检测到数组变化的，但是只有以下八种方法,vm.items[indexOfItem] = newValue这种是无法检测的。push()、pop()、shift()、unshift()、splice()、sort()、reverse() Object.defineProperty的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。 Object.keys(value).forEach(key =&gt; **this**.convert(key, value[key])); 无法检测到对象属性的添加或删除(如data.location.a=1)。 这是因为 Vue 通过Object.defineProperty来将对象的 key 转换成getter/setter的形式来追踪变化，但getter/setter只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。如果是删除属性，我们可以用vm.$delete实现，那如果是新增属性，该怎么办呢？1）可以使用 Vue.set(location, a, 1) 方法向嵌套对象添加响应式属性;2）也可以给这个对象重新赋值，比如data.location = {...data.location,a:1} Proxy 实现的双向绑定的特点Proxy 在 ES2015 规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy 是Object.defineProperty的全方位加强版 Proxy 可以直接监听对象而非属性我们还是以上文中用Object.defineProperty实现的极简版双向绑定为例,用 Proxy 进行改写。 12345678910111213141516171819202122const input = document.getElementById(\"input\");const p = document.getElementById(\"p\");const obj = &#123;&#125;;const newObj = new Proxy(obj, &#123; get: function(target, key, receiver) &#123; console.log(`getting $&#123;key&#125;!`); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key === \"text\") &#123; input.value = value; p.innerHTML = value; &#125; return Reflect.set(target, key, value, receiver); &#125;&#125;);input.addEventListener(\"keyup\", function(e) &#123; newObj.text = e.target.value;&#125;); 我们可以看到,Proxy 直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于Object.defineProperty。 Proxy 可以直接监听数组的变化当我们对数组进行操作(push、shift、splice 等)时，会触发对应的方法名称和length的变化，我们可以借此进行操作,以上文中Object.defineProperty无法生效的列表渲染为例。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950const list = document.getElementById(\"list\");const btn = document.getElementById(\"btn\");// 渲染列表const Render = &#123; // 初始化 init: function(arr) &#123; const fragment = document.createDocumentFragment(); for (let i = 0; i &lt; arr.length; i++) &#123; const li = document.createElement(\"li\"); li.textContent = arr[i]; fragment.appendChild(li); &#125; list.appendChild(fragment); &#125;, // 我们只考虑了增加的情况,仅作为示例 change: function(val) &#123; const li = document.createElement(\"li\"); li.textContent = val; list.appendChild(li); &#125;&#125;;// 初始数组const arr = [1, 2, 3, 4];// 监听数组const newArr = new Proxy(arr, &#123; get: function(target, key, receiver) &#123; console.log(key); return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; console.log(target, key, value, receiver); if (key !== \"length\") &#123; Render.change(value); &#125; return Reflect.set(target, key, value, receiver); &#125;&#125;);// 初始化window.onload = function() &#123; Render.init(arr);&#125;;// push数字btn.addEventListener(\"click\", function() &#123; newArr.push(6);&#125;); 很显然,Proxy 不需要那么多 hack（即使 hack 也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于 hack。 Proxy 的其他优势Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是Object.defineProperty不具备的。 Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而Object.defineProperty只能遍历对象属性直接修改。 Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。 当然,Proxy 的劣势就是兼容性问题,而且无法用 polyfill 磨平,因此 Vue 的作者才声明需要等到下个大版本(3.0)才能用 Proxy 重写。 基础 proxy 的双向数据绑定的实现发布订阅中心(Dep)Dep保存订阅者,并在 Observer 发生变化时通知保存在 Dep 中的订阅者,让订阅者得知变化并更新视图,这样才能保证视图与状态的同步。 12345678910111213141516171819202122232425262728293031/** * [subs description] 订阅器,储存订阅者,通知订阅者 * @type &#123;Map&#125; */export default class Dep &#123; constructor() &#123; // 我们用 hash 储存订阅者 this.subs = new Map(); &#125; // 添加订阅者 addSub(key, sub) &#123; // 取出键为 key 的订阅者 const currentSub = this.subs.get(key); // 如果能取出说明有相同的 key 的订阅者已经存在,直接添加 if (currentSub) &#123; currentSub.add(sub); &#125; else &#123; // 用 Set 数据结构储存,保证唯一值 this.subs.set(key, new Set([sub])); &#125; &#125; // 通知 notify(key) &#123; // 触发键为 key 的订阅者们 if (this.subs.get(key)) &#123; this.subs.get(key).forEach(sub =&gt; &#123; sub.update(); &#125;); &#125; &#125;&#125; 监听者的实现(Observer)我们在订阅器 Dep 中实现了一个notify方法来通知相应的订阅这们,然而notify方法到底什么时候被触发呢? 当然是当状态发生变化时,即 MVVM 中的 Modal 变化时触发通知,然而Dep 显然无法得知 Modal 是否发生了变化,因此我们需要创建一个监听者Observer来监听 Modal, 当 Modal 发生变化的时候我们就执行通知操作。 与Object.defineProperty监听属性不同, Proxy 可以监听(实际是代理)整个对象,因此就不需要遍历对象的属性依次监听了,但是如果对象的属性依然是个对象,那么 Proxy 也无法监听,所以我们实现了一个observify进行递归监听即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * [Observer description] 监听器,监听对象,触发后通知订阅 * @param &#123;[type]&#125; obj [description] 需要被监听的对象 */const Observer = obj =&gt; &#123; const dep = new Dep(); return new Proxy(obj, &#123; get: function(target, key, receiver) &#123; // 如果订阅者存在，直接添加订阅 if (Dep.target) &#123; dep.addSub(key, Dep.target); &#125; return Reflect.get(target, key, receiver); &#125;, set: function(target, key, value, receiver) &#123; // 如果对象值没有变,那么不触发下面的操作直接返回 if (Reflect.get(receiver, key) === value) &#123; return; &#125; const res = Reflect.set(target, key, observify(value), receiver); // 当值被触发更改的时候,触发 Dep 的通知方法 dep.notify(key); return res; &#125; &#125;);&#125;;/** * 将对象转为监听对象 * @param &#123;*&#125; obj 要监听的对象 */export default function observify(obj) &#123; if (!isObject(obj)) &#123; return obj; &#125; // 深度监听 Object.keys(obj).forEach(key =&gt; &#123; obj[key] = observify(obj[key]); &#125;); return Observer(obj);&#125; 订阅者的实现(watcher)我们目前已经解决了两个问题,一个是如何得知 Modal 发生了改变(利用监听者 Observer 监听 Modal 对象),一个是如何收集订阅者并通知其变化(利用订阅器收集订阅者,并用 notify 通知订阅者)。 我们目前还差一个订阅者（Watcher） 12345678910111213141516171819202122232425262728293031// 订阅者export default class Watcher &#123; constructor(vm, exp, cb) &#123; this.vm = vm; // vm 是 vue 的实例 this.exp = exp; // 被订阅的数据 this.cb = cb; // 触发更新后的回调 this.value = this.get(); // 获取老数据 &#125; get() &#123; const exp = this.exp; let value; Dep.target = this; if (typeof exp === \"function\") &#123; value = exp.call(this.vm); &#125; else if (typeof exp === \"string\") &#123; value = this.vm[exp]; &#125; Dep.target = null; return value; &#125; // 将订阅者放入待更新队列等待批量更新 update() &#123; pushQueue(this); &#125; // 触发真正的更新操作 run() &#123; const val = this.get(); // 获取新数据 this.cb.call(this.vm, val, this.value); this.value = val; &#125;&#125; 批量更新的实现我们在上一节中实现了订阅者( Watcher),但是其中的update方法是将订阅者放入了一个待更新的队列中,而不是直接触发,原因如下: 因此这个队列需要做的是异步且去重,因此我们用 Set作为数据结构储存 Watcher 来去重,同时用Promise模拟异步更新。 1234567891011121314151617181920212223// 创建异步更新队列let queue = new Set();// 用Promise模拟nextTickfunction nextTick(cb) &#123; Promise.resolve().then(cb);&#125;// 执行刷新队列function flushQueue(args) &#123; queue.forEach(watcher =&gt; &#123; watcher.run(); &#125;); // 清空 queue = new Set();&#125;// 添加到队列export default function pushQueue(watcher) &#123; queue.add(watcher); // 下一个循环调用 nextTick(flushQueue);&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"九种实现跨域的方式","slug":"九种实现跨域的方式","date":"2019-03-07T07:00:20.000Z","updated":"2019-04-07T08:25:36.210Z","comments":true,"path":"2019/03/07/九种实现跨域的方式/","link":"","permalink":"http://yoursite.com/2019/03/07/九种实现跨域的方式/","excerpt":"基本概念同源策略是约定，它是浏览器最核心也最基本的安全功能。同源：”协议+域名+端口” 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了","text":"基本概念同源策略是约定，它是浏览器最核心也最基本的安全功能。同源：”协议+域名+端口” 同源策略限制内容有： Cookie、LocalStorage、IndexedDB 等存储性内容 DOM 节点 AJAX 请求发送后，结果被浏览器拦截了 有三个标签是允许跨域加载资源： 123&lt;img src=XXX&gt;&lt;link href=XXX&gt;&lt;script src=XXX&gt; 跨域解决方案：JSONPJSONP 原理利用 script 标签没有跨域限制的漏洞，网页可以得到从其他来源动态产生的 JSON 数据。JSONP 请求一定需要对方的服务器做支持才可以。 JSONP 优缺点JSONP 优点是简单兼容性好，可用于解决主流浏览器的跨域数据访问的问题。缺点是仅支持 get 方法具有局限性,不安全可能会遭受 XSS 攻击。 JSONP 的实现流程 声明一个回调函数，其函数名(如 show)当做参数值，要传递给跨域请求数据的服务器，函数形参为要获取目标数据(服务器返回的 data)。 创建一个 script 标签，把那个跨域的 API 数据接口地址，赋值给 script 的 src,还要在这个地址中向服务器传递该函数名（可以通过问号传参:?callback=show）。 服务器接收到请求后，需要进行特殊的处理：把传递进来的函数名和它需要给你的数据拼接成一个字符串,例如：传递进去的函数名是 show，它准备好的数据是 show(‘我不爱你’)。 最后服务器把准备的数据通过 HTTP 协议返回给客户端，客户端再调用执行之前声明的回调函数（show），对返回的数据进行操作。 123456789101112131415161718192021222324// index.htmlfunction jsonp(&#123; url, params, callback &#125;) &#123; return new Promise((resolve, reject) =&gt; &#123; let script = document.createElement(\"script\"); window[callback] = function(data) &#123; resolve(data); document.body.removeChild(script); &#125;; params = &#123; ...params, callback &#125;; // wd=b&amp;callback=show let arrs = []; for (let key in params) &#123; arrs.push(`$&#123;key&#125;=$&#123;params[key]&#125;`); &#125; script.src = `$&#123;url&#125;?$&#123;arrs.join(\"&amp;\")&#125;`; document.body.appendChild(script); &#125;);&#125;jsonp(&#123; url: \"http://localhost:3000/say\", params: &#123; wd: \"Iloveyou\" &#125;, callback: \"show\"&#125;).then(data =&gt; &#123; console.log(data);&#125;); 上面这段代码相当于向http://localhost:3000/say?wd=Iloveyou&amp;callback=show 这个地址请求数据，然后后台返回 show(‘我不爱你’)，最后会运行 show()这个函数，打印出’我不爱你’ 12345678910// server.jslet express = require(\"express\");let app = express();app.get(\"/say\", function(req, res) &#123; let &#123; wd, callback &#125; = req.query; console.log(wd); // Iloveyou console.log(callback); // show res.end(`$&#123;callback&#125;('我不爱你')`);&#125;);app.listen(3000); corsCORS 需要浏览器和后端同时支持。IE 8 和 9 需要通过 XDomainRequest 来实现。浏览器会自动进行 CORS 通信，实现 CORS 通信的关键是后端。 服务端设置 Access-Control-Allow-Origin 就可以开启 CORS。 该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。 简单请求使用方法为 GET、HEAD、POST 之一Content-Type 的值仅限于 text/plain、multipart/form-data、application/x-www-form-urlencoded 三者之一同时满足这两大条件，为简单请求 复杂请求复杂请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求,该请求是 option 方法的，通过该请求来知道服务端是否允许跨域请求。 12345678910111213141516// index.htmllet xhr = new XMLHttpRequest();document.cookie = \"name=xiamen\"; // cookie不能跨域xhr.withCredentials = true; // 前端设置是否带cookiexhr.open(\"PUT\", \"http://localhost:4000/getData\", true);xhr.setRequestHeader(\"name\", \"xiamen\");xhr.onreadystatechange = function() &#123; if (xhr.readyState === 4) &#123; if ((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr.status === 304) &#123; console.log(xhr.response); //得到响应头，后台需设置Access-Control-Expose-Headers console.log(xhr.getResponseHeader(\"name\")); &#125; &#125;&#125;;xhr.send(); 12345//server1.jslet express = require(\"express\");let app = express();app.use(express.static(__dirname));app.listen(3000); 123456789101112131415161718192021222324252627282930313233343536//server2.jslet express = require(\"express\");let app = express();let whitList = [\"http://localhost:3000\"]; //设置白名单app.use(function(req, res, next) &#123; let origin = req.headers.origin; if (whitList.includes(origin)) &#123; // 设置哪个源可以访问我 res.setHeader(\"Access-Control-Allow-Origin\", origin); // 允许携带哪个头访问我 res.setHeader(\"Access-Control-Allow-Headers\", \"name\"); // 允许哪个方法访问我 res.setHeader(\"Access-Control-Allow-Methods\", \"PUT\"); // 允许携带cookie res.setHeader(\"Access-Control-Allow-Credentials\", true); // 预检的存活时间 res.setHeader(\"Access-Control-Max-Age\", 6); // 允许返回的头 res.setHeader(\"Access-Control-Expose-Headers\", \"name\"); if (req.method === \"OPTIONS\") &#123; res.end(); // OPTIONS请求不做任何处理 &#125; &#125; next();&#125;);app.put(\"/getData\", function(req, res) &#123; console.log(req.headers); res.setHeader(\"name\", \"jw\"); //返回一个响应头，后台需设置 res.end(\"我不爱你\");&#125;);app.get(\"/getData\", function(req, res) &#123; console.log(req.headers); res.end(\"我不爱你\");&#125;);app.use(express.static(__dirname));app.listen(4000); postMessage是为数不多可以跨域操作的 window 属性，可用于解决以下方面的问题： 页面和其打开的新窗口的数据传递 多窗口之间消息传递 页面与嵌套的 iframe 消息传递 上面三个场景的跨域数据传递postMessage()方法允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文本档、多窗口、跨域消息传递。 1otherWindow.postMessage(message, targetOrigin, [transfer]); 例子： 123456789101112131415161718// a.html&lt;iframe src=\"http://localhost:4000/b.html\" frameborder=\"0\" id=\"frame\" onload=\"load()\"&gt;&lt;/iframe&gt;//等它加载完触发一个事件 //内嵌在http://localhost:3000/a.html&lt;script&gt; function load() &#123; let frame = document.getElementById(\"frame\"); frame.contentWindow.postMessage(\"我爱你\", \"http://localhost:4000\"); //发送数据 window.onmessage = function(e) &#123; //接受返回数据 console.log(e.data); //我不爱你 &#125;; &#125;&lt;/script&gt; 12345// b.htmlwindow.onmessage = function(e) &#123; console.log(e.data); //我爱你 e.source.postMessage(\"我不爱你\", e.origin);&#125;; websocketWebsocket 是 HTML5 的 WebSocket 和 HTTP 都是应用层协议，都基于 TCP 协议。但是 WebSocket 是一种双向通信协议，在建立连接之后，WebSocket 的 server 与 client 都能主动向对方发送或接收数据。一个持久化的协议，它实现了浏览器与服务器的全双工通信，同时也是跨域的一种解决方案。同时，WebSocket 在建立连接时需要借助 HTTP 协议，连接建立好了之后 client 与 server 之间的双向通信就与 HTTP 无关了。 12345678910// socket.html&lt;script&gt; let socket = new WebSocket(\"ws://localhost:3000\"); socket.onopen = function() &#123; socket.send(\"我爱你\"); //向服务器发送数据 &#125;; socket.onmessage = function(e) &#123; console.log(e.data); //接收服务器返回的数据 &#125;;&lt;/script&gt; 1234567891011// server.jslet express = require(\"express\");let app = express();let WebSocket = require(\"ws\"); //记得安装wslet wss = new WebSocket.Server(&#123; port: 3000 &#125;);wss.on(\"connection\", function(ws) &#123; ws.on(\"message\", function(data) &#123; console.log(data); ws.send(\"我不爱你\"); &#125;);&#125;); Node 中间件代理(两次跨域)实现原理：同源策略是浏览器需要遵循的标准，而如果是服务器向服务器请求就无需遵循同源策略。 代理服务器，需要做以下几个步骤： 接受客户端请求 。 将请求 转发给服务器。 拿到服务器 响应 数据。 将 响应 转发给客户端。 本地文件 index.html 文件，通过代理服务器http://localhost:3000向目标服务器http://localhost:4000请求数据： 12345678910111213141516// index.html(http://127.0.0.1:5500)&lt;script src=\"https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; $.ajax(&#123; url: \"http://localhost:3000\", type: \"post\", data: &#123; name: \"xiamen\", password: \"123456\" &#125;, contentType: \"application/json;charset=utf-8\", success: function(result) &#123; console.log(result); // &#123;\"title\":\"fontend\",\"password\":\"123456\"&#125; &#125;, error: function(msg) &#123; console.log(msg); &#125; &#125;);&lt;/script&gt; 1234567891011121314151617181920212223242526272829303132333435363738// server1.js 代理服务器(http://localhost:3000)const http = require(\"http\");// 第一步：接受客户端请求const server = http.createServer((request, response) =&gt; &#123; // 代理服务器，直接和浏览器直接交互，需要设置CORS 的首部字段 response.writeHead(200, &#123; \"Access-Control-Allow-Origin\": \"*\", \"Access-Control-Allow-Methods\": \"*\", \"Access-Control-Allow-Headers\": \"Content-Type\" &#125;); // 第二步：将请求转发给服务器 const proxyRequest = http .request( &#123; host: \"127.0.0.1\", port: 4000, url: \"/\", method: request.method, headers: request.headers &#125;, serverResponse =&gt; &#123; // 第三步：收到服务器的响应 var body = \"\"; serverResponse.on(\"data\", chunk =&gt; &#123; body += chunk; &#125;); serverResponse.on(\"end\", () =&gt; &#123; console.log(\"The data is \" + body); // 第四步：将响应结果转发给浏览器 response.end(body); &#125;); &#125; ) .end();&#125;);server.listen(3000, () =&gt; &#123; console.log(\"The proxyServer is running at http://localhost:3000\");&#125;); 1234567891011// server2.js(http://localhost:4000)const http = require(\"http\");const data = &#123; title: \"fontend\", password: \"123456\" &#125;;const server = http.createServer((request, response) =&gt; &#123; if (request.url === \"/\") &#123; response.end(JSON.stringify(data)); &#125;&#125;);server.listen(4000, () =&gt; &#123; console.log(\"The server is running at http://localhost:4000\");&#125;); nginx 反向代理实现原理类似于 Node 中间件代理，需要你搭建一个中转 nginx 服务器，用于转发请求。 使用 nginx 反向代理实现跨域，是最简单的跨域方式。只需要修改 nginx 的配置即可解决跨域问题，支持所有浏览器，支持 session，不需要修改任何代码，并且不会影响服务器性能。 实现思路：通过 nginx 配置一个代理服务器（域名与 domain1 相同，端口不同）做跳板机，反向代理访问 domain2 接口，并且可以顺便修改 cookie 中 domain 信息，方便当前域 cookie 写入，实现跨域登录。 先下载 nginx，然后将 nginx 目录下的 nginx.conf 修改，最后通过命令行 nginx -s reload 启动 nginx window.name + iframewindow.name 属性的独特之处：name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。其中 a.html 和 b.html 是同域的，都是http://localhost:3000;而c.html是http://localhost:4000 12345678910111213141516171819202122// a.html(http://localhost:3000/b.html)&lt;iframe src=\"http://localhost:4000/c.html\" frameborder=\"0\" onload=\"load()\" id=\"iframe\"&gt;&lt;/iframe&gt;&lt;script&gt; let first = true; // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name function load() &#123; if (first) &#123; // 第1次onload(跨域页)成功后，切换到同域代理页面 let iframe = document.getElementById(\"iframe\"); iframe.src = \"http://localhost:3000/b.html\"; first = false; &#125; else &#123; // 第2次onload(同域b.html页)成功后，读取同域window.name中数据 console.log(iframe.contentWindow.name); &#125; &#125;&lt;/script&gt; b.html 为中间代理页，与 a.html 同域，内容为空。 1234// c.html(http://localhost:4000/c.html)&lt;script&gt; window.name = \"我不爱你\";&lt;/script&gt; 通过 iframe 的 src 属性由外域转向本地域，跨域数据即由 iframe 的 window.name 从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。 location.hash + iframe实现原理： a.html 欲与 c.html 跨域相互通信，通过中间页 b.html 来实现。 三个页面，不同域之间利用 iframe 的 location.hash 传值，相同域之间直接 js 访问来通信。 具体实现步骤：一开始 a.html 给 c.html 传一个 hash 值，然后 c.html 收到 hash 值后，再把 hash 值传递给 b.html，最后 b.html 将结果放到 a.html 的 hash 值中。 12345678// a.html&lt;iframe src=\"http://localhost:4000/c.html#iloveyou\"&gt;&lt;/iframe&gt;&lt;script&gt; window.onhashchange = function() &#123; //检测hash的变化 console.log(location.hash); &#125;;&lt;/script&gt; 12345// b.html&lt;script&gt; window.parent.parent.location.hash = location.hash; //b.html将结果放到a.html的hash值中，b.html可通过parent.parent访问a.html页面&lt;/script&gt; 12345// c.htmlconsole.log(location.hash);let iframe = document.createElement(\"iframe\");iframe.src = \"http://localhost:3000/b.html#idontloveyou\";document.body.appendChild(iframe); document.domain + iframe该方式只能用于二级域名相同的情况下，比如 a.test.com 和 b.test.com 适用于该方式。只需要给页面添加 document.domain =’test.com’ 表示二级域名都相同就可以实现跨域。实现原理：两个页面都通过 js 强制设置 document.domain 为基础主域，就实现了同域。 12345678910111213141516// a.zf1.cn:3000/a.html&lt;body&gt; helloa &lt;iframe src=\"http://b.zf1.cn:3000/b.html\" frameborder=\"0\" onload=\"load()\" id=\"frame\" &gt;&lt;/iframe&gt; &lt;script&gt; document.domain = \"zf1.cn\"; function load() &#123; console.log(frame.contentWindow.a); &#125; &lt;/script&gt;&lt;/body&gt; 12345678// b.zf1.cn:3000/b.html&lt;body&gt; hellob &lt;script&gt; document.domain = \"zf1.cn\"; var a = 100; &lt;/script&gt;&lt;/body&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"树的diff算法（vue 2.0）","slug":"树的diff算法（vue 2.0）","date":"2019-02-25T16:26:33.000Z","updated":"2019-08-15T17:55:59.934Z","comments":true,"path":"2019/02/26/树的diff算法（vue 2.0）/","link":"","permalink":"http://yoursite.com/2019/02/26/树的diff算法（vue 2.0）/","excerpt":"树的 diff 算法（vue 2.0）模板转换成视图的过程 Vue.js 通过编译将 template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树 在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。 简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。","text":"树的 diff 算法（vue 2.0）模板转换成视图的过程 Vue.js 通过编译将 template 模板转换成渲染函数(render ) ，执行渲染函数就可以得到一个虚拟节点树 在对 Model 进行操作的时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。这个过程主要是将新旧虚拟节点进行差异对比，然后根据对比结果进行 DOM 操作来更新视图。 简单点讲，在 Vue 的底层实现上，Vue 将模板编译成虚拟 DOM 渲染函数。结合 Vue 自带的响应系统，在状态改变时，Vue 能够智能地计算出重新渲染组件的最小代价并应到 DOM 操作上。 渲染函数：渲染函数是用来生成 Virtual DOM 的。Vue 推荐使用模板来构建我们的应用界面，在底层实现中 Vue 会将模板编译成渲染函数，当然我们也可以不写模板，直接写渲染函数，以获得更好的控制。 VNode 虚拟节点：它可以代表一个真实的 dom 节点。通过 createElement 方法能将 VNode 渲染成 dom 节点。简单地说，vnode 可以理解成节点描述对象，它描述了应该怎样去创建真实的 DOM 节点。 patch(也叫做 patching 算法)：虚拟 DOM 最核心的部分，它可以将 vnode 渲染成真实的 DOM，这个过程是对比新旧虚拟节点之间有哪些不同，然后根据对比结果找出需要更新的的节点进行更新。这点我们从单词含义就可以看出， patch 本身就有补丁、修补的意思，其实际作用是在现有 DOM 上进行修改来实现更新视图的目的。Vue 的 Virtual DOM Patching 算法是基于Snabbdom的实现，并在些基础上作了很多的调整和改进。 Virtual DOM 是什么？Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。 简单来说，可以把 Virtual DOM 理解为一个简单的 JS 对象，并且最少包含标签名( tag)、属性(attrs)和子元素对象( children)三个属性。不同的框架对这三个属性的命名会有点差别。 对于虚拟 DOM，咱们来看一个简单的实例，就是下图所示的这个，详细的阐述了模板 → 渲染函数 → 虚拟DOM树 → 真实DOM的一个过程 Virtual DOM 作用是什么？虚拟 DOM 的最终目标是将虚拟节点渲染到视图上。但是如果直接使用虚拟节点覆盖旧节点的话，会有很多不必要的 DOM 操作。例如，一个 ul 标签下很多个 li 标签，其中只有一个 li 有变化，这种情况下如果使用新的 ul 去替代旧的 ul,因为这些不必要的 DOM 操作而造成了性能上的浪费。 为了避免不必要的 DOM 操作，虚拟 DOM 在虚拟节点映射到视图的过程中，将虚拟节点与上一次渲染视图所使用的旧虚拟节点（oldVnode）做对比，找出真正需要更新的节点来进行 DOM 操作，从而避免操作其他无需改动的 DOM。 其实虚拟 DOM 在 Vue.js 主要做了两件事： 提供与真实 DOM 节点所对应的虚拟节点 vnode 将虚拟节点 vnode 和旧虚拟节点 oldVnode 进行对比，然后更新视图 为何需要 Virtual DOM？ 具备跨平台的优势 由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 操作 DOM 慢，js 运行效率高。我们可以将 DOM 对比操作放在 JS 层，提高效率。 因为 DOM 操作的执行速度远不如 Javascript 的运算速度快，因此，把大量的 DOM 操作搬运到 Javascript 中，运用 patching 算法来计算出真正需要更新的节点，最大限度地减少 DOM 操作，从而显著提高性能。 Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM） 提升渲染性能 Virtual DOM 的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新。 为了实现高效的 DOM 操作，一套高效的虚拟 DOM diff 算法显得很有必要。我们通过 patch 的核心—-diff 算法，找出本次 DOM 需要更新的节点来更新，其他的不更新。 VNode抽象 Dom 树把真实 Dom 树抽象成一棵以 javascript 对象构成的抽象树，在修改抽象树数据后将抽象树转化成真实 Dom 重绘到页面上呢？于是虚拟 Dom 出现了，它是真实 Dom 的一层抽象，用属性描述真实 Dom 的各个特性。当它发生变化的时候，就会去修改视图。 但是这样的 javascript 操作 Dom 进行重绘整个视图层是相当消耗性能的，我们是不是可以每次只更新它的修改呢？所以 Vue.js 将 Dom 抽象成一个以 javascript 对象为节点的虚拟 Dom 树，以 VNode 节点模拟真实 Dom，可以对这颗抽象树进行创建节点、删除节点以及修改节点等操作，在这过程中都不需要操作真实 Dom，只需要操作 javascript 对象，大大提升了性能。修改以后经过 diff 算法得出一些需要修改的最小单位，再将这些小单位的视图进行更新。这样做减少了很多不需要的 Dom 操作，大大提高了性能。 Vue 就使用了这样的抽象节点 VNode，它是对真实 Dom 的一层抽象，而不依赖某个平台，它可以是浏览器平台，也可以是 weex，甚至是 node 平台也可以对这样一棵抽象 Dom 树进行创建删除修改等操作，这也为前后端同构提供了可能。 VNode 基类先来看一下 Vue.js 源码中对 VNode 类的定义。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273export default class VNode &#123; tag: string | void; data: VNodeData | void; children: ?Array&lt;VNode&gt;; text: string | void; elm: Node | void; ns: string | void; context: Component | void; // rendered in this component's scope functionalContext: Component | void; // only for functional component root nodes key: string | number | void; componentOptions: VNodeComponentOptions | void; componentInstance: Component | void; // component instance parent: VNode | void; // component placeholder node raw: boolean; // contains raw HTML? (server only) isStatic: boolean; // hoisted static node isRootInsert: boolean; // necessary for enter transition check isComment: boolean; // empty comment placeholder? isCloned: boolean; // is a cloned node? isOnce: boolean; // is a v-once node? constructor( tag?: string, data?: VNodeData, children?: ?Array&lt;VNode&gt;, text?: string, elm?: Node, context?: Component, componentOptions?: VNodeComponentOptions ) &#123; /*当前节点的标签名*/ this.tag = tag; /*当前节点对应的对象，包含了具体的一些数据信息，是一个VNodeData类型，可以参考VNodeData类型中的数据信息*/ this.data = data; /*当前节点的子节点，是一个数组*/ this.children = children; /*当前节点的文本*/ this.text = text; /*当前虚拟节点对应的真实dom节点*/ this.elm = elm; /*当前节点的名字空间*/ this.ns = undefined; /*编译作用域*/ this.context = context; /*函数化组件作用域*/ this.functionalContext = undefined; /*节点的key属性，被当作节点的标志，用以优化*/ this.key = data &amp;&amp; data.key; /*组件的option选项*/ this.componentOptions = componentOptions; /*当前节点对应的组件的实例*/ this.componentInstance = undefined; /*当前节点的父节点*/ this.parent = undefined; /*简而言之就是是否为原生HTML或只是普通文本，innerHTML的时候为true，textContent的时候为false*/ this.raw = false; /*静态节点标志*/ this.isStatic = false; /*是否作为跟节点插入*/ this.isRootInsert = true; /*是否为注释节点*/ this.isComment = false; /*是否为克隆节点*/ this.isCloned = false; /*是否有v-once指令*/ this.isOnce = false; &#125; // DEPRECATED: alias for componentInstance for backwards compat. /* istanbul ignore next https://github.com/answershuto/learnVue*/ get child(): Component | void &#123; return this.componentInstance; &#125;&#125; 这是一个最基础的 VNode 节点，作为其他派生 VNode 类的基类，里面定义了下面这些数据。 tag: 当前节点的标签名 data: 当前节点对应的对象，包含了具体的一些数据信息，是一个 VNodeData 类型，可以参考 VNodeData 类型中的数据信息 children: 当前节点的子节点，是一个数组 text: 当前节点的文本 elm: 当前虚拟节点对应的真实 dom 节点 ns: 当前节点的名字空间 context: 当前节点的编译作用域 functionalContext: 函数化组件作用域 key: 节点的 key 属性，被当作节点的标志，用以优化 componentOptions: 组件的 option 选项 componentInstance: 当前节点对应的组件的实例 parent: 当前节点的父节点 raw: 简而言之就是是否为原生 HTML 或只是普通文本，innerHTML 的时候为 true，textContent 的时候为 false isStatic: 是否为静态节点 isRootInsert: 是否作为跟节点插入 isComment: 是否为注释节点 isCloned: 是否为克隆节点 isOnce: 是否有 v-once 指令 打个比方，比如说我现在有这么一个 VNode 树 123456789101112131415&#123; tag: 'div' data: &#123; class: 'test' &#125;, children: [ &#123; tag: 'span', data: &#123; class: 'demo' &#125; text: 'hello,VNode' &#125; ]&#125; 渲染之后的结果就是这样的 123&lt;div class=\"test\"&gt; &lt;span class=\"demo\"&gt;hello,VNode&lt;/span&gt;&lt;/div&gt; 生成一个新的 VNode 的方法下面这些方法都是一些常用的构造 VNode 的方法。 createEmptyVNode 创建一个空 VNode 节点 1234567/*创建一个空VNode节点*/export const createEmptyVNode = () =&gt; &#123; const node = new VNode(); node.text = \"\"; node.isComment = true; return node;&#125;; createTextVNode 创建一个文本节点 1234/*创建一个文本节点*/export function createTextVNode(val: string | number) &#123; return new VNode(undefined, undefined, undefined, String(val));&#125; createComponent 创建一个组件节点 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071 // plain options object: turn it into a constructor https://github.com/answershuto/learnVue if (isObject(Ctor)) &#123; Ctor = baseCtor.extend(Ctor) &#125; // if at this stage it's not a constructor or an async component factory, // reject. /*Github:https://github.com/answershuto*/ /*如果在该阶段Ctor依然不是一个构造函数或者是一个异步组件工厂则直接返回*/ if (typeof Ctor !== 'function') &#123; if (process.env.NODE_ENV !== 'production') &#123; warn(`Invalid Component definition: $&#123;String(Ctor)&#125;`, context) &#125; return &#125; // async component /*处理异步组件*/ if (isUndef(Ctor.cid)) &#123; Ctor = resolveAsyncComponent(Ctor, baseCtor, context) if (Ctor === undefined) &#123; // return nothing if this is indeed an async component // wait for the callback to trigger parent update. /*如果这是一个异步组件则会不会返回任何东西（undifiened），直接return掉，等待回调函数去触发父组件更新。s*/ return &#125; &#125; // resolve constructor options in case global mixins are applied after // component constructor creation resolveConstructorOptions(Ctor) data = data || &#123;&#125; // transform component v-model data into props &amp; events if (isDef(data.model)) &#123; transformModel(Ctor.options, data) &#125; // extract props const propsData = extractPropsFromVNodeData(data, Ctor, tag) // functional component if (isTrue(Ctor.options.functional)) &#123; return createFunctionalComponent(Ctor, propsData, data, context, children) &#125; // extract listeners, since these needs to be treated as // child component listeners instead of DOM listeners const listeners = data.on // replace with listeners with .native modifier data.on = data.nativeOn if (isTrue(Ctor.options.abstract)) &#123; // abstract components do not keep anything // other than props &amp; listeners data = &#123;&#125; &#125; // merge component management hooks onto the placeholder node mergeHooks(data) // return a placeholder vnode const name = Ctor.options.name || tag const vnode = new VNode( `vue-component-$&#123;Ctor.cid&#125;$&#123;name ? `-$&#123;name&#125;` : ''&#125;`, data, undefined, undefined, undefined, context, &#123; Ctor, propsData, listeners, tag, children &#125; ) return vnode&#125; cloneVNode 克隆一个 VNode 节点 12345678910111213141516export function cloneVNode(vnode: VNode): VNode &#123; const cloned = new VNode( vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, vnode.componentOptions ); cloned.ns = vnode.ns; cloned.isStatic = vnode.isStatic; cloned.key = vnode.key; cloned.isCloned = true; return cloned;&#125; createElementcreateElement 用来创建一个虚拟节点。当 data 上已经绑定ob的时候，代表该对象已经被 Oberver 过了，所以创建一个空节点。tag 不存在的时候同样创建一个空节点。当 tag 不是一个 String 类型的时候代表 tag 是一个组件的构造类，直接用 new VNode 创建。当 tag 是 String 类型的时候，如果是保留标签，则用 new VNode 创建一个 VNode 实例，如果在 vm 的 option 的 components 找得到该 tag，代表这是一个组件，否则统一用 new VNode 创建。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109// wrapper function for providing a more flexible interface// without getting yelled at by flowexport function createElement( context: Component, tag: any, data: any, children: any, normalizationType: any, alwaysNormalize: boolean): VNode &#123; /*兼容不传data的情况*/ if (Array.isArray(data) || isPrimitive(data)) &#123; normalizationType = children; children = data; data = undefined; &#125; /*如果alwaysNormalize为true，则normalizationType标记为ALWAYS_NORMALIZE*/ if (isTrue(alwaysNormalize)) &#123; normalizationType = ALWAYS_NORMALIZE; &#125; /*Github:https://github.com/answershuto*/ /*创建虚拟节点*/ return _createElement(context, tag, data, children, normalizationType);&#125;/*创建虚拟节点*/export function _createElement( context: Component, tag?: string | Class&lt;Component&gt; | Function | Object, data?: VNodeData, children?: any, normalizationType?: number): VNode &#123; /* 如果data未定义（undefined或者null）或者是data的__ob__已经定义（代表已经被observed，上面绑定了Oberver对象）， https://cn.vuejs.org/v2/guide/render-function.html#约束 那么创建一个空节点 */ if (isDef(data) &amp;&amp; isDef((data: any).__ob__)) &#123; process.env.NODE_ENV !== \"production\" &amp;&amp; warn( `Avoid using observed data object as vnode data: $&#123;JSON.stringify( data )&#125;\\n` + \"Always create fresh vnode data objects in each render!\", context ); return createEmptyVNode(); &#125; /*如果tag不存在也是创建一个空节点*/ if (!tag) &#123; // in case of component :is set to falsy value return createEmptyVNode(); &#125; // support single function children as default scoped slot /*默认默认作用域插槽*/ if (Array.isArray(children) &amp;&amp; typeof children[0] === \"function\") &#123; data = data || &#123;&#125;; data.scopedSlots = &#123; default: children[0] &#125;; children.length = 0; &#125; if (normalizationType === ALWAYS_NORMALIZE) &#123; children = normalizeChildren(children); &#125; else if (normalizationType === SIMPLE_NORMALIZE) &#123; children = simpleNormalizeChildren(children); &#125; let vnode, ns; if (typeof tag === \"string\") &#123; let Ctor; /*获取tag的名字空间*/ ns = config.getTagNamespace(tag); /*判断是否是保留的标签*/ if (config.isReservedTag(tag)) &#123; // platform built-in elements /*如果是保留的标签则创建一个相应节点*/ vnode = new VNode( config.parsePlatformTagName(tag), data, children, undefined, undefined, context ); &#125; else if ( isDef((Ctor = resolveAsset(context.$options, \"components\", tag))) ) &#123; // component /*从vm实例的option的components中寻找该tag，存在则就是一个组件，创建相应节点，Ctor为组件的构造类*/ vnode = createComponent(Ctor, data, context, children, tag); &#125; else &#123; // unknown or unlisted namespaced elements // check at runtime because it may get assigned a namespace when its // parent normalizes children /*未知的元素，在运行时检查，因为父组件可能在序列化子组件的时候分配一个名字空间*/ vnode = new VNode(tag, data, children, undefined, undefined, context); &#125; &#125; else &#123; // direct component options / constructor /*tag不是字符串的时候则是组件的构造类*/ vnode = createComponent(tag, data, context, children); &#125; if (isDef(vnode)) &#123; /*如果有名字空间，则递归所有子节点应用该名字空间*/ if (ns) applyNS(vnode, ns); return vnode; &#125; else &#123; /*如果vnode没有成功创建则创建空节点*/ return createEmptyVNode(); &#125;&#125; diff 概解1.当数据发生变化时，vue 是怎么更新节点的？周所周知，Vue 通过数据绑定来修改视图，当某个数据被修改的时候，set 方法会让闭包中的 Dep 调用 notify 通知所有订阅者 Watcher，Watcher 通过 get 方法执行 vm._update(vm._render(), hydrating)。 这里看一下_update 方法 1234567891011121314151617181920212223242526272829303132333435363738394041Vue.prototype._update = function (vnode: VNode, hydrating?: boolean) &#123; const vm: Component = this /*如果已经该组件已经挂载过了则代表进入这个步骤是个更新的过程，触发beforeUpdate钩子*/ if (vm._isMounted) &#123; callHook(vm, 'beforeUpdate') &#125; const prevEl = vm.$el const prevVnode = vm._vnode const prevActiveInstance = activeInstance activeInstance = vm vm._vnode = vnode // Vue.prototype.__patch__ is injected in entry points // based on the rendering backend used. /*基于后端渲染Vue.prototype.__patch__被用来作为一个入口*/ if (!prevVnode) &#123; // initial render vm.$el = vm.__patch__( vm.$el, vnode, hydrating, false /* removeOnly */, vm.$options._parentElm, vm.$options._refElm ) &#125; else &#123; // updates vm.$el = vm.__patch__(prevVnode, vnode) &#125; activeInstance = prevActiveInstance // update __vue__ reference /*更新新的实例对象的__vue__*/ if (prevEl) &#123; prevEl.__vue__ = null &#125; if (vm.$el) &#123; vm.$el.__vue__ = vm &#125; // if parent is an HOC, update its $el as well if (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123; vm.$parent.$el = vm.$el &#125; // updated hook is called by the scheduler to ensure that children are // updated in a parent's updated hook. &#125;复制代码 _update 方法的第一个参数是一个 VNode 对象，在内部会将该 VNode 对象与之前旧的 VNode 对象进行patch。 要知道渲染真实 DOM 的开销是很大的，比如有时候我们修改了某个数据，如果直接渲染到真实 dom 上会引起整个 dom 树的重绘和重排，有没有可能我们只更新我们修改的那一小块 dom 而不要更新整个 dom 呢？diff 算法能够帮助我们。 我们先根据真实 DOM 生成一颗virtual DOM，当virtual DOM某个节点的数据改变后会生成一个新的Vnode，然后Vnode和oldVnode作对比，发现有不一样的地方就直接修改在真实的 DOM 上，然后使oldVnode的值为Vnode。 diff 的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的 DOM打补丁。 2. virtual DOM 和真实 DOM 的区别？虚拟 dom 对应的是真实 dom， 使用document.CreateElement 和 document.CreateTextNode创建的就是真实节点。 virtual DOM 是将真实的 DOM 的数据抽取出来，以对象的形式模拟树形结构。比如 dom 是这样的： 123&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt; 对应的 virtual DOM（伪代码）： 1234var Vnode = &#123; tag: \"div\", children: [&#123; tag: \"p\", text: \"123\" &#125;]&#125;; （温馨提示：VNode和oldVNode都是对象，一定要记住） virtual dom 很多时候都不是最优的操作，但它具有普适性，在效率、可维护性之间达平衡。 3. diff 的比较方式？在采取 diff 算法比较新旧节点的时候，比较只会在同层级进行, 不会跨层级比较。 1234567&lt;div&gt; &lt;p&gt;123&lt;/p&gt;&lt;/div&gt;&lt;div&gt; &lt;span&gt;456&lt;/span&gt;&lt;/div&gt; 上面的代码会分别比较同一层的两个 div 以及第二层的 p 和 span，但是不会拿 div 和 span 作比较。在别处看到的一张很形象的图： diff 流程图当数据发生改变时，set 方法会让调用Dep.notify通知所有订阅者 Watcher，订阅者就会调用patch给真实的 DOM 打补丁，更新相应的视图。 diff 算法包括几个步骤： 用 JavaScript 对象结构表示 DOM 树的结构；然后用这个树构建一个真正的 DOM 树，插到文档当中 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异 把所记录的差异应用到所构建的真正的 DOM 树上，视图就更新了 diff 算法具体分析1. patch来看看patch是怎么打补丁的（代码只保留核心部分） 123456789101112131415161718function patch(oldVnode, vnode) &#123; // some code if (sameVnode(oldVnode, vnode)) &#123; patchVnode(oldVnode, vnode); &#125; else &#123; const oEl = oldVnode.el; // 当前oldVnode对应的真实元素节点 let parentEle = api.parentNode(oEl); // 父元素 createEle(vnode); // 根据Vnode生成新元素 if (parentEle !== null) &#123; api.insertBefore(parentEle, vnode.el, api.nextSibling(oEl)); // 将新元素添加进父元素 api.removeChild(parentEle, oldVnode.el); // 移除以前的旧元素节点 oldVnode = null; &#125; &#125; // some code return vnode;&#125;复制代码; patch 函数接收两个参数oldVnode和Vnode分别代表新的节点和之前的旧节点 判断两节点是否值得比较，值得比较则执行patchVnode 1234567891011function sameVnode(a, b) &#123; return ( a.key === b.key &amp;&amp; // key值 a.tag === b.tag &amp;&amp; // 标签名 a.isComment === b.isComment &amp;&amp; // 是否为注释节点 // 是否都定义了data，data包含一些具体信息，例如onclick , style isDef(a.data) === isDef(b.data) &amp;&amp; sameInputType(a, b) // 当标签是&lt;input&gt;的时候，type必须相同 );&#125;复制代码; 不值得比较则用Vnode替换oldVnode 如果两个节点都是一样的，那么就深入检查他们的子节点。如果两个节点不一样那就说明Vnode完全被改变了，就可以直接替换oldVnode。 虽然这两个节点不一样但是他们的子节点一样怎么办？别忘了，diff 可是逐层比较的，如果第一层不一样那么就不会继续深入比较第二层了。（我在想这算是一个缺点吗？相同子节点不能重复利用了…） 2. patchVnode当我们确定两个节点值得比较之后我们会对两个节点指定patchVnode方法。那么这个方法做了什么呢？ 123456789101112131415161718patchVnode (oldVnode, vnode) &#123; const el = vnode.el = oldVnode.el let i, oldCh = oldVnode.children, ch = vnode.children if (oldVnode === vnode) return if (oldVnode.text !== null &amp;&amp; vnode.text !== null &amp;&amp; oldVnode.text !== vnode.text) &#123; api.setTextContent(el, vnode.text) &#125;else &#123; updateEle(el, vnode, oldVnode) if (oldCh &amp;&amp; ch &amp;&amp; oldCh !== ch) &#123; updateChildren(el, oldCh, ch) &#125;else if (ch)&#123; createEle(vnode) //create el's children dom &#125;else if (oldCh)&#123; api.removeChildren(el) &#125; &#125;&#125;复制代码 这个函数做了以下事情： 找到对应的真实 dom，称为el 判断Vnode和oldVnode是否指向同一个对象，如果是，那么直接return 如果他们都有文本节点并且不相等，那么将el的文本节点设置为Vnode的文本节点。 如果oldVnode有子节点而Vnode没有，则删除el的子节点 如果oldVnode没有子节点而Vnode有，则将Vnode的子节点真实化之后添加到el 如果两者都有子节点，则执行updateChildren函数比较子节点，这一步很重要 其他几个点都很好理解，我们详细来讲一下 updateChildren 3. updateChildren代码量很大，不方便一行一行的讲解，所以下面结合一些示例图来描述一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0, newStartIdx = 0 let oldEndIdx = oldCh.length - 1 let oldStartVnode = oldCh[0] let oldEndVnode = oldCh[oldEndIdx] let newEndIdx = newCh.length - 1 let newStartVnode = newCh[0] let newEndVnode = newCh[newEndIdx] let oldKeyToIdx let idxInOld let elmToMove let before while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (oldStartVnode == null) &#123; // 对于vnode.key的比较，会把oldVnode = null oldStartVnode = oldCh[++oldStartIdx] &#125;else if (oldEndVnode == null) &#123; oldEndVnode = oldCh[--oldEndIdx] &#125;else if (newStartVnode == null) &#123; newStartVnode = newCh[++newStartIdx] &#125;else if (newEndVnode == null) &#123; newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode) oldStartVnode = oldCh[++oldStartIdx] newStartVnode = newCh[++newStartIdx] &#125;else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode) oldEndVnode = oldCh[--oldEndIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode) api.insertBefore(parentElm, oldStartVnode.el, api.nextSibling(oldEndVnode.el)) oldStartVnode = oldCh[++oldStartIdx] newEndVnode = newCh[--newEndIdx] &#125;else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode) api.insertBefore(parentElm, oldEndVnode.el, oldStartVnode.el) oldEndVnode = oldCh[--oldEndIdx] newStartVnode = newCh[++newStartIdx] &#125;else &#123; // 使用key时的比较 if (oldKeyToIdx === undefined) &#123; oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx) // 有key生成index表 &#125; idxInOld = oldKeyToIdx[newStartVnode.key] if (!idxInOld) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) newStartVnode = newCh[++newStartIdx] &#125; else &#123; elmToMove = oldCh[idxInOld] if (elmToMove.sel !== newStartVnode.sel) &#123; api.insertBefore(parentElm, createEle(newStartVnode).el, oldStartVnode.el) &#125;else &#123; patchVnode(elmToMove, newStartVnode) oldCh[idxInOld] = null api.insertBefore(parentElm, elmToMove.el, oldStartVnode.el) &#125; newStartVnode = newCh[++newStartIdx] &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].el addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx) &#125;else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx) &#125;&#125;复制代码 先说一下这个函数做了什么 将Vnode的子节点Vch和oldVnode的子节点oldCh提取出来 oldCh和vCh各有两个头尾的变量StartIdx和EndIdx，它们的 2 个变量相互比较，一共有 4 种比较方式。如果 4 种比较都没匹配，如果设置了key，就会用key进行比较，在比较的过程中，变量会往中间靠，一旦StartIdx&gt;EndIdx表明oldCh和vCh至少有一个已经遍历完了，就会结束比较。 图解 updateChildren终于来到了这一部分，上面的总结相信很多人也看得一脸懵逼，下面我们好好说道说道。 粉红色的部分为 oldCh、黄色的部分为 vCh 我们将它们取出来并分别用 s 和 e 指针指向它们的头 child 和尾 child 现在分别对oldS、oldE、S、E两两做sameVnode比较，有四种比较方式，当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，这句话有点绕，打个比方 如果是 oldS 和 E 匹配上了，那么真实 dom 中的第一个节点会移到最后 如果是 oldE 和 S 匹配上了，那么真实 dom 中的最后一个节点会移到最前，匹配上的两个指针向中间移动 如果四种匹配没有一对是成功的，分为两种情况 如果新旧子节点都存在 key，那么会根据oldChild的 key 生成一张 hash 表，用S的 key 与 hash 表做匹配，匹配成功就判断S和匹配节点是否为sameNode，如果是，就在真实 dom 中将成功的节点移到最前面，否则，将S生成对应的节点插入到 dom 中对应的oldS位置，oldS和S指针向中间移动。 如果没有 key,则直接将S生成新的节点插入真实DOM（ps：这下可以解释为什么 v-for 的时候需要设置 key 了，如果没有 key 那么就只会做四种匹配，就算指针中间有可复用的节点都不能被复用了） 再配个图（假设下图中的所有节点都是有 key 的，且 key 为自身的值） 第一步 12oldS = a, oldE = d；S = a, E = b; oldS和S匹配，则将 dom 中的 a 节点放到第一个，已经是第一个了就不管了，此时 dom 的位置为：a b d 第二步 12oldS = b, oldE = d；S = c, E = b; oldS和E匹配，就将原本的 b 节点移动到最后，因为E是最后一个节点，他们位置要一致，这就是上面说的：当其中两个能匹配上那么真实 dom 中的相应节点会移到 Vnode 相应的位置，此时 dom 的位置为：a d b 第三步 12oldS = d, oldE = d；S = c, E = d; oldE和E匹配，位置不变此时 dom 的位置为：a d b 第四步 123oldS++;oldE--;oldS &gt; oldE; 遍历结束，说明oldCh先遍历完。就将剩余的vCh节点根据自己的的 index 插入到真实 dom 中去，此时 dom 位置为：a c d b 一次模拟完成。 这个匹配过程的结束有两个条件： oldS &gt; oldE表示oldCh先遍历完，那么就将多余的vCh根据 index 添加到 dom 中去（如上图） S &gt; E表示 vCh 先遍历完，那么就在真实 dom 中将区间为[oldS, oldE]的多余节点删掉 下面再举一个例子，可以像上面那样自己试着模拟一下 当这些节点sameVnode成功后就会紧接着执行patchVnode了，可以看一下上面的代码 123if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode);&#125; 就这样层层递归下去，直到将 oldVnode 和 Vnode 中的所有子节点比对完。也将 dom 的所有补丁都打好啦。那么现在再回过去看 updateChildren 的代码会不会容易很多呢？ 4. 操作 dom这里我们只是将虚拟 DOM 映射成了真实的 DOM。那如何给这些 DOM 加入 attr、class、style 等 DOM 属性呢？ 这要依赖于虚拟 DOM 的生命钩子。虚拟 DOM 提供了如下的钩子函数，分别在不同的时期会进行调用。 1234567891011const hooks = [\"create\", \"activate\", \"update\", \"remove\", \"destroy\"];/*构建cbs回调函数，web平台上见/platforms/web/runtime/modules*/for (i = 0; i &lt; hooks.length; ++i) &#123; cbs[hooks[i]] = []; for (j = 0; j &lt; modules.length; ++j) &#123; if (isDef(modules[j][hooks[i]])) &#123; cbs[hooks[i]].push(modules[j][hooks[i]]); &#125; &#125;&#125; 同理，也会根据不同平台有自己不同的实现，我们这里以 Web 平台为例。Web 平台的钩子函数见/platforms/web/runtime/modules。里面有对 attr、class、props、events、style 以及 transition（过渡状态）的 DOM 属性进行操作。 以 attr 为例，代码很简单。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192/* @flow */import &#123; isIE9 &#125; from \"core/util/env\";import &#123; extend, isDef, isUndef &#125; from \"shared/util\";import &#123; isXlink, xlinkNS, getXlinkProp, isBooleanAttr, isEnumeratedAttr, isFalsyAttrValue&#125; from \"web/util/index\";/*更新attr*/function updateAttrs(oldVnode: VNodeWithData, vnode: VNodeWithData) &#123; /*如果旧的以及新的VNode节点均没有attr属性，则直接返回*/ if (isUndef(oldVnode.data.attrs) &amp;&amp; isUndef(vnode.data.attrs)) &#123; return; &#125; let key, cur, old; /*VNode节点对应的Dom实例*/ const elm = vnode.elm; /*旧VNode节点的attr*/ const oldAttrs = oldVnode.data.attrs || &#123;&#125;; /*新VNode节点的attr*/ let attrs: any = vnode.data.attrs || &#123;&#125;; // clone observed objects, as the user probably wants to mutate it /*如果新的VNode的attr已经有__ob__（代表已经被Observe处理过了）， 进行深拷贝*/ if (isDef(attrs.__ob__)) &#123; attrs = vnode.data.attrs = extend(&#123;&#125;, attrs); &#125; /*遍历attr，不一致则替换*/ for (key in attrs) &#123; cur = attrs[key]; old = oldAttrs[key]; if (old !== cur) &#123; setAttr(elm, key, cur); &#125; &#125; // #4391: in IE9, setting type can reset value for input[type=radio] /* istanbul ignore if */ if (isIE9 &amp;&amp; attrs.value !== oldAttrs.value) &#123; setAttr(elm, \"value\", attrs.value); &#125; for (key in oldAttrs) &#123; if (isUndef(attrs[key])) &#123; if (isXlink(key)) &#123; elm.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else if (!isEnumeratedAttr(key)) &#123; elm.removeAttribute(key); &#125; &#125; &#125;&#125;/*设置attr*/function setAttr(el: Element, key: string, value: any) &#123; if (isBooleanAttr(key)) &#123; // set attribute for blank value // e.g. &lt;option disabled&gt;Select one&lt;/option&gt; if (isFalsyAttrValue(value)) &#123; el.removeAttribute(key); &#125; else &#123; el.setAttribute(key, key); &#125; &#125; else if (isEnumeratedAttr(key)) &#123; el.setAttribute( key, isFalsyAttrValue(value) || value === \"false\" ? \"false\" : \"true\" ); &#125; else if (isXlink(key)) &#123; if (isFalsyAttrValue(value)) &#123; el.removeAttributeNS(xlinkNS, getXlinkProp(key)); &#125; else &#123; el.setAttributeNS(xlinkNS, key, value); &#125; &#125; else &#123; if (isFalsyAttrValue(value)) &#123; el.removeAttribute(key); &#125; else &#123; el.setAttribute(key, value); &#125; &#125;&#125;export default &#123; create: updateAttrs, update: updateAttrs&#125;; attr 只需要在 create 以及 update 钩子被调用时更新 DOM 的 attr 属性即可。","categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]},{"title":"leetcode算法刷题笔记（三）——排序","slug":"leetcode算法刷题笔记（三）——排序","date":"2019-02-22T06:54:39.000Z","updated":"2019-04-28T15:24:34.809Z","comments":true,"path":"2019/02/22/leetcode算法刷题笔记（三）——排序/","link":"","permalink":"http://yoursite.com/2019/02/22/leetcode算法刷题笔记（三）——排序/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [56] Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.难度：Medium (34.95%)思路： 首先按 start 升序或按 end 升序排列 如果前一项的 end 大于后一项的 start，说明要 merge 因为已经做了升序排列，所以要 push 进结果的那一项的 start 一定为前一项的 start，而 end 为两项中 end 较大的那个值。","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [56] Merge IntervalsGiven a collection of intervals, merge all overlapping intervals.难度：Medium (34.95%)思路： 首先按 start 升序或按 end 升序排列 如果前一项的 end 大于后一项的 start，说明要 merge 因为已经做了升序排列，所以要 push 进结果的那一项的 start 一定为前一项的 start，而 end 为两项中 end 较大的那个值。 12345678910111213141516171819202122var merge = function(intervals) &#123; var res = []; if (intervals.length == 0) &#123; return res; &#125; intervals.sort(function(a, b) &#123; return a.start !== b.start ? a.start - b.start : a.end - b.end; &#125;); var pre = intervals[0]; res.push(pre); for (var cur of intervals) &#123; if (pre.end &gt;= cur.start) &#123; if (cur.end &gt; pre.end) &#123; pre.end = cur.end; &#125; &#125; else &#123; res.push(cur); pre = cur; &#125; &#125; return res;&#125;; [75] Sort ColorsGiven an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.Note: You are not suppose to use the library’s sort function for this problem.难度：Medium (41.44%)思路：遇到 0 放在最前面，遇到 2 放在最后面，1 不动 i 从 0 开始，如果 nums[i]等于 1，则 i++。 如果 nums[i]等于 0，则把 nums[i]放到最前面 如果 nums[i]等于 2，则把 nums[i]放到最后面 1234567891011121314151617181920212223242526var sortColors = function(nums) &#123; if (nums.length == 0) &#123; return -1; &#125; var i = 0; var m = 0; var n = nums.length - 1; var temp; while (i &lt;= n) &#123; if (nums[i] == 1) &#123; i++; &#125; else if (nums[i] == 0) &#123; temp = nums[m]; nums[m] = nums[i]; nums[i] = temp; m++; i++; &#125; else &#123; temp = nums[n]; nums[n] = nums[i]; nums[i] = temp; n--; &#125; &#125; return nums;&#125;; [147] Insertion Sort ListSort a linked list using insertion sort.A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list.Algorithm of Insertion Sort:Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list. At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there. It repeats until no input elements remain.难度：Medium (36.50%)思路：新开辟一个空链表，作为以排序区域，每次拿出 head 来，与以排序区域的链表的 val 进行比较，找到插入位置，插入。则未排序区域的了链表长度减一。 123456789101112131415var insertionSortList = function(head) &#123; var current = &#123; val: -Number.MAX_VALUE, next: null &#125;; while (head) &#123; var prev = current; while (prev.next &amp;&amp; prev.next.val &lt; head.val) &#123; prev = prev.next; &#125; var next = head.next; head.next = prev.next; prev.next = head; head = next; &#125; return current.next;&#125;; [148] Sort ListSort a linked list in O(n log n) time using constant space complexity.难度：Medium (34.12%)思路：归并排序的链表实现 123456789101112131415161718192021222324252627282930313233343536373839404142var sortList = function(head) &#123; if (head == null || head.next == null) &#123; return head; &#125; var fast = head; var slow = head; var pre = null; while (fast &amp;&amp; fast.next != null) &#123; pre = slow; slow = slow.next; fast = fast.next.next; &#125; pre.next = null; return merge(sortList(head), sortList(slow));&#125;;function merge(left, right) &#123; var result = &#123;&#125;; var pre = result; while (left &amp;&amp; right) &#123; if (left.val &lt; right.val) &#123; pre.next = left; pre = pre.next; left = left.next; &#125; else &#123; pre.next = right; pre = pre.next; right = right.next; &#125; &#125; while (left) &#123; pre.next = left; pre = pre.next; left = left.next; &#125; while (right) &#123; pre.next = right; pre = pre.next; right = right.next; &#125; return result.next;&#125; [179] Largest NumberGiven a list of non negative integers, arrange them such that they form the largest number.难度：Medium (25.32%) 12345678910111213var largestNumber = function(nums) &#123; nums.sort(function(a, b) &#123; var ab = a.toString() + b.toString(); var ba = b.toString() + a.toString(); return ba - ab; &#125;); var result = nums.join(\"\"); if (parseInt(result) == 0) &#123; return \"0\"; &#125; else &#123; return result; &#125;&#125;; [242] Valid AnagramGiven two strings s and t , write a function to determine if t is an anagram of s.Note: You may assume the string contains only lowercase alphabets.难度：Easy (51.12%) 1234567891011121314151617var isAnagram = function(s, t) &#123; if (s.length != = t.length) &#123; return false; &#125; var res = new Array(26); res.fill(0); for (var i = 0; i &lt; s.length; i++) &#123; res[s.codePointAt(i) - 97]++; res[t.codePointAt(i) - 97]--; &#125; for (var i = 0; i &lt; res.length; i++) &#123; if (res[i] !== 0) &#123; return false; &#125; &#125; return true;&#125;; [274] H-IndexGiven an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”难度：Medium (34.43%)思路：一个人在其所有学术文章中有 N 篇论文分别被引用了至少 N 次，他的 H 指数就是 N。根据这个规则，首先讲数组倒序排列，判断数组中的第 i 个，是否大于等于 i+1，如果成立，则代表，至少有 i+1 篇文章，被引用了 i+1 次，则他的 h-index 就是 i+1. 12345678910111213141516var hIndex = function(citations) &#123; if (citations.length == 0) &#123; return 0; &#125; citations.sort((a, b) =&gt; b - a); var res = citations.length; for (var i = citations.length - 1; i &gt;= 0; i--) &#123; if (citations[i] &gt;= res) &#123; return res; &#125; res--; &#125; if (res == 0) &#123; return 0; &#125;&#125;; [324] Wiggle Sort IIGiven an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]….难度：Medium (27.54%)思路：将数组正序排序之后，从中间分为两个数组，每次从小数组里拿一个数，从大数组里拿一个数，组成的 新数组就是一个数大一个数小的状态。 12345678910111213141516171819202122232425262728var wiggleSort = function(nums) &#123; if (nums.length &lt;= 1) &#123; return nums; &#125; nums = nums.sort((a, b) =&gt; a - b); var mid = Math.floor((nums.length + 1) / 2); var small = nums.slice(0, mid); var big = nums.slice(mid); if (big.length &gt; small.length) &#123; return []; &#125; var i = 0; var j = small.length - 1; var k = big.length - 1; while (i &lt; nums.length &amp;&amp; j &gt;= 0 &amp;&amp; k &gt;= 0) &#123; nums[i] = small[j]; nums[i + 1] = big[k]; i = i + 2; j--; k--; &#125; while (i &lt; nums.length &amp;&amp; j &gt;= 0) &#123; nums[i] = small[j]; i++; j--; &#125; return nums;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"排序","slug":"排序","permalink":"http://yoursite.com/tags/排序/"}]},{"title":"前端路由","slug":"前端路由","date":"2019-01-28T12:56:32.000Z","updated":"2019-08-15T10:31:34.491Z","comments":true,"path":"2019/01/28/前端路由/","link":"","permalink":"http://yoursite.com/2019/01/28/前端路由/","excerpt":"前端路由1.什么是前端路由对于用户来说，路由就是浏览器地址栏中的 url 与所见网页的对应关系。而对于 web 开发人员来说，路由更像是 url 与处理函数的对应关系。 传统的服务端路由，根据客户端请求的不同网址，返回不同的网页内容，这种情况一是会造成服务器压力增加，二是每次都重新请求，响应较慢、用户体验下降。于是，单页应用（spa,single page application）应运而生。在 url 地址改变的过程中，通过 js 来实现不同 UI 之间的切换（js 对 DOM 的操作），而不再向服务器重新请求页面，只通过 ajax 向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。其中，根据 url 地址栏的变化而展示不同的 UI，就是通过前端路由来实现的。目前主流的支持单页应用的前端框架，基本都有配套的或第三方的路由系统。","text":"前端路由1.什么是前端路由对于用户来说，路由就是浏览器地址栏中的 url 与所见网页的对应关系。而对于 web 开发人员来说，路由更像是 url 与处理函数的对应关系。 传统的服务端路由，根据客户端请求的不同网址，返回不同的网页内容，这种情况一是会造成服务器压力增加，二是每次都重新请求，响应较慢、用户体验下降。于是，单页应用（spa,single page application）应运而生。在 url 地址改变的过程中，通过 js 来实现不同 UI 之间的切换（js 对 DOM 的操作），而不再向服务器重新请求页面，只通过 ajax 向服务端请求数据，对用户来说这种无刷新的、即时响应是更好的体验。其中，根据 url 地址栏的变化而展示不同的 UI，就是通过前端路由来实现的。目前主流的支持单页应用的前端框架，基本都有配套的或第三方的路由系统。 2.前端路由的实现方式在 HTML5 的 history API 出现之前，前端路由主要是通过 hash 来实现的，hash 能兼容低版本的浏览器。下面分别来介绍这 2 种方式。 方法一：基于 hash（location.hash+hashchange 事件） 我们知道 location.hash 的值是 url 中#后面的内容，如http://www.163.com#netease此网址中，location.hash=’#netease’。 hash 满足以下几个特性，才使得其可以实现前端路由： url 中 hash 值的变化并不会重新加载页面，因为 hash 是用来指导浏览器行为的，对服务端是无用的，所以不会包括在 http 请求中。 hash 值的改变，都会在浏览器的访问历史中增加一个记录，也就是能通过浏览器的回退、前进按钮控制 hash 的切换 我们可以通过 hashchange 事件，监听到 hash 值的变化，从而响应不同路径的逻辑处理。 1window.addEventListener(\"hashchange\", funcRef, false); 如此一来，我们就可以在 hashchange 事件里，根据 hash 值来更新对应的视图，但不会去重新请求页面，同时呢，也在 history 里增加了一条访问记录，用户也仍然可以通过前进后退键实现 UI 的切换。 触发 hash 值的变化有 2 种方法:一种是通过 a 标签，设置 href 属性，当标签点击之后，地址栏会改变，同时会触发 hashchange 事件 1&lt;a href=\"#kaola\"&gt;to KAOLA&lt;/a&gt; 另一种是通过 js 直接赋值给 location.hash，也会改变 url，触发 hashchange 事件。 1location.hash = \"#kaola\"; 下面展示一个通过 hash 实现的简易 Router：123456789101112131415161718192021222324function Router() &#123; this.routes = &#123;&#125;; this.currentUrl = \"\";&#125;Router.prototype.route = function(path, callback) &#123; this.routes[path] = callback || function() &#123;&#125;;&#125;;Router.prototype.refresh = function() &#123; this.currentUrl = location.hash.slice(1) || \"/\"; this.routes[this.currentUrl]();&#125;;Router.prototype.init = function() &#123; window.addEventListener(\"load\", this.refresh.bind(this), false); window.addEventListener(\"hashchange\", this.refresh.bind(this), false);&#125;;window.Router = new Router();window.Router.init();// 添加路由规则Router.route(\"/\", function() &#123; // 设置响应内容&#125;);Router.route(\"/blue\", function() &#123; // 设置响应内容&#125;); 【route vs router】route 是一条路由，是将一个 URL 路径和一个处理函数相关联，是一条 url 和函数的映射规则，如上面代码中通过原型上的 route 可以设置一条路由规则，将一个 path 和其 callback 关联起来。 而 router 则更像是一个容器，或者说一种机制，它管理了一组 route。简单来说，route 只是进行了 URL 和函数的映射，而在当接收到一个 URL 之后，去路由映射表中查找相应的函数，这个过程是由 router 来处理的，如上面代码，Router 管理传入的 route，并且在 hash 改变的时候，根据当前的 url 响应其对应的函数。 方法二：基于 History 新 API（history.pushState()+popState 事件） HTML5 中 history 对象上新的 API，同样能实现前端的路由。通过 pushState()方法或 replaceState()方法可以修改 url 的地址，并在 popstate 事件中能监听地址的改变，不同的是，手动的进行 pushState()并不会触发 popstate 事件。 两个新增的 API：history.pushState 和 history.replaceState这两个 API 都接收三个参数： 1window.history.pushState(null, null, \"http://www.163.com\"); 状态对象（state object），一个 JavaScript 对象，与用 pushState()方法创建的新历史记录条目关联。无论何时用户导航到新创建的状态，会触发 popstate 事件，并能在事件中使用该对象。 标题（title） ：传入一个短标题给当前 state。现在大多数浏览器不支持或者会忽略此参数，最好传入 null 代替； 地址（URL）：新的历史记录条目的地址。浏览器不会在调用 pushState()方法后加载该地址，但之后，可能会试图加载，例如用户重启浏览器。新的 URL 不一定是绝对路径；如果是相对路径，它将以当前 URL 为基准；传入的 URL 与当前 URL 应该是同源的，否则，pushState()会抛出异常。该参数是可选的；不指定的话则为文档当前 URL。 这两个 API 的相同之处是都会操作浏览器的历史记录，而不会引起页面的刷新。不同之处在于，pushState 会增加一条新的历史记录，而 replaceState 则会替换当前的历史记录。这两个 api，加上 state 改变触发的 popstate 事件，提供了单页应该的另一种路由方式。 下面展示一个使用这种方式的简单 demo：12345678910111213141516171819202122232425&lt;p id=\"menu\"&gt; &lt;a href=\"/profile\" title=\"profile\"&gt;profile&lt;/a&gt; &lt;a href=\"/account\" title=\"account\"&gt;account&lt;/a&gt;?&lt;/p&gt;&lt;div class=\"main\" id=\"main\"&gt;&lt;/div&gt;&lt;script&gt; (function() &#123; var menubox = document.getElementById(\"menu\"); var mainbox = document.getElementById(\"main\"); menubox.addEventListener(\"click\", function(e) &#123; e.preventDefault(); var elm = e.target; var uri = elm.href; var tlt = elm.title; history.pushState(&#123; path: uri, title: tlt &#125;, null, uri); mainbox.innerHTML = \"current page is \" + tlt; &#125;); window.addEventListener(\"popstate\", function(e) &#123; var state = e.state; console.log(state); mainbox.innerHTML = \"current page is \" + state.title; // 还原UI &#125;); &#125;)();&lt;/script&gt; 当我们在历史记录中切换时就会触发 popstate 事件，可以在事件中还原当前 state 对应的 UI。对于触发 popstate 事件的方式，各浏览器实现也有差异，我们可以根据不同浏览器做兼容处理。 两种方式对比（History&amp;&amp;hash） 两种方式对比，基于 Hash 的路由，兼容性更好；基于 History API 的路由，则更正式，可以设置与当前 URL 同源的任意 URL，路径更直观。另外，基于 Hash 的路由不需要对服务器做改动，基于 History API 的路由需要对服务器做一些改造，配置不同的路由都返回相同的页面。 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。当从http://example.com/跳转到http://example.com/#/foobar或者http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问http://example.com/#/foobar的时候，实际上向服务器发起的请求是http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar的时候，实际上向服务器发起的请求也是http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于 History API 的路由，需要改造服务器端，使得访问/foobar 的时候也能返回 index.html 文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。 Vue Routervue-router 基本的路由配置如下： 123456789101112131415161718192021222324import Router from 'vue-router'import Index from 'pages/index'import Error from 'pages/error'Vue.use(Router)export default new Router(&#123; mode: 'history', // 设置路由方式 routes: [ &#123; path: '/', name: 'index', component: Index &#125;, &#123; path: '*', name: '404', component: Error &#125; ]&#125;)// 在组件中使用router视图组件&lt;router-view&gt;&lt;/router-view&gt; 可以通过 vue-router 实例来配置路由规则列表，指定路径 path 与组件 component 的对应关系。 1.模式参数在 vue-router 中是通过 mode 这一参数控制路由的实现模式的： 1234const router = new VueRouter(&#123; mode: 'history', routes: [...]&#125;) 创建 VueRouter 的实例对象时，mode 以构造函数参数的形式传入。从 VueRouter 类的定义入手。一般插件对外暴露的类都是定义在源码 src 根目录下的 index.js 文件中，打开该文件，可以看到 VueRouter 类的定义，摘录与 mode 参数有关的部分如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667export default class VueRouter &#123; mode: string; // 传入的字符串参数，指示history类别 history: HashHistory | HTML5History | AbstractHistory; // 实际起作用的对象属性，必须是以上三个类的枚举 fallback: boolean; // 如浏览器不支持，'history'模式需回滚为'hash'模式 constructor(options: RouterOptions = &#123;&#125;) &#123; let mode = options.mode || \"hash\"; // 默认为'hash'模式 this.fallback = mode === \"history\" &amp;&amp; !supportsPushState; // 通过supportsPushState判断浏览器是否支持'history'模式 if (this.fallback) &#123; mode = \"hash\"; &#125; if (!inBrowser) &#123; mode = \"abstract\"; // 不在浏览器环境下运行需强制为'abstract'模式 &#125; this.mode = mode; // 根据mode确定history实际的类并实例化 switch (mode) &#123; case \"history\": this.history = new HTML5History(this, options.base); break; case \"hash\": this.history = new HashHistory(this, options.base, this.fallback); break; case \"abstract\": this.history = new AbstractHistory(this, options.base); break; default: if (process.env.NODE_ENV !== \"production\") &#123; assert(false, `invalid mode: $&#123;mode&#125;`); &#125; &#125; &#125; init(app: any /* Vue component instance */) &#123; const history = this.history; // 根据history的类别执行相应的初始化操作和监听 if (history instanceof HTML5History) &#123; history.transitionTo(history.getCurrentLocation()); &#125; else if (history instanceof HashHistory) &#123; const setupHashListener = () =&gt; &#123; history.setupListeners(); &#125;; history.transitionTo( history.getCurrentLocation(), setupHashListener, setupHashListener ); &#125; history.listen(route =&gt; &#123; this.apps.forEach(app =&gt; &#123; app._route = route; &#125;); &#125;); &#125; // VueRouter类暴露的以下方法实际是调用具体history对象的方法 push(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.push(location, onComplete, onAbort); &#125; replace(location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.history.replace(location, onComplete, onAbort); &#125;&#125; 可以看出： 作为参数传入的字符串属性 mode 只是一个标记，用来指示实际起作用的对象属性 history 的实现类，两者对应关系如下： modehistory： ‘history’——HTML5History ‘hash’——HashHistory ‘abstract’——AbstractHistory 在初始化对应的 history 之前，会对 mode 做一些校验：若浏览器不支持 HTML5History 方式（通过 supportsPushState 变量判断），则 mode 强制设为’hash’；若不是在浏览器环境下运行，则 mode 强制设为’abstract’ VueRouter 类中的 onReady(), push()等方法只是一个代理，实际是调用的具体 history 对象的对应方法，在 init()方法中初始化时，也是根据 history 对象具体的类别执行不同操作 在浏览器环境下的两种方式，分别就是在 HTML5History，HashHistory 两个类中实现的。他们都定义在 src/history 文件夹下，继承自同目录下 base.js 文件中定义的 History 类。History 中定义的是公用和基础的方法，直接看会一头雾水，我们先从 HTML5History，HashHistory 两个类中看着亲切的 push(), replace()方法的说起。 2.HashHistory看源码前先回顾一下原理： hash（“#”）符号的本来作用是加在 URL 中指示网页中的位置： http://www.example.com/index.html#print #符号本身以及它后面的字符称之为 hash，可通过 window.location.hash 属性读取。它具有如下特点： hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中。它是用来指导浏览器动作的，对服务器端完全无用，因此，改变 hash 不会重新加载页面 可以为 hash 的改变添加监听事件： 1window.addEventListener(\"hashchange\", funcRef, false); 每一次改变 hash（window.location.hash），都会在浏览器的访问历史中增加一个记录 利用 hash 的以上特点，就可以来实现前端路由“更新视图但不重新请求页面”的功能了。 HashHistory.push()我们来看 HashHistory 中的 push()方法： 12345678910push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; pushHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;function pushHash (path) &#123; window.location.hash = path&#125; transitionTo()方法是父类中定义的是用来处理路由变化中的基础逻辑的，push()方法最主要的是对 window 的 hash 进行了直接赋值： 1window.location.hash = route.fullPath; hash 的改变会自动添加到浏览器的访问历史记录中。 那么视图的更新是怎么实现的呢，我们来看父类 History 中 transitionTo()方法的这么一段： 123456789101112131415transitionTo (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const route = this.router.match(location, this.current) this.confirmTransition(route, () =&gt; &#123; this.updateRoute(route) ... &#125;)&#125;updateRoute (route: Route) &#123; this.cb &amp;&amp; this.cb(route)&#125;listen (cb: Function) &#123; this.cb = cb&#125; 可以看到，当路由变化时，调用了 History 中的 this.cb 方法，而 this.cb 方法是通过 History.listen(cb)进行设置的。回到 VueRouter 类定义中，找到了在 init()方法中对其进行了设置： 12345678910init (app: any /* Vue component instance */) &#123; this.apps.push(app) history.listen(route =&gt; &#123; this.apps.forEach((app) =&gt; &#123; app._route = route &#125;) &#125;)&#125; 根据注释，app 为 Vue 组件实例，但我们知道 Vue 作为渐进式的前端框架，本身的组件定义中应该是没有有关路由内置属性_route，如果组件中要有这个属性，应该是在插件加载的地方，即 VueRouter 的 install()方法中混合入 Vue 对象的，查看 install.js 源码，有如下一段： 123456789101112export function install(Vue) &#123; Vue.mixin(&#123; beforeCreate() &#123; if (isDef(this.$options.router)) &#123; this._router = this.$options.router; this._router.init(this); Vue.util.defineReactive(this, \"_route\", this._router.history.current); &#125; registerInstance(this, this); &#125; &#125;);&#125; 通过 Vue.mixin()方法，全局注册一个混合，影响注册之后所有创建的每个 Vue 实例，该混合在 beforeCreate 钩子中通过 Vue.util.defineReactive()定义了响应式的_route 属性。所谓响应式属性，即当_route 值改变时，会自动调用 Vue 实例的 render()方法，更新视图。 总结一下，从设置路由改变到视图更新的流程如下：1$router.push() --&gt; HashHistory.push() --&gt; History.transitionTo() --&gt; History.updateRoute() --&gt; &#123;app._route = route&#125; --&gt; vm.render() HashHistory.replace()replace()方法与 push()方法不同之处在于，它并不是将新路由添加到浏览器访问历史的栈顶，而是替换掉当前的路由： 12345678910111213replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; this.transitionTo(location, route =&gt; &#123; replaceHash(route.fullPath) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;function replaceHash (path) &#123; const i = window.location.href.indexOf('#') window.location.replace( window.location.href.slice(0, i &gt;= 0 ? i : 0) + '#' + path )&#125; 可以看出，它与 push()的实现结构上基本相似，不同点在于它不是直接对 window.location.hash 进行赋值，而是调用 window.location.replace 方法将路由进行替换。 监听地址栏以上讨论的 VueRouter.push()和 VueRouter.replace()是可以在 vue 组件的逻辑代码中直接调用的，除此之外在浏览器中，用户还可以直接在浏览器地址栏中输入改变路由，因此 VueRouter 还需要能监听浏览器地址栏中路由的变化，并具有与通过代码调用相同的响应行为。在 HashHistory 中这一功能通过 setupListeners 实现： 12345678910setupListeners () &#123; window.addEventListener('hashchange', () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; this.transitionTo(getHash(), route =&gt; &#123; replaceHash(route.fullPath) &#125;) &#125;)&#125; 该方法设置监听了浏览器事件 hashchange，调用的函数为 replaceHash，即在浏览器地址栏中直接输入路由相当于代码调用了 replace()方法 3.HTML5HistoryHistory interface 是浏览器历史记录栈提供的接口，通过 back(), forward(), go()等方法，我们可以读取浏览器历史记录栈的信息，进行各种跳转操作。 从 HTML5 开始，History interface 提供了两个新的方法：pushState(), replaceState()使得我们可以对浏览器历史记录栈进行修改：12window.history.pushState(stateObject, title, URL);window.history.replaceState(stateObject, title, URL); stateObject: 当浏览器跳转到新的状态时，将触发 popState 事件，该事件将携带这个 stateObject 参数的副本 title: 所添加记录的标题 URL: 所添加记录的 URL 这两个方法有个共同的特点：当调用他们修改浏览器历史记录栈后，虽然当前 URL 改变了，但浏览器不会立即发送请求该 URL（the browser won’t attempt to load this URL after a call to pushState()），这就为单页应用前端路由“更新视图但不重新请求页面”提供了基础。 我们来看 vue-router 中的源码： 123456789101112131415161718192021222324252627282930313233343536373839push (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; pushState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;replace (location: RawLocation, onComplete?: Function, onAbort?: Function) &#123; const &#123; current: fromRoute &#125; = this this.transitionTo(location, route =&gt; &#123; replaceState(cleanPath(this.base + route.fullPath)) handleScroll(this.router, route, fromRoute, false) onComplete &amp;&amp; onComplete(route) &#125;, onAbort)&#125;// src/util/push-state.jsexport function pushState (url?: string, replace?: boolean) &#123; saveScrollPosition() // try...catch the pushState call to get around Safari // DOM Exception 18 where it limits to 100 pushState calls const history = window.history try &#123; if (replace) &#123; history.replaceState(&#123; key: _key &#125;, '', url) &#125; else &#123; _key = genKey() history.pushState(&#123; key: _key &#125;, '', url) &#125; &#125; catch (e) &#123; window.location[replace ? 'replace' : 'assign'](url) &#125;&#125;export function replaceState (url?: string) &#123; pushState(url, true)&#125; 代码结构以及更新视图的逻辑与 hash 模式基本类似，只不过将对 window.location.hash 直接进行赋值 window.location.replace()改为了调用 history.pushState()和 history.replaceState()方法。 在 HTML5History 中添加对修改浏览器地址栏 URL 的监听是直接在构造函数中执行的：1234567891011constructor (router: Router, base: ?string) &#123; window.addEventListener('popstate', e =&gt; &#123; const current = this.current this.transitionTo(getLocation(this.base), route =&gt; &#123; if (expectScroll) &#123; handleScroll(router, route, current, true) &#125; &#125;) &#125;)&#125; 当然了 HTML5History 用到了 HTML5 的新特特性，是需要特定浏览器版本的支持的，前文已经知道，浏览器是否支持是通过变量 supportsPushState 来检查的： 1234567891011121314151617// src/util/push-state.jsexport const supportsPushState = inBrowser &amp;&amp; (function() &#123; const ua = window.navigator.userAgent; if ( (ua.indexOf(\"Android 2.\") !== -1 || ua.indexOf(\"Android 4.0\") !== -1) &amp;&amp; ua.indexOf(\"Mobile Safari\") !== -1 &amp;&amp; ua.indexOf(\"Chrome\") === -1 &amp;&amp; ua.indexOf(\"Windows Phone\") === -1 ) &#123; return false; &#125; return window.history &amp;&amp; \"pushState\" in window.history; &#125;)(); 这两种模式都是通过浏览器接口实现的，除此之外 vue-router 还为非浏览器环境准备了一个 abstract 模式，其原理为用一个数组 stack 模拟出浏览器历史记录栈的功能。 4.vue 中两种模式比较在一般的需求场景中，hash 模式与 history 模式是差不多的，但几乎所有的文章都推荐使用 history 模式，理由竟然是：”#” 符号太丑…0_0 “ 如果不想要很丑的 hash，我们可以用路由的 history 模式 ——官方文档 当然，严谨的我们肯定不应该用颜值评价技术的好坏。根据 MDN 的介绍，调用 history.pushState()相比于直接修改 hash 主要有以下优势： pushState 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改#后面的部分，故只可设置与当前同文档的 URL pushState 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发记录添加到栈中 pushState 通过 stateObject 可以添加任意类型的数据到记录中；而 hash 只可添加短字符串 pushState 可额外设置 title 属性供后续使用 a 标签 hash 跳转，会改变页面路径的 hash 值，但不会重载 history 模式的一个问题 我们知道对于单页应用来讲，理想的使用场景是仅在进入应用时加载 index.html，后续在的网络操作通过 Ajax 完成，不会根据 URL 重新请求页面，但是难免遇到特殊情况，比如用户直接在地址栏中输入并回车，浏览器重启重新加载应用等。 hash 模式仅改变 hash 部分的内容，而 hash 部分是不会包含在 HTTP 请求中的： 1http://oursite.com/#/user/id // 如重新请求只会发送http://oursite.com/ 故在 hash 模式下遇到根据 URL 请求页面的情况不会有问题。 而 history 模式则会将 URL 修改得就和正常请求后端的 URL 一样 1http://oursite.com/user/id 在此情况下重新向后端发送请求，如后端没有配置对应/user/id 的路由处理，则会返回 404 错误。官方推荐的解决办法是在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。同时这么做以后，服务器就不再返回 404 错误页面，因为对于所有路径都会返回 index.html 文件。为了避免这种情况，在 Vue 应用里面覆盖所有的路由情况，然后在给出一个 404 页面。或者，如果是用 Node.js 作后台，可以使用服务端的路由来匹配 URL，当没有匹配到路由的时候返回 404，从而实现 fallback。 5.AbstractHistory‘abstract’模式，不涉及和浏览器地址的相关记录，流程跟’HashHistory’是一样的，其原理是通过数组模拟浏览器历史记录栈的功能 12345678910111213141516171819// 对于 go 的模拟 go (n: number) &#123; // 新的历史记录位置 const targetIndex = this.index + n // 超出返回了 if (targetIndex &lt; 0 || targetIndex &gt;= this.stack.length) &#123; return &#125; // 取得新的 route 对象 // 因为是和浏览器无关的 这里得到的一定是已经访问过的 const route = this.stack[targetIndex] // 所以这里直接调用 confirmTransition 了 // 而不是调用 transitionTo 还要走一遍 match 逻辑 this.confirmTransition(route, () =&gt; &#123; // 更新 this.index = targetIndex this.updateRoute(route) &#125;) &#125; 6.直接加载应用文件 Tip: built files are meant to be served over an HTTP server. Opening index.html over file:// won’t work. Vue 项目通过 vue-cli 的 webpack 打包完成后，命令行会有这么一段提示。通常情况，无论是开发还是线上，前端项目都是通过服务器访问，不存在 “Opening index.html over file://“ ，但程序员都知道，需求和场景永远是千奇百怪的，只有你想不到的，没有产品经理想不到的。 本文写作的初衷就是遇到了这样一个问题：需要快速开发一个移动端的展示项目，决定采用 WebView 加载 Vue 单页应用的形式，但没有后端服务器提供，所以所有资源需从本地文件系统加载： 123456789101112131415161718192021222324// AndroidAppWrapperpublic class MainActivity extends AppCompatActivity &#123; private WebView webView; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); webView = new WebView(this); webView.getSettings().setJavaScriptEnabled(true); webView.loadUrl(\"file:///android_asset/index.html\"); setContentView(webView); &#125; @Override public boolean onKeyDown(int keyCode, KeyEvent event) &#123; if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; webView.canGoBack()) &#123; webView.goBack(); return true; &#125; return false; &#125;&#125; 此情此景看来是必须 “Opening index.html over file://“ 了，为此，我首先要进行了一些设置 在项目 config.js 文件中将 assetsPublicPath 字段的值改为相对路径 ‘./‘ 调整生成的 static 文件夹中图片等静态资源的位置与代码中的引用地址一致 这是比较明显的需要改动之处，但改完后依旧无法顺利加载，经过反复排查发现，项目在开发时，router 设置为了 history 模式（为了美观…0_0”），当改为 hash 模式后就可正常加载了。 为什么会出现这种情况呢？我分析原因可能如下： 当从文件系统中直接加载 index.html 时，URL 为： 1file:///android_asset/index.html 而首页视图需匹配的路径为 path: ‘/‘ : 12345678910export default new Router(&#123; mode: \"history\", routes: [ &#123; path: \"/\", name: \"index\", component: IndexView &#125; ]&#125;); 我们先来看 history 模式，在 HTML5History 中： 1234567891011121314ensureURL (push?: boolean) &#123; if (getLocation(this.base) !== this.current.fullPath) &#123; const current = cleanPath(this.base + this.current.fullPath) push ? pushState(current) : replaceState(current) &#125;&#125;export function getLocation (base: string): string &#123; let path = window.location.pathname if (base &amp;&amp; path.indexOf(base) === 0) &#123; path = path.slice(base.length) &#125; return (path || '/') + window.location.search + window.location.hash&#125; 逻辑只会确保存在 URL，path 是通过剪切的方式直接从 window.location.pathname 获取到的，它的结尾是 index.html，因此匹配不到 ‘/‘ ，故 “Opening index.html over file:// won’t work” 。 再看 hash 模式，在 HashHistory 中： 123456789101112131415161718192021222324252627282930313233343536export class HashHistory extends History &#123; constructor (router: Router, base: ?string, fallback: boolean) &#123; ... ensureSlash() &#125; // this is delayed until the app mounts // to avoid the hashchange listener being fired too early setupListeners () &#123; window.addEventListener('hashchange', () =&gt; &#123; if (!ensureSlash()) &#123; return &#125; ... &#125;) &#125; getCurrentLocation () &#123; return getHash() &#125;&#125;function ensureSlash (): boolean &#123; const path = getHash() if (path.charAt(0) === '/') &#123; return true &#125; replaceHash('/' + path) return false&#125;export function getHash (): string &#123; const href = window.location.href const index = href.indexOf('#') return index === -1 ? '' : href.slice(index + 1)&#125; 我们看到在代码逻辑中，多次出现一个函数 ensureSlash()，当#符号后紧跟着的是’/‘，则返回 true，否则强行插入这个’/‘，故我们可以看到，即使是从文件系统打开 index.html，URL 依旧会变为以下形式： 1file:///C:/Users/dist/index.html#/ getHash()方法返回的 path 为 ‘/‘ ，可与首页视图的路由匹配。 故要想从文件系统直接加载 Vue 单页应用而不借助后端服务器，除了打包后的一些路径设置外，还需确保 vue-router 使用的是 hash 模式。 React Routerreact-router 是基于 history 模块提供的 api 进行开发的。其路由配置是通过 react component 方式进行的，路由更改触发的回调函数是我们自己写的操作 DOM 的函数；在 react 中我们不直接操作 DOM，而是管理抽象出来的 VDOM 或者说 JSX，对 react 的来说路由需要管理组件的生命周期，对不同的路由渲染不同的组件。 如下： 1234567891011121314render(( &lt;Router history=&#123;browserHistory&#125;&gt; &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt; &lt;Route path=&quot;about&quot; component=&#123;About&#125;/&gt; &lt;Route path=&quot;users&quot; component=&#123;Users&#125;&gt; &lt;Route path=&quot;/user/:userId&quot; component=&#123;User&#125;/&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; component=&#123;NoMatch&#125;/&gt; &lt;/Route&gt; &lt;/Router&gt;), document.body)// link 触发路由&lt;Link to=&#123;`/user/89757`&#125;&gt;&apos;joey&apos;&lt;/Link&gt; 以上声明了一份含有 path to component 的各个映射的路由表。Router 在 react 组件生命周期的钩子 componentWillMount （组件被挂载前）中，使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 会去 render 新的 component。 1.historyhistory 库，是 rr4 依赖的一个对 window.history 加强版的 history 库。 match源自 history 库，表示当前的 URL 与 path 的匹配的结果 123456match: &#123; path: &quot;/&quot;, // 用来匹配的 path url: &quot;/&quot;, // 当前的 URL params: &#123;&#125;, // 路径中的参数 isExact: pathname === &quot;/&quot; // 是否为严格匹配&#125; location还是源自 history 库，是 history 库基于 window.location 的一个衍生。 12345hash: &quot;&quot; // hashkey: &quot;nyi4ea&quot; // 一个 uuidpathname: &quot;/explore&quot; // URL 中路径部分search: &quot;&quot; // URL 参数state: undefined // 路由跳转时传递的 state 我们带着问题去分析源码，先逐个分析每个组件的作用，在最后会有回答，在这里先举一个 rr4 的小 DEMO 页面初始化时的渲染过程？ 点击一个 Link 跳转及渲染更新的过程？ 2.packagesrr4 将路由拆成了几个包： react-router 负责通用的路由逻辑 react-router-dom 负责浏览器的路由管理 react-router-native 负责 react-native 的路由管理 通用的部分直接从 react-router 中导入，用户只需引入 react-router-dom 或 react-router-native 即可，react-router 作为依赖存在不再需要单独引入。 Router123456789101112import React from &apos;react&apos;import &#123; render &#125; from &apos;react-dom&apos;import &#123; BrowserRouter &#125; from &apos;react-router-dom&apos;import App from &apos;./components/App&apos;;render()&#123; return( &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; ))&#125; 这是我们调用 Router 的方式，这里拿 BrowserRouter 来举例。 BrowserRouter 的源码在 react-router-dom 中，它是一个高阶组件，在内部创建一个全局的 history 对象（可以监听整个路由的变化），并将 history 作为 props 传递给 react-router 的 Router 组件（Router 组件再会将这个 history 的属性作为 context 传递给子组件） 123render() &#123; return &lt;Router history=&#123;this.history&#125; children=&#123;this.props.children&#125; /&gt;;&#125; 整个 Router 的核心是在 react-router 的 Router 组件中，如下，借助 context 向 Route 传递组件，这也解释了为什么 Router 要在所有 Route 的外面。 123456789101112getChildContext() &#123; return &#123; router: &#123; ...this.context.router, history: this.props.history, route: &#123; location: this.props.history.location, match: this.state.match &#125; &#125; &#125;;&#125; 这是 Router 传递给子组件的 context，事实上 Route 也会将 router 作为 context 向下传递，如果我们在 Route 渲染的组件中加入 1234567static contextTypes = &#123; router: PropTypes.shape(&#123; history: PropTypes.object.isRequired, route: PropTypes.object.isRequired, staticContext: PropTypes.object &#125;)&#125;; 来通过 context 访问 router，不过 rr4 一般通过 props 传递，将 history, location, match 作为三个独立的 props 传递给要渲染的组件，这样访问起来方便一点（实际上已经完全将 router 对象的属性完全传递了）。 在 Router 的 componentWillMount 中， 添加了 1234567891011121314151617componentWillMount() &#123; const &#123; children, history &#125; = this.props; invariant( children == null || React.Children.count(children) === 1, &quot;A &lt;Router&gt; may have only one child element&quot; ); // Do this here so we can setState when a &lt;Redirect&gt; changes the // location in componentWillMount. This happens e.g. when doing // server rendering using a &lt;sStaticRouter&gt;. this.unlisten = history.listen(() =&gt; &#123; this.setState(&#123; match: this.computeMatch(history.location.pathname) &#125;); &#125;);&#125; history.listen 能够监听路由的变化并执行回调事件。 在这里每次路由的变化执行的回调事件为 123this.setState(&#123; match: this.computeMatch(history.location.pathname)&#125;); 相比于在 setState 里做的操作，setState 本身的意义更大 —— 每次路由变化 -&gt; 触发顶层 Router 的回调事件 -&gt; Router 进行 setState -&gt; 向下传递 nextContext（context 中含有最新的 location）-&gt; 下面的 Route 获取新的 nextContext 判断是否进行渲染。 之所以把这个 subscribe 的函数写在 componentWillMount 里，就像源码中给出的注释：是为了 SSR 的时候，能够使用 Redirect。 RouteRoute 的作用是匹配路由，并传递给要渲染的组件 props。 在 Route 的 componentWillReceiveProps 中 123456componentWillReceiveProps(nextProps, nextContext) &#123; ... this.setState(&#123; match: this.computeMatch(nextProps, nextContext.router) &#125;);&#125; Route 接受上层的 Router 传入的 context，Router 中的 history 监听着整个页面的路由变化，当页面发生跳转时，history 触发监听事件，Router 向下传递 nextContext，就会更新 Route 的 props 和 context 来判断当前 Route 的 path 是否匹配 location，如果匹配则渲染，否则不渲染。 是否匹配的依据就是 computeMatch 这个函数，在下文会有分析，这里只需要知道匹配失败则 match 为 null，如果匹配成功则将 match 的结果作为 props 的一部分，在 render 中传递给传进来的要渲染的组件。 接下来看一下 Route 的 render 部分。 123456789101112131415161718render() &#123; const &#123; match &#125; = this.state; // 布尔值，表示 location 是否匹配当前 Route 的 path const &#123; children, component, render &#125; = this.props; // Route 提供的三种可选的渲染方式 const &#123; history, route, staticContext &#125; = this.context.router; // Router 传入的 context const location = this.props.location || route.location; const props = &#123; match, location, history, staticContext &#125;; if (component) return match ? React.createElement(component, props) : null; // Component 创建 if (render) return match ? render(props) : null; // render 创建 if (typeof children === &quot;function&quot;) return children(props); // 回调 children 创建 if (children &amp;&amp; !isEmptyChildren(children)) // 普通 children 创建 return React.Children.only(children); return null;&#125; rr4 提供了三种渲染组件的方法：component props，render props 和 children props，渲染的优先级也是依次按照顺序，如果前面的已经渲染后了，将会直接 return。 component (props) —— 由于使用 React.createElement 创建，所以可以传入一个 class component。 render (props) —— 直接调用 render() 展开子元素，所以需要传入 stateless function component。 children (props) —— 其实和 render 差不多，区别是不判断 match，总是会被渲染。 children（子元素）—— 如果以上都没有，那么会默认渲染子元素，但是只能有一个子元素。 这里解释一下官网的 tips，component 是使用 React.createElement 来创建新的元素，所以如果传入一个内联函数，比如 1&lt;Route path=&apos;/&apos; component=&#123;()=&gt;(&lt;div&gt;hello world&lt;/div&gt;)&#125; 的话，由于每次的 props.component 都是新创建的，所以 React 在 diff 的时候会认为进来了一个全新的组件，所以会将旧的组件 unmount，再 re-mount。这时候就要使用 render，少了一层包裹的 component 元素，render 展开后的元素类型每次都是一样的，就不会发生 re-mount 了（children 也不会发生 re-mount）。 Switch我们紧接着 Route 来看 Switch，Switch 是用来嵌套在 Route 的外面，当 Switch 中的第一个 Route 匹配之后就不会再渲染其他的 Route 了。 123456789101112131415161718192021222324252627282930render() &#123; const &#123; route &#125; = this.context.router; const &#123; children &#125; = this.props; const location = this.props.location || route.location; let match, child; React.Children.forEach(children, element =&gt; &#123; if (match == null &amp;&amp; React.isValidElement(element)) &#123; const &#123; path: pathProp, exact, strict, sensitive, from &#125; = element.props; const path = pathProp || from; child = element; match = matchPath( location.pathname, &#123; path, exact, strict, sensitive &#125;, route.match ); &#125; &#125;); return match ? React.cloneElement(child, &#123; location, computedMatch: match &#125;) : null;&#125; Switch 也是通过 matchPath 这个函数来判断是否匹配成功，一直按照 Switch 中 children 的顺序依次遍历子元素，如果匹配失败则 match 为 null，如果匹配成功则标记这个子元素和它对应的 location、computedMatch。在最后的时候使用 React.cloneElement 渲染，如果没有匹配到的子元素则返回 null。 接下来我们看下 matchPath 是如何判断 location 是否符合 path 的。 matchPathmatchPath 返回的是一个如下结构的对象 123456789101112&#123; path, // 用来进行匹配的路径，其实是直接导出的传入 matchPath 的 options 中的 path url: path === &quot;/&quot; &amp;&amp; url === &quot;&quot; ? &quot;/&quot; : url, // 整个的 URL isExact, // url 与 path 是否是 exact 的匹配 // 返回的是一个键值对的映射 // 比如你的 path 是 /users/:id，然后匹配的 pathname 是 /user/123 // 那么 params 的返回值就是 &#123;id: &apos;123&apos;&#125; params: keys.reduce((memo, key, index) =&gt; &#123; memo[key.name] = values[index]; return memo; &#125;, &#123;&#125;) &#125; 这些信息将作为匹配的参数传递给 Route 和 Switch（Switch 只是一个代理，它的作用还是渲染 Route，Switch 计算得到的 computedMatch 会传递给要渲染的 Route，此时 Route 将直接使用这个 computedMatch 而不需要再自己来计算）。 在 matchPath 内部 compilePath 时，有个 123const patternCache = &#123;&#125;;const cacheLimit = 10000;let cacheCount = 0; 作为 pathToRegexp 的缓存，因为 ES6 的 import 模块导出的是值的引用，所以将 patternCache 可以理解为一个全局变量缓存，缓存以 {option:{pattern: }} 的形式存储，之后如果需要匹配相同 pattern 和 option 的 path，则可以直接从缓存中获得正则表达式和 keys。 加缓存的原因是路由页面大部分情况下都是相似的，比如要访问 /user/123 或 /users/234，都会使用 /user/:id 这个 path 去匹配，没有必要每次都生成一个新的正则表达式。SPA 在页面整个访问的过程中都维护着这份缓存。 Link实际上我们可能写的最多的就是 Link 这个标签了，我们从它的 render 函数开始看 12345678910111213141516171819202122render() &#123; const &#123; replace, to, innerRef, ...props &#125; = this.props; // eslint-disable-line no-unused-vars invariant( this.context.router, &quot;You should not use &lt;Link&gt; outside a &lt;Router&gt;&quot; ); invariant(to !== undefined, &apos;You must specify the &quot;to&quot; property&apos;); const &#123; history &#125; = this.context.router; const location = typeof to === &quot;string&quot; ? createLocation(to, null, null, history.location) : to; const href = history.createHref(location); // 最终创建的是一个 a 标签 return ( &lt;a &#123;...props&#125; onClick=&#123;this.handleClick&#125; href=&#123;href&#125; ref=&#123;innerRef&#125; /&gt; ); &#125; 可以看到Link 最终还是创建一个 a 标签来包裹住要跳转的元素，但是如果只是一个普通的带 href 的 a 标签，那么就会直接跳转到一个新的页面而不是 SPA 了，所以在这个 a 标签的 handleClick 中会 preventDefault 禁止默认的跳转，所以这里的 href 并没有实际的作用，但仍然可以标示出要跳转到的页面的 URL 并且有更好的 html 语义。 在 handleClick 中，对没有被 “preventDefault 的 &amp;&amp; 鼠标左键点击的 &amp;&amp; 非 _blank 跳转 的&amp;&amp; 没有按住其他功能键的“ 单击进行 preventDefault，然后 push 进 history 中，这也是前面讲过的 —— 路由的变化 与 页面的跳转 是不互相关联的，rr4 在 Link 中通过 history 库的 push 调用了 HTML5 history 的 pushState，但是这仅仅会让路由变化，其他什么都没有改变。还记不记得 Router 中的 listen，它会监听路由的变化，然后通过 context 更新 props 和 nextContext 让下层的 Route 去重新匹配，完成需要渲染部分的更新。 123456789101112131415161718192021handleClick = event =&gt; &#123; if (this.props.onClick) this.props.onClick(event); if ( !event.defaultPrevented &amp;&amp; // onClick prevented default event.button === 0 &amp;&amp; // ignore everything but left clicks !this.props.target &amp;&amp; // let browser handle &quot;target=_blank&quot; etc. !isModifiedEvent(event) // ignore clicks with modifier keys ) &#123; event.preventDefault(); const &#123; history &#125; = this.context.router; const &#123; replace, to &#125; = this.props; if (replace) &#123; history.replace(to); &#125; else &#123; history.push(to); &#125; &#125;&#125;; withRouter1234567891011121314151617181920212223242526const withRouter = Component =&gt; &#123; const C = props =&gt; &#123; const &#123; wrappedComponentRef, ...remainingProps &#125; = props; return ( &lt;Route children=&#123;routeComponentProps =&gt; ( &lt;Component &#123;...remainingProps&#125; &#123;...routeComponentProps&#125; ref=&#123;wrappedComponentRef&#125; /&gt; )&#125; /&gt; ); &#125;; C.displayName = `withRouter($&#123;Component.displayName || Component.name&#125;)`; C.WrappedComponent = Component; C.propTypes = &#123; wrappedComponentRef: PropTypes.func &#125;; return hoistStatics(C, Component);&#125;;export default withRouter; withRouter 的作用是让我们在普通的非直接嵌套在 Route 中的组件也能获得路由的信息，这时候我们就要 WithRouter(wrappedComponent) 来创建一个 HOC 传递 props，WithRouter 的其实就是用 Route 包裹了 SomeComponent 的一个 HOC。 创建 Route 有三种方法，这里直接采用了传递 children props 的方法，因为这个 HOC 要原封不动的渲染 wrappedComponent（children props 比较少用得到，某种程度上是一个内部方法）。 在最后返回 HOC 时，使用了 hoistStatics 这个方法，这个方法的作用是保留 SomeComponent 类的静态方法，因为 HOC 是在 wrappedComponent 的外层又包了一层 Route，所以要将 wrappedComponent 类的静态方法转移给新的 Route，具体参见 Static Methods Must Be Copied Over。 3.理解现在回到一开始的问题，重新理解一下点击一个 Link 跳转的过程。 有两件事需要完成： 路由的改变 页面的渲染部分的改变 过程如下： 在最一开始 mount Router 的时候，Router 在 componentWillMount 中 listen 了一个回调函数，由 history 库管理，路由每次改变的时候触发这个回调函数。这个回调函数会触发 setState。 当点击 Link 标签的时候，实际上点击的是页面上渲染出来的 a 标签，然后通过 preventDefault 阻止 a 标签的页面跳转。 Link 中也能拿到 Router -&gt; Route 中通过 context 传递的 history，执行 hitsory.push(to)，这个函数实际上就是包装了一下 window.history.pushState()，是 HTML5 history 的 API，但是 pushState 之后除了地址栏有变化其他没有任何影响，到这一步已经完成了目标 1：路由的改变。 第 1 步中，路由改变是会触发 Router 的 setState 的，在 Router 那章有写道：每次路由变化 -&gt; 触发顶层 Router 的监听事件 -&gt; Router 触发 setState -&gt; 向下传递新的 nextContext（nextContext 中含有最新的 location） 下层的 Route 拿到新的 nextContext 通过 matchPath 函数来判断 path 是否与 location 匹配，如果匹配则渲染，不匹配则不渲染，完成目标 2：页面的渲染部分的改变。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"},{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"leetcode算法刷题笔记（二）——回溯问题","slug":"leetcode算法刷题笔记（二）——回溯问题","date":"2019-01-15T14:07:43.000Z","updated":"2019-04-07T08:27:27.810Z","comments":true,"path":"2019/01/15/leetcode算法刷题笔记（二）——回溯问题/","link":"","permalink":"http://yoursite.com/2019/01/15/leetcode算法刷题笔记（二）——回溯问题/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [17] Letter Combinations of a Phone NumberGiven a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.Note:Although the above answer is in lexicographical order, your answer could be in any order you want.难度：Medium (40.58%)考点：回溯 123456789101112131415161718192021222324252627282930313233var letterCombinations = function(digits) &#123; var res = []; var sort = []; if (digits.length == 0) &#123; return res; &#125; var phone = [ \"0\", \"1\", [\"a\", \"b\", \"c\"], [\"d\", \"e\", \"f\"], [\"g\", \"h\", \"i\"], [\"j\", \"k\", \"l\"], [\"m\", \"n\", \"o\"], [\"p\", \"q\", \"r\", \"s\"], [\"t\", \"u\", \"v\"], [\"w\", \"x\", \"y\", \"z\"] ]; finger(0); return res; function finger(index) &#123; if (index == digits.length) &#123; return res.push(sort.join(\"\")); &#125; var temp = phone[digits[index]]; for (var i = 0; i &lt; temp.length; i++) &#123; sort.push(temp[i]); finger(index + 1); sort.pop(); &#125; &#125;&#125;; [22] Generate ParenthesesGiven n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.难度：Medium (53.42%)考点：回溯思路： 给定 n 值，则总共有 n 个左括号，n 个右括号。 第一个添加的一定是左括号。 当添加了一个左括号之后，才会有一个右括号可以添加。所以回溯时，left-1 的同时 right+1 当已添加了 n 个左括号后，剩下的都应该添加右括号 123456789101112131415161718192021var generateParenthesis = function(n) &#123; var res = []; var left = n - 1; var right = 1; function quote(left, right, str) &#123; if (left &lt;= 0) &#123; if (right) &#123; for (var i = 0; i &lt; right; i++) &#123; str = str + \")\"; &#125; &#125; return res.push(str); &#125; quote(left - 1, right + 1, str + \"(\"); if (right &gt; 0) &#123; quote(left, right - 1, str + \")\"); &#125; &#125; quote(left, right, \"(\"); return res;&#125;; [46] PermutationsGiven a collection of distinct integers, return all possible permutations.难度：Medium (53.67%)考点：回溯思路：选择一个元素之后，则下次可选择的元素就少一个。 12345678910111213141516171819202122var permute = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [47] Permutations IIGiven a collection of numbers that might contain duplicates, return all possible unique permutations.难度：Medium (39.35%)考点：回溯思路：思路同上题。注意筛选条件。 12345678910111213141516171819202122232425262728var permuteUnique = function(nums) &#123; var res = []; var sort = []; if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; &#123; return a - b; &#125;); select(nums); return res; function select(nums) &#123; if (nums.length &lt; 1) &#123; return res.push(sort.slice()); &#125; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] == nums[i - 1]) &#123; continue; &#125; var nextNums = nums.slice(); sort.push(nextNums[i]); nextNums.splice(i, 1); select(nextNums); sort.pop(); &#125; &#125;&#125;; [60] Permutations II ☆☆The set [1,2,3,…,n] contains a total of n! unique permutations.By listing and labeling all of the permutations in order, we get the following sequence for n = 3:“123”“132”“213”“231”“312”“321”Given n and k, return the k^th permutation sequence.Note:Given n will be between 1 and 9 inclusive. Given k will be between 1 and n! inclusive.难度：Medium (32.42%)考点：回溯 123456789101112131415161718192021var getPermutation = function(n, k) &#123; (res = []), (pos = k - 1); var nums = []; if (n == 0) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; var numsSort = nums.reduce((a, b) =&gt; a * b); if (k &lt; 1 || k &gt; numsSort) &#123; return \"error\"; &#125; for (var j = n; j &gt;= 1; --j) &#123; numsSort /= j; res.push(nums.splice(parseInt(pos / numsSort), 1)[0]); pos %= numsSort; &#125; return res.join(\"\");&#125;; [77] ombinations ☆☆Given two integers n and k, return all possible combinations of k numbers out of 1 … n.难度：Medium (46.23%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件 12345678910111213141516171819202122232425262728var combine = function(n, k) &#123; var nums = []; var res = []; var temp = []; if (n == 0 || k &lt;= 0 || k &gt; n) &#123; return \"error\"; &#125; for (var i = 0; i &lt; n; i++) &#123; nums[i] = i + 1; &#125; select(0, nums); return res; function select(start, nums) &#123; if (temp.length == k) &#123; return res.push(temp.slice()); &#125; for (var i = start; i &lt; n; i++) &#123; if (temp.length &gt;= 1 &amp;&amp; temp[temp.length - 1] &gt; i) &#123; continue; &#125; temp.push(nums[i]); select(start + 1, nums); temp.pop(); &#125; &#125;&#125;; [78] SubsetsGiven a set of distinct integers, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (51.26%)考点：回溯难点：下一次选择不能选择比上一次小的数，所以需注意 push 进去的条件。 123456789101112131415161718192021222324252627282930313233var subsets = function(nums) &#123; var res = []; var subsets = []; var used = []; res.push(subsets.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var j = 1; j &lt;= nums.length; j++) &#123; findSubsets(0, j); &#125; return res; function findSubsets(start, k) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; if (subsets.length == k) &#123; return res.push(subsets.slice()); &#125; if (used[i]) &#123; continue; &#125; if (start &gt; 0 &amp;&amp; nums[i] &lt; subsets[subsets.length - 1]) &#123; continue; &#125; subsets.push(nums[i]); used[i] = true; findSubsets(start + 1, k); subsets.pop(); used[i] = false; &#125; &#125;&#125;; [79] Word SearchGiven a 2D board and a word, find if the word exists in the grid.The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.难度：Medium (30.52%)考点：回溯思路：要分四个方向分别回溯。 123456789101112131415161718192021222324252627282930313233343536373839404142434445var exist = function(board, word) &#123; var row = board.length; var col = board[0].length; if (word.length &gt; row * col) &#123; return false; &#125; function search(i, j, n) &#123; if ( i &gt;= row || j &gt;= col || i &lt; 0 || j &lt; 0 || board[i][j] != word[n] || n &gt; word.length ) &#123; return false; &#125; if (n == word.length - 1) &#123; return true; &#125; board[i][j] = true; if (search(i + 1, j, n + 1)) &#123; return true; &#125; if (search(i - 1, j, n + 1)) &#123; return true; &#125; if (search(i, j + 1, n + 1)) &#123; return true; &#125; if (search(i, j - 1, n + 1)) &#123; return true; &#125; board[i][j] = word[n]; return false; &#125; for (var i = 0; i &lt; row; i++) &#123; for (var j = 0; j &lt; col; j++) &#123; if (search(i, j, 0)) &#123; return true; &#125; &#125; &#125; return false;&#125;; [89] Gray Code ☆☆The gray code is a binary numeral system where two successive values differ in only one bit.Given a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.难度：Medium (45.03%)考点：回溯思路：可根据格雷码的特性考虑解法一（普通解法）： 123456789101112131415161718192021222324252627282930var grayCode = function(n) &#123; var result = []; var graycodeFn = function(n) &#123; var graycode = []; if (n == 1) &#123; graycode[0] = \"0\"; graycode[1] = \"1\"; return graycode; &#125; var last = arguments.callee(n - 1); // arguments.callee(n-1) == graycodeFn(n-1) for (var i = last.length - 1; i &gt;= 0; --i) &#123; graycode.unshift(\"0\" + last[i]); graycode.push(\"1\" + last[i]); &#125; return graycode; &#125;; var graycode = n == 0 ? [\"0\"] : graycodeFn(n); for (var i = 0; i &lt; graycode.length; ++i) &#123; result.push(parseInt(parseInt(graycode[i], 2), 10)); // String To Number &#125; return result;&#125;; 解法二（大神解法）： 1234567var grayCode = function(n) &#123; let nums = [0], c = -1; while (c++ &lt; n - 1) nums = [...nums, ...nums.map(num =&gt; num + Math.pow(2, c)).reverse()]; return nums;&#125;; [90] Subsets IIGiven a collection of integers that might contain duplicates, nums, return all possible subsets (the power set).Note: The solution set must not contain duplicate subsets.难度：Medium (41.57%)考点：回溯 12345678910111213141516171819202122232425262728var subsetsWithDup = function(nums) &#123; var sub = []; var res = []; res.push(sub.slice()); if (nums.length == 0) &#123; return res; &#125; nums = nums.sort((a, b) =&gt; a - b); for (var i = 1; i &lt;= nums.length; i++) &#123; findSub(0, i); &#125; return res; function findSub(start, k) &#123; if (sub.length == k) &#123; return res.push(sub.slice()); &#125; for (var j = start; j &lt; nums.length; j++) &#123; if (j &gt; start &amp;&amp; nums[j] == nums[j - 1]) &#123; continue; &#125; sub.push(nums[j]); findSub(j + 1, k); sub.pop(); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"回溯","slug":"回溯","permalink":"http://yoursite.com/tags/回溯/"}]},{"title":"浏览器内核","slug":"浏览器内核","date":"2019-01-07T13:07:44.000Z","updated":"2019-08-15T10:31:21.482Z","comments":true,"path":"2019/01/07/浏览器内核/","link":"","permalink":"http://yoursite.com/2019/01/07/浏览器内核/","excerpt":"浏览器内核浏览器内核有哪几种？Trident：IE（Internet Explorer），由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大。 但是由于微软长时间没有更新 Trident 内核，则导致了两个后果：一是 Trident 内核曾经几乎与 W3C 标准脱节（2005 年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器。","text":"浏览器内核浏览器内核有哪几种？Trident：IE（Internet Explorer），由于其被包含在全世界使用率最高的操作系统 Windows 中，得到了极高的市场占有率，从而使得 Trident 内核（也被称为 IE 内核）长期一家独大。 但是由于微软长时间没有更新 Trident 内核，则导致了两个后果：一是 Trident 内核曾经几乎与 W3C 标准脱节（2005 年），二是 Trident 内核的大量 Bug 等安全性问题没有得到及时解决，然后加上一些致力于开源的开发者和一些学者们公开自己认为 IE 浏览器不安全的观点，也有很多用户转向了其他浏览器。 Trident 内核常见浏览器（1）IE6、IE7、IE8（Trident 4.0）、IE9（Trident 5.0）、IE10（Trident 6.0）； （2）猎豹安全浏览器：1.0-4.2 版本为 Trident+Webkit，4.3 版本为 Trident+Blink； （3）360 安全浏览器 ：1.0-5.0 为 Trident，6.0 为 Trident+Webkit，7.0 为 Trident+Blink； （4）360 极速浏览器：7.5 之前为 Trident+Webkit,7.5 为 Trident+Blink； （5）傲游浏览器 ：傲游 1.x、2.x 为 IE 内核，3.x 为 IE 与 Webkit 双核； （6）搜狗高速浏览器：1.x 为 Trident，2.0 及以后版本为 Trident+Webkit； 兼容模式国内很多的双核浏览器的其中一核便是 Trident，美其名曰 “兼容模式”。 EdgeHTML 内核Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。 Gecko ([‘gekəʊ])开源内核Gecko(Firefox 内核)：Netscape6 开始采用的内核，后来的 Mozilla FireFox(火狐浏览器) 也采用了该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。因为这是个开源内核，因此受到许多人的青睐，Gecko 内核的浏览器也很多，这也是 Gecko 内核虽然年轻但市场占有率能够迅速提高的重要原因。 Firefox 内核事实上，Gecko 引擎的由来跟 IE 不无关系，前面说过 IE 没有使用 W3C 的标准，这导致了微软内部一些开发人员的不满；他们与当时已经停止更新了的 Netscape 的一些员工一起创办了 Mozilla，以当时的 Mosaic 内核为基础重新编写内核，于是开发出了 Gecko。不过事实上，Gecko 内核的浏览器仍然还是 Firefox (火狐) 用户最多，所以有时也会被称为 Firefox 内核。此外 Gecko 也是一个跨平台内核，可以在 Windows、 BSD、Linux 和 Mac OS X 中使用。 WebkitSafari 浏览器只要提到 Webkit，大多数人立马想到的必然是 Chrome，结果导致如今有了把 webkit 称为 chrome 内核的错误说法，即使 chrome 的内核已经是 blink，其实 Webkit 的祖先是 Safari，也就是苹果系列产品的专属浏览器。 WebKit 是 KHTML 的分支WebKit 的前身是苹果公司使用 KDE（Linux 桌面系统）开发的 KHTML 开源引擎，可以说 WebKit 是 KHTML 的一个开源分支。 Chromium/BlinkChromium Fork webkit2008 年，谷歌公司发布了 chrome 浏览器，浏览器使用的内核被命名为 chromium。chromium fork 自开源引擎 webkit，并提高了 WebKit 的代码可读性和编译速度。 V8 引擎谷歌公司还研发了自己的 Javascript 引擎，V8，极大地提高了 Javascript 的运算速度。 Blink 是 WebKit 的分支Google 的 Chromium 项目最初一直使用 WebKit(WebCore) 作为渲染引擎，但由于后来苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发）。 Blink 其实是 WebKit 的分支，如同 WebKit 是 KHTML 的分支。Google 的 Chromium 项目此前一直使用 WebKit(WebCore) 作为渲染引擎，但出于某种原因，并没有将其多进程架构移植入 Webkit。 后来，由于苹果推出的 WebKit2 与 Chromium 的沙箱设计存在冲突，所以 Chromium 一直停留在 WebKit，并使用移植的方式来实现和主线 WebKit2 的对接。这增加了 Chromium 的复杂性，且在一定程度上影响了 Chromium 的架构移植工作。 基于以上原因，Google 决定从 WebKit 衍生出自己的 Blink 引擎（后由 Google 和 Opera Software 共同研发），将在 WebKit 代码的基础上研发更加快速和简约的渲染引擎，并逐步脱离 WebKit 的影响，创造一个完全独立的 Blink 引擎。这样以来，唯一一条维系 Google 和苹果之间技术关系的纽带就这样被切断了。 Presto ([‘prestəʊ])Opera 浏览器Presto 是 Opera 自主研发的渲染引擎，然而为了减少研发成本，Opera 在 2013 年 2 月宣布放弃 Presto，转而跟随 Chrome 使用 WebKit 分支的 Chromium 引擎作为自家浏览器核心引擎。 在 Chrome 于 2013 年推出 Blink 引擎之后，Opera 也紧跟其脚步表示将转而使用 Blink 作为浏览器核心引擎。 移动端移动端的浏览器内核主要说的是系统内置浏览器的内核。 目前移动设备浏览器上常用的内核有 Webkit，Blink，Trident，Gecko 。 1、iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit。 2、Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android 4.4 系统浏览器切换到了 Chromium，内核是 Webkit 的分支 Blink。 3、Windows Phone 8 系统浏览器内核是 Trident。 webkit 内核了解多少？（chrome 内核是 b-link）深入剖析 webkit 微信 x5 内核和别的内核有什么差别？（x5 是基于 webkit 的）认识 X5 腾讯基于优秀开源 Webkit 深度优化的浏览器渲染引擎 为抹平不同 Android 版本不同 Webview 的坑而生。但本身也带来了许多坑。 虽然官方不承认，但实际上它是基于 Chromuim 开源项目的。 webkit 内核以及 blink 内核在 x5 的使用情况 QQ 浏览器：6.2 版本及以后使用 blink 内核。 X5 tbs 1.x：版本号为 02xxxx，使用 webkit 内核。 X5 tbs 2.x：版本号为 03xxxx。使用 blink 内核。 拓展：Webkit &amp; Chromuim &amp;Chrome &amp; Blink WebKit是一个开源的项目，其前身是来源于 KDE 的 KHTML 和 KJS。该项目专注于网页内容的展示，开发出一流的网页渲染引擎。 Chromium是一个建立在 WebKit 之上的浏览器开源项目，由 Google 发起的。 Chrome是 Google 公司的浏览器产品，它基于 chromium 开源项目。可以理解为，内核是开源的，UI 是闭源的。 Blink是 Google 退出 WebKit 项目，从而自己创建的渲染引擎。但并不是全新的引擎，Blink 目前就是从 WebKit 直接复制出一个版本出来，然后将与 chromium 无关的 Ports 全部移除掉，将代码结构重新整理，就目前而言，Blink 的渲染和 WebKit 是一样，但是，以后两者将各自走不同的路。 X5 升级了截至 16 年 4 月份，x5 升级全量发布。TBS2.0 基于 Android 5.0 WebView Blink 内核（M37 版本）适配定制优化，适配 Android 全部主流平台，可以在所有 Android 手机上使用 Blink 的技术能力。具有更好的 H5/CSS3 支持和性能。TBS2.0 已经发布，将逐步在各客户端中静默升级，无需更新微信、手机 QQ、QQ 空间即可使用最新的 TBS2.0 Blink 内核。 更简洁地说，即是： 基于 Blink 内核（chrome 37 版本） 适用于 Android 全部主流平台 静默升级 PS：iOS 版本的微信 Web View 一直是 WKWebView 内核，WKWebView 的版本依赖于 iOS 的系统版本。 TBS2.0 内核详情 BLINK 版本: 基于 Chrome 37 HTML 版本: HTML5.0 XHTML 版本: xHTML Basic 1.0 | xHTML1.1 SVG 版本: SVG1.2 WML 版本: Wml 1.0 CSS 版本: CSS3 Spdy 版本: 3.1 支持的 JavaScript 版本: Ecma5 Changelog 以及 解读1.内核从 Webkit 升级至 Blink，拥有更好的支持 那么哪里可以查阅兼容性呢？ X5 CanIUse 2.内核版本号升级到 362xx 版本。可以根据 UserAgent判断当前环境是否已升级到 TBS2.0 版本,包含（TBS/03xxxx）字段。 那么怎么查看自己微信里的 TBS 版本？ 用微信打开这个页面，检查 TBS 的版本号，0362xx 表示已更新。页面的代码只有两句，为： 123// 检测页面的核心代码var resultDiv = document.getElementById(\"result\");resultDiv.innerHTML = window.navigator.userAgent; 3.CSS3 属性支持增强： 完整支持 flex 伪元素支持动画效果 filter: blur 有模糊效果 PS：更多更具体的支持情况可查阅这里 4.autoplay 属性有效，可自动播放 5.canvas 支持设置背景色 6.标准的缓存策略，支持 Spdy 3.1 7.动画性能提升 8.更好的 inspector 支持 微信远程调试解决方案——微信 web 开发者工具 手机 QQ 浏览器的远程调试解决方案 参考资料： 解读微信全面升级 X5 Blink 内核，H5 游戏行业重大利好 官方网站：腾讯浏览服务－技术指南 总结常用工具 检测是否为 x5－TBS/03xxxx x5 的各项支持情况－X5 CanIUse Android 下微信远程调试工具-微信 web 开发者工具（PS:iOS 下使用 Safari 远程调试即可） 我们可以从中了解到什么一、工具方面： 可以通过查询 UA 来检测是否为 X5－TBS/03xxxx，在线检测地址 想知道某个 CSS3 属性，或者其他 API 在 X5 是否支持的时候，可以查询X5 CanIUse 远程调试微信内页面时，在 Android 下可以使用微信远程调试工具-微信 web 开发者工具，在 iOS 下使用 Safari 远程调试即可。 二、对于开发调试页面 目前，暂时还没有查找到 X5 在微信 android 客户端的版本分布情况的数据(可能是由于 X5 tbs2.0 是今年 4 月份初才开始全量发布的)。 虽然说，X5 是静默升级，无需用户手动更新，基本上都实现升级为最新版本(业界说法)，但仍存在 X5 内核是旧版本的情况(根据是部分测试的检测 UA 结果)。希望能够在后续的日子可以获取到相关的数据。 手机同时安装了 QQ 浏览器和微信，但 QQ 浏览器内核版本不等于微信内核版本，只有在 QQ 浏览器内核为大于等于 6.2 版本才是 Blink 内核，调试页面的结果才可以替代在微信内页面调试的结果（想要不登陆微信用 QQ 浏览器来替代调试的需要注意下 X5 的版本分布情况据腾讯内部的小伙伴告知，x5 内核基本覆盖理论上达到 100%，但难免会有漏网之鱼。而根据实际数据抽样整理显示，截至 2016 年 5 月 19 日，x5 内核基本覆盖率达到 91.47%。 X5 问题汇总","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"leetcode算法刷题笔记（一）——数组","slug":"leetcode算法刷题笔记（一）——数组","date":"2018-12-18T16:07:06.000Z","updated":"2019-03-22T06:57:31.402Z","comments":true,"path":"2018/12/19/leetcode算法刷题笔记（一）——数组/","link":"","permalink":"http://yoursite.com/2018/12/19/leetcode算法刷题笔记（一）——数组/","excerpt":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断","text":"该笔记只为个人所写算法，不一定是最优解法，仅供参考 [1] Two SumGiven an array of integers, return indices of the two numbers such that they add up to a specific target.难度：Easy (42.36%)考点：哈希表思路：用一遍循环 一边向哈希表中存值，一边比较判断 1234567891011var twoSum = function(nums, target) &#123; var map = &#123;&#125;; for (i = 0; i &lt; nums.length; i++) &#123; const complement = target - nums[i]; if (complement in map) &#123; return [i, map[complement]]; &#125; map[nums[i]] = i; &#125; return -1;&#125;; [11] Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Note: You may not slant the container and n is at least 2.难度：Medium (42.93%)考点：动态规划思路： 设定 i，j 分别指向数组的头和尾 比较 i，j 所对应的位置的值，值较小的那一个移动（i++或 j–） 123456789101112131415161718var maxArea = function(height) &#123; var maxArea = 0; var i = 0; var j = height.length - 1; while (i &lt; j) &#123; const long = Math.min(height[i], height[j]); const area = long * (j - i); if (area &gt; maxArea) &#123; maxArea = area; &#125; if (height[i] &lt; height[j]) &#123; i++; &#125; else &#123; j--; &#125; &#125; return maxArea;&#125;; [15] 3SumGiven an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.Note: The solution set must not contain duplicate triplets.难度：Medium (23.55%)思路： 数组排序（升序） 设定三个指针，最外层循环从 0 开始，到数组的尾结束（i=0） 第二层循环，一个指向上一个指针的下一个元素（j=i+1），另一个指向数组的尾部(k=nums.length-1) 如果三个元素之和等于 0，则 push 进要返回的数组中；如果三个元素之和大于 0，说明第三个指针指向的元素过大，则第三个指针向前移(k–);如果三个元素之和小于 0，说明第二个指针指向的元素过小，则第二个指针向后移(j++); 123456789101112131415161718192021222324252627282930313233343536var threeSum = function(nums) &#123; var rtn = []; if (nums.length &lt; 3) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var i = 0; i &lt; nums.length - 1; i++) &#123; if (nums[i] &gt; 0) &#123; return rtn; &#125; if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123; continue; &#125; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === 0) &#123; rtn.push([nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; 0) &#123; k--; &#125; else &#123; j++; &#125; &#125; &#125; return rtn;&#125;; [16] 3Sum ClosestGiven an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. Return the sum of the three integers. You may assume that each input would have exactly one solution.难度：Medium (41.40%)思路：与上题类似 12345678910111213141516171819202122232425262728var threeSumClosest = function(nums, target) &#123; var sum; if (nums.length &lt; 3) &#123; return sum; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); var sum = nums[0] + nums[1] + nums[2]; var distance = Math.abs(sum - target); for (var i = 0; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (Math.abs(nums[i] + nums[j] + nums[k] - target) &lt; distance) &#123; sum = nums[i] + nums[j] + nums[k]; distance = Math.abs(sum - target); &#125; if (nums[i] + nums[j] + nums[k] === target) &#123; break; &#125; if (nums[i] + nums[j] + nums[k] &gt; target) &#123; k--; &#125; else if (nums[i] + nums[j] + nums[k] &lt; target) &#123; j++; &#125; &#125; &#125; return sum;&#125;; [18] 4SumGiven an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.Note: The solution set must not contain duplicate quadruplets.难度：Medium (29.83%)思路：思路同 3Sum，多一层循环。注意跳过相同的数（最外两层的循环变量） 1234567891011121314151617181920212223242526272829303132333435363738var fourSum = function(nums, target) &#123; var rtn = []; if (nums.length &lt; 4) &#123; return rtn; &#125; nums = nums.sort(function(a, b) &#123; return a - b; &#125;); for (var m = 0; m &lt; nums.length - 3; m++) &#123; var complement = target - nums[m]; for (var i = m + 1; i &lt; nums.length - 2; i++) &#123; for (var j = i + 1, k = nums.length - 1; j &lt; k; ) &#123; if (nums[i] + nums[j] + nums[k] === complement) &#123; rtn.push([nums[m], nums[i], nums[j], nums[k]]); j++; k--; while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) &#123; j++; &#125; while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) &#123; k--; &#125; &#125; else if (nums[i] + nums[j] + nums[k] &gt; complement) &#123; k--; &#125; else &#123; j++; &#125; if (i &lt; nums.length - 1 &amp;&amp; nums[i] == nums[i + 1]) &#123; ++i; &#125; &#125; if (m &lt; nums.length - 1 &amp;&amp; nums[m] == nums[m + 1]) &#123; ++m; &#125; &#125; &#125; return rtn;&#125;; [26] Remove Duplicates from Sorted ArrayGiven a sorted array nums, remove the duplicates in-place such that each element appear only once and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.难度：Easy (39.80%)思路：两个指针，一个指针负责寻找和后一个不相等的数，另一个指针负责一步步向后移去重。 1234567891011121314151617181920var removeDuplicates = function(nums) &#123; if (nums.length == 0) &#123; return 0; &#125; var i = 0; var j = 0; for (i = 0; i &lt; nums.length - 1; ) &#123; if (nums[i] === nums[i + 1]) &#123; i++; &#125; else &#123; if (i !== j) &#123; nums[j + 1] = nums[i + 1]; &#125; j++; i++; &#125; &#125; nums = nums.slice(0, j + 1); return nums.length;&#125;; [27] Remove ElementGiven an array nums and a value val, remove all instances of that value in-place and return the new length.Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.The order of elements can be changed. It doesn’t matter what you leave beyond the new length.难度：Easy (43.73%)思路：找到和 val 值相等的位置，将数组最后一个元素赋值过来（去掉这个 val，数组长度减一） 12345678910111213var removeElement = function(nums, val) &#123; var i = 0; var n = nums.length; for (i = 0; i &lt; n; ) &#123; if (nums[i] == val) &#123; nums[i] = nums[n - 1]; n--; &#125; else &#123; i++; &#125; &#125; return n;&#125;; [31] Next PermutationImplement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.If such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).The replacement must be in-place and use only constant extra memory.Here are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.1,2,3 → 1,3,23,2,1 → 1,2,31,1,5 → 1,5,1难度：Medium (30.09%)思路： 从后向前比较相邻的两个元素，直到前一个元素小于后一个元素，停止（i）。 若已经没有了前一个元素（i=0），则该序列为递减序列，没有 Next Permutation。按照题目要求，直接反转序列。 前一个元素（j=i-1）小于后一个元素（i），找到前一个元素（j）要交换的元素，从 i 的后一个元素开始往后查找，找到最后一个比“前一个元素（j）”大的元素（k），也就是再往后的元素，就比元素 j 小了。交换 j 和 k 元素。 从 i 开始，包括 i 到序列的尾部，反转。则得出的即是 Next Permutation 1234567891011121314151617181920212223var nextPermutation = function(nums) &#123; var i = nums.length - 1; while (nums[i] &lt;= nums[i - 1]) &#123; i--; &#125; if (i !== 0) &#123; var j = i - 1; var k = i + 1; while (nums[j] &lt; nums[k]) &#123; k++; &#125; var temp = nums[k - 1]; nums[k - 1] = nums[j]; nums[j] = temp; for (var m = i, n = nums.length - 1; m &lt; n; m++, n--) &#123; var temp = nums[n]; nums[n] = nums[m]; nums[m] = temp; &#125; &#125; else &#123; nums = nums.reverse(); &#125;&#125;; [33] Search in Rotated Sorted ArraySuppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).You are given a target value to search. If found in the array return its index, otherwise return -1.You may assume no duplicate exists in the array.Your algorithm’s runtime complexity must be in the order of O(log n).难度：Medium (32.68%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627var search = function(nums, target) &#123; if (nums.length == 0) &#123; return -1; &#125; var start = 0; var end = nums.length - 1; while (start &lt;= end) &#123; var middle = parseInt((start + end) / 2); if (nums[middle] == target) &#123; return middle; &#125; if (nums[middle] &gt; nums[end]) &#123; if (target &gt;= nums[start] &amp;&amp; target &lt; nums[middle]) &#123; end = middle - 1; &#125; else &#123; start = middle + 1; &#125; &#125; else &#123; if (target &gt; nums[middle] &amp;&amp; target &lt;= nums[end]) &#123; start = middle + 1; &#125; else &#123; end = middle - 1; &#125; &#125; &#125; return -1;&#125;; [34] Find First and Last Position of Element in Sorted ArrayGiven an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.Your algorithm’s runtime complexity must be in the order of O(log n).If the target is not found in the array, return [-1, -1].难度：Medium (33.06%)考点：二分法注意：判断和循环的边界条件 123456789101112131415161718192021222324252627282930var searchRange = function(nums, target) &#123; if (nums.length == 0) &#123; return [-1, -1]; &#125; var startFind = 0; var endFind = nums.length - 1; var start; var end; while (startFind &lt;= endFind) &#123; var mid = parseInt((startFind + endFind) / 2); if (nums[mid] == target) &#123; start = mid; end = mid; while (nums[start - 1] == target || nums[end + 1] == target) &#123; if (nums[start - 1] == target) &#123; start--; &#125; if (nums[end + 1] == target) &#123; end++; &#125; &#125; return [start, end]; &#125; else if (nums[mid] &lt; target) &#123; startFind = mid + 1; &#125; else &#123; endFind = mid - 1; &#125; &#125; return [-1, -1];&#125;; [35] Search Insert PositionGiven a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.You may assume no duplicates in the array.难度：Easy (40.50%) 123456789101112var searchInsert = function(nums, target) &#123; if (nums.length == 0) &#123; return 0; &#125; let out = nums.indexOf(target); if (out == -1) &#123; let i = 0; for (; target &gt; nums[i]; i++) &#123;&#125; out = i; &#125; return out;&#125;; [39] Combination SumGiven a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.The same repeated number may be chosen from candidates unlimited number of times.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (46.97%)考点：递归 12345678910111213141516171819202122232425262728var combinationSum = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); sarch(0, target); function sarch(start, target) &#123; if (start == candidates.length) &#123; return; &#125; if (target == 0) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0) &#123; return; &#125; solution.push(candidates[start]); sarch(start, target - candidates[start]); solution.pop(); sarch(start + 1, target); &#125; return rt;&#125;; [40] Combination Sum IIGiven a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.Each number in candidates may only be used once in the combination.Note:All numbers (including target) will be positive integers.The solution set must not contain duplicate combinations.难度：Medium (40.37%)考点：递归注意：限制边界条件，过滤重复的结果 12345678910111213141516171819202122232425262728var combinationSum2 = function(candidates, target) &#123; var rt = []; var solution = []; if (candidates.length == 0) &#123; return rt; &#125; candidates = candidates.sort(function(a, b) &#123; return a - b; &#125;); search(0, target); return rt; function search(start, target) &#123; if (target === 0 &amp;&amp; start === candidates.length) &#123; return rt.push(solution.slice()); &#125; if (target &lt; 0 || start === candidates.length) &#123; return; &#125; solution.push(candidates[start]); search(start + 1, target - candidates[start]); solution.pop(); if (solution[solution.length - 1] !== candidates[start]) &#123; search(start + 1, target); &#125; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"leetcode","slug":"leetcode","permalink":"http://yoursite.com/tags/leetcode/"},{"name":"数组","slug":"数组","permalink":"http://yoursite.com/tags/数组/"}]},{"title":"webpack基础知识（二）","slug":"webpack基础知识（二）","date":"2018-12-05T07:12:28.000Z","updated":"2019-04-08T04:39:59.993Z","comments":true,"path":"2018/12/05/webpack基础知识（二）/","link":"","permalink":"http://yoursite.com/2018/12/05/webpack基础知识（二）/","excerpt":"代码分离代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。","text":"代码分离代码分离是 webpack 中最引人注目的特性之一。此特性能够把代码分离到不同的 bundle 中，然后可以按需加载或并行加载这些文件。代码分离可以用于获取更小的 bundle，以及控制资源加载优先级，如果使用合理，会极大影响加载时间。 有三种常用的代码分离方法： 入口起点：使用 entry 配置手动地分离代码。 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。 动态导入：通过模块的内联函数调用来分离代码。 入口起点(entry points)问题： 如果入口 chunks 之间包含重复的模块，那些重复模块都会被引入到各个 bundle 中。 这种方法不够灵活，并且不能将核心应用程序逻辑进行动态拆分代码。 防止重复(prevent duplication)CommonsChunkPlugin 插件可以将公共的依赖模块提取到已有的入口 chunk 中，或者提取到一个新生成的 chunk。使用这个插件，可将重复的 lodash 模块去除。需要注意的是，CommonsChunkPlugin 插件将 lodash 分离到单独的 chunk，并且将其从 main bundle 中移除，减轻了大小。 以下是由社区提供的，一些对于代码分离很有帮助的插件和 loaders： ExtractTextPlugin: 用于将 CSS 从主应用程序中分离。 bundle-loader: 用于分离代码和延迟加载生成的 bundle。 promise-loader: 类似于 bundle-loader ，但是使用的是 promises。 CommonsChunkPlugin 插件还可以通过使用显式的 vendor chunks 功能，从应用程序代码中分离 vendor 模块。 动态导入(dynamic imports)当涉及到动态代码拆分时，webpack 提供了两个类似的技术。对于动态导入，第一种，也是优先选择的方式是，使用符合 ECMAScript 提案 的 import() 语法。第二种，则是使用 webpack 特定的 require.ensure。 懒加载懒加载或者按需加载，是一种很好的优化网页或应用的方式。这种方式实际上是先把你的代码在一些逻辑断点处分离开，然后在一些代码块中完成某些操作后，立即引用或即将引用另外一些新的代码块。这样加快了应用的初始加载速度，减轻了它的总体体积，因为某些代码块可能永远不会被加载。 缓存我们使用 webpack 来打包我们的模块化后的应用程序，webpack 会生成一个可部署的 /dist 目录，然后把打包后的内容放置在此目录中。只要 /dist 目录中的内容部署到服务器上，客户端（通常是浏览器）就能够访问网站此服务器的网站及其资源。而最后一步获取资源是比较耗费时间的。因此我们使用缓存技术。以通过命中缓存，以降低网络流量，使网站加载速度更快，然而，如果我们在部署新版本时不更改资源的文件名，浏览器可能会认为它没有被更新，就会使用它的缓存版本。由于缓存的存在，当你需要获取新的代码时，就会显得很棘手。所以需要通过必要的配置，以确保 webpack 编译生成的文件能够被客户端缓存，而在文件内容变化后，能够请求到新的文件。 输出文件的文件名(Output Filenames)通过使用 output.filename 进行文件名替换，可以确保浏览器获取到修改后的文件。[hash] 替换可以用于在文件名中包含一个构建相关(build-specific)的 hash，但是更好的方式是使用 [chunkhash] 替换，在文件名中包含一个 chunk 相关(chunk-specific)的哈希。 提取模板(Extracting Boilerplate)CommonsChunkPlugin 可以用于将模块分离到单独的文件中，还能够在每次修改后的构建结果中，将 webpack 的样板(boilerplate)和 manifest 提取出来。通过指定 entry 配置中未用到的名称，此插件会自动将我们需要的内容提取到单独的包中： 12345678910111213141516171819202122const path = require('path');+ const webpack = require('webpack'); const CleanWebpackPlugin = require('clean-webpack-plugin'); const HtmlWebpackPlugin = require('html-webpack-plugin'); module.exports = &#123; entry: './src/index.js', plugins: [ new CleanWebpackPlugin(['dist']), new HtmlWebpackPlugin(&#123; title: 'Caching'- &#125;)+ &#125;),+ new webpack.optimize.CommonsChunkPlugin(&#123;+ name: 'manifest'+ &#125;) ], output: &#123; filename: '[name].[chunkhash].js', path: path.resolve(__dirname, 'dist') &#125; &#125;; 将第三方库(library)（例如 lodash 或 react）提取到单独的 vendor chunk 文件中，是比较推荐的做法，这是因为，它们很少像本地的源代码那样频繁修改。因此通过实现以上步骤，利用客户端的长效缓存机制，可以通过命中缓存来消除请求，并减少向服务器获取资源，同时还能保证客户端代码和服务器端代码版本一致。 模块标识符(Module Identifiers)每个 module.id 会基于默认的解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。 可以使用两个插件来解决这个问题。第一个插件是 NamedModulesPlugin，将使用模块的路径，而不是数字标识符。虽然此插件有助于在开发过程中输出结果的可读性，然而执行时间会长一些。第二个选择是使用 HashedModuleIdsPlugin，推荐用于生产环境构建。 library可以通过以下方式暴露 library： 变量：作为一个全局变量，通过 script 标签来访问（libraryTarget:’var’）。 this：通过 this 对象访问（libraryTarget:’this’）。 window：通过 window 对象访问，在浏览器中（libraryTarget:’window’）。 UMD：在 AMD 或 CommonJS 的 require 之后可访问（libraryTarget:’umd’）。如果设置了 library 但没设置 libraryTarget，则 libraryTarget 默认为 var shimming一些第三方的库(library)可能会引用一些全局依赖（例如 jQuery 中的 \\$）。这些库也可能创建一些需要被导出的全局变量。这些“不符合规范的模块”就是 shimming 发挥作用的地方。 shimming 全局变量使用 ProvidePlugin 后，能够在通过 webpack 编译的每个模块中，通过访问一个变量来获取到 package 包。如果 webpack 知道这个变量在某个模块中被使用了，那么 webpack 将在最终 bundle 中引入我们给定的 package。我们还可以使用 ProvidePlugin 暴露某个模块中单个导出值，只需通过一个“数组路径”进行配置（例如 [module, child, …children?]） src/index.js 12345678910 function component() &#123; var element = document.createElement('div');- element.innerHTML = _.join(['Hello', 'webpack'], ' ');+ element.innerHTML = join(['Hello', 'webpack'], ' '); return element; &#125; document.body.appendChild(component()); webpack.config.js 12345678910111213141516 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, plugins: [ new webpack.ProvidePlugin(&#123;- _: 'lodash'+ join: ['lodash', 'join'] &#125;) ] &#125;; 这样，无论 join 方法在何处调用，我们都只会得到的是 lodash 中提供的 join 方法。与 tree shaking 配合，能够很好的将 lodash 库中的其他没用到的部分去除。 细粒度 shimming一些传统的模块依赖的 this 指向的是 window 对象。当模块运行在 CommonJS 环境下这将会变成一个问题，也就是说此时的 this 指向的是 module.exports。此时，可以通过使用 imports-loader 覆写 this： 1234567891011121314151617181920212223 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;,+ module: &#123;+ rules: [+ &#123;+ test: require.resolve('index.js'),+ use: 'imports-loader?this=&gt;window'+ &#125;+ ]+ &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 全局 exports使用 exports-loader，将一个全局变量作为一个普通的模块来导出。 12345678910111213141516171819202122232425262728 const path = require('path'); const webpack = require('webpack'); module.exports = &#123; entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'dist') &#125;, module: &#123; rules: [ &#123; test: require.resolve('index.js'), use: 'imports-loader?this=&gt;window'- &#125;+ &#125;,+ &#123;+ test: require.resolve('globals.js'),+ use: 'exports-loader?file,parse=helpers.parse'+ &#125; ] &#125;, plugins: [ new webpack.ProvidePlugin(&#123; join: ['lodash', 'join'] &#125;) ] &#125;; 渐进式网络应用程序渐进式网络应用程序(Progressive Web Application - PWA)，是一种可以提供类似于原生应用程序(native app)体验的网络应用程序(web app)。PWA 可以用来做很多事。其中最重要的是，在离线(offline)时应用程序能够继续运行功能。这是通过使用名为 Service Workers 的网络技术来实现的。 添加 Workbox 注册 Service Worker 停止服务器并刷新页面。如果浏览器能够支持 Service Worker，你应该可以看到你的应用程序还在正常运行。然而，服务器已经停止了服务，此刻是 Service Worker 在提供服务。 构建性能chunks减少编译的整体大小，以提高构建性能。尽量保持 chunks 小巧。 使用 更少/更小 的库。 在多页面应用程序中使用 CommonsChunksPlugin。 在多页面应用程序中以 async 模式使用 CommonsChunksPlugin 。 移除不使用的代码。 只编译你当前正在开发部分的代码。 最小化入口 chunkwebpack 只会在文件系统中生成已经更新的 chunk 。对于某些配置选项(HMR, [name]/[chunkhash] in output.chunkFilename, [hash])来说，除了更新的 chunks 无效之外，入口 chunk 也不会生效。应当在生成入口 chunk 时，尽量减少入口 chunk 的体积，以提高性能。下述代码块将只提取包含 runtime 的 chunk ，其他 chunk 都作为子模块: 1234new CommonsChunkPlugin(&#123; name: \"manifest\", minChunks: Infinity&#125;); Worker Poolthread-loader 可以将非常消耗资源的 loaders 转存到 worker pool 中 持久化缓存使用 cache-loader 启用持久化缓存。使用 package.json 中的 “postinstall” 清除缓存目录。 Dlls使用 DllPlugin 将更改不频繁的代码进行单独编译。这将改善引用程序的编译速度，即使它增加了构建过程的复杂性。 公共路径(public path)webpack 提供一个非常有用的配置，该配置能帮助你为项目中的所有资源指定一个基础路径。它被称为公共路径(publicPath)。webpack 提供一个全局变量供你设置，它名叫 webpack_public_path 1__webpack_public_path__ = process.env.ASSET_PATH;","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"webpack基础知识（一）","slug":"webpack基础知识（一）","date":"2018-11-25T04:03:08.000Z","updated":"2019-04-08T04:39:56.589Z","comments":true,"path":"2018/11/25/webpack基础知识（一）/","link":"","permalink":"http://yoursite.com/2018/11/25/webpack基础知识（一）/","excerpt":"基本概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的，会以正确顺序执行的 bundle。","text":"基本概念webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。通过声明模块所需的依赖，webpack 能够利用这些信息去构建依赖图，然后使用图生成一个优化过的，会以正确顺序执行的 bundle。 依赖图(dependency graph)任何时候，一个文件依赖于另一个文件，webpack 就把此视为文件之间有 依赖关系 。这使得 webpack 可以接收非代码资源(non-code asset)（例如图像或 web 字体），并且可以把它们作为 _依赖_ 提供给你的应用程序。 webpack 从命令行或配置文件中定义的一个模块列表开始，处理你的应用程序。 从这些 入口起点 开始，webpack 递归地构建一个 依赖图 ，这个依赖图包含着应用程序所需的每个模块，然后将所有这些模块打包为少量的 bundle - 通常只有一个 - 可由浏览器加载。 入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 123module.exports = &#123; entry: \"./path/to/my/entry/file.js\"&#125;; 入口配置支持： 单个入口语法注：向 entry 传入一个「文件路径(file path)数组」时将创建“多个主入口(multi-main entry)”。在你想要多个依赖文件一起注入，并且将它们的依赖导向(graph)到一个“chunk”时，传入数组的方式就很有用。 对象语法这是应用程序中定义入口的最可扩展的方式。 出口(output)output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。你可以通过在配置中指定一个 output 字段，来配置这些处理过程： 123456789const path = require(\"path\");module.exports = &#123; entry: \"./path/to/my/entry/file.js\", output: &#123; path: path.resolve(__dirname, \"dist\"), filename: \"my-first-webpack.bundle.js\" &#125;&#125;; filename 用于输出文件的文件名。目标输出目录 path 的绝对路径。 注：如果配置创建了多个单独的 “chunk”（例如，使用多个入口起点或使用像 CommonsChunkPlugin 这样的插件），则应该使用占位符(substitutions)来确保每个文件具有唯一的名称。 设定 HtmlWebpackPlugin，虽然在 dist/ 文件夹我们已经有 index.html 这个文件，然而 HtmlWebpackPlugin 还是会默认生成 index.html 文件。这就是说，它会用新生成的 index.html 文件，把我们的原来的替换。 使用 source map当 webpack 打包源代码时，可能会很难追踪到错误和警告在源代码中的原始位置。例如，如果将三个源文件（a.js, b.js 和 c.js）打包到一个 bundle（bundle.js）中，而其中一个源文件包含一个错误，那么堆栈跟踪就会简单地指向到 bundle.js。为了更容易地追踪错误和警告，JavaScript 提供了 source map 功能，将编译后的代码映射回原始源代码。如果一个错误来自于 b.js，source map 就会明确的告诉你。 loaderloader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 本质上，webpack loader 将所有类型的文件，转换为应用程序的依赖图（和最终的 bundle）可以直接引用的模块。 在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 123456789101112const path = require(\"path\");const config = &#123; output: &#123; filename: \"my-first-webpack.bundle.js\" &#125;, module: &#123; rules: [&#123; test: /\\.txt$/, use: \"raw-loader\" &#125;] &#125;&#125;;module.exports = config; 在你的应用程序中，有三种使用 loader 的方式： 配置（推荐）：在 webpack.config.js 文件中指定 loader。module.rules 允许你在 webpack 配置中指定多个 loader。 这是展示 loader 的一种简明方式，并且有助于使代码变得简洁。同时让你对各个 loader 有个全局概览 内联：在每个 import 语句中显式指定 loader。可以在 import 语句或任何等效于 “import” 的方式中指定 loader。使用 ! 将资源中的 loader 分开。分开的每个部分都相对于当前目录解析。 CLI：在 shell 命令中指定它们。 loader 特性： loader 支持链式传递。能够对资源使用流水线(pipeline)。一组链式的 loader 将按照相反的顺序执行。loader 链中的第一个 loader 返回值给下一个 loader。在最后一个 loader，返回 webpack 所预期的 JavaScript。 loader 可以是同步的，也可以是异步的。 loader 运行在 Node.js 中，并且能够执行任何可能的操作。 loader 接收查询参数。用于对 loader 传递配置。 loader 也能够使用 options 对象进行配置。 除了使用 package.json 常见的 main 属性，还可以将普通的 npm 模块导出为 loader，做法是在 package.json 里定义一个 loader 字段。 插件(plugin)可以为 loader 带来更多特性。 loader 能够产生额外的任意文件。 插件(plugins)loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。插件接口功能极其强大，可以用来处理各种各样的任务。插件目的在于解决 loader 无法实现的其他事。 1234567891011const HtmlWebpackPlugin = require(\"html-webpack-plugin\"); // 通过 npm 安装const webpack = require(\"webpack\"); // 用于访问内置插件const config = &#123; module: &#123; rules: [&#123; test: /\\.txt$/, use: \"raw-loader\" &#125;] &#125;, plugins: [new HtmlWebpackPlugin(&#123; template: \"./src/index.html\" &#125;)]&#125;;module.exports = config; 用法：用 require（）引入由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。 模式提供 mode 配置选项，告知 webpack 使用相应模式的内置优化。通过选择 development 或 production 之中的一个，来设置 mode 参数，可以启用相应模式下的 webpack 内置的优化 用法： 只在配置中提供 mode 选项： 123module.exports = &#123; mode: \"production\"&#125;; 从 CLI 参数中传递： 1webpack --mode=production 模块热替换(hot module replacement)模块热替换(HMR - Hot Module Replacement)功能会在应用程序运行过程中替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度： 保留在完全重新加载页面时丢失的应用程序状态。 只更新变更内容，以节省宝贵的开发时间。 调整样式更加快速 - 几乎相当于在浏览器调试器中更改样式。 tree shaking通常用于描述移除 JavaScript 上下文中的未引用代码(dead-code)。它依赖于 ES2015 模块系统中的静态结构特性，例如 import 和 export。 如果所有代码都不包含副作用，我们就可以简单地将 package.json 的 “sideEffects” 属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。注：「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export。 如果你的代码确实有一些副作用，那么可以改为提供一个数组： 123456&#123; \"name\": \"your-project\", \"sideEffects\": [ \"./src/some-side-effectful-file.js\" ]&#125; 数组方式支持相关文件的相对路径、绝对路径和 glob 模式。它在内部使用 micromatch。 注意，任何导入的文件都会受到 tree shaking 的影响。这意味着，如果在项目中使用类似 css-loader 并导入 CSS 文件，则需要将其添加到 side effect 列表中，以免在生产模式中无意中将它删除。 从 webpack 4 开始，也可以通过 “mode” 配置选项轻松切换到压缩输出，只需设置为 “production”。","categories":[{"name":"前端工具","slug":"前端工具","permalink":"http://yoursite.com/categories/前端工具/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"React组件","slug":"React组件","date":"2018-11-11T04:10:52.000Z","updated":"2019-03-22T06:57:04.956Z","comments":true,"path":"2018/11/11/React组件/","link":"","permalink":"http://yoursite.com/2018/11/11/React组件/","excerpt":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上）","text":"Web Copmpoents React 组件 React 组件： 自定义元素是库自己构建的 渲染过程包含了模版的概念 实现均在方法与类中，相互隔离（不包括样式） 引用方式遵循 ES6 构建： React 方式：creatClass ES6 方式：class 无状态函数 React 底层——合成事件事件委派把事件处理函数绑定到结构的最外层，使用一个统一的事件监听器。（不会把事件处理函数直接绑定到真实的节点上） 自动绑定每个方法的上下文都会指向该组件的实例——自动绑定 this 为当前组件。React 会对这种引用进行缓存，达到 CPU 内存最优。（使用 ES6 class 或纯函数时，自动绑定不复存在，需要手动绑定 this） bind 绑定绑定事件处理器内的 this，并可以向事件处理器中传参 构造器内声明好处：仅需进行一次绑定 箭头函数箭头函数自动绑定了定义此函数作用域的 this，因此不需要再用 bind 绑定 注意：React 中使用 DOM 原生事件，一定要在组件卸载时手动移除，否则内存泄漏。使用合成事件则不需要。 React 合成事件与 JS 原生事件对比原生 DOM 事件传播 3 个阶段：事件捕获阶段、目标对象本身的事件处理程序调用，以及事件冒泡。 事件捕获阶段会优先调用结构树最外层的元素上绑定的事件侦听器，依次向内调用，一直调用到目标元素上的事件监听器为止。 1e.addEventListener(\"click\", () =&gt; &#123;&#125;, false); 第三个参数，若传 true，为元素 e 注册捕获事件处理程序，并且在事件捕获阶段调用。 事件冒泡与事件捕获相反，它会从目标元素向外传播，由内而外。React 的合成事件仅支持事件冒泡阻止原生事件冒泡用 e.preventDefault() React 受控组件更新 state 的流程 可以通过在初始 state 中设置表单的默认值 每当表单的值发生变化时，调用 onchange 事件处理器 事件处理器通过合成事件对象 e 拿到改变后的状态，并更行应用的 state setState 触发视图的重新渲染，完成表单的组件值更新 React 非受控组件是一种反模式，他的值不受组件自身的 state 或 props 控制。通常需要为其添加 ref prop 来访问渲染后的底层 DOM","categories":[{"name":"React","slug":"React","permalink":"http://yoursite.com/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"浏览器缓存位置","slug":"浏览器缓存位置","date":"2018-11-01T15:10:55.000Z","updated":"2019-08-15T10:31:10.153Z","comments":true,"path":"2018/11/01/浏览器缓存位置/","link":"","permalink":"http://yoursite.com/2018/11/01/浏览器缓存位置/","excerpt":"浏览器缓存位置缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache","text":"浏览器缓存位置缓存位置从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。 Service Worker Memory Cache Disk Cache Push Cache 1.Service WorkerService Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。使用 Service Worker 的话，传输协议必须为 HTTPS。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。 Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。 当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。也就是说，如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。 2.Memory CacheMemory Cache 也就是内存中的缓存，主要包含的是当前中页面中已经抓取到的资源, 例如页面上已经下载的样式、脚本、图片等。读取内存中的数据肯定比磁盘快, 内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。 那么既然内存缓存这么高效，我们是不是能让数据都存放在内存中呢？这是不可能的。计算机中的内存一定比硬盘容量小得多，操作系统需要精打细算内存的使用，所以能让我们使用的内存必然不多。 当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存。 内存缓存中有一块重要的缓存资源是 preloader 相关指令（例如&lt;link rel=&quot;prefetch&quot;&gt;）下载的资源。众所周知 preloader 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。 需要注意的事情是，内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 Cache-Control 是什么值，同时资源的匹配也并非仅仅是对 URL 做匹配，还可能会对 Content-Type，CORS 等其他特征做校验。 3.Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。 在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 Disk Cache，关于 HTTP 的协议头中的缓存字段，我们会在下文进行详细介绍。 浏览器会把哪些文件丢进内存中？哪些丢进硬盘中？关于这点，网上说法不一，不过以下观点比较靠得住： 对于大文件来说，大概率是不存储在内存中的，反之优先； 当前系统内存使用率高的话，文件优先存储进硬盘。 4.Push CachePush Cache（推送缓存）是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome 浏览器中只有 5 分钟左右，同时它也并非严格执行 HTTP 头中的缓存指令。 Push Cache 在国内能够查到的资料很少，也是因为 HTTP/2 在国内不够普及。这里推荐阅读Jake Archibald的 HTTP/2 push is tougher than I thought 这篇文章，文章中的几个结论： 所有的资源都能被推送，并且能够被缓存, 但是 Edge 和 Safari 浏览器支持相对比较差； 可以推送 no-cache 和 no-store 的资源； 一旦连接被关闭，Push Cache 就被释放； 多个页面可以使用同一个 HTTP/2 的连接，也就可以使用同一个 Push Cache。这主要还是依赖浏览器的实现而定，出于对性能的考虑，有的浏览器会对相同域名但不同的 tab 标签使用同一个 HTTP 连接； Push Cache 中的缓存只能被使用一次； 浏览器可以拒绝接受已经存在的资源推送； 你可以给其他域名推送资源。 如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。 那么为了性能上的考虑，大部分的接口都应该选择好缓存策略，通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。 http 状态码与缓存策略200 from memory cache不访问服务器，直接读缓存，从内存中读取缓存。此时的数据时缓存到内存中的，当 kill 进程后，也就是浏览器关闭以后，数据将不存在。 但是这种方式只能缓存派生资源 200 from disk cache不访问服务器，直接读缓存，从磁盘中读取缓存，当 kill 进程时，数据还是存在。 这种方式也只能缓存派生资源 304 Not Modified访问服务器，发现数据没有 更新，服务器返回此状态码。然后从缓存中读取数据。 三级缓存原理 先去内存看，如果有，直接加载 如果内存没有，择取硬盘获取，如果有直接加载 如果硬盘也没有，那么就进行网络请求 加载到的资源缓存到硬盘和内存 常见缓存情况 第一个现象： 访问-&gt; 200 -&gt; 退出浏览器 再进来-&gt; 200(from disk cache) -&gt; 刷新 -&gt; 200(from memory cache) 总结: 会不会是 chrome 很聪明的判断既然已经从 disk 拿来了， 第二次就内存拿吧 快。（笑哭) 第二个现象: 只要图片是 base64 都是 from memroy cache。 总结: 解析渲染图片这么费劲的事情，还是做一次然后放到内存吧。 用的时候直接拿 第三个现象(以 js css 为例): 个人在做静态测试的发现，大型的 js css 文件都是直接 disk cache 总结: chrome 会不会说 我擦 你这么大 太 JB 占地方了。 你就去硬盘里呆着吧。 慢就慢点吧。 第四个现象: 隐私模式下，几乎都是 from memroy cache. 总结: 隐私模式 是吧。 我不能暴露你东西。还是放到内存吧。 你关，我死。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"Proxy","slug":"Proxy","date":"2018-10-27T03:07:46.000Z","updated":"2019-03-22T07:02:55.682Z","comments":true,"path":"2018/10/27/Proxy/","link":"","permalink":"http://yoursite.com/2018/10/27/Proxy/","excerpt":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。","text":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是 handler 参数的写法。其中，new Proxy()表示生成一个 Proxy 实例，target 参数表示所要拦截的目标对象，handler 参数也是一个对象，用来定制拦截行为。 下面是一个拦截读取属性行为的例子。 123456789101112var proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125; &#125;);proxy.time; // 35proxy.name; // 35proxy.title; // 35 上面代码中，作为构造函数，Proxy 接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有 Proxy 的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个 get 方法，用来拦截对目标对象属性的访问请求。get 方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回 35，所以访问任何属性都得到 35。注意，要使得 Proxy 起作用，必须针对 Proxy 实例（上例是 proxy 对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。如果 handler 没有设置任何拦截，那就等同于直接通向原对象。同一个拦截器函数，可以设置拦截多个操作。 12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === \"prototype\") &#123; return Object.prototype; &#125; return \"Hello, \" + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123; value: args[1] &#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2); // 1new fproxy(1, 2); // &#123;value: 2&#125;fproxy.prototype === Object.prototype; // truefproxy.foo === \"Hello, foo\"; // true Proxy 支持的拦截操作一览Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)拦截对象属性的读取，比如 proxy.foo 和 proxy[‘foo’]。 set(target, propKey, value, receiver)拦截对象属性的设置，比如 proxy.foo = v 或 proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)拦截 propKey in proxy 的操作，返回一个布尔值。 deleteProperty(target, propKey)拦截 delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in 循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而 Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)拦截 Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)拦截 Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)拦截 Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)拦截 Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)拦截 Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)拦截 Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)拦截 Proxy 实例作为函数调用的操作，比如 proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)拦截 Proxy 实例作为构造函数调用的操作，比如 new proxy(…args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get 方法用于拦截某个属性的读取操作，可以接受三个参数，依次为目标对象、属性名和 proxy 实例本身（严格地说，它总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例），其中最后一个参数可选。 12345678910111213141516var person = &#123; name: \"张三\"&#125;;var proxy = new Proxy(person, &#123; get: function(target, property) &#123; if (property in target) &#123; return target[property]; &#125; else &#123; throw new ReferenceError('Property \"' + property + '\" does not exist.'); &#125; &#125;&#125;);proxy.name; // \"张三\"proxy.age; // 抛出一个错误 get 方法可以继承。 123456789101112let proto = new Proxy( &#123;&#125;, &#123; get(target, propertyKey, receiver) &#123; console.log(\"GET \" + propertyKey); return target[propertyKey]; &#125; &#125;);let obj = Object.create(proto);obj.foo; // \"GET foo\" 上面代码中，拦截操作定义在 Prototype 对象上面，所以如果读取 obj 对象继承的属性时，拦截会生效。利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 1234567891011121314151617181920212223242526272829303132var pipe = (function() &#123; return function(value) &#123; var funcStack = []; var oproxy = new Proxy( &#123;&#125;, &#123; get: function(pipeObject, fnName) &#123; if (fnName === \"get\") &#123; return funcStack.reduce(function(val, fn) &#123; return fn(val); &#125;, value); &#125; funcStack.push(window[fnName]); return oproxy; &#125; &#125; ); return oproxy; &#125;;&#125;)();var double = n =&gt; n * 2;var pow = n =&gt; n * n;var reverseInt = n =&gt; n .toString() .split(\"\") .reverse() .join(\"\") | 0;pipe(3).double.pow.reverseInt.get; // 63 下面是一个 get 方法的第三个参数的例子 1234567891011const proxy = new Proxy( &#123;&#125;, &#123; get: function(target, property, receiver) &#123; return receiver; &#125; &#125;);const d = Object.create(proxy);d.a === d; // true 上面代码中，d 对象本身没有 a 属性，所以读取 d.a 的时候，会去 d 的原型 proxy 对象找。这时，receiver 就指向 d，代表原始的读操作所在的那个对象。如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。 123456789101112131415161718192021const target = Object.defineProperties( &#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125; &#125;);const handler = &#123; get(target, propKey) &#123; return \"abc\"; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo;// TypeError: Invariant check failed set()set 方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象、属性名、属性值和 Proxy 实例本身，其中最后一个参数可选。利用 set 方法，可以进行数据验证，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合 get 和 set 方法，就可以做到防止这些内部属性被外部读写。 12345678910111213141516171819202122const handler = &#123; get(target, key) &#123; invariant(key, \"get\"); return target[key]; &#125;, set(target, key, value) &#123; invariant(key, \"set\"); target[key] = value; return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;const target = &#123;&#125;;const proxy = new Proxy(target, handler);proxy._prop;// Error: Invalid attempt to get private \"_prop\" propertyproxy._prop = \"c\";// Error: Invalid attempt to set private \"_prop\" property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。下面是 set 方法第四个参数的例子。 1234567891011const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = receiver; &#125;&#125;;const proxy = new Proxy(&#123;&#125;, handler);const myObj = &#123;&#125;;Object.setPrototypeOf(myObj, proxy);myObj.foo = \"bar\";myObj.foo === myObj; // true 上面代码中，设置 myObj.foo 属性的值时，myObj 并没有 foo 属性，因此引擎会到 myObj 的原型链去找 foo 属性。myObj 的原型对象 proxy 是一个 Proxy 实例，设置它的 foo 属性会触发 set 方法。这时，第四个参数 receiver 就指向原始赋值行为所在的对象 myObj。如果目标对象自身的某个属性，不可写且不可配置，那么 set 方法将不起作用。 123456789101112131415const obj = &#123;&#125;;Object.defineProperty(obj, \"foo\", &#123; value: \"bar\", writable: false&#125;);const handler = &#123; set: function(obj, prop, value, receiver) &#123; obj[prop] = \"baz\"; &#125;&#125;;const proxy = new Proxy(obj, handler);proxy.foo = \"baz\";proxy.foo; // \"bar\" apply()apply 方法拦截函数的调用、call 和 apply 操作。apply 方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 12345678910111213var target = function() &#123; return \"I am the target\";&#125;;var handler = &#123; apply: function() &#123; return \"I am the proxy\"; &#125;&#125;;var p = new Proxy(target, handler);p();// \"I am the proxy\" 上面代码中，变量 p 是 Proxy 的实例，当它作为函数调用时（p()），就会被 apply 方法拦截，返回一个字符串。另外，直接调用 Reflect.apply 方法，也会被拦截。 has()has 方法用来拦截 HasProperty 操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是 in 运算符。has 方法可以接受两个参数，分别是目标对象、需查询的属性名。下面的例子使用 has 方法隐藏某些属性，不被 in 运算符发现。 1234567891011var handler = &#123; has(target, key) &#123; if (key[0] === \"_\") &#123; return false; &#125; return key in target; &#125;&#125;;var target = &#123; _prop: \"foo\", prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);\"_prop\" in proxy; // false 如果原对象不可配置或者禁止扩展，这时 has 拦截会报错。 12345678910var obj = &#123; a: 10 &#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; has: function(target, prop) &#123; return false; &#125;&#125;);\"a\" in p; // TypeError is thrown 上面代码中，obj 对象禁止扩展，结果使用 has 拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则 has 方法就不得“隐藏”（即返回 false）目标对象的该属性。has 方法拦截的是 HasProperty 操作，而不是 HasOwnProperty 操作，即 has 方法不判断一个属性是对象自身的属性，还是继承的属性。另外，虽然 for…in 循环也用到了 in 运算符，但是 has 拦截对 for…in 循环不生效。 construct()construct 方法用于拦截 new 命令，下面是拦截对象的写法。 12345var handler = &#123; construct(target, args, newTarget) &#123; return new target(...args); &#125;&#125;; construct 方法可以接受三个参数。target：目标对象。args：构造函数的参数对象。newTarget：创造实例对象时，new 命令作用的构造函数。construct 方法返回的必须是一个对象，否则会报错。 12345678910var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, args) &#123; console.log(\"called: \" + args.join(\", \")); return &#123; value: args[0] * 10 &#125;; &#125;&#125;);new p(1).value;// \"called: 1\"// 10 1234567var p = new Proxy(function() &#123;&#125;, &#123; construct: function(target, argumentsList) &#123; return 1; &#125;&#125;);new p(); // 报错 deleteProperty()deleteProperty 方法用于拦截 delete 操作，如果这个方法抛出错误或者返回 false，当前属性就无法被 delete 命令删除。 12345678910111213141516var handler = &#123; deleteProperty(target, key) &#123; invariant(key, \"delete\"); return true; &#125;&#125;;function invariant(key, action) &#123; if (key[0] === \"_\") &#123; throw new Error(`Invalid attempt to $&#123;action&#125; private \"$&#123;key&#125;\" property`); &#125;&#125;var target = &#123; _prop: \"foo\" &#125;;var proxy = new Proxy(target, handler);delete proxy._prop;// Error: Invalid attempt to delete private \"_prop\" property deleteProperty 方法拦截了 delete 操作符，删除第一个字符为下划线的属性会报错。注意，目标对象自身的不可配置（configurable）的属性，不能被 deleteProperty 方法删除，否则报错。 defineProperty()defineProperty 方法拦截了 Object.defineProperty 操作。 12345678var handler = &#123; defineProperty(target, key, descriptor) &#123; return false; &#125;&#125;;var target = &#123;&#125;;var proxy = new Proxy(target, handler);proxy.foo = \"bar\"; // 不会生效 defineProperty 方法返回 false，导致添加新属性总是无效。注意，如果目标对象不可扩展（extensible），则 defineProperty 不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则 defineProperty 方法不得改变这两个设置。 getOwnPropertyDescriptor()getOwnPropertyDescriptor 方法拦截 Object.getOwnPropertyDescriptor()，返回一个属性描述对象或者 undefined。 12345678910111213141516var handler = &#123; getOwnPropertyDescriptor(target, key) &#123; if (key[0] === \"_\") &#123; return; &#125; return Object.getOwnPropertyDescriptor(target, key); &#125;&#125;;var target = &#123; _foo: \"bar\", baz: \"tar\" &#125;;var proxy = new Proxy(target, handler);Object.getOwnPropertyDescriptor(proxy, \"wat\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"_foo\");// undefinedObject.getOwnPropertyDescriptor(proxy, \"baz\");// &#123; value: 'tar', writable: true, enumerable: true, configurable: true &#125; handler.getOwnPropertyDescriptor 方法对于第一个字符为下划线的属性名会返回 undefined。 getPrototypeOf()getPrototypeOf 方法主要用来拦截获取对象原型。具体来说，拦截下面这些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof 12345678910var proto = &#123;&#125;;var p = new Proxy( &#123;&#125;, &#123; getPrototypeOf(target) &#123; return proto; &#125; &#125;);Object.getPrototypeOf(p) === proto; // true getPrototypeOf 方法的返回值必须是对象或者 null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf 方法必须返回目标对象的原型对象。 isExtensible()isExtensible 方法拦截 Object.isExtensible 操作 12345678910111213var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; console.log(\"called\"); return true; &#125; &#125;);Object.isExtensible(p);// \"called\"// true 该方法只能返回布尔值，否则返回值会被自动转为布尔值。这个方法有一个强限制，它的返回值必须与目标对象的 isExtensible 属性保持一致，否则就会抛出错误。 1234567891011var p = new Proxy( &#123;&#125;, &#123; isExtensible: function(target) &#123; return false; &#125; &#125;);Object.isExtensible(p); // 报错Object.isExtensible(proxy) === Object.isExtensible(target); //true ownKeys()ownKeys 方法用来拦截对象自身属性的读取操作。具体来说，拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() for…in 循环 12345678910111213141516let target = &#123; a: 1, b: 2, c: 3&#125;;let handler = &#123; ownKeys(target) &#123; return [\"a\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// [ 'a' ] 注意，使用 Object.keys 方法时，有三类属性会被 ownKeys 方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 123456789101112131415161718192021222324let target = &#123; a: 1, b: 2, c: 3, [Symbol.for(\"secret\")]: \"4\"&#125;;Object.defineProperty(target, \"key\", &#123; enumerable: false, configurable: true, writable: true, value: \"static\"&#125;);let handler = &#123; ownKeys(target) &#123; return [\"a\", \"d\", Symbol.for(\"secret\"), \"key\"]; &#125;&#125;;let proxy = new Proxy(target, handler);Object.keys(proxy);// ['a'] 上面代码中，ownKeys 方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for(‘secret’)）、不可遍历的属性（key），结果都被自动过滤掉。 123456789101112131415161718192021222324//ownKeys方法还可以拦截Object.getOwnPropertyNames()var p = new Proxy( &#123;&#125;, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\", \"c\"]; &#125; &#125;);Object.getOwnPropertyNames(p);// [ 'a', 'b', 'c' ]//for...in循环也受到ownKeys方法的拦截const obj = &#123; hello: \"world\" &#125;;const proxy = new Proxy(obj, &#123; ownKeys: function() &#123; return [\"a\", \"b\"]; &#125;&#125;);for (let key in proxy) &#123; console.log(key); // 没有任何输出&#125; 上面代码中，ownkeys 指定只返回 a 和 b 属性，由于 obj 没有这两个属性，因此 for…in 循环不会有任何输出。ownKeys 方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。 12345678910var obj = &#123;&#125;;var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [123, true, undefined, null, &#123;&#125;, []]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 123 is not a valid property name 如果目标对象自身包含不可配置的属性，则该属性必须被 ownKeys 方法返回，否则报错。 123456789101112131415var obj = &#123;&#125;;Object.defineProperty(obj, \"a\", &#123; configurable: false, enumerable: true, value: 10&#125;);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap result did not include 'a' 如果目标对象是不可扩展的（non-extensition），这时 ownKeys 方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。 1234567891011121314var obj = &#123; a: 1&#125;;Object.preventExtensions(obj);var p = new Proxy(obj, &#123; ownKeys: function(target) &#123; return [\"a\", \"b\"]; &#125;&#125;);Object.getOwnPropertyNames(p);// Uncaught TypeError: 'ownKeys' on proxy: trap returned extra keys but proxy target is non-extensible preventExtensions()preventExtensions 方法拦截 Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。这个方法有一个限制，只有目标对象不可扩展时（即 Object.isExtensible(proxy)为 false），proxy.preventExtensions 才能返回 true，否则会报错。 1234567891011121314151617181920212223242526var p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; return true; &#125; &#125;);Object.preventExtensions(p); // 报错//为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensionsvar p = new Proxy( &#123;&#125;, &#123; preventExtensions: function(target) &#123; console.log(\"called\"); Object.preventExtensions(target); return true; &#125; &#125;);Object.preventExtensions(p);// \"called\"// true setPrototypeOf()setPrototypeOf 方法主要用来拦截 Object.setPrototypeOf 方法。 12345678910var handler = &#123; setPrototypeOf(target, proto) &#123; throw new Error(\"Changing the prototype is forbidden\"); &#125;&#125;;var proto = &#123;&#125;;var target = function() &#123;&#125;;var proxy = new Proxy(target, handler);Object.setPrototypeOf(proxy, proto);// Error: Changing the prototype is forbidden 上面代码中，只要修改 target 的原型对象，就会报错。注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf 方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable 方法返回一个可取消的 Proxy 实例 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123; proxy, revoke &#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo; // 123revoke();proxy.foo; // TypeError: Revoked Proxy.revocable 方法返回一个对象，该对象的 proxy 属性是 Proxy 实例，revoke 属性是一个函数，可以取消 Proxy 实例。上面代码中，当执行 revoke 函数之后，再访问 Proxy 实例，就会抛出一个错误。Proxy.revocable 的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的 this 关键字会指向 Proxy 代理。 1234567891011const target = &#123; m: function() &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m(); // falseproxy.m(); // true","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"浏览器缓存机制","slug":"浏览器缓存机制","date":"2018-10-20T07:23:45.000Z","updated":"2019-08-15T10:30:59.885Z","comments":true,"path":"2018/10/20/浏览器缓存机制/","link":"","permalink":"http://yoursite.com/2018/10/20/浏览器缓存机制/","excerpt":"浏览器缓存机制概念浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。（浏览器缓存分为强缓存和协商缓存）","text":"浏览器缓存机制概念浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据，整体上加速网页展示给用户。（浏览器缓存分为强缓存和协商缓存） 浏览器缓存机制要素： 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识； 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。 九种浏览器缓存：http 缓存http 缓存是基于 HTTP 协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件。主要是针对重复的 http 请求，在有缓存的情况下判断过程主要分 3 步：判断 expires，如果未过期，直接读取 http 缓存文件，不发 http 请求，否则进入下一步；判断是否含有 etag，有则带上 if-none-match 发送请求，未修改返回 304，修改返回 200，否则进入下一步；判断是否含有 last-modified，有则带上 if-modified-since 发送请求，无效返回 200，有效返回 304，否则直接向服务器请求 websql它是将数据以数据库的形式存储在客户端，根据需求去读取；跟 Storage 的区别是： Storage 和 Cookie 都是以键值对的形式存在的。 indexDBIndexedDB 是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的 API。同步 API 本来是要用于仅供 Web Workers 内部使用，但是还没有被任何浏览器所实现。异步 API 在 Web Workers 内部和外部都可以使用，另外浏览器可能对 indexDB 有 50M 大小的限制，一般用户保存大量用户数据并要求数据之间有搜索需要的场景。 Cookie指一般网站为了辨别用户身份、进行 session 跟踪而储存在用户本地终端上的数据（通常经过加密）。cookie 一般通过 http 请求中在头部一起发送到服务器端。一条 cookie 记录主要由键、值、域、过期时间、大小组成，一般用于保存用户的认证信息。cookie 最大长度和域名个数由不同浏览器决定。不同域名之间的 cookie 信息是独立的，如果需要设置共享可以在服务器端设置 cookie 的 path 和 domain 来实现共享。浏览器端也可以通过 document.cookie 来获取 cookie，并通过 js 浏览器端也可以方便地读取/设置 cookie 的值。（Cookie 只能存储少量的数据，每个 Cookie 的大小不超过 4KB。RFC 标准不允许浏览器保存超过 300 个 Cookie，为每个 web 服务器保存的 Cookie 数不超过 20 个。JavaScript 中使用 Cookie 不会采用任何加密机制，因此它们是不安全的。） LocalstoragelocalStorage 是 html5 的一种新的本地缓存方案，目前用的比较多，一般用来存储 ajax 返回的数据，加快下次页面打开时的渲染速度。 SessionstoragesessionStorage 和 localstorage 类似，但是浏览器关闭则会全部删除，api 和 localstorage 相同，实际项目中使用较少。 application cacheapplication cahce 是将大部分图片资源、js、css 等静态资源放在 manifest 文件配置中。当页面打开时通过 manifest 文件来读取本地文件或是请求服务器文件。在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。并在下一次生效。离线的情况下，浏览器就直接使用离线存储的资源。 cacheStorageCacheStorage 是在 ServiceWorker 的规范中定义的。CacheStorage 可以保存每个 serverWorker 申明的 cache 对象，cacheStorage 有 open、match、has、delete、keys 五个核心方法，可以对 cache 对象的不同匹配进行不同的响应。 flash 缓存这种方式基本不用，这一方法主要基于 flash 有读写浏览器端本地目录的功能，同时也可以向 js 提供调用的 api，则页面可以通过 js 调用 flash 去读写特定的磁盘目录，达到本地数据缓存的目的。 cookie 背景：早期 Web 开发面临的最大问题之一是如何管理状态。简言之，服务器端没有办法知道两个请求是否来自于同一个浏览器。那时的办法是在请求的页面中插入一个 token，并且在下一次请求中将这个 token 返回（至服务器）。这就需要在 form 中插入一个包含 token 的隐藏表单域，或着在 URL 的 qurey 字符串中传递该 token。这两种办法都强调手工操作并且极易出错。 内容：键、值、域、过期时间、大小 是否生效：expires 指定了 cookie 何时不会再被发送到服务器端的，因此该 cookie 可能会被浏览器删掉。（过期时间）在没有 expires 选项时，cookie 的寿命仅限于单一的会话中。浏览器的关闭意味这一次会话的结束，所以会话 cookie 只存在于浏览器保持打开的状态之下。如果 expires 选项设置了一个过去的时间点，那么这个 cookie 会被立即删除。 存在哪里：cookie 的值被存储在名为 Cookie 的 HTTP 消息头中，并且只包含了 cookie 的值，其它的选项全部被去除。 存放形式：Cookies 是纯文本形式。几乎所有的实现方式都对 cookie 的值进行了一些列的 URL 编码（但不是必须）。原始的文档中指示仅有三种类型的字符必须进行编码：分号，逗号，和空格。 不同域名之间的 cookie 信息是独立的，不会冲突。浏览器会对 domain 的值与请求所要发送至的域名，做一个尾部比较（即从字符串的尾部开始比较），并且在匹配后发送一个 Cookie 消息头。domain 设置的值必须是发送 Set-Cookie 消息头的域名。与 domain 选项相同的是，path 指明了在发 Cookie 消息头之前必须在请求资源中存在一个 URL 路径。这个比较是通过将 path 属性值与请求的 URL 从头开始逐字符串比较完成的。如果字符匹配，则发送 Cookie 消息头。只有在 domain 选项核实完毕之后才会对 path 属性进行比较。path 属性的默认值是发送 Set-Cookie 消息头所对应的 URL 中的 path 部分。path 值越详细则 cookie 越靠前。domain-path 越详细则 cookie 字符串越靠前。可以通过设置 Cookie 的 path 属性来修改 Cookie 的作用域，如果把 path 设为“/”，就等同于让 Cookie 拥有了 localStorage 的作用域，即整个文档源。 默认情况下，Cookie 对于创建它的页面，以及与该页面同目录或子目录下的其他 web 页面可见。在 a.example.com 下的一个页面设置了 Cookie，将其 path 设为“/”，并将 domain 设为“.example.com”，这样该 Cookie 就对 example.com 域下的所有页面可见。 创建和存储 Cookie：对 Cookie 的所有操作都要通过读写 document 对象的 Cookie 属性来完成。Cookie 的值都是以键值对的形式存储。同样的，如果要设置 path、domain 等属性，只须以如下形式追加到 Cookie 值的后面: ;path=path 1234567891011//创建一个名字Cookie，同时设置它的过期时间function setCookie(c_name, value, expiredays) &#123; var exdate = new Date(); exdate.setDate(exdate.getDate() + expiredays); //encodeURIComponent() 对 URI 进行编码 document.cookie = c_name + \"=\" + encodeURIComponent(value) + (expiredays == null ? \"\" : \";expires=\" + exdate.toGMTString());&#125; 读取 Cookie：使用 document.cookie 可以获取到 Cookie 的值，不过这个值是一个字符串，为了更好地查看 Cookie 的值，往往会采用 split()方法将 Cookie 中的名值对分离出来。 12345678910111213141516171819202122function getCookie() &#123; // 初始化要返回的对象 var cookie = &#123;&#125;; var all = document.cookie; if (all === null) &#123; return cookie; &#125; //分离出Cookie的各个属性 var list = all.split(\";\"); for (var i = 0; i &lt; list.length; i++) &#123; // 查询出等号所在的位置 var p = list[i].indexOf(\"=\"); // 分离出名字和值 var name = list[i].substring(0, p); var value = list[i].substring(p + 1); //对值进行解码 value = decodeURIComponent(value); // 将名值对存储到对象中 cookie[name] = value; &#125; return cookie;&#125; Localstorage 和 sessionstorageLocalstorage 和 sessionstorage 是做什么的？localstorage 怎么清除它？在代码层面怎么清除？setitem 的是什么数据类型？getitem 的值是什么数据类型？ 怎么清除 12localStorage.removeItem(key); //删除该域名下单条记录localStorage.clear(); //删除该域名下所有记录 存储格式：所有的数据都是以文本格式保存。其中 value 需为可转化为字符串的对象。localStorage 对象的键和值只能是字符串，假设我们要保存一个对象到 localStorage 中，可以使用拼接的方式。当然也可以借助 JSON 类，将对象转换成字符串保存，然后在取出来的时候将 json 字符串转换成真正可用的 json 对象格式 数据共享：不同浏览器无法共享 localStorage 或 sessionStorage 中的信息。相同浏览器的不同页面间可以共享相同的 localStorage（页面属于相同域名和端口），但是不同页面或标签页间无法共享 sessionStorage 的信息。","categories":[{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/categories/浏览器/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"浏览器","slug":"浏览器","permalink":"http://yoursite.com/tags/浏览器/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-10-14T07:55:35.000Z","updated":"2019-03-19T13:43:39.901Z","comments":true,"path":"2018/10/14/箭头函数/","link":"","permalink":"http://yoursite.com/2018/10/14/箭头函数/","excerpt":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。","text":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function(v) &#123; return v;&#125;; 参数部分如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 1234567891011var f = () =&gt; 5;// 等同于var f = function() &#123; return 5;&#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用 return 语句返回。 123var sum = (num1, num2) =&gt; &#123; return num1 + num2;&#125;; 返回对象由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 1234let foo = () =&gt; &#123; a: 1;&#125;;foo(); // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句 a: 1。这时，a 可以被解释为语句的标签，因此实际执行的语句是 1;，然后函数就结束了，没有返回值。箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + \" \" + last;// 等同于function full(person) &#123; return person.first + \" \" + person.last;&#125; 简化回调函数箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1, 2, 3].map(function(x) &#123; return x * x;&#125;);// 箭头函数写法[1, 2, 3].map(x =&gt; x * x); rest 参数与箭头函数结合123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5);// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5);// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用 new 命令，否则会抛出一个错误。 不可以使用 arguments 对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用 yield 命令，因此箭头函数不能用作 Generator 函数。上面四点中，第一点尤其值得注意。this 对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log(\"id:\", this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout 的参数是一个箭头函数，这个箭头函数的定义生效是在 foo 函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时 this 应该指向全局对象 window，这时应该输出 21。但是，箭头函数导致 this 总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是 42。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。 123456789101112131415161718192021222324252627282930function insert(value) &#123; return &#123; into: function(array) &#123; return &#123; after: function(afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;; &#125; &#125;;&#125;insert(2) .into([1, 3]) .after(1); //[1, 2, 3]//使用箭头函数改写let insert = value =&gt; (&#123; into: array =&gt; (&#123; after: afterValue =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125; &#125;)&#125;);insert(2) .into([1, 3]) .after(1); //[1, 2, 3] 改写 λ 演算123456// λ演算的写法fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))// ES6的写法var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v)));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"this和super关键字","slug":"this和super关键字","date":"2018-09-24T10:41:35.000Z","updated":"2019-03-22T06:55:53.017Z","comments":true,"path":"2018/09/24/this和super关键字/","link":"","permalink":"http://yoursite.com/2018/09/24/this和super关键字/","excerpt":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身","text":"this 关键字this 的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this 指向这个对象本身 12345678910var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向obj对象obj.getA(); 作为普通函数调用作为普通函数调用时，this 指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。 1234567891011var obj = &#123; a: 1, getA: function() &#123; console.log(this === obj); console.log(this.a); &#125;&#125;;//this指向window对象var getA = obj.getA;getA(); 这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。 构造器调用构造器调用时，this 指向返回的对象。用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。 12345678910111213var a = 10;var b = 20;function Point(x, y) &#123; this.x = x; this.y = y;&#125;var a = new Point(1, 2);console.log(a.x); // 1console.log(x); // 10var b = new Point(1, 2);console.log(a === b); // false call apply bind当函数通过 call()和 apply()方法绑定时，this 指向两个方法的第一个参数对象上，若第一个参数不是对象，JS 内部会尝试将其转化为对象然后再指向它。通过 bind 方法绑定后，无论其在什么情况下被调用，函数将被永远绑定在其第一个参数对象上，bind 绑定后返回的是一个函数。 call, apply 的用途 改变 this 的指向 Function.prototype.bind 12345678Function.prototype.bind = function() &#123; var self = this; var context = [].shift.call(arguments); var args = [].slice.call(arguments); return function() &#123; return self.apply(context, args.concat([].slice.call(arguments))); &#125;;&#125;; 三者区别call 只能一个一个传入参数apply 可直接传入参数数组bind 会返回一个新的函数 super 关键字关键字 super，指向当前对象的原型对象。 12345678910111213const proto = &#123; foo: \"hello\"&#125;;const obj = &#123; foo: \"world\", find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find(); // \"hello\" 上面代码中，对象 obj 的 find 方法之中，通过 super.foo 引用了原型对象 proto 的 foo 属性。注意，super 关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。 12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;;// 报错const obj = &#123; foo: function() &#123; return super.foo; &#125;&#125;; 上面三种 super 的用法都会报错，因为对于 JavaScript 引擎来说，这里的 super 都没有用在对象的方法之中。第一种写法是 super 用在属性里面，第二种和第三种写法是 super 用在一个函数里面，然后赋值给 foo 属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。JavaScript 引擎内部，super.foo 等同于 Object.getPrototypeOf(this).foo（属性）或 Object.getPrototypeOf(this).foo.call(this)（方法）。 1234567891011121314151617const proto = &#123; x: \"hello\", foo() &#123; console.log(this.x); &#125;&#125;;const obj = &#123; x: \"world\", foo() &#123; super.foo(); &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.foo(); // \"world\" 上面代码中，super.foo 指向原型对象 proto 的 foo 方法，但是绑定的 this 却还是当前对象 obj，因此输出的就是 world。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"常用git命令","slug":"常用git命令","date":"2018-09-16T03:50:00.000Z","updated":"2019-03-19T13:43:41.209Z","comments":true,"path":"2018/09/16/常用git命令/","link":"","permalink":"http://yoursite.com/2018/09/16/常用git命令/","excerpt":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库","text":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个 git 仓库（master 分支）git init [project-name]新建一个目录，将其初始化为 git 仓库 git status 查看状态“.” 代表文件夹中所有文件 git add [file1][file2]添加指定文件到暂存区 git commit在第一行写入这次修改记录。将缓存区文件放入提交区。git commit -m [‘message’]git commit -amend修改上次记录信息 git log查看提交记录vim ~/.zshrc 配置文件中可自定义操作source ~/.zshrc 修改配置文件后 source 保存生效 git config查看当前 git 配置git config -h查看帮助信息vim ~/.gitconfig 自定义 git 命令，修改个人名字邮箱等信息cat .git/config 本地配置 touch .gitignore 忽略一些文件 12.vscodenode_modules 写入 gitignore 后即可忽略 node_modules 文件更多信息查看gitignore git diff现实暂存区和工作区的差异 git checkout –a放弃 a 的变更依照提交区恢复工作区的文件，丢弃工作区的变更 git reset HEAD –a从暂存区恢复到工作区 git stash把工作区和暂存区的文件都存入 stash 中git stash list查看 stash 中的文件git stash pop恢复 stash 中的文件到工作区（pop=apply+drop） git reset HEAD\b^后退一步（几个^代表后退几步）git reset HEAD~[number]抛弃了 number 个 commit git reflog查看近期的 log 记录git reset [版本号]回退到版本号为……的 commit 分支操作 git branch develop创建 develop 分支,但依然停留在当前分支git branch -v查看分支 git checkout develop切换进入 develop 分支git checkout -b feature创建并切换进入 feature 分支 合并分支a. 先进入要合并的分支（checkout develop）在执行 git merge feature 即可把 feature 合并到 develop 分支上b. git merge feature develop可达到同样的效果 改变基线git rebase -i [提交记录号]将 HEAD 指向记录号所在位置 远程仓库 git remote add origin [SSH 地址]创建远程仓库连接 git push -u origin develop上传 develop 分支到远程仓库上（远程无项目可直接 push，有项目先 merge 再 push） git pull origin feature拉取远程 feature 分支（pull=fetch+merge） git brach -d feature删除 feature 分支 git push origin :feature删除远程 feature 分支 git tag [标签号]git push origin [标签号]打标签 git remote remove origin取消本地目录下关联的远程仓库 git clone [url]下载一个项目和它的整个代码历史 打 tag vim package.json(vim package-lock.json)可以查看 version 号 npm version -h查看这一个 tag 即将提升的版本号（大版本或者小版本） npm version patch提升 patch 这个小版本（v0.2.2） git tag –list查看 tag 的列表 git push origin masterpush 代码 git push origin v0.2.3push tag","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"跨域请求：JSONP&&CORS","slug":"跨域请求：JSONP&&CORS","date":"2018-09-03T09:28:34.000Z","updated":"2019-08-15T10:30:47.660Z","comments":true,"path":"2018/09/03/跨域请求：JSONP&&CORS/","link":"","permalink":"http://yoursite.com/2018/09/03/跨域请求：JSONP&&CORS/","excerpt":"JSONPJSONP 是 JSON with Padding 的略称。它是一个非官方的协议，它允许在服务器端集成 Script tags 返回至客户端，通过 javascript callback 的形式实现跨域访问（这仅仅是 JSONP 简单的实现形式） JSONP 的简单实现模式：创建一个回调函数，然后在远程服务上调用这个函数并且将 JSON 数据形式作为参数传递，完成回调。 我们知道script，link，img 等标签引入外部资源，都是GET请求的，那么就决定了 JSONP 一定是 GET的。","text":"JSONPJSONP 是 JSON with Padding 的略称。它是一个非官方的协议，它允许在服务器端集成 Script tags 返回至客户端，通过 javascript callback 的形式实现跨域访问（这仅仅是 JSONP 简单的实现形式） JSONP 的简单实现模式：创建一个回调函数，然后在远程服务上调用这个函数并且将 JSON 数据形式作为参数传递，完成回调。 我们知道script，link，img 等标签引入外部资源，都是GET请求的，那么就决定了 JSONP 一定是 GET的。 原生 JS 实现 JSONP 的步骤：客户端 定义获取数据后调用的回调函数 动态生成对服务端 JS 进行引用的代码 设置url为提供jsonp服务的url地址，并在该url中设置相关callback参数 创建script标签，并设置其src属性 把script标签加入head，此时调用开始。 服务端将客户端发送的callback参数作为函数名来包裹住JSON数据，返回数据至客户端。 例子：客户端代码： 12345678910111213141516171819202122232425262728&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data) &#123; alert( \"你查询的航班结果是：票价 \" + data.price + \" 元，\" + \"余票 \" + data.tickets + \" 张。\" ); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = \"http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler\"; // 创建script标签，设置其属性 var script = document.createElement(\"script\"); script.setAttribute(\"src\", url); // 把script标签加入head，此时调用开始 document.getElementsByTagName(\"head\")[0].appendChild(script); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 编码实现动态查询，而这也正是 JSONP 客户端实现的核心部分，本例中的重点也就在于如何完成 JSONP 调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是 CA1998 次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）： 12345flightHandler(&#123; code: \"CA1998\", price: 1780, tickets: 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，JSONP 的执行全过程顺利完成！ CORS跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的 Web 应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域 HTTP 请求。 CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。 整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。 因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。 1.两种请求浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 只要同时满足以下两大条件，就属于简单请求。 （1) 请求方法是以下三种方法之一： HEAD GET POST （2）HTTP 的头信息不超出以下几种字段： Accept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 凡是不同时满足上面两个条件，就属于非简单请求。 浏览器对这两种请求的处理，是不一样的。 2.简单请求 基本流程 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个Origin字段。 下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个Origin字段。 123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。 如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。 如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。 1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以Access-Control-开头。 （1）Access-Control-Allow-Origin 该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 （2）Access-Control-Allow-Credentials 该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送 Cookie，删除该字段即可。 （3）Access-Control-Expose-Headers 该字段可选。CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(&#39;FooBar&#39;)可以返回FooBar字段的值。 withCredentials 属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。 1Access-Control-Allow-Credentials: true 另一方面，开发者必须在 AJAX 请求中打开withCredentials属性。 12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。 但是，如果省略withCredentials设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭withCredentials。 1xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。 3.非简单请求 预检请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。 非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为”预检”请求（preflight）。 浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 下面是一段浏览器的 JavaScript 脚本。 12345var url = \"http://api.alice.com/cors\";var xhr = new XMLHttpRequest();xhr.open(\"PUT\", url, true);xhr.setRequestHeader(\"X-Custom-Header\", \"value\");xhr.send(); 上面代码中，HTTP 请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的 HTTP 头信息。 12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... “预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。 （1）Access-Control-Request-Method 该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是PUT。 （2）Access-Control-Request-Headers 该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应 服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。 123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain 上面的 HTTP 回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。 1Access-Control-Allow-Origin: * 如果浏览器否定了”预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。 12XMLHttpRequest cannot load http://api.alice.com.Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他 CORS 相关字段如下。 1234Access-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderAccess-Control-Allow-Credentials: trueAccess-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 （2）Access-Control-Allow-Headers 如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 （3）Access-Control-Allow-Credentials 该字段与简单请求时的含义相同。 （4）Access-Control-Max-Age 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。 浏览器的正常请求和回应 一旦服务器通过了”预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。 下面是”预检”请求之后，浏览器的正常 CORS 请求。 1234567PUT /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comX-Custom-Header: valueAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。 下面是服务器正常的回应。 12Access-Control-Allow-Origin: http://api.bob.comContent-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。 4.与 JSONP 的比较CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。 JSONP 只支持GET请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"正则的扩展","slug":"正则的扩展","date":"2018-08-29T08:56:12.000Z","updated":"2019-03-19T13:43:42.770Z","comments":true,"path":"2018/08/29/正则的扩展/","link":"","permalink":"http://yoursite.com/2018/08/29/正则的扩展/","excerpt":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。","text":"RegExp 构造函数RegExp 构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 12345var regex = new RegExp(\"xyz\", \"i\");// 等价于var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; ES6 中，如果 RegExp 构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/gi, \"i\").flags;// \"i\" 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和 split()。ES6 将这 4 个方法，在语言内部全部调用 RegExp 的实例方法，从而做到所有与正则相关的方法，全都定义在 RegExp 对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了 u 修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF 的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 点字符点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于 0xFFFF 的 Unicode 字符，点字符不能识别，必须加上 u 修饰符。 1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true Unicode 字符表示法ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上 u 修饰符，才能识别当中的大括号，否则会被解读为量词。 12345/\\u&#123;61&#125;/.test(\"a\") / // falsea /u.test(\"a\") / // true 𠮷 / u.test(\"𠮷\"); // true 量词使用 u 修饰符后，所有量词都会正确识别码点大于 0xFFFF 的 Unicode 字符。 1234/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true 预定义模式\\S 是预定义模式，匹配所有非空白字符。只有加了 u 修饰符，它才能正确匹配码点大于 0xFFFF 的 Unicode 字符。 12/^\\S$/.test('𠮷') // false/^\\S$/u.test('𠮷') // true i 修饰符有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B 与\\u212A 都是大写的 K。不加 u 修饰符，就无法识别非规范的 K 字符。 123/[a-z]/i.test(\"\\u212A\") / // false [a - z] / iu.test(\"\\u212A\"); // true RegExp.prototype.unicode 属性正则实例对象新增 unicode 属性，表示是否设置了 u 修饰符 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode; // falser2.unicode; // true 上面代码中，正则表达式是否设置了 u 修饰符，可以从 unicode 属性看出来。 y 修饰符ES6 为正则表达式添加了 y 修饰符，叫做“粘连”（sticky）修饰符。y 修饰符的作用与 g 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g 修饰符只要剩余位置中存在匹配就可，而 y 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = \"aaa_aa_a\";var r1 = /a+/g;var r2 = /a+/y;r1.exec(s); // [\"aaa\"]r2.exec(s); // [\"aaa\"]r1.exec(s); // [\"aa\"]r2.exec(s); // null 单单一个 y 修饰符对 match 方法，只能返回第一个匹配，必须与 g 修饰符联用，才能返回所有匹配。 12\"a1a2a3\".match(/a\\d/y); // [\"a1\"]\"a1a2a3\".match(/a\\d/gy); // [\"a1\", \"a2\", \"a3\"] RegExp.prototype.sticky 属性与 y 修饰符相匹配，ES6 的正则实例对象多了 sticky 属性，表示是否设置了 y 修饰符。 12var r = /hello\\d/y;r.sticky; // true RegExp.prototype.flags 属性ES6 为正则表达式新增了 flags 属性，会返回正则表达式的修饰符。 12345678910// ES5 的 source 属性// 返回正则表达式的正文/abc/gi.source / // \"abc\" // ES6 的 flags 属性 // 返回正则表达式的修饰符 abc / ig.flags;// 'gi' s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用 u 修饰符解决；另一个是行终止符。行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator）ES2018 引入 s 修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test(\"foo\\nbar\"); // true 这被称为 dotAll 模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个 dotAll 属性，返回一个布尔值，表示该正则表达式是否处在 dotAll 模式。/s 修饰符和多行修饰符/m 不冲突，两者一起使用的情况下，.匹配所有字符，而^和\\$匹配每一行的行首和行尾。 后行断言”先行断言“指的是，x 只有在 y 前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。”先行否定断言“指的是，x 只有不在 y 前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。“后行断言”正好与“先行断言”相反，x 只有在 y 后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\\$)\\d+/。”后行否定断言“则与”先行否定断言“相反，x 只有不在 y 后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\\$)\\d+/。 123const RE_DOLLAR_PREFIX = /(?&lt;=\\$)foo/g;\"$foo %foo foo\".replace(RE_DOLLAR_PREFIX, \"bar\");// '$bar %foo foo' “后行断言”的实现，需要先匹配/(?&lt;=y)x/的 x，然后再回到左边，匹配 y 的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。首先，后行断言的组匹配，与正常情况下结果是不一样的。 12/(?&lt;=(\\d+)(\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]/^(\\d+)(\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是 105 和 3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是 1 和 053。其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 Unicode 属性类ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。\\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。这两种类只对 Unicode 有效，所以使用的时候一定要加上 u 修饰符。如果不加 u 修饰符，正则表达式使用\\p 和\\P 会报错，ECMAScript 预留了这两个类。 123456789101112131415// 匹配所有空格\\p&#123;White_Space&#125;// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w[\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W[^\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配 Emoji/\\p&#123;Emoji_Modifier_Base&#125;\\p&#123;Emoji_Modifier&#125;?|\\p&#123;Emoji_Presentation&#125;|\\p&#123;Emoji&#125;\\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 具名组匹配正则表达式使用圆括号进行组匹配。 123456const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 正则表达式里面有三组圆括号。使用 exec 方法，就可以将这三组匹配结果提取出来。组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如 matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec(\"1999-12-31\");const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 “具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在 exec 方法返回结果的 groups 属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。如果具名组没有匹配，那么对应的 groups 对象属性会是 undefined。 解构赋值和替换具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。字符串替换时，使用\\$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;\"2015-01-02\".replace(re, \"$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;\");// '02/01/2015' 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法或者数字引用（\\1）的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;RE_TWICE.test(\"abc!abc!abc\"); // trueRE_TWICE.test(\"abc!abc!ab\"); // false String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用 g 修饰符或 y 修饰符，在循环里面逐一取出。或者使用 String.prototype.matchAll 方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = \"test1test2test3\";// g 修饰符加不加都可以const regex = /t(e)(st(\\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于 string.matchAll(regex)返回的是遍历器，所以可以用 for…of 循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。遍历器转为数组是非常简单的，使用…运算符和 Array.from 方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)];// 转为数组方法二Array.from(string.matchAll(regex));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"柯里化&&闭包","slug":"柯里化&&闭包","date":"2018-08-16T00:30:22.000Z","updated":"2019-08-15T10:30:33.593Z","comments":true,"path":"2018/08/16/柯里化&&闭包/","link":"","permalink":"http://yoursite.com/2018/08/16/柯里化&&闭包/","excerpt":"柯里化闭包实现multi(2)(3)(4)=24 1234567function multi(a) &#123; return function(b) &#123; return function(c) &#123; return a * b * c; &#125;; &#125;;&#125;","text":"柯里化闭包实现multi(2)(3)(4)=24 1234567function multi(a) &#123; return function(b) &#123; return function(c) &#123; return a * b * c; &#125;; &#125;;&#125; 函数柯里化函数柯里化指的是将能够接收多个参数的函数转化为接收单一参数的函数，并且返回接收余下参数且返回结果的新函数的技术。 函数柯里化的主要作用和特点就是参数复用、提前返回和延迟执行。 普通版把固定的函数变成柯里化。如果传入的参数个数小于 fn 所需要的形参个数，就继续执行 curry 函数接收参数，如果参数达到 fn 所需要的形参个数，就执行柯里化了的函数。 1234567891011121314151617181920function curry(fn, args) &#123; var length = fn.length; var args = args || []; return function() &#123; newArgs = args.concat(Array.prototype.slice.call(arguments)); if (newArgs.length &lt; length) &#123; return curry.call(this, fn, newArgs); &#125; else &#123; return fn.apply(this, newArgs); &#125; &#125;;&#125;function multiFn(a, b, c) &#123; return a * b * c;&#125;var multi = curry(multiFn);multi(2)(3)(4);multi(2, 3, 4);multi(2)(3, 4);multi(2, 3)(4); 优化版不需要事先知道函数形参个数。可以任意参数个数调用。（重写 valueOf 函数） 12345678910111213function multi() &#123; var args = Array.prototype.slice.call(arguments); var fn = function() &#123; var newArgs = args.concat(Array.prototype.slice.call(arguments)); return multi.apply(this, newArgs); &#125;; fn.valueOf = function() &#123; return args.reduce(function(a, b) &#123; return a * b; &#125;); &#125;; return fn;&#125; 闭包1234567var func = [];for (var i = 0; i &lt; 10; i++) &#123; func[i] = function() &#123; return i; &#125;;&#125;console.log(func[6]); //10 改成 12345678910var func = [];for (var i = 0; i &lt; 10; i++) &#123; func[i] = (function() &#123; return (function() &#123; return i; &#125;)(); &#125;)();&#125;console.log(func[6]); //6","categories":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"字符串的扩展","slug":"字符串的扩展","date":"2018-08-09T03:20:29.000Z","updated":"2019-03-19T13:43:48.706Z","comments":true,"path":"2018/08/09/字符串的扩展/","link":"","permalink":"http://yoursite.com/2018/08/09/字符串的扩展/","excerpt":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。","text":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx 形式表示一个字符，其中 xxxx 表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF 之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12345678\"\\u0061\";// \"a\"\"\\uD842\\uDFB7\";// \"𠮷\"\"\\u20BB7\";// \" 7\" 如果直接在\\u 后面跟上超过 0xFFFF 的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB 是一个不可打印字符，所以只会显示一个空格，后面跟着一个 7。ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 codePointAt()codePointAt 方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与 charCodeAt 方法相同。例如，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是 0x20BB7，UTF-16 编码为 0xD842 0xDFB7（十进制为 55362 57271），需要 4 个字节储存。对于这种 4 个字节的字符，JavaScript 不能正确处理，字符串长度会误判为 2，而且 charAt 方法无法读取整个字符，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。ES6 提供了 codePointAt 方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点（codePointAt 方法返回的是码点的十进制值）。 1234567891011121314var s = \"𠮷\";s.length; // 2s.charAt(0); // ''s.charAt(1); // ''s.charCodeAt(0); // 55362s.charCodeAt(1); // 57271let a = \"𠮷a\";a.codePointAt(0); // 134071a.codePointAt(1); // 57271a.codePointAt(2); // 97 codePointAt 方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷 a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的 20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt 方法的结果与 charCodeAt 方法相同。 String.fromCodePoint()ES5 提供 String.fromCharCode 方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于 0xFFFF）。ES6 提供了 String.fromCodePoint 方法，可以识别大于 0xFFFF 的字符，弥补了 String.fromCharCode 方法的不足。在作用上，正好与 codePointAt 方法相反。且如果 String.fromCodePoint 方法有多个参数，则它们会被合并成一个字符串返回。 1234String.fromCodePoint(0x20bb7);// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === \"x\\uD83D\\uDE80y\";// true 字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被 for…of 循环遍历,并且遍历器最大的优点是可以识别大于 0xFFFF 的码点。 1234567891011for (let codePoint of \"foo\") &#123; console.log(codePoint);&#125;// \"f\"// \"o\"// \"o\"for (let i of text) &#123; console.log(i);&#125;// \"𠮷\" at()ES5 对字符串对象提供 charAt 方法，返回字符串给定位置的字符。该方法不能识别码点大于 0xFFFF 的字符。字符串实例的 at 方法，可以识别 Unicode 编号大于 0xFFFF 的字符，返回正确的字符。 12\"abc\".at(0); // \"a\"\"𠮷\".at(0); // \"𠮷\" normalize()在字符排序或比较时，会出现一种情况，就是“等效”。 规范的等效是指，无论从哪个角度看，两个序列的码位都是没有区别的。 兼容关系，两个互相兼容的码位序列看起来不同，但是在特定的情况下可以相互交换使用。例如 Ǒ（\\u01D1）和 O（\\u004F） ˇ（\\u030C）两个字符的组合（\\u004F\\u030C），在视觉和语义上其实是等效的。 ES6 提供字符串实例的 normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。normalize 方法可以接受一个参数来指定 normalize 的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize 方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12\"\\u01D1\".normalize() === \"\\u004F\\u030C\".normalize();// true 不过，normalize 方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 includes(), startsWith(), endsWith()includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数 n 时，endsWith 的行为与其他两个方法有所不同。它针对前 n 个字符，而其他两个方法针对从第 n 个位置直到字符串结束。 12345let s = \"Hello world!\";s.startsWith(\"world\", 6); // trues.endsWith(\"Hello\", 5); // trues.includes(\"Hello\", 6); // false repeat()repeat 方法返回一个新字符串，表示将原字符串重复 n 次。参数如果是小数，会被取整。如果 repeat 的参数是负数或者 Infinity，会报错。参数 NaN 等同于 0。如果 repeat 的参数是字符串，则会先转换成数字。 1234567891011121314\"x\".repeat(3); // \"xxx\"\"hello\".repeat(2); // \"hellohello\"\"na\".repeat(0); // \"\"\"na\".repeat(2.9); // \"nana\"\"na\".repeat(Infinity);// RangeError\"na\".repeat(-1);// RangeError\"na\".repeat(NaN); // \"\"\"na\".repeat(\"na\"); // \"\"\"na\".repeat(\"3\"); // \"nanana\" padStart()，padEnd()如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。padStart 和 padEnd 一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。 1234567891011\"x\".padStart(4, \"ab\"); // 'abax'\"x\".padEnd(5, \"ab\"); // 'xabab'\"xxx\".padStart(2, \"ab\"); // 'xxx'\"xxx\".padEnd(2, \"ab\"); // 'xxx'\"abc\".padStart(10, \"0123456789\");// '0123456abc'\"x\".padStart(4); // ' x'\"x\".padEnd(4); // 'x ' matchAll()matchAll 方法返回一个正则表达式在当前字符串的所有匹配 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。嵌入变量，需要将变量名写在\\${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的 toString 方法。如果模板字符串中的变量没有声明，将报错。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 12345678910111213// 普通字符串`In JavaScript '\\n' is a line-feed.``In JavaScript this is // 多行字符串 not legal.`;console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`;let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 所有模板字符串的空格和换行，都是被保留的，比如”&lt; ul&gt;”标签前面会有一个换行。如果你不想要这个换行，可以使用 trim 方法消除它。如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = \"return \" + \"`Hello $&#123;name&#125;!`\";let func = new Function(\"name\", str);func(\"Jack\"); // \"Hello Jack!\"// 写法二let str = \"(name) =&gt; `Hello $&#123;name&#125;!`\";let func = eval.call(null, str);func(\"Jack\"); // \"Hello Jack!\" 标签模板模板字符串，紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello $&#123;a + b&#125; world $&#123;a * b&#125;`;// 等同于tag([\"Hello \", \" world \", \"\"], 15, 50); 上面代码中，模板字符串前面有一个标识名 tag，它是一个函数。整个表达式的返回值，就是 tag 函数处理模板字符串后的返回值。函数 tag 依次会接收到多个参数。tag 函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。tag 函数的其他参数，都是模板字符串各个变量被替换后的值。 “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg .replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender 变量往往是用户提供的，经过 SaferHTML 函数处理，里面的特殊字符都会被转义。 标签模板的另一个应用，就是多语言转换（国际化处理）。多语言转换（国际化处理）。可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 模板处理函数的第一个参数（模板字符串数组），还有一个 raw 属性。保存的是转义后的原字符串。 1234567tag`First line\\nSecond line`;function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"&#125; String.raw()ES6 还为原生的 String 对象，提供了一个 raw 方法。String.raw 方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。如果原字符串的斜杠已经转义，那么 String.raw 会进行再次转义。 12345678String.raw`Hi\\n$&#123;2 + 3&#125;!`;// 返回 \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 返回 \"Hi\\\\u000A!\"String.raw`Hi\\\\n`;// 返回 \"Hi\\\\\\\\n\"","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"递归与尾递归","slug":"递归与尾递归","date":"2018-07-23T10:15:56.000Z","updated":"2019-08-15T10:30:08.340Z","comments":true,"path":"2018/07/23/递归与尾递归/","link":"","permalink":"http://yoursite.com/2018/07/23/递归与尾递归/","excerpt":"递归的问题函数的递归调用是通过栈来实现的，每一次函数调用都会把当前函数的状态，如变量，返回地址保存在栈中一直到函数返回才能出栈。因为程序运行时，栈的大小一般很有限（在 chrome 中运行下面的代码可以计算出 chrome 给每个线程的栈大小），因此如果递归调用的层次如果过多，将会使栈区溢出。","text":"递归的问题函数的递归调用是通过栈来实现的，每一次函数调用都会把当前函数的状态，如变量，返回地址保存在栈中一直到函数返回才能出栈。因为程序运行时，栈的大小一般很有限（在 chrome 中运行下面的代码可以计算出 chrome 给每个线程的栈大小），因此如果递归调用的层次如果过多，将会使栈区溢出。 尾递归尾递归就是函数最后的语句是调用函数自身，但调用自己的时候，已经不再需要上一个函数的环境了。 123456function factorial(n,a)&#123; if(n&lt;=0) return 0; if(n == 1) return a; return factorial(n-1,a*n); 相比较之前一般形式的递归代码，有两个不同的地方： 递归调用时，把 n 当做参数传给了递归函数，无需等待递归调用返回后参与计算。 最终的计算结果在最后一次递归调用后产生，无需回溯。 我们通过这种形式，解决了需要函数回跳才能计算的问题，但最后产生的计算结果仍然需要层层的回调，但这种代码的形式对于普通的递归来说，编译器更容易对其进行优化。这种特殊的递归叫做尾递归，从递归代码形式上看，它自身的调用是函数的最后一个操作。尾递归的目的是为了优化，而优化的目标是减少栈的空间。 尾递归是递归的一种优化 按照尾递归的定义，尾递归就至少必须解决一般递归的两个问题： 不能重复计算 重复利用栈空间 然而尾递归是为编译器优化的目的，所以还要依赖于编译器的实现，如果一种语言不支持尾递归，那么尾递归也就仅仅是个形式上递归了，JavaScript 就是这样的语言，因为它无法优化栈空间的利用。 实际上尾递归一直被看作一种编译技巧，特别是对于函数式编程语言来说，尾递归的编译器实现做当做的一种必须的标准 es6 中的尾调用优化尾调用被识别出来，重复利用了已存在的栈结构来进行递归，移除了之前函数调用的本地变量和状态。 如果使用了BABEL，它会直接、自递归地处理尾调用。 爆栈问题解决递归改循环","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"变量的解构赋值","slug":"变量的解构赋值","date":"2018-07-16T04:05:20.000Z","updated":"2019-03-19T13:43:53.897Z","comments":true,"path":"2018/07/16/变量的解构赋值/","link":"","permalink":"http://yoursite.com/2018/07/16/变量的解构赋值/","excerpt":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。","text":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 解构不成功如果解构不成功，变量的值就等于 undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo 的值都会等于 undefined。 不完全解构等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x; // 1y; // 2let [a, [b], d] = [1, [2, 3], 4];a; // 1b; // 2d; // 4 等号右边不是数组如果等号的右边不是数组，那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo; // truelet [x, y = \"b\"] = [\"a\"]; // x='a', y='b'let [x, y = \"b\"] = [\"a\", undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于 undefined，默认值才会生效。null 不严格等于 undefined。所以，如果数组成员是 null，默认值则不会生效。 12345let [x = 1] = [undefined];x; // 1let [x = 1] = [null];x; // null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1let [x = y, y = 1] = []; // ReferenceError: y is not defined 上式之所以会报错，是因为 x 用 y 做默认值时，y 还没有声明。 对象的解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 1234567891011121314let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo; // \"aaa\"bar; // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // undefinedlet &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"let obj = &#123; first: \"hello\", last: \"world\" &#125;;let &#123; first: f, last: l &#125; = obj;f; // 'hello'l; // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz; // \"aaa\"foo; // error: foo is not defined 上面代码中，foo 是匹配的模式，baz 才是变量。真正被赋值的是变量 baz，而不是模式 foo。 解构失败如果解构失败，变量的值等于 undefined。 12let &#123; foo &#125; = &#123; bar: \"baz\" &#125;;foo; // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 1234// 报错let &#123; foo: &#123; bar &#125;&#125; = &#123; baz: \"baz\" &#125;; 上面代码中，等号左边对象的 foo 属性，对应一个子对象。该子对象的 bar 属性，解构时会报错。原因很简单，因为 foo 这时等于 undefined，再取子属性就会报错。 默认值对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于 undefined。 12345var &#123; x = 3 &#125; = &#123; x: undefined &#125;;x; // 3var &#123; x = 3 &#125; = &#123; x: null &#125;;x; // null 上面代码中，属性 x 等于 null，因为 null 与 undefined 不严格相等，所以是个有效的赋值，导致默认值 3 不会生效。 字符串的解构赋值字符串被转换成了一个类似数组的对象。 123456789const [a, b, c, d, e] = \"hello\";a; // \"h\"b; // \"e\"c; // \"l\"d; // \"l\"e; // \"o\"let &#123; length: len &#125; = \"hello\";len; // 5 数值和布尔值的解构赋值等号右边是数值和布尔值，则会先转为对象。解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象。由于 undefined 和 null 无法转为对象，所以对它们进行解构赋值，都会报错。 12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值1234567function add([x, y]) &#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。 12345678function move(&#123; x = 0, y = 0 &#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数 move 的参数是一个对象，通过对这个对象进行解构，得到变量 x 和 y 的值。如果解构失败，x 和 y 等于默认值。 12345678function move(&#123; x, y &#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123; x: 3, y: 8 &#125;); // [3, 8]move(&#123; x: 3 &#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数 move 的参数指定默认值，而不是为变量 x 和 y 指定默认值，所以会得到与前一种写法不同的结果。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"var，let和const声明及区别","slug":"var，let和const声明及区别","date":"2018-07-04T03:29:59.000Z","updated":"2018-07-27T03:57:38.924Z","comments":true,"path":"2018/07/04/var，let和const声明及区别/","link":"","permalink":"http://yoursite.com/2018/07/04/var，let和const声明及区别/","excerpt":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。","text":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。例如：123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 事实上，在预编译阶段，JavaScript引擎会将上面的函数修改为下面这样：12345678910111213fuction getValue(condition)&#123; var value; if(condition)&#123; value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 变量value的声明会被提升至函数顶部，而初始化操作依然留在原处执行。这样，就意味着，在函数的其他部分，else子句中或者if-else外，也能访问到value变量，而由于此时value变量并未被初始化赋值，所以访问到值为undefined。 块级声明ES6中引入块级作用域来强化对变量生命周期的控制。块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（词法作用域）存在于： 函数内部 块中（字符{和}之间的区域） let声明let声明的用法与var相同。用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。let声明不会被提升，因此通常将let声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //变量value在此处不存在 return null; &#125; //变量value在此处不存在&#125; let声明后，不会被提升至函数顶部。因此执行流离开if块之后，value立刻被销毁，如果condition的值为false，就永远不会声明并初始化value。并且，假设作用域中已经存在了某个标识符，此时再用let关键字声明它，就会抛出错误： 123var count=30;//抛出语法错误let count=40; 在同一作用域中不能用let重复定义已经存在的标识符，所以此处使用let声明会抛出错误。但如果当前作用域内内嵌另一个作用域，就可在内嵌的作用域中使用let声明同名变量。 例如： 12345var count=30;if(condition)&#123; //不会抛出错误 let count=40;&#125; 此时，if内部块中的count会遮蔽全局作用域中的count，而var声明的count只能在if块外访问到。 const声明使用const声明的是常量，其值一旦被设定后不可更改。因此每个通过const声明的常量必须在声明的同时被初始化。12345//有效的常量const max=30;//语法错误，常量未初始化const name; const和let声明都是块级标识符，所以常量也只在当前的代码块内有效，一旦执行到代码块外会被立即销毁。并且，常量也不会被提升至作用域顶部。同样，与let相似，在同一作用域用const声明已经存在的标识符，也会导致语法错误。 如上所述，const定义的值一旦被设定后不可更改，无论在严格模式还是非严格模式下，都不可以为const定义的常量再赋值，否则会抛出语法错误：123const max=50;//抛出语法错误max=30; 然而，与其他语言中的常量不同的是，JavaScript中的常量，如果是对象，则对象的值可以修改，也就是const声明不允许修改绑定，但允许修改值这也意味着，const声明对象后，可以修改对象的属性。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。1234567891011const person=&#123; name:\"Nicholas\";&#125;;//可以修改对象属性的值person.name=\"Greg\";//抛出语法错误person=&#123; name:\"Greg\";&#125;; 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 临时死区（Temporal Dead Zone）临时死区常被描述let和const的不提升的效果。JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到var声明时），要么将声明放到TDZ中（遇到let和const声明时）。访问TDZ中的变量会触发运行错误。只有在执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。1234if(condition)&#123; console.log(typeof value);//引用错误！ let value=\"blue\";&#125; 但在let声明的作用域外对该变量使用typeof则不会报错：12345console.log(typeof value); //\"undefined\"if(condition)&#123; let value=\"blue\";&#125; typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中，也就意味着不存在value这个绑定，typeof操作最终返回”undefined”。 循环中的块级作用域绑定先看这段代码：1234567891011var funcs=[];for(var i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出10次数字10&#125;); 预想结果是输出数字0～9，但是因为循环里的每次迭代同时共享着i，循环内部创建的函数全部都保存了对相同变量的引用。循环结束时变量i的值为10，所以每次调用console.log（i）时都会输出数字10。而使用let声明，每次迭代循环都会创建一个新变量，并以之前的迭代中同名变量的值将其初始化，得到预期的效果。1234567891011var funcs=[];for(let i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出0，1，2，……，9&#125;); 当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。const也是同样，但在循环中不能修改const声明的变量，否则会抛出错误。 全局作用域绑定当var被用在全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。这意味着，用var很可能会无意中覆盖一个已经存在的全局属性。例如：123//在浏览器中var RegExp=\"Hello!\";console.log(window.RegExp); //\"Hello!\" 全局对象定义在RegExp定义在window上，但不能幸免被var覆盖，成为window的属性。但如果在全局作用域中使用let或者const，会在全局作用域下创建一个新的绑定，但该绑定不会添加全局对象的属性。用let或const不能覆盖全局变量，只能遮蔽它。1234//在浏览器中let RegExp=\"Hello!\";console.log(RegExp); //\"Hello!\"console.log(window.RegExp===RegExp); //false 这里let声明的RegExp创建了一个绑定并遮蔽了全局的RegExp变量，但window.RegExp和RegExp并不相同，说明它不会破坏全局作用域，不会为全局对象创建属性。 ES6声明变量的六种方法ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]}