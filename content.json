{"meta":{"title":"01不是包子脸","subtitle":"小01的程序猿成长之路","description":null,"author":"Linyi Li","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:37:46.747Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:36:30.431Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T07:21:46.777Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 ProfileCease to struggle and you cease to live. 大家好，我是『01』。一个不承认自己是包子脸的小仙女～哈哈哈哈～ 作为一只程序猿，虽然我比较菜，但是我在努力成长啊。这个博客，想记录一路走来的点点滴滴。 希望我们，都能有自己的一技之长，在社会上的某个方面能成为独当一面的佼佼者。 生命不止，奋斗不息。 Social Info : 01 : 01"}],"posts":[{"title":"Proxy","slug":"Proxy","date":"2018-07-27T03:07:46.000Z","updated":"2018-07-27T03:52:05.512Z","comments":true,"path":"2018/07/27/Proxy/","link":"","permalink":"http://yoursite.com/2018/07/27/Proxy/","excerpt":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。","text":"概述ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。1var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。下面是一个拦截读取属性行为的例子。123456789var proxy = new Proxy(&#123;&#125;, &#123; get: function(target, property) &#123; return 35; &#125;&#125;);proxy.time // 35proxy.name // 35proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。如果handler没有设置任何拦截，那就等同于直接通向原对象。同一个拦截器函数，可以设置拦截多个操作。12345678910111213141516171819202122232425var handler = &#123; get: function(target, name) &#123; if (name === 'prototype') &#123; return Object.prototype; &#125; return 'Hello, ' + name; &#125;, apply: function(target, thisBinding, args) &#123; return args[0]; &#125;, construct: function(target, args) &#123; return &#123;value: args[1]&#125;; &#125;&#125;;var fproxy = new Proxy(function(x, y) &#123; return x + y;&#125;, handler);fproxy(1, 2) // 1new fproxy(1, 2) // &#123;value: 2&#125;fproxy.prototype === Object.prototype // truefproxy.foo === \"Hello, foo\" // true Proxy 支持的拦截操作一览，一共 13 种。 get(target, propKey, receiver)：拦截对象属性的读取，比如proxy.foo和proxy[‘foo’]。 set(target, propKey, value, receiver)：拦截对象属性的设置，比如proxy.foo = v或proxy[‘foo’] = v，返回一个布尔值。 has(target, propKey)：拦截propKey in proxy的操作，返回一个布尔值。 deleteProperty(target, propKey)：拦截delete proxy[propKey]的操作，返回一个布尔值。 ownKeys(target)：拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for…in循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 getOwnPropertyDescriptor(target, propKey)：拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 defineProperty(target, propKey, propDesc)：拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 preventExtensions(target)：拦截Object.preventExtensions(proxy)，返回一个布尔值。 getPrototypeOf(target)：拦截Object.getPrototypeOf(proxy)，返回一个对象。 isExtensible(target)：拦截Object.isExtensible(proxy)，返回一个布尔值。 setPrototypeOf(target, proto)：拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。 apply(target, object, args)：拦截 Proxy 实例作为函数调用的操作，比如proxy(…args)、proxy.call(object, …args)、proxy.apply(…)。 construct(target, args)：拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(…args)。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"this和super关键字","slug":"this和super关键字","date":"2018-07-24T10:41:35.000Z","updated":"2018-07-27T03:56:48.029Z","comments":true,"path":"2018/07/24/this和super关键字/","link":"","permalink":"http://yoursite.com/2018/07/24/this和super关键字/","excerpt":"this关键字this的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this指向这个对象本身","text":"this关键字this的指向： 作为普通对象的方法调用作为普通对象的方法调用时，this指向这个对象本身12345678910var obj = &#123; a: 1, getA: function () &#123; console.log(this === obj) console.log(this.a) &#125;&#125;//this指向obj对象obj.getA() 作为普通函数调用作为普通函数调用时，this指向全局对象，在浏览器中全局对象是 window，在 NodeJs 中全局对象是 global。1234567891011var obj = &#123; a: 1, getA: function () &#123; console.log(this === obj) console.log(this.a) &#125;&#125;//this指向window对象var getA = obj.getAgetA() 这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过 函数名(…) 来对函数进行调用的方式，都称为直接调用。 构造器调用构造器调用时，this指向返回的对象。用 new 调用一个构造函数，会创建一个新对象，而其中的 this 就指向这个新对象。12345678910111213var a = 10;var b = 20;function Point (x, y) &#123; this.x = x this.y = y&#125;var a = new Point(1, 2);console.log(a.x); // 1console.log(x); // 10var b = new Point(1, 2);console.log(a === b); // false call apply bindcall, apply 的用途 改变this的指向 Function.prototype.bind12345678Function.prototype.bind = function () &#123; var self = this var context = [].shift.call(arguments) var args = [].slice.call(arguments) return function () &#123; return self.apply(context, args.concat([].slice.call(arguments))) &#125;&#125; 三者区别call只能一个一个传入参数apply可直接传入参数数组bind会返回一个新的函数 super关键字关键字super，指向当前对象的原型对象。12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // \"hello\" 上面代码中，对象obj的find方法之中，通过super.foo引用了原型对象proto的foo属性。注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;// 报错const obj = &#123; foo: function () &#123; return super.foo &#125;&#125; 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。1234567891011121314151617const proto = &#123; x: 'hello', foo() &#123; console.log(this.x); &#125;,&#125;;const obj = &#123; x: 'world', foo() &#123; super.foo(); &#125;&#125;Object.setPrototypeOf(obj, proto);obj.foo() // \"world\" 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"箭头函数","slug":"箭头函数","date":"2018-07-16T07:55:35.000Z","updated":"2018-07-27T03:59:04.229Z","comments":true,"path":"2018/07/16/箭头函数/","link":"","permalink":"http://yoursite.com/2018/07/16/箭头函数/","excerpt":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。","text":"基本用法ES6 允许使用“箭头”（=&gt;）定义函数。123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 参数部分如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 返回对象由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。12345// 报错let getTempItem = id =&gt; &#123; id: id, name: \"Temp\" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: \"Temp\" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。箭头函数可以与变量解构结合使用。123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 简化回调函数箭头函数的一个用处是简化回调函数。1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); rest 参数与箭头函数结合123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 不可以使用yield命令，因此箭头函数不能用作 Generator 函数。上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。123456789101112131415161718function insert(value) &#123; return &#123;into: function (array) &#123; return &#123;after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); //[1, 2, 3]//使用箭头函数改写let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); //[1, 2, 3] 改写 λ 演算123456// λ演算的写法fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))// ES6的写法var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v)));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"常用git命令","slug":"常用git命令","date":"2018-07-16T03:50:00.000Z","updated":"2018-07-27T03:58:10.302Z","comments":true,"path":"2018/07/16/常用git命令/","link":"","permalink":"http://yoursite.com/2018/07/16/常用git命令/","excerpt":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个git仓库（master分支）git init [project-name]新建一个目录，将其初始化为git仓库","text":"红色代表工作区，绿色代表暂存区 文件操作 git init在当前目录下新建一个git仓库（master分支）git init [project-name]新建一个目录，将其初始化为git仓库 git status 查看状态“.” 代表文件夹中所有文件 git add [file1][file2]添加指定文件到暂存区 git commit在第一行写入这次修改记录。将缓存区文件放入提交区。git commit -m [‘message’]git commit -amend修改上次记录信息 git log查看提交记录vim ~/.zshrc 配置文件中可自定义操作source ~/.zshrc 修改配置文件后source保存生效 git config查看当前git配置git config -h查看帮助信息vim ~/.gitconfig 自定义git命令，修改个人名字邮箱等信息cat .git/config 本地配置 touch .gitignore 忽略一些文件 12.vscodenode_modules 写入gitignore后即可忽略node_modules文件更多信息查看gitignore git diff现实暂存区和工作区的差异 git checkout –a放弃a的变更依照提交区恢复工作区的文件，丢弃工作区的变更 git reset HEAD –a从暂存区恢复到工作区 git stash把工作区和暂存区的文件都存入stash中git stash list查看stash中的文件git stash pop恢复stash中的文件到工作区（pop=apply+drop） git reset HEAD\b^后退一步（几个^代表后退几步）git reset HEAD~[number]抛弃了number个commit git reflog查看近期的log记录git reset [版本号]回退到版本号为……的commit 分支操作 git branch develop创建develop分支git branch -v查看分支 git checkout develop切换进入develop分支git checkout -b feature创建并切换进入feature分支 合并分支a. 先进入要合并的分支（checkout develop）在执行git merge feature 即可把feature合并到develop分支上b. git merge feature develop可达到同样的效果 改变基线git rebase -i [提交记录号]将HEAD指向记录号所在位置 远程仓库 git remote add origin [SSH地址]创建远程仓库连接 git push -u origin develop上传develop分支到远程仓库上（远程无项目可直接push，有项目先merge 再push） git pull origin feature拉取远程feature分支（pull=fetch+merge） git brach -d feature删除feature分支 git push origin :feature删除远程feature分支 git tag [标签号]git push origin [标签号]打标签 git remote remove origin取消本地目录下关联的远程仓库","categories":[{"name":"git","slug":"git","permalink":"http://yoursite.com/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"正则的扩展","slug":"正则的扩展","date":"2018-07-09T08:56:12.000Z","updated":"2018-07-27T03:58:58.295Z","comments":true,"path":"2018/07/09/正则的扩展/","link":"","permalink":"http://yoursite.com/2018/07/09/正则的扩展/","excerpt":"RegExp 构造函数RegExp构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。","text":"RegExp 构造函数RegExp构造函数的参数有两种情况。 参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 12345var regex = new RegExp('xyz', 'i');// 等价于var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; ES6中，如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。12new RegExp(/abc/ig, 'i').flags// \"i\" 字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u 修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 点字符点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true Unicode 字符表示法ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。123/\\u&#123;61&#125;/.test('a') // false/\\u&#123;61&#125;/u.test('a') // true/\\u&#123;20BB7&#125;/u.test('𠮷') // true 量词使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。1234/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true 预定义模式\\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。12/^\\S$/.test('𠮷') // false/^\\S$/u.test('𠮷') // true i 修饰符有些 Unicode 字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。不加u修饰符，就无法识别非规范的K字符。12/[a-z]/i.test('\\u212A') // false/[a-z]/iu.test('\\u212A') // true RegExp.prototype.unicode 属性正则实例对象新增unicode属性，表示是否设置了u修饰符12345const r1 = /hello/;const r2 = /hello/u;r1.unicode // falser2.unicode // true 上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。 y 修饰符ES6 为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // [\"aaa\"]r2.exec(s) // [\"aaa\"]r1.exec(s) // [\"aa\"]r2.exec(s) // null 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。12'a1a2a3'.match(/a\\d/y) // [\"a1\"]'a1a2a3'.match(/a\\d/gy) // [\"a1\", \"a2\", \"a3\"] RegExp.prototype.sticky 属性与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。12var r = /hello\\d/y;r.sticky // true RegExp.prototype.flags 属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。123456789// ES5 的 source 属性// 返回正则表达式的正文/abc/ig.source// \"abc\"// ES6 的 flags 属性// 返回正则表达式的修饰符/abc/ig.flags// 'gi' s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符。行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator）ES2018 引入s修饰符，使得.可以匹配任意单个字符。1/foo.bar/s.test('foo\\nbar') // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\\$)\\d+/。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\\$)\\d+/。123const RE_DOLLAR_PREFIX = /(?&lt;=\\$)foo/g;'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');// '$bar %foo foo' “后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。首先，后行断言的组匹配，与正常情况下结果是不一样的。12/(?&lt;=(\\d+)(\\d+))$/.exec('1053') // [\"\", \"1\", \"053\"]/^(\\d+)(\\d+)$/.exec('1053') // [\"1053\", \"105\", \"3\"] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 Unicode 属性类ES2018 引入了一种新的类的写法\\p{…}和\\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。Unicode 属性类要指定属性名和属性值。对于某些属性，可以只写属性名，或者只写属性值。\\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript 预留了这两个类。123456789101112131415// 匹配所有空格\\p&#123;White_Space&#125;// 匹配各种文字的所有字母，等同于 Unicode 版的 \\w[\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \\W[^\\p&#123;Alphabetic&#125;\\p&#123;Mark&#125;\\p&#123;Decimal_Number&#125;\\p&#123;Connector_Punctuation&#125;\\p&#123;Join_Control&#125;]// 匹配 Emoji/\\p&#123;Emoji_Modifier_Base&#125;\\p&#123;Emoji_Modifier&#125;?|\\p&#123;Emoji_Presentation&#125;|\\p&#123;Emoji&#125;\\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 具名组匹配正则表达式使用圆括号进行组匹配。123456const RE_DATE = /(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。123456const RE_DATE = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 “具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。如果具名组没有匹配，那么对应的groups对象属性会是undefined。 解构赋值和替换具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。字符串替换时，使用$&lt;组名&gt;引用具名组。1234let re = /(?&lt;year&gt;\\d&#123;4&#125;)-(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')// '02/01/2015' 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\\k&lt;组名&gt;的写法或者数字引用（\\1）的写法。123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\\k&lt;word&gt;!\\1$/;RE_TWICE.test('abc!abc!abc') // trueRE_TWICE.test('abc!abc!ab') // false String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。或者使用String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。1234567891011const string = 'test1test2test3';// g 修饰符加不加都可以const regex = /t(e)(st(\\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// [\"test1\", \"e\", \"st1\", \"1\", index: 0, input: \"test1test2test3\"]// [\"test2\", \"e\", \"st2\", \"2\", index: 5, input: \"test1test2test3\"]// [\"test3\", \"e\", \"st3\", \"3\", index: 10, input: \"test1test2test3\"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。遍历器转为数组是非常简单的，使用…运算符和Array.from方法就可以了。12345// 转为数组方法一[...string.matchAll(regex)]// 转为数组方法二Array.from(string.matchAll(regex));","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"字符串的扩展","slug":"字符串的扩展","date":"2018-07-09T03:20:29.000Z","updated":"2018-07-27T03:57:56.440Z","comments":true,"path":"2018/07/09/字符串的扩展/","link":"","permalink":"http://yoursite.com/2018/07/09/字符串的扩展/","excerpt":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。","text":"字符的 Unicode 表示法JavaScript 允许采用\\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。码点在\\u0000~\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。12345678\"\\u0061\"// \"a\"\"\\uD842\\uDFB7\"// \"𠮷\"\"\\u20BB7\"// \" 7\" 如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript 会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 codePointAt()codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。例如，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点（codePointAt方法返回的是码点的十进制值）。1234567891011121314var s = \"𠮷\";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271let a = '𠮷a';a.codePointAt(0) // 134071a.codePointAt(1) // 57271a.codePointAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。且如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。1234String.fromCodePoint(0x20BB7)// \"𠮷\"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\\uD83D\\uDE80y'// true 字符串的遍历器接口ES6 为字符串添加了遍历器接口，使得字符串可以被for…of循环遍历,并且遍历器最大的优点是可以识别大于0xFFFF的码点。1234567891011for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// \"f\"// \"o\"// \"o\"for (let i of text) &#123; console.log(i);&#125;// \"𠮷\" at()ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。12'abc'.at(0) // \"a\"'𠮷'.at(0) // \"𠮷\" normalize()在字符排序或比较时，会出现一种情况，就是“等效”。 规范的等效是指，无论从哪个角度看，两个序列的码位都是没有区别的。 兼容关系，两个互相兼容的码位序列看起来不同，但是在特定的情况下可以相互交换使用。例如Ǒ（\\u01D1）和O（\\u004F） ˇ（\\u030C）两个字符的组合（\\u004F\\u030C），在视觉和语义上其实是等效的。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。12'\\u01D1'.normalize() === '\\u004F\\u030C'.normalize()// true 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 includes(), startsWith(), endsWith()includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。参数如果是小数，会被取整。如果repeat的参数是负数或者Infinity，会报错。参数NaN等同于 0。如果repeat的参数是字符串，则会先转换成数字。1234567891011121314'x'.repeat(3) // \"xxx\"'hello'.repeat(2) // \"hellohello\"'na'.repeat(0) // \"\"'na'.repeat(2.9) // \"nana\"'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError'na'.repeat(NaN) // \"\"'na'.repeat('na') // \"\"'na'.repeat('3') // \"nanana\" padStart()，padEnd()如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。如果省略第二个参数，默认使用空格补全长度。1234567891011'x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx''abc'.padStart(10, '0123456789')// '0123456abc''x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配 模板字符串模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。嵌入变量，需要将变量名写在${}之中。大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。如果模板字符串中的变量没有声明，将报错。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。123456789101112131415// 普通字符串`In JavaScript '\\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = \"Bob\", time = \"today\";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?`let greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 所有模板字符串的空格和换行，都是被保留的，比如”&lt; ul&gt;”标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // \"Hello Jack!\"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // \"Hello Jack!\" 标签模板模板字符串，紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。123456let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。函数tag依次会接收到多个参数。tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。tag函数的其他参数，都是模板字符串各个变量被替换后的值。 “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, \"&amp;amp;\") .replace(/&lt;/g, \"&amp;lt;\") .replace(/&gt;/g, \"&amp;gt;\"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 标签模板的另一个应用，就是多语言转换（国际化处理）。多语言转换（国际化处理）。可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。保存的是转义后的原字符串。1234567tag`First line\\nSecond line`function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 \"First line\\\\nSecond line\" // 打印输出 \"First line\\nSecond line\"&#125; String.raw()ES6 还为原生的 String 对象，提供了一个raw方法。String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。如果原字符串的斜杠已经转义，那么String.raw会进行再次转义。12345678String.raw`Hi\\n$&#123;2+3&#125;!`;// 返回 \"Hi\\\\n5!\"String.raw`Hi\\u000A!`;// 返回 \"Hi\\\\u000A!\"String.raw`Hi\\\\n`// 返回 \"Hi\\\\\\\\n\"","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"变量的解构赋值","slug":"变量的解构赋值","date":"2018-07-06T04:05:20.000Z","updated":"2018-07-27T03:57:48.687Z","comments":true,"path":"2018/07/06/变量的解构赋值/","link":"","permalink":"http://yoursite.com/2018/07/06/变量的解构赋值/","excerpt":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。","text":"数组的解构赋值ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。1let [a,b,c]=[1,2,3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。 解构不成功如果解构不成功，变量的值就等于undefined。12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 不完全解构等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 等号右边不是数组如果等号的右边不是数组，那么将会报错。1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 默认值解构赋值允许指定默认值。12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。null不严格等于undefined。所以，如果数组成员是null，默认值则不会生效。12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。1let [x = y, y = 1] = []; // ReferenceError: y is not defined 上式之所以会报错，是因为x用y做默认值时，y还没有声明。 对象的解构赋值数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。1234567891011121314let &#123; bar, foo &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;foo // \"aaa\"bar // \"bbb\"let &#123; baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // undefinedlet &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // \"aaa\"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。123let &#123; foo: baz &#125; = &#123; foo: \"aaa\", bar: \"bbb\" &#125;;baz // \"aaa\"foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 解构失败如果解构失败，变量的值等于undefined。12let &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错。 默认值对象的解构也可以指定默认值。默认值生效的条件是，对象的属性值严格等于undefined。12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 字符串的解构赋值字符串被转换成了一个类似数组的对象。123456789const [a, b, c, d, e] = 'hello';a // \"h\"b // \"e\"c // \"l\"d // \"l\"e // \"o\"let &#123;length : len&#125; = 'hello';len // 5 数值和布尔值的解构赋值等号右边是数值和布尔值，则会先转为对象。解构赋值的规则是，只要等号右边的值不是对象或数组，都会先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。12let &#123; prop: x &#125; = undefined; // TypeErrorlet &#123; prop: y &#125; = null; // TypeError 函数参数的解构赋值1234567function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);// [ 3, 7 ] 函数参数的解构也可以使用默认值。12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"var，let和const声明及区别","slug":"var，let和const声明及区别","date":"2018-07-04T03:29:59.000Z","updated":"2018-07-27T03:57:38.924Z","comments":true,"path":"2018/07/04/var，let和const声明及区别/","link":"","permalink":"http://yoursite.com/2018/07/04/var，let和const声明及区别/","excerpt":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。","text":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。例如：123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 事实上，在预编译阶段，JavaScript引擎会将上面的函数修改为下面这样：12345678910111213fuction getValue(condition)&#123; var value; if(condition)&#123; value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 变量value的声明会被提升至函数顶部，而初始化操作依然留在原处执行。这样，就意味着，在函数的其他部分，else子句中或者if-else外，也能访问到value变量，而由于此时value变量并未被初始化赋值，所以访问到值为undefined。 块级声明ES6中引入块级作用域来强化对变量生命周期的控制。块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（词法作用域）存在于： 函数内部 块中（字符{和}之间的区域） let声明let声明的用法与var相同。用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。let声明不会被提升，因此通常将let声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //变量value在此处不存在 return null; &#125; //变量value在此处不存在&#125; let声明后，不会被提升至函数顶部。因此执行流离开if块之后，value立刻被销毁，如果condition的值为false，就永远不会声明并初始化value。并且，假设作用域中已经存在了某个标识符，此时再用let关键字声明它，就会抛出错误： 123var count=30;//抛出语法错误let count=40; 在同一作用域中不能用let重复定义已经存在的标识符，所以此处使用let声明会抛出错误。但如果当前作用域内内嵌另一个作用域，就可在内嵌的作用域中使用let声明同名变量。 例如： 12345var count=30;if(condition)&#123; //不会抛出错误 let count=40;&#125; 此时，if内部块中的count会遮蔽全局作用域中的count，而var声明的count只能在if块外访问到。 const声明使用const声明的是常量，其值一旦被设定后不可更改。因此每个通过const声明的常量必须在声明的同时被初始化。12345//有效的常量const max=30;//语法错误，常量未初始化const name; const和let声明都是块级标识符，所以常量也只在当前的代码块内有效，一旦执行到代码块外会被立即销毁。并且，常量也不会被提升至作用域顶部。同样，与let相似，在同一作用域用const声明已经存在的标识符，也会导致语法错误。 如上所述，const定义的值一旦被设定后不可更改，无论在严格模式还是非严格模式下，都不可以为const定义的常量再赋值，否则会抛出语法错误：123const max=50;//抛出语法错误max=30; 然而，与其他语言中的常量不同的是，JavaScript中的常量，如果是对象，则对象的值可以修改，也就是const声明不允许修改绑定，但允许修改值这也意味着，const声明对象后，可以修改对象的属性。const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。1234567891011const person=&#123; name:\"Nicholas\";&#125;;//可以修改对象属性的值person.name=\"Greg\";//抛出语法错误person=&#123; name:\"Greg\";&#125;; 如果真的想将对象冻结，应该使用Object.freeze方法。12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; 临时死区（Temporal Dead Zone）临时死区常被描述let和const的不提升的效果。JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到var声明时），要么将声明放到TDZ中（遇到let和const声明时）。访问TDZ中的变量会触发运行错误。只有在执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。1234if(condition)&#123; console.log(typeof value);//引用错误！ let value=\"blue\";&#125; 但在let声明的作用域外对该变量使用typeof则不会报错：12345console.log(typeof value); //\"undefined\"if(condition)&#123; let value=\"blue\";&#125; typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中，也就意味着不存在value这个绑定，typeof操作最终返回”undefined”。 循环中的块级作用域绑定先看这段代码：1234567891011var funcs=[];for(var i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出10次数字10&#125;); 预想结果是输出数字0～9，但是因为循环里的每次迭代同时共享着i，循环内部创建的函数全部都保存了对相同变量的引用。循环结束时变量i的值为10，所以每次调用console.log（i）时都会输出数字10。而使用let声明，每次迭代循环都会创建一个新变量，并以之前的迭代中同名变量的值将其初始化，得到预期的效果。1234567891011var funcs=[];for(let i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出0，1，2，……，9&#125;); 当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。const也是同样，但在循环中不能修改const声明的变量，否则会抛出错误。 全局作用域绑定当var被用在全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。这意味着，用var很可能会无意中覆盖一个已经存在的全局属性。例如：123//在浏览器中var RegExp=\"Hello!\";console.log(window.RegExp); //\"Hello!\" 全局对象定义在RegExp定义在window上，但不能幸免被var覆盖，成为window的属性。但如果在全局作用域中使用let或者const，会在全局作用域下创建一个新的绑定，但该绑定不会添加全局对象的属性。用let或const不能覆盖全局变量，只能遮蔽它。1234//在浏览器中let RegExp=\"Hello!\";console.log(RegExp); //\"Hello!\"console.log(window.RegExp===RegExp); //false 这里let声明的RegExp创建了一个绑定并遮蔽了全局的RegExp变量，但window.RegExp和RegExp并不相同，说明它不会破坏全局作用域，不会为全局对象创建属性。 ES6声明变量的六种方法ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，还有另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]}]}