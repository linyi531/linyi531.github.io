{"meta":{"title":"01不是包子脸","subtitle":"小01的程序猿成长之路","description":null,"author":"Linyi Li","url":"http://yoursite.com"},"pages":[{"title":"Categories","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:37:46.747Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T07:21:46.777Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 ProfileCease to struggle and you cease to live. 大家好，我是『01』。一个不承认自己是包子脸的小仙女～哈哈哈哈～ 作为一只程序猿，虽然我比较菜，但是我在努力成长啊。这个博客，想记录一路走来的点点滴滴。 希望我们，都能有自己的一技之长，在社会上的某个方面能成为独当一面的佼佼者。 生命不止，奋斗不息。 Social Info : 01 : 01"},{"title":"Tags","date":"2018-06-20T16:00:00.000Z","updated":"2018-06-21T02:36:30.431Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"var，let和const声明及区别","slug":"var，let和const声明及区别","date":"2018-07-04T03:29:59.000Z","updated":"2018-07-04T07:12:13.959Z","comments":true,"path":"2018/07/04/var，let和const声明及区别/","link":"","permalink":"http://yoursite.com/2018/07/04/var，let和const声明及区别/","excerpt":"","text":"var声明在函数作用域或全局作用域中通过var声明的变量，都会被当成在当前作用域顶部声明的变量。这就是提升（Hoisting）机制。例如：123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 事实上，在预编译阶段，JavaScript引擎会将上面的函数修改为下面这样：12345678910111213fuction getValue(condition)&#123; var value; if(condition)&#123; value=\"blue\"; //其他代码 return value; &#125; else&#123; //此处可以访问变量value，其值为undefined return null; &#125; //此处可以访问变量value，其值为undefined&#125; 变量value的声明会被提升至函数顶部，而初始化操作依然留在原处执行。这样，就意味着，在函数的其他部分，else子句中或者if-else外，也能访问到value变量，而由于此时value变量并未被初始化赋值，所以访问到值为undefined。 块级声明ES6中引入块级作用域来强化对变量生命周期的控制。块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（词法作用域）存在于： 函数内部 块中（字符{和}之间的区域） let声明let声明的用法与var相同。用let代替var来声明变量，就可以把变量的作用域限制在当前代码块中。let声明不会被提升，因此通常将let声明语句放在封闭代码块的顶部，以便整个代码块都可以访问。123456789101112fuction getValue(condition)&#123; if(condition)&#123; var value=\"blue\"; //其他代码 return value; &#125; else&#123; //变量value在此处不存在 return null; &#125; //变量value在此处不存在&#125; let声明后，不会被提升至函数顶部。因此执行流离开if块之后，value立刻被销毁，如果condition的值为false，就永远不会声明并初始化value。并且，假设作用域中已经存在了某个标识符，此时再用let关键字声明它，就会抛出错误： 123var count=30;//抛出语法错误let count=40; 在同一作用域中不能用let重复定义已经存在的标识符，所以此处使用let声明会抛出错误。但如果当前作用域内内嵌另一个作用域，就可在内嵌的作用域中使用let声明同名变量。 例如： 12345var count=30;if(condition)&#123; //不会抛出错误 let count=40;&#125; 此时，if内部块中的count会遮蔽全局作用域中的count，而var声明的count只能在if块外访问到。 const声明使用const声明的是常量，其值一旦被设定后不可更改。因此每个通过const声明的常量必须在声明的同时被初始化。12345//有效的常量const max=30;//语法错误，常量未初始化const name; const和let声明都是块级标识符，所以常量也只在当前的代码块内有效，一旦执行到代码块外会被立即销毁。并且，常量也不会被提升至作用域顶部。同样，与let相似，在同一作用域用const声明已经存在的标识符，也会导致语法错误。 如上所述，const定义的值一旦被设定后不可更改，无论在严格模式还是非严格模式下，都不可以为const定义的常量再赋值，否则会抛出语法错误：123const max=50;//抛出语法错误max=30; 然而，与其他语言中的常量不同的是，JavaScript中的常量，如果是对象，则对象的值可以修改，也就是const声明不允许修改绑定，但允许修改值这也意味着，const声明对象后，可以修改对象的属性。1234567891011const person=&#123; name:\"Nicholas\";&#125;;//可以修改对象属性的值person.name=\"Greg\";//抛出语法错误person=&#123; name:\"Greg\";&#125;; 临时死区（Temporal Dead Zone）临时死区常被描述let和const的不提升的效果。JavaScript引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到var声明时），要么将声明放到TDZ中（遇到let和const声明时）。访问TDZ中的变量会触发运行错误。只有在执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。1234if(condition)&#123; console.log(typeof value);//引用错误！ let value=\"blue\";&#125; 但在let声明的作用域外对该变量使用typeof则不会报错：12345console.log(typeof value); //\"undefined\"if(condition)&#123; let value=\"blue\";&#125; typeof是在声明变量value的代码块外执行的，此时value并不在TDZ中，也就意味着不存在value这个绑定，typeof操作最终返回”undefined”。 循环中的块级作用域绑定先看这段代码：1234567891011var funcs=[];for(var i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出10次数字10&#125;); 预想结果是输出数字0～9，但是因为循环里的每次迭代同时共享着i，循环内部创建的函数全部都保存了对相同变量的引用。循环结束时变量i的值为10，所以每次调用console.log（i）时都会输出数字10。而使用let声明，每次迭代循环都会创建一个新变量，并以之前的迭代中同名变量的值将其初始化，得到预期的效果。1234567891011var funcs=[];for(let i=0;i&lt;10;i++)&#123; funcs.push(function()&#123; console.log(i); &#125;);&#125;funcs.forEach(function(func)&#123; func(); //输出0，1，2，……，9&#125;); const也是同样，但在循环中不能修改const声明的变量，否则会抛出错误。 全局作用域绑定当var被用在全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。这意味着，用var很可能会无意中覆盖一个已经存在的全局属性。例如：123//在浏览器中var RegExp=\"Hello!\";console.log(window.RegExp); //\"Hello!\" 全局对象定义在RegExp定义在window上，但不能幸免被var覆盖，成为window的属性。但如果在全局作用域中使用let或者const，会在全局作用域下创建一个新的绑定，但该绑定不会添加全局对象的属性。用let或const不能覆盖全局变量，只能遮蔽它。1234//在浏览器中let RegExp=\"Hello!\";console.log(RegExp); //\"Hello!\"console.log(window.RegExp===RegExp); //false 这里let声明的RegExp创建了一个绑定并遮蔽了全局的RegExp变量，但window.RegExp和RegExp并不相同，说明它不会破坏全局作用域，不会为全局对象创建属性。","categories":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/categories/ES6/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"http://yoursite.com/tags/ES6/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-06-20T03:34:05.847Z","updated":"2018-06-21T02:29:37.617Z","comments":true,"path":"2018/06/20/hello-world/","link":"","permalink":"http://yoursite.com/2018/06/20/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hello","slug":"hello","permalink":"http://yoursite.com/tags/hello/"}]}]}