<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>双向数据绑定Proxy和Object.defineProperty对比 | 01不是包子脸</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  <meta name="keywords" content="vue" />
  
  
  
  
  <meta name="description" content="双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在：  无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &amp;#39;渣渣辉&amp;#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 z">
<meta name="keywords" content="vue">
<meta property="og:type" content="article">
<meta property="og:title" content="双向数据绑定Proxy和Object.defineProperty对比">
<meta property="og:url" content="http://yoursite.com/2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/index.html">
<meta property="og:site_name" content="01不是包子脸">
<meta property="og:description" content="双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在：  无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &amp;#39;渣渣辉&amp;#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 z">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/image/MVVM.png">
<meta property="og:image" content="http://yoursite.com/Users/lilinyi/Library/Application%20Support/typora-user-images/image-20190721175729186.png">
<meta property="og:updated_time" content="2019-08-15T10:32:02.082Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="双向数据绑定Proxy和Object.defineProperty对比">
<meta name="twitter:description" content="双向数据绑定Proxy和Object.defineProperty对比数据劫持的优势所在。对比其他双向绑定的实现方法,数据劫持的优势所在：  无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现data.name = &amp;#39;渣渣辉&amp;#39;后直接触发变更,而比如 Angular 的脏检测则需要显示调用markForCheck(可以用 z">
<meta name="twitter:image" content="http://yoursite.com/image/MVVM.png">
  
    <link rel="alternate" href="/atom.xml" title="01不是包子脸" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/dog.JPG">
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  <link rel="stylesheet" href="/css/style.css">

  <script src="/js/jquery-3.1.1.min.js"></script>

  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

</head>



  <body data-spy="scroll" data-target="#toc" data-offset="50">


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" rel="home" >
                <img style="margin-bottom: 10px;"  width="975px" height="200px" alt="Hike News" src=" /images/IMG_5299.JPG">
              </a>
            
          </h1>
          
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/">首页</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/archives">归档</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/categories">分类</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/tags">标签</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663"> <a class="" href="/about">关于</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main" style="float:none;"><article id="post-双向数据绑定Proxy和Object.defineProperty对比" style="width: 66%; float:left;" class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" class="article-title" itemprop="name">
      双向数据绑定Proxy和Object.defineProperty对比
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/2019/03/11/双向数据绑定Proxy和Object.defineProperty对比/" class="article-date">
	  <time datetime="2019-03-11T03:52:12.000Z" itemprop="datePublished">三月 11, 2019</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/vue/">vue</a>
 
      
	<span id="busuanzi_container_page_pv">
	  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
	</span>

    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="双向数据绑定Proxy和Object-defineProperty对比"><a href="#双向数据绑定Proxy和Object-defineProperty对比" class="headerlink" title="双向数据绑定Proxy和Object.defineProperty对比"></a>双向数据绑定<code>Proxy</code>和<code>Object.defineProperty</code>对比</h1><h2 id="数据劫持的优势所在。"><a href="#数据劫持的优势所在。" class="headerlink" title="数据劫持的优势所在。"></a>数据劫持的优势所在。</h2><p>对比其他双向绑定的实现方法,数据劫持的优势所在：</p>
<ol>
<li>无需显示调用: 例如 Vue 运用数据劫持+发布订阅,直接可以通知变化并驱动视图,上面的例子也是比较简单的实现<code>data.name = &#39;渣渣辉&#39;</code>后直接触发变更,而比如 Angular 的脏检测则需要显示调用<code>markForCheck</code>(可以用 zone.js 避免显示调用,不展开),react 需要显示调用<code>setState</code>。</li>
<li>可精确得知变化数据：还是上面的小例子，我们劫持了属性的 setter,当属性值改变,我们可以精确获知变化的内容<code>newVal</code>,因此在这部分不需要额外的 diff 操作,否则我们只知道数据发生了变化而不知道具体哪些数据变化了,这个时候需要大量 diff 来找出变化值,这是额外性能损耗。<a id="more"></a>
</li>
</ol>
<h2 id="基于数据劫持双向绑定的实现思路"><a href="#基于数据劫持双向绑定的实现思路" class="headerlink" title="基于数据劫持双向绑定的实现思路"></a>基于数据劫持双向绑定的实现思路</h2><p><strong>数据劫持</strong>是双向绑定各种方案中比较流行的一种,最著名的实现就是 Vue。</p>
<p>基于数据劫持的双向绑定离不开<code>Proxy</code>与<code>Object.defineProperty</code>等方法对对象/对象属性的”劫持”,我们要实现一个完整的双向绑定需要以下几个要点。</p>
<ol>
<li>利用<code>Proxy</code>或<code>Object.defineProperty</code>生成的 Observer 针对对象/对象的属性进行”劫持”,在属性发生变化后通知订阅者</li>
<li>解析器 Compile 解析模板中的<code>Directive</code>(指令)，收集指令所依赖的方法和数据,等待数据变化然后进行渲染</li>
<li>Watcher 属于 Observer 和 Compile 桥梁,它将接收到的 Observer 产生的数据变化,并根据 Compile 提供的指令进行视图渲染,使得数据变化促使视图变化</li>
</ol>
<p><img src="/image/MVVM.png" alt="MVVM"></p>
<ul>
<li>在 <code>new Vue()</code> 后， Vue 会调用<code>_init</code> 函数进行初始化，也就是 init 过程，在 这个过程 Data 通过 Observer 转换成了 getter/setter 的形式，来对数据追踪变化，当被设置的对象被读取的时候会执行<code>getter</code> 函数，而在当被赋值的时候会执行 <code>setter</code>函数。</li>
<li>当 render function 执行的时候，因为会读取所需对象的值，所以会触发<code>getter</code>函数从而将 Watcher 添加到依赖中进行依赖收集。</li>
<li>在修改对象的值的时候，会触发对应的<code>setter</code>， <code>setter</code>通知之前<strong>依赖收集</strong>得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 <code>update</code> 来更新视图。</li>
</ul>
<h2 id="基于-Object-defineProperty-双向绑定的特点"><a href="#基于-Object-defineProperty-双向绑定的特点" class="headerlink" title="基于 Object.defineProperty 双向绑定的特点"></a>基于 Object.defineProperty 双向绑定的特点</h2><p>Vue 通过设定对象属性的 setter/getter 方法来监听数据的变化，通过 getter 进行依赖收集，而每个 setter 方法就是一个观察者，在数据变更的时候通知订阅者更新视图。</p>
<p><strong>在 getter 中收集依赖，在 setter 中触发依赖。</strong></p>
<p>当外界通过 Watcher 读取数据时，便会触发 getter 从而将 Watcher 添加到依赖中，哪个 Watcher 触发了 getter，就把哪个 Watcher 收集到 Dep 中。当数据发生变化时，会循环依赖列表，把所有的 Watcher 都通知一遍。</p>
<h3 id="极简版的双向绑定"><a href="#极简版的双向绑定" class="headerlink" title="极简版的双向绑定"></a>极简版的双向绑定</h3><p><code>Object.defineProperty</code>的作用就是劫持一个对象的属性,通常我们对属性的<code>getter</code>和<code>setter</code>方法进行劫持,在对象的属性发生变化时进行特定的操作。</p>
<p>我们就对对象<code>obj</code>的<code>text</code>属性进行劫持,在获取此属性的值时打印<code>&#39;get val&#39;</code>,在更改属性值的时候对 DOM 进行操作,这就是一个极简的双向绑定。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">"text"</span>, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"get val"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"set val:"</span> + newVal);</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>).value = newVal;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"span"</span>).innerHTML = newVal;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>);</span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  obj.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="升级改造"><a href="#升级改造" class="headerlink" title="升级改造"></a>升级改造</h3><p>我们很快会发现，这个所谓的<em>双向绑定</em>貌似并没有什么乱用。。。</p>
<p>原因如下:</p>
<ol>
<li>我们只监听了一个属性,一个对象不可能只有一个属性,我们需要对对象每个属性进行监听。</li>
<li>违反开放封闭原则,我们如果了解<a href="https://link.juejin.im?target=https%3A%2F%2Fzh.wikipedia.org%2Fzh-hans%2F%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99" target="_blank" rel="noopener">开放封闭原则</a>的话,上述代码是明显违反此原则,我们每次修改都需要进入方法内部,这是需要坚决杜绝的。</li>
<li>代码耦合严重,我们的数据、方法和 DOM 都是耦合在一起的，就是传说中的面条代码。</li>
</ol>
<p>那么如何解决上述问题？</p>
<p>Vue 的操作就是加入了<strong>发布订阅</strong>模式，结合<code>Object.defineProperty</code>的劫持能力，实现了可用性很高的双向绑定。</p>
<p>首先，我们以<strong>发布订阅</strong>的角度看我们第一部分写的那一坨代码,会发现它的<em>监听</em>、<em>发布</em>和<em>订阅</em>都是写在一起的,我们首先要做的就是解耦。</p>
<p>我们先实现<strong>一个订阅发布中心，即消息管理员（Dep）,它负责储存订阅者和消息的分发,不管是订阅者还是发布者都需要依赖于它</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 用于储存订阅者并发布消息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 设置id,用于区分新Watcher和只改变属性值后新产生的Watcher</span></span><br><span class="line">    <span class="keyword">this</span>.id = uid++;</span><br><span class="line">    <span class="comment">// 储存订阅者的数组</span></span><br><span class="line">    <span class="keyword">this</span>.subs = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发target上的Watcher中的addDep方法,参数为dep的实例本身</span></span><br><span class="line">  depend() &#123;</span><br><span class="line">    Dep.target.addDep(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  addSub(sub) &#123;</span><br><span class="line">    <span class="keyword">this</span>.subs.push(sub);</span><br><span class="line">  &#125;</span><br><span class="line">  notify() &#123;</span><br><span class="line">    <span class="comment">// 通知所有的订阅者(Watcher)，触发订阅者的相应逻辑处理</span></span><br><span class="line">    <span class="keyword">this</span>.subs.forEach(<span class="function"><span class="params">sub</span> =&gt;</span> sub.update());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 为Dep类设置一个静态属性,默认为null,工作时指向当前的Watcher</span></span><br><span class="line">Dep.target = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>现在我们需要实现监听者(Observer),用于监听属性值的变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听者,监听对象属性值的变化</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.walk(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历属性值并监听</span></span><br><span class="line">  walk(value) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.keys(value).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>.convert(key, value[key]));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行监听的具体方法</span></span><br><span class="line">  convert(key, val) &#123;</span><br><span class="line">    defineReactive(<span class="keyword">this</span>.value, key, val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span>(<span class="params">obj, key, val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="comment">// 给当前属性的值添加监听</span></span><br><span class="line">  <span class="keyword">let</span> chlidOb = observe(val);</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    get: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果Dep类存在target属性，将其添加到dep实例的subs数组中</span></span><br><span class="line">      <span class="comment">// target指向一个Watcher实例，每个Watcher都是一个订阅者</span></span><br><span class="line">      <span class="comment">// Watcher实例在实例化过程中，会读取data中的某个属性，从而触发当前get方法</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="params">newVal</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (val === newVal) <span class="keyword">return</span>;</span><br><span class="line">      val = newVal;</span><br><span class="line">      <span class="comment">// 对新值进行监听</span></span><br><span class="line">      chlidOb = observe(newVal);</span><br><span class="line">      <span class="comment">// 通知所有订阅者，数值被改变了</span></span><br><span class="line">      dep.notify();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observe</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 当值不存在，或者不是复杂数据类型时，不再需要继续深入监听</span></span><br><span class="line">  <span class="keyword">if</span> (!value || <span class="keyword">typeof</span> value !== <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Observer(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么接下来就简单了,我们需要实现一个订阅者(Watcher)。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, expOrFn, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.depIds = &#123;&#125;; <span class="comment">// hash储存订阅者的id,避免重复的订阅者</span></span><br><span class="line">    <span class="keyword">this</span>.vm = vm; <span class="comment">// 被订阅的数据一定来自于当前Vue实例</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb; <span class="comment">// 当数据更新时想要做的事情</span></span><br><span class="line">    <span class="keyword">this</span>.expOrFn = expOrFn; <span class="comment">// 被订阅的数据</span></span><br><span class="line">    <span class="keyword">this</span>.val = <span class="keyword">this</span>.get(); <span class="comment">// 维护更新之前的数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 对外暴露的接口，用于在订阅的数据被更新时，由订阅者管理员(Dep)调用</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    <span class="keyword">this</span>.run();</span><br><span class="line">  &#125;</span><br><span class="line">  addDep(dep) &#123;</span><br><span class="line">    <span class="comment">// 如果在depIds的hash中没有当前的id,可以判断是新Watcher,因此可以添加到dep的数组中储存</span></span><br><span class="line">    <span class="comment">// 此判断是避免同id的Watcher被多次储存</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.depIds.hasOwnProperty(dep.id)) &#123;</span><br><span class="line">      dep.addSub(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">this</span>.depIds[dep.id] = dep;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">this</span>.get();</span><br><span class="line">    <span class="built_in">console</span>.log(val);</span><br><span class="line">    <span class="keyword">if</span> (val !== <span class="keyword">this</span>.val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.val = val;</span><br><span class="line">      <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, val);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="comment">// 当前订阅者(Watcher)读取被订阅数据的最新更新后的值时，通知订阅者管理员收集当前订阅者</span></span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">this</span>.vm._data[<span class="keyword">this</span>.expOrFn];</span><br><span class="line">    <span class="comment">// 置空，用于下一个Watcher使用</span></span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么我们最后完成 Vue,将上述方法挂载在 Vue 上。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">      <span class="comment">// 简化了$options的处理</span></span><br><span class="line">      <span class="keyword">this</span>.$options = options;</span><br><span class="line">      <span class="comment">// 简化了对data的处理</span></span><br><span class="line">      <span class="keyword">let</span> data = (<span class="keyword">this</span>._data = <span class="keyword">this</span>.$options.data);</span><br><span class="line">      <span class="comment">// 将所有data最外层属性代理到Vue实例上</span></span><br><span class="line">      <span class="built_in">Object</span>.keys(data).forEach(<span class="function"><span class="params">key</span> =&gt;</span> <span class="keyword">this</span>._proxy(key));</span><br><span class="line">      <span class="comment">// 监听数据</span></span><br><span class="line">      observe(data);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对外暴露调用订阅者的接口，内部主要在指令中使用订阅者</span></span><br><span class="line">    $watch(expOrFn, cb) &#123;</span><br><span class="line">      <span class="keyword">new</span> Watcher(<span class="keyword">this</span>, expOrFn, cb);</span><br><span class="line">    &#125;</span><br><span class="line">    _proxy(key) &#123;</span><br><span class="line">      <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">        configurable: <span class="literal">true</span>,</span><br><span class="line">        enumerable: <span class="literal">true</span>,</span><br><span class="line">        get: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>._data[key],</span><br><span class="line">        set: <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>._data[key] = val;</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>至此,一个简单的双向绑定算是被我们实现了。</p>
<h3 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h3><ul>
<li><p><code>Object.defineProperty</code>的第一个缺陷,无法监听数组变化。<a href="https://link.juejin.im/?target=https%3A%2F%2Fcn.vuejs.org%2Fv2%2Fguide%2Flist.html%23%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B" target="_blank" rel="noopener">Vue 的文档</a>提到了 Vue 是可以检测到数组变化的，但是只有以下八种方法,<code>vm.items[indexOfItem] = newValue</code>这种是无法检测的。<code>push()</code>、<code>pop()</code>、<code>shift()</code>、<code>unshift()</code>、<code>splice()</code>、<code>sort()</code>、<code>reverse()</code></p>
</li>
<li><p><code>Object.defineProperty</code>的第二个缺陷,只能劫持对象的属性,因此我们需要对每个对象的每个属性进行遍历，如果属性值也是对象那么需要深度遍历,显然能劫持一个完整的对象是更好的选择。</p>
<p><code>Object.keys(value).forEach(key =&gt; **this**.convert(key, value[key]));</code></p>
</li>
<li><p><strong>无法检测到对象属性的添加或删除</strong>(如<code>data.location.a=1</code>)。</p>
<p>这是因为 Vue 通过<code>Object.defineProperty</code>来将对象的 key 转换成<code>getter/setter</code>的形式来追踪变化，但<code>getter/setter</code>只能追踪一个数据是否被修改，无法追踪新增属性和删除属性。如果是删除属性，我们可以用<code>vm.$delete</code>实现，那如果是新增属性，该怎么办呢？<br>1）可以使用 <code>Vue.set(location, a, 1)</code> 方法向嵌套对象添加响应式属性;<br>2）也可以给这个对象重新赋值，比如<code>data.location = {...data.location,a:1}</code></p>
</li>
</ul>
<h2 id="Proxy-实现的双向绑定的特点"><a href="#Proxy-实现的双向绑定的特点" class="headerlink" title="Proxy 实现的双向绑定的特点"></a>Proxy 实现的双向绑定的特点</h2><p>Proxy 在 ES2015 规范中被正式发布,它在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写,我们可以这样认为,Proxy 是<code>Object.defineProperty</code>的全方位加强版</p>
<h3 id="Proxy-可以直接监听对象而非属性"><a href="#Proxy-可以直接监听对象而非属性" class="headerlink" title="Proxy 可以直接监听对象而非属性"></a>Proxy 可以直接监听对象而非属性</h3><p>我们还是以上文中用<code>Object.defineProperty</code>实现的极简版双向绑定为例,用 Proxy 进行改写。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">"input"</span>);</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.getElementById(<span class="string">"p"</span>);</span><br><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> newObj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`getting <span class="subst">$&#123;key&#125;</span>!`</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key === <span class="string">"text"</span>) &#123;</span><br><span class="line">      input.value = value;</span><br><span class="line">      p.innerHTML = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener(<span class="string">"keyup"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  newObj.text = e.target.value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>我们可以看到,Proxy 直接可以劫持整个对象,并返回一个新对象,不管是操作便利程度还是底层功能上都远强于<code>Object.defineProperty</code>。</p>
<h3 id="Proxy-可以直接监听数组的变化"><a href="#Proxy-可以直接监听数组的变化" class="headerlink" title="Proxy 可以直接监听数组的变化"></a>Proxy 可以直接监听数组的变化</h3><p>当我们对数组进行操作(push、shift、splice 等)时，会触发对应的方法名称和<em>length</em>的变化，我们可以借此进行操作,以上文中<code>Object.defineProperty</code>无法生效的列表渲染为例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = <span class="built_in">document</span>.getElementById(<span class="string">"list"</span>);</span><br><span class="line"><span class="keyword">const</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"btn"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染列表</span></span><br><span class="line"><span class="keyword">const</span> Render = &#123;</span><br><span class="line">  <span class="comment">// 初始化</span></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">      li.textContent = arr[i];</span><br><span class="line">      fragment.appendChild(li);</span><br><span class="line">    &#125;</span><br><span class="line">    list.appendChild(fragment);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 我们只考虑了增加的情况,仅作为示例</span></span><br><span class="line">  change: <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> li = <span class="built_in">document</span>.createElement(<span class="string">"li"</span>);</span><br><span class="line">    li.textContent = val;</span><br><span class="line">    list.appendChild(li);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听数组</span></span><br><span class="line"><span class="keyword">const</span> newArr = <span class="keyword">new</span> <span class="built_in">Proxy</span>(arr, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(key);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">  &#125;,</span><br><span class="line">  set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(target, key, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (key !== <span class="string">"length"</span>) &#123;</span><br><span class="line">      Render.change(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(target, key, value, receiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Render.init(arr);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// push数字</span></span><br><span class="line">btn.addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  newArr.push(<span class="number">6</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>很显然,Proxy 不需要那么多 hack（即使 hack 也无法完美实现监听）就可以无压力监听数组的变化,我们都知道,标准永远优先于 hack。</p>
<h3 id="Proxy-的其他优势"><a href="#Proxy-的其他优势" class="headerlink" title="Proxy 的其他优势"></a>Proxy 的其他优势</h3><p>Proxy 有多达 13 种拦截方法,不限于 apply、ownKeys、deleteProperty、has 等等是<code>Object.defineProperty</code>不具备的。</p>
<p>Proxy 返回的是一个新对象,我们可以只操作新的对象达到目的,而<code>Object.defineProperty</code>只能遍历对象属性直接修改。</p>
<p>Proxy 作为新标准将受到浏览器厂商重点持续的性能优化，也就是传说中的新标准的性能红利。</p>
<p>当然,Proxy 的劣势就是兼容性问题,而且无法用 polyfill 磨平,因此 Vue 的作者才声明需要等到下个大版本(3.0)才能用 Proxy 重写。</p>
<h3 id="基础-proxy-的双向数据绑定的实现"><a href="#基础-proxy-的双向数据绑定的实现" class="headerlink" title="基础 proxy 的双向数据绑定的实现"></a>基础 proxy 的双向数据绑定的实现</h3><h4 id="发布订阅中心-Dep"><a href="#发布订阅中心-Dep" class="headerlink" title="发布订阅中心(Dep)"></a>发布订阅中心(Dep)</h4><p><code>Dep</code>保存订阅者,并在 Observer 发生变化时通知保存在 Dep 中的订阅者,让订阅者得知变化并更新视图,这样才能保证视图与状态的同步。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [subs description] 订阅器,储存订阅者,通知订阅者</span></span><br><span class="line"><span class="comment"> * @type &#123;Map&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="comment">// 我们用 hash 储存订阅者</span></span><br><span class="line">    <span class="keyword">this</span>.subs = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 添加订阅者</span></span><br><span class="line">  addSub(key, sub) &#123;</span><br><span class="line">    <span class="comment">// 取出键为 key 的订阅者</span></span><br><span class="line">    <span class="keyword">const</span> currentSub = <span class="keyword">this</span>.subs.get(key);</span><br><span class="line">    <span class="comment">// 如果能取出说明有相同的 key 的订阅者已经存在,直接添加</span></span><br><span class="line">    <span class="keyword">if</span> (currentSub) &#123;</span><br><span class="line">      currentSub.add(sub);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 用 Set 数据结构储存,保证唯一值</span></span><br><span class="line">      <span class="keyword">this</span>.subs.set(key, <span class="keyword">new</span> <span class="built_in">Set</span>([sub]));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通知</span></span><br><span class="line">  notify(key) &#123;</span><br><span class="line">    <span class="comment">// 触发键为 key 的订阅者们</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.subs.get(key)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.subs.get(key).forEach(<span class="function"><span class="params">sub</span> =&gt;</span> &#123;</span><br><span class="line">        sub.update();</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="监听者的实现-Observer"><a href="#监听者的实现-Observer" class="headerlink" title="监听者的实现(Observer)"></a>监听者的实现(Observer)</h4><p>我们在订阅器 <code>Dep</code> 中实现了一个<code>notify</code>方法来通知相应的订阅这们,然而<code>notify</code>方法到底什么时候被触发呢?</p>
<p>当然是当状态发生变化时,即 MVVM 中的 Modal 变化时触发通知,然而<code>Dep</code> 显然无法得知 Modal 是否发生了变化,因此我们需要创建一个监听者<code>Observer</code>来监听 Modal, 当 Modal 发生变化的时候我们就执行通知操作。</p>
<p>与<code>Object.defineProperty</code>监听属性不同, Proxy 可以监听(实际是代理)整个对象,因此就不需要遍历对象的属性依次监听了,但是如果对象的属性依然是个对象,那么 Proxy 也无法监听,所以我们实现了一个<code>observify</code>进行递归监听即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [Observer description] 监听器,监听对象,触发后通知订阅</span></span><br><span class="line"><span class="comment"> * @param &#123;[type]&#125;   obj [description] 需要被监听的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">const</span> Observer = <span class="function"><span class="params">obj</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep();</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果订阅者存在，直接添加订阅</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.addSub(key, Dep.target);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(target, key, receiver);</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">target, key, value, receiver</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 如果对象值没有变,那么不触发下面的操作直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">Reflect</span>.get(receiver, key) === value) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> res = <span class="built_in">Reflect</span>.set(target, key, observify(value), receiver);</span><br><span class="line">      <span class="comment">// 当值被触发更改的时候,触发 Dep 的通知方法</span></span><br><span class="line">      dep.notify(key);</span><br><span class="line">      <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将对象转为监听对象</span></span><br><span class="line"><span class="comment"> * @param &#123;*&#125; obj 要监听的对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">observify</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 深度监听</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach(<span class="function"><span class="params">key</span> =&gt;</span> &#123;</span><br><span class="line">    obj[key] = observify(obj[key]);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Observer(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="订阅者的实现-watcher"><a href="#订阅者的实现-watcher" class="headerlink" title="订阅者的实现(watcher)"></a>订阅者的实现(watcher)</h4><p>我们目前已经解决了两个问题,一个是如何得知 Modal 发生了改变(利用监听者 Observer 监听 Modal 对象),一个是如何收集订阅者并通知其变化(利用订阅器收集订阅者,并用 notify 通知订阅者)。</p>
<p>我们目前还差一个订阅者（Watcher）</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 订阅者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(vm, exp, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.vm = vm; <span class="comment">// vm 是 vue 的实例</span></span><br><span class="line">    <span class="keyword">this</span>.exp = exp; <span class="comment">// 被订阅的数据</span></span><br><span class="line">    <span class="keyword">this</span>.cb = cb; <span class="comment">// 触发更新后的回调</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="keyword">this</span>.get(); <span class="comment">// 获取老数据</span></span><br><span class="line">  &#125;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">const</span> exp = <span class="keyword">this</span>.exp;</span><br><span class="line">    <span class="keyword">let</span> value;</span><br><span class="line">    Dep.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> exp === <span class="string">"function"</span>) &#123;</span><br><span class="line">      value = exp.call(<span class="keyword">this</span>.vm);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exp === <span class="string">"string"</span>) &#123;</span><br><span class="line">      value = <span class="keyword">this</span>.vm[exp];</span><br><span class="line">    &#125;</span><br><span class="line">    Dep.target = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将订阅者放入待更新队列等待批量更新</span></span><br><span class="line">  update() &#123;</span><br><span class="line">    pushQueue(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发真正的更新操作</span></span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">const</span> val = <span class="keyword">this</span>.get(); <span class="comment">// 获取新数据</span></span><br><span class="line">    <span class="keyword">this</span>.cb.call(<span class="keyword">this</span>.vm, val, <span class="keyword">this</span>.value);</span><br><span class="line">    <span class="keyword">this</span>.value = val;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="批量更新的实现"><a href="#批量更新的实现" class="headerlink" title="批量更新的实现"></a>批量更新的实现</h4><p>我们在上一节中实现了订阅者( Watcher),但是其中的<code>update</code>方法是将订阅者放入了一个待更新的队列中,而不是直接触发,原因如下:</p>
<p><img src="/Users/lilinyi/Library/Application Support/typora-user-images/image-20190721175729186.png" alt="image-20190721175729186"></p>
<p>因此这个队列需要做的是<strong>异步</strong>且<strong>去重</strong>,因此我们用 <code>Set</code>作为数据结构储存 Watcher 来去重,同时用<code>Promise</code>模拟异步更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建异步更新队列</span></span><br><span class="line"><span class="keyword">let</span> queue = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用Promise模拟nextTick</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">cb</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(cb);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行刷新队列</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushQueue</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">  queue.forEach(<span class="function"><span class="params">watcher</span> =&gt;</span> &#123;</span><br><span class="line">    watcher.run();</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// 清空</span></span><br><span class="line">  queue = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加到队列</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">pushQueue</span>(<span class="params">watcher</span>) </span>&#123;</span><br><span class="line">  queue.add(watcher);</span><br><span class="line">  <span class="comment">// 下一个循环调用</span></span><br><span class="line">  nextTick(flushQueue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/vue/">vue</a>

      
  <span class="ico-tags"></span>
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

      
        
	<div id="comment">
		<!-- 来必力City版安装代码 -->
		<div id="lv-container" data-id="city" data-uid="MTAyMC8yOTQ4MS82MDQ5">
		<script type="text/javascript">
		   (function(d, s) {
		       var j, e = d.getElementsByTagName(s)[0];

		       if (typeof LivereTower === 'function') { return; }

		       j = d.createElement(s);
		       j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
		       j.async = true;

		       e.parentNode.insertBefore(j, e);
		   })(document, 'script');
		</script>
		<noscript>为正常使用来必力评论功能请激活JavaScript</noscript>
		</div>
		<!-- City版安装代码已完成 -->
	</div>



      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/22/移动端的触屏事件/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          移动端的触屏事件
        
      </div>
    </a>
  
  
    <a href="/2019/03/07/九种实现跨域的方式/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">九种实现跨域的方式</div>
    </a>
  
</nav>

  
</article>

<!-- Table of Contents -->

  <aside id="sidebar">
    <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    
      <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#双向数据绑定Proxy和Object-defineProperty对比"><span class="nav-number">1.</span> <span class="nav-text">双向数据绑定Proxy和Object.defineProperty对比</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#数据劫持的优势所在。"><span class="nav-number">1.1.</span> <span class="nav-text">数据劫持的优势所在。</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于数据劫持双向绑定的实现思路"><span class="nav-number">1.2.</span> <span class="nav-text">基于数据劫持双向绑定的实现思路</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于-Object-defineProperty-双向绑定的特点"><span class="nav-number">1.3.</span> <span class="nav-text">基于 Object.defineProperty 双向绑定的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#极简版的双向绑定"><span class="nav-number">1.3.1.</span> <span class="nav-text">极简版的双向绑定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#升级改造"><span class="nav-number">1.3.2.</span> <span class="nav-text">升级改造</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Object-defineProperty-的缺陷"><span class="nav-number">1.3.3.</span> <span class="nav-text">Object.defineProperty 的缺陷</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Proxy-实现的双向绑定的特点"><span class="nav-number">1.4.</span> <span class="nav-text">Proxy 实现的双向绑定的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-可以直接监听对象而非属性"><span class="nav-number">1.4.1.</span> <span class="nav-text">Proxy 可以直接监听对象而非属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-可以直接监听数组的变化"><span class="nav-number">1.4.2.</span> <span class="nav-text">Proxy 可以直接监听数组的变化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Proxy-的其他优势"><span class="nav-number">1.4.3.</span> <span class="nav-text">Proxy 的其他优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基础-proxy-的双向数据绑定的实现"><span class="nav-number">1.4.4.</span> <span class="nav-text">基础 proxy 的双向数据绑定的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发布订阅中心-Dep"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">发布订阅中心(Dep)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监听者的实现-Observer"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">监听者的实现(Observer)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#订阅者的实现-watcher"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">订阅者的实现(watcher)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#批量更新的实现"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">批量更新的实现</span></a></li></ol></li></ol></li></ol></li></ol>
    
    </div>
  </aside>
</section>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2019 01不是包子脸 All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>
<script src="/js/bootstrap.js"></script>
<script src="/js/main.js"></script>







  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1273997385&web_id=1273997385" language="JavaScript"></script>
  </div>



	<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
  <!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>
</body>
</html>
